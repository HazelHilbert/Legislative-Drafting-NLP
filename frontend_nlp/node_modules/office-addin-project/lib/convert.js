// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertProject = void 0;
const AdmZip = require("adm-zip");
const fs = require("fs");
const fsExtra = require("fs-extra");
const path = require("path");
const util = require("util");
const child_process_1 = require("child_process");
const office_addin_manifest_converter_1 = require("office-addin-manifest-converter");
const office_addin_usage_data_1 = require("office-addin-usage-data");
/* global console */
const execAsync = util.promisify(child_process_1.exec);
const skipBackup = ["node_modules"];
function convertProject(manifestPath = "./manifest.xml", backupPath = "./backup.zip", projectDir = "") {
    return __awaiter(this, void 0, void 0, function* () {
        if (manifestPath.endsWith(".json")) {
            throw new office_addin_usage_data_1.ExpectedError(`The convert command only works on xml manifest based projects`);
        }
        if (!fs.existsSync(manifestPath)) {
            throw new office_addin_usage_data_1.ExpectedError(`The manifest file '${manifestPath}' does not exist`);
        }
        const outputPath = path.dirname(manifestPath);
        const currentDir = process.cwd();
        yield backupProject(backupPath);
        try {
            // assume project dir is the same as manifest dir if not specified
            projectDir = projectDir === "" ? outputPath : projectDir;
            process.chdir(projectDir);
            yield (0, office_addin_manifest_converter_1.convert)(manifestPath, outputPath, false /* imageDownload */, true /* imageUrls */);
            yield updatePackages();
            yield updateManifestXmlReferences();
            fs.unlinkSync(manifestPath);
        }
        catch (err) {
            console.log(`Error in conversion. Restoring project initial state.`);
            yield restoreBackup(backupPath);
            throw err;
        }
        finally {
            process.chdir(currentDir);
        }
    });
}
exports.convertProject = convertProject;
function backupProject(backupPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const zip = new AdmZip();
        const outputPath = path.resolve(backupPath);
        const rootDir = path.resolve();
        const files = fs.readdirSync(rootDir);
        files.forEach((entry) => {
            const fullPath = path.resolve(entry);
            const entryStats = fs.lstatSync(fullPath);
            if (skipBackup.includes(entry)) {
                // Don't add it to the backup
            }
            else if (entryStats.isDirectory()) {
                zip.addLocalFolder(entry, entry);
            }
            else {
                zip.addLocalFile(entry);
            }
        });
        fsExtra.ensureDirSync(path.dirname(outputPath));
        if (yield zip.writeZipPromise(outputPath)) {
            console.log(`A backup of your project was created to ${outputPath}`);
        }
        else {
            throw new Error(`Error writting zip file to ${outputPath}`);
        }
    });
}
function restoreBackup(backupPath) {
    return __awaiter(this, void 0, void 0, function* () {
        var zip = new AdmZip(backupPath); // reading archives
        zip.extractAllTo("./", true); // overwrite
    });
}
function updatePackages() {
    return __awaiter(this, void 0, void 0, function* () {
        // Contains name of the package and minimum version
        const depedentPackages = [
            "office-addin-debugging",
            "office-addin-manifest",
        ];
        let command = "npm install";
        let messageToBePrinted = "Installing latest versions of";
        for (let i = 0; i < depedentPackages.length; i++) {
            const depedentPackage = depedentPackages[i];
            command += ` ${depedentPackage}@latest`;
            messageToBePrinted += ` ${depedentPackage}`;
            if (i === depedentPackages.length - 2) {
                messageToBePrinted += " and";
            }
            else {
                messageToBePrinted += ",";
            }
        }
        command += ` --save-dev`;
        console.log(messageToBePrinted.slice(0, -1));
        yield execAsync(command);
    });
}
function updateManifestXmlReferences() {
    return __awaiter(this, void 0, void 0, function* () {
        yield updatePackageJson();
        yield updateWebpackConfig();
    });
}
function updatePackageJson() {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJson = `./package.json`;
        const readFileAsync = util.promisify(fs.readFile);
        const data = yield readFileAsync(packageJson, "utf8");
        let content = JSON.parse(data);
        // Change .xml references to .json
        Object.keys(content.scripts).forEach(function (key) {
            content.scripts[key] = content.scripts[key].replace(/manifest.xml/gi, `manifest.json`);
        });
        // write updated json to file
        const writeFileAsync = util.promisify(fs.writeFile);
        yield writeFileAsync(packageJson, JSON.stringify(content, null, 2));
    });
}
function updateWebpackConfig() {
    return __awaiter(this, void 0, void 0, function* () {
        const weppackConfig = `./webpack.config.js`;
        const readFileAsync = util.promisify(fs.readFile);
        const data = yield readFileAsync(weppackConfig, "utf8");
        // switching to json extension is the easy fix.
        // TODO: update to remove the manifest copy plugin since it's not needed in webpack
        let content = data.replace(/"(manifest\*\.)xml"/gi, '"$1json"');
        const writeFileAsync = util.promisify(fs.writeFile);
        yield writeFileAsync(weppackConfig, content);
    });
}
//# sourceMappingURL=convert.js.map