{"version":3,"file":"inject.decorator.js","sourceRoot":"","sources":["../../../src/decorators/inject.decorator.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,oBAAoB,CAAC;AAE/C,OAAO,EAAE,sBAAsB,EAAE,MAAM,oCAAoC,CAAC;AAG5E,OAAO,EAAE,oBAAoB,EAAE,MAAM,uCAAuC,CAAC;AAS7E,MAAM,UAAU,MAAM,CACpB,gBAA0F;IAE1F,OAAO,UAAU,MAAc,EAAE,YAA6B,EAAE,KAAc;QAC5E,IAAM,WAAW,GAAG,oBAAoB,CAAC,gBAAgB,EAAE,MAAM,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;QAExF,0FAA0F;QAC1F,IAAI,WAAW,KAAK,SAAS,IAAI,WAAW,CAAC,SAAS,KAAK,SAAS,IAAI,WAAW,CAAC,SAAS,KAAK,MAAM,EAAE;YACxG,MAAM,IAAI,sBAAsB,CAAC,MAAgC,EAAE,YAAsB,CAAC,CAAC;SAC5F;QAED,SAAS,CAAC,eAAe,CAAC;YACxB,MAAM,EAAE,MAAgC;YACxC,YAAY,EAAE,YAAsB;YACpC,KAAK,EAAE,KAAK;YACZ,KAAK,EAAE,UAAA,iBAAiB;gBACtB,IAAM,iBAAiB,GAAG,WAAW,CAAC,QAAQ,EAAE,CAAC;gBAEjD,iGAAiG;gBACjG,IAAI,iBAAiB,KAAK,SAAS,IAAI,iBAAiB,KAAK,MAAM,EAAE;oBACnE,MAAM,IAAI,sBAAsB,CAAC,MAAgC,EAAE,YAAsB,CAAC,CAAC;iBAC5F;gBAED,OAAO,iBAAiB,CAAC,GAAG,CAAU,iBAAiB,CAAC,CAAC;YAC3D,CAAC;SACF,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import { Container } from '../container.class';\nimport { Token } from '../token.class';\nimport { CannotInjectValueError } from '../error/cannot-inject-value.error';\nimport { ServiceIdentifier } from '../types/service-identifier.type';\nimport { Constructable } from '../types/constructable.type';\nimport { resolveToTypeWrapper } from '../utils/resolve-to-type-wrapper.util';\n\n/**\n * Injects a service into a class property or constructor parameter.\n */\nexport function Inject(): Function;\nexport function Inject(typeFn: (type?: never) => Constructable<unknown>): Function;\nexport function Inject(serviceName?: string): Function;\nexport function Inject(token: Token<unknown>): Function;\nexport function Inject(\n  typeOrIdentifier?: ((type?: never) => Constructable<unknown>) | ServiceIdentifier<unknown>\n): ParameterDecorator | PropertyDecorator {\n  return function (target: Object, propertyName: string | Symbol, index?: number): void {\n    const typeWrapper = resolveToTypeWrapper(typeOrIdentifier, target, propertyName, index);\n\n    /** If no type was inferred, or the general Object type was inferred we throw an error. */\n    if (typeWrapper === undefined || typeWrapper.eagerType === undefined || typeWrapper.eagerType === Object) {\n      throw new CannotInjectValueError(target as Constructable<unknown>, propertyName as string);\n    }\n\n    Container.registerHandler({\n      object: target as Constructable<unknown>,\n      propertyName: propertyName as string,\n      index: index,\n      value: containerInstance => {\n        const evaluatedLazyType = typeWrapper.lazyType();\n\n        /** If no type was inferred lazily, or the general Object type was inferred we throw an error. */\n        if (evaluatedLazyType === undefined || evaluatedLazyType === Object) {\n          throw new CannotInjectValueError(target as Constructable<unknown>, propertyName as string);\n        }\n\n        return containerInstance.get<unknown>(evaluatedLazyType);\n      },\n    });\n  };\n}\n"]}