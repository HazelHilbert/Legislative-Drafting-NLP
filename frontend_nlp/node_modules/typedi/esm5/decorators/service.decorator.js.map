{"version":3,"file":"service.decorator.js","sourceRoot":"","sources":["../../../src/decorators/service.decorator.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,oBAAoB,CAAC;AAC/C,OAAO,EAAE,KAAK,EAAE,MAAM,gBAAgB,CAAC;AAGvC,OAAO,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;AAU7C,MAAM,UAAU,OAAO,CAAI,0BAAoE;IAC7F,OAAO,UAAA,iBAAiB;QACtB,IAAM,eAAe,GAAuB;YAC1C,EAAE,EAAE,iBAAiB;YACrB,mFAAmF;YACnF,IAAI,EAAG,iBAAiD;YACxD,OAAO,EAAE,SAAS;YAClB,QAAQ,EAAE,KAAK;YACf,MAAM,EAAE,KAAK;YACb,KAAK,EAAE,KAAK;YACZ,SAAS,EAAE,KAAK;YAChB,KAAK,EAAE,WAAW;SACnB,CAAC;QAEF,IAAI,0BAA0B,YAAY,KAAK,IAAI,OAAO,0BAA0B,KAAK,QAAQ,EAAE;YACjG,wCAAwC;YACxC,eAAe,CAAC,EAAE,GAAG,0BAA0B,CAAC;SACjD;aAAM,IAAI,0BAA0B,EAAE;YACrC,2CAA2C;YAC3C,eAAe,CAAC,EAAE,GAAI,0BAA8C,CAAC,EAAE,IAAI,iBAAiB,CAAC;YAC7F,eAAe,CAAC,OAAO,GAAI,0BAA8C,CAAC,OAAO,IAAI,SAAS,CAAC;YAC/F,eAAe,CAAC,QAAQ,GAAI,0BAA8C,CAAC,QAAQ,IAAI,KAAK,CAAC;YAC7F,eAAe,CAAC,MAAM,GAAI,0BAA8C,CAAC,MAAM,IAAI,KAAK,CAAC;YACzF,eAAe,CAAC,KAAK,GAAI,0BAA8C,CAAC,KAAK,IAAI,KAAK,CAAC;YACvF,eAAe,CAAC,SAAS,GAAI,0BAA8C,CAAC,SAAS,IAAI,KAAK,CAAC;SAChG;QAED,SAAS,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;IACjC,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import { Container } from '../container.class';\nimport { Token } from '../token.class';\nimport { ServiceMetadata } from '../interfaces/service-metadata.interface';\nimport { ServiceOptions } from '../interfaces/service-options.interface';\nimport { EMPTY_VALUE } from '../empty.const';\nimport { Constructable } from '../types/constructable.type';\n\n/**\n * Marks class as a service that can be injected using Container.\n */\nexport function Service<T = unknown>(): Function;\nexport function Service<T = unknown>(name: string): Function;\nexport function Service<T = unknown>(token: Token<unknown>): Function;\nexport function Service<T = unknown>(options?: ServiceOptions<T>): Function;\nexport function Service<T>(optionsOrServiceIdentifier?: ServiceOptions<T> | Token<any> | string): ClassDecorator {\n  return targetConstructor => {\n    const serviceMetadata: ServiceMetadata<T> = {\n      id: targetConstructor,\n      // TODO: Let's investigate why we receive Function type instead of a constructable.\n      type: (targetConstructor as unknown) as Constructable<T>,\n      factory: undefined,\n      multiple: false,\n      global: false,\n      eager: false,\n      transient: false,\n      value: EMPTY_VALUE,\n    };\n\n    if (optionsOrServiceIdentifier instanceof Token || typeof optionsOrServiceIdentifier === 'string') {\n      /** We received a Token or string ID. */\n      serviceMetadata.id = optionsOrServiceIdentifier;\n    } else if (optionsOrServiceIdentifier) {\n      /** We received a ServiceOptions object. */\n      serviceMetadata.id = (optionsOrServiceIdentifier as ServiceMetadata).id || targetConstructor;\n      serviceMetadata.factory = (optionsOrServiceIdentifier as ServiceMetadata).factory || undefined;\n      serviceMetadata.multiple = (optionsOrServiceIdentifier as ServiceMetadata).multiple || false;\n      serviceMetadata.global = (optionsOrServiceIdentifier as ServiceMetadata).global || false;\n      serviceMetadata.eager = (optionsOrServiceIdentifier as ServiceMetadata).eager || false;\n      serviceMetadata.transient = (optionsOrServiceIdentifier as ServiceMetadata).transient || false;\n    }\n\n    Container.set(serviceMetadata);\n  };\n}\n"]}