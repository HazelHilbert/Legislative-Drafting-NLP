{"version":3,"file":"resolve-to-type-wrapper.util.js","sourceRoot":"","sources":["../../../src/utils/resolve-to-type-wrapper.util.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,MAAM,gBAAgB,CAAC;AAIvC;;;;;;;;GAQG;AACH,MAAM,UAAU,oBAAoB,CAClC,gBAAqG,EACrG,MAAc,EACd,YAA6B,EAC7B,KAAc;IAEd;;;;;;;;OAQG;IACH,IAAI,WAAoG,CAAC;IAEzG,0FAA0F;IAC1F,IAAI,CAAC,gBAAgB,IAAI,OAAO,gBAAgB,KAAK,QAAQ,CAAC,IAAI,gBAAgB,YAAY,KAAK,EAAE;QACnG,WAAW,GAAG,EAAE,SAAS,EAAE,gBAAgB,EAAE,QAAQ,EAAE,cAAM,OAAA,gBAAgB,EAAhB,CAAgB,EAAE,CAAC;KACjF;IAED,gGAAgG;IAChG,IAAI,gBAAgB,IAAI,OAAO,gBAAgB,KAAK,UAAU,EAAE;QAC9D,qGAAqG;QACrG,WAAW,GAAG,EAAE,SAAS,EAAE,IAAI,EAAE,QAAQ,EAAE,cAAM,OAAC,gBAAqC,EAAE,EAAxC,CAAwC,EAAE,CAAC;KAC7F;IAED,gHAAgH;IAChH,IAAI,CAAC,gBAAgB,IAAI,YAAY,EAAE;QACrC,IAAM,YAAU,GAAI,OAAe,CAAC,WAAW,CAAC,aAAa,EAAE,MAAM,EAAE,YAAY,CAAC,CAAC;QAErF,WAAW,GAAG,EAAE,SAAS,EAAE,YAAU,EAAE,QAAQ,EAAE,cAAM,OAAA,YAAU,EAAV,CAAU,EAAE,CAAC;KACrE;IAED,yHAAyH;IACzH,IAAI,CAAC,gBAAgB,IAAI,OAAO,KAAK,IAAI,QAAQ,IAAI,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;QAC5E,IAAM,UAAU,GAAyB,OAAe,CAAC,WAAW,CAAC,mBAAmB,EAAE,MAAM,EAAE,YAAY,CAAC,CAAC;QAChH,uEAAuE;QACvE,IAAM,YAAU,GAAG,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAG,KAAK,CAAC,CAAC;QAEvC,WAAW,GAAG,EAAE,SAAS,EAAE,YAAU,EAAE,QAAQ,EAAE,cAAM,OAAA,YAAU,EAAV,CAAU,EAAE,CAAC;KACrE;IAED,OAAO,WAAW,CAAC;AACrB,CAAC","sourcesContent":["import { Token } from '../token.class';\nimport { Constructable } from '../types/constructable.type';\nimport { ServiceIdentifier } from '../types/service-identifier.type';\n\n/**\n * Helper function used in inject decorators to resolve the received identifier to\n * an eager type when possible or to a lazy type when cyclic dependencies are possibly involved.\n *\n * @param typeOrIdentifier a service identifier or a function returning a type acting as service identifier or nothing\n * @param target the class definition of the target of the decorator\n * @param propertyName the name of the property in case of a PropertyDecorator\n * @param index the index of the parameter in the constructor in case of ParameterDecorator\n */\nexport function resolveToTypeWrapper(\n  typeOrIdentifier: ((type?: never) => Constructable<unknown>) | ServiceIdentifier<unknown> | undefined,\n  target: Object,\n  propertyName: string | Symbol,\n  index?: number\n): { eagerType: ServiceIdentifier | null; lazyType: (type?: never) => ServiceIdentifier } {\n  /**\n   * ? We want to error out as soon as possible when looking up services to inject, however\n   * ? we cannot determine the type at decorator execution when cyclic dependencies are involved\n   * ? because calling the received `() => MyType` function right away would cause a JS error:\n   * ? \"Cannot access 'MyType' before initialization\", so we need to execute the function in the handler,\n   * ? when the classes are already created. To overcome this, we use a wrapper:\n   * ?  - the lazyType is executed in the handler so we never have a JS error\n   * ?  - the eagerType is checked when decorator is running and an error is raised if an unknown type is encountered\n   */\n  let typeWrapper!: { eagerType: ServiceIdentifier | null; lazyType: (type?: never) => ServiceIdentifier };\n\n  /** If requested type is explicitly set via a string ID or token, we set it explicitly. */\n  if ((typeOrIdentifier && typeof typeOrIdentifier === 'string') || typeOrIdentifier instanceof Token) {\n    typeWrapper = { eagerType: typeOrIdentifier, lazyType: () => typeOrIdentifier };\n  }\n\n  /** If requested type is explicitly set via a () => MyClassType format, we set it explicitly. */\n  if (typeOrIdentifier && typeof typeOrIdentifier === 'function') {\n    /** We set eagerType to null, preventing the raising of the CannotInjectValueError in decorators.  */\n    typeWrapper = { eagerType: null, lazyType: () => (typeOrIdentifier as CallableFunction)() };\n  }\n\n  /** If no explicit type is set and handler registered for a class property, we need to get the property type. */\n  if (!typeOrIdentifier && propertyName) {\n    const identifier = (Reflect as any).getMetadata('design:type', target, propertyName);\n\n    typeWrapper = { eagerType: identifier, lazyType: () => identifier };\n  }\n\n  /** If no explicit type is set and handler registered for a constructor parameter, we need to get the parameter types. */\n  if (!typeOrIdentifier && typeof index == 'number' && Number.isInteger(index)) {\n    const paramTypes: ServiceIdentifier[] = (Reflect as any).getMetadata('design:paramtypes', target, propertyName);\n    /** It's not guaranteed, that we find any types for the constructor. */\n    const identifier = paramTypes?.[index];\n\n    typeWrapper = { eagerType: identifier, lazyType: () => identifier };\n  }\n\n  return typeWrapper;\n}\n"]}