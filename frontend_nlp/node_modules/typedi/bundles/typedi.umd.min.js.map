{"version":3,"file":"typedi.umd.min.js","sources":["../esm5/error/service-not-found.error.js","../esm5/token.class.js","../esm5/error/cannot-instantiate-value.error.js","../esm5/empty.const.js","../esm5/container-instance.class.js","../esm5/container.class.js","../esm5/error/cannot-inject-value.error.js","../esm5/utils/resolve-to-type-wrapper.util.js","../esm5/decorators/inject.decorator.js","../esm5/decorators/inject-many.decorator.js","../esm5/decorators/service.decorator.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Token } from '../token.class';\n/**\n * Thrown when requested service was not found.\n */\nvar ServiceNotFoundError = /** @class */ (function (_super) {\n    __extends(ServiceNotFoundError, _super);\n    function ServiceNotFoundError(identifier) {\n        var _a, _b;\n        var _this = _super.call(this) || this;\n        _this.name = 'ServiceNotFoundError';\n        /** Normalized identifier name used in the error message. */\n        _this.normalizedIdentifier = '<UNKNOWN_IDENTIFIER>';\n        if (typeof identifier === 'string') {\n            _this.normalizedIdentifier = identifier;\n        }\n        else if (identifier instanceof Token) {\n            _this.normalizedIdentifier = \"Token<\" + (identifier.name || 'UNSET_NAME') + \">\";\n        }\n        else if (identifier && (identifier.name || ((_a = identifier.prototype) === null || _a === void 0 ? void 0 : _a.name))) {\n            _this.normalizedIdentifier =\n                \"MaybeConstructable<\" + identifier.name + \">\" ||\n                    \"MaybeConstructable<\" + ((_b = identifier.prototype) === null || _b === void 0 ? void 0 : _b.name) + \">\";\n        }\n        return _this;\n    }\n    Object.defineProperty(ServiceNotFoundError.prototype, \"message\", {\n        get: function () {\n            return (\"Service with \\\"\" + this.normalizedIdentifier + \"\\\" identifier was not found in the container. \" +\n                \"Register it before usage via explicitly calling the \\\"Container.set\\\" function or using the \\\"@Service()\\\" decorator.\");\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ServiceNotFoundError;\n}(Error));\nexport { ServiceNotFoundError };\n//# sourceMappingURL=service-not-found.error.js.map","/**\n * Used to create unique typed service identifier.\n * Useful when service has only interface, but don't have a class.\n */\nvar Token = /** @class */ (function () {\n    /**\n     * @param name Token name, optional and only used for debugging purposes.\n     */\n    function Token(name) {\n        this.name = name;\n    }\n    return Token;\n}());\nexport { Token };\n//# sourceMappingURL=token.class.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Token } from '../token.class';\n/**\n * Thrown when DI cannot inject value into property decorated by @Inject decorator.\n */\nvar CannotInstantiateValueError = /** @class */ (function (_super) {\n    __extends(CannotInstantiateValueError, _super);\n    function CannotInstantiateValueError(identifier) {\n        var _a, _b;\n        var _this = _super.call(this) || this;\n        _this.name = 'CannotInstantiateValueError';\n        /** Normalized identifier name used in the error message. */\n        _this.normalizedIdentifier = '<UNKNOWN_IDENTIFIER>';\n        // TODO: Extract this to a helper function and share between this and NotFoundError.\n        if (typeof identifier === 'string') {\n            _this.normalizedIdentifier = identifier;\n        }\n        else if (identifier instanceof Token) {\n            _this.normalizedIdentifier = \"Token<\" + (identifier.name || 'UNSET_NAME') + \">\";\n        }\n        else if (identifier && (identifier.name || ((_a = identifier.prototype) === null || _a === void 0 ? void 0 : _a.name))) {\n            _this.normalizedIdentifier =\n                \"MaybeConstructable<\" + identifier.name + \">\" ||\n                    \"MaybeConstructable<\" + ((_b = identifier.prototype) === null || _b === void 0 ? void 0 : _b.name) + \">\";\n        }\n        return _this;\n    }\n    Object.defineProperty(CannotInstantiateValueError.prototype, \"message\", {\n        get: function () {\n            return (\"Cannot instantiate the requested value for the \\\"\" + this.normalizedIdentifier + \"\\\" identifier. \" +\n                \"The related metadata doesn't contain a factory or a type to instantiate.\");\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return CannotInstantiateValueError;\n}(Error));\nexport { CannotInstantiateValueError };\n//# sourceMappingURL=cannot-instantiate-value.error.js.map","export var EMPTY_VALUE = Symbol('EMPTY_VALUE');\n//# sourceMappingURL=empty.const.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { Container } from './container.class';\nimport { ServiceNotFoundError } from './error/service-not-found.error';\nimport { CannotInstantiateValueError } from './error/cannot-instantiate-value.error';\nimport { Token } from './token.class';\nimport { EMPTY_VALUE } from './empty.const';\n/**\n * TypeDI can have multiple containers.\n * One container is ContainerInstance.\n */\nvar ContainerInstance = /** @class */ (function () {\n    function ContainerInstance(id) {\n        /** All registered services in the container. */\n        this.services = [];\n        this.id = id;\n    }\n    ContainerInstance.prototype.has = function (identifier) {\n        return !!this.findService(identifier);\n    };\n    ContainerInstance.prototype.get = function (identifier) {\n        var globalContainer = Container.of(undefined);\n        var globalService = globalContainer.findService(identifier);\n        var scopedService = this.findService(identifier);\n        if (globalService && globalService.global === true)\n            return this.getServiceValue(globalService);\n        if (scopedService)\n            return this.getServiceValue(scopedService);\n        /** If it's the first time requested in the child container we load it from parent and set it. */\n        if (globalService && this !== globalContainer) {\n            var clonedService = __assign({}, globalService);\n            clonedService.value = EMPTY_VALUE;\n            /**\n             * We need to immediately set the empty value from the root container\n             * to prevent infinite lookup in cyclic dependencies.\n             */\n            this.set(clonedService);\n            var value = this.getServiceValue(clonedService);\n            this.set(__assign(__assign({}, clonedService), { value: value }));\n            return value;\n        }\n        if (globalService)\n            return this.getServiceValue(globalService);\n        throw new ServiceNotFoundError(identifier);\n    };\n    ContainerInstance.prototype.getMany = function (identifier) {\n        var _this = this;\n        return this.findAllServices(identifier).map(function (service) { return _this.getServiceValue(service); });\n    };\n    ContainerInstance.prototype.set = function (identifierOrServiceMetadata, value) {\n        var _this = this;\n        if (identifierOrServiceMetadata instanceof Array) {\n            identifierOrServiceMetadata.forEach(function (data) { return _this.set(data); });\n            return this;\n        }\n        if (typeof identifierOrServiceMetadata === 'string' || identifierOrServiceMetadata instanceof Token) {\n            return this.set({\n                id: identifierOrServiceMetadata,\n                type: null,\n                value: value,\n                factory: undefined,\n                global: false,\n                multiple: false,\n                eager: false,\n                transient: false,\n            });\n        }\n        if (typeof identifierOrServiceMetadata === 'function') {\n            return this.set({\n                id: identifierOrServiceMetadata,\n                // TODO: remove explicit casting\n                type: identifierOrServiceMetadata,\n                value: value,\n                factory: undefined,\n                global: false,\n                multiple: false,\n                eager: false,\n                transient: false,\n            });\n        }\n        var newService = __assign({ id: new Token('UNREACHABLE'), type: null, factory: undefined, value: EMPTY_VALUE, global: false, multiple: false, eager: false, transient: false }, identifierOrServiceMetadata);\n        var service = this.findService(newService.id);\n        if (service && service.multiple !== true) {\n            Object.assign(service, newService);\n        }\n        else {\n            this.services.push(newService);\n        }\n        if (newService.eager) {\n            this.get(newService.id);\n        }\n        return this;\n    };\n    /**\n     * Removes services with a given service identifiers.\n     */\n    ContainerInstance.prototype.remove = function (identifierOrIdentifierArray) {\n        var _this = this;\n        if (Array.isArray(identifierOrIdentifierArray)) {\n            identifierOrIdentifierArray.forEach(function (id) { return _this.remove(id); });\n        }\n        else {\n            this.services = this.services.filter(function (service) {\n                if (service.id === identifierOrIdentifierArray) {\n                    _this.destroyServiceInstance(service);\n                    return false;\n                }\n                return true;\n            });\n        }\n        return this;\n    };\n    /**\n     * Completely resets the container by removing all previously registered services from it.\n     */\n    ContainerInstance.prototype.reset = function (options) {\n        var _this = this;\n        if (options === void 0) { options = { strategy: 'resetValue' }; }\n        switch (options.strategy) {\n            case 'resetValue':\n                this.services.forEach(function (service) { return _this.destroyServiceInstance(service); });\n                break;\n            case 'resetServices':\n                this.services.forEach(function (service) { return _this.destroyServiceInstance(service); });\n                this.services = [];\n                break;\n            default:\n                throw new Error('Received invalid reset strategy.');\n        }\n        return this;\n    };\n    /**\n     * Returns all services registered with the given identifier.\n     */\n    ContainerInstance.prototype.findAllServices = function (identifier) {\n        return this.services.filter(function (service) { return service.id === identifier; });\n    };\n    /**\n     * Finds registered service in the with a given service identifier.\n     */\n    ContainerInstance.prototype.findService = function (identifier) {\n        return this.services.find(function (service) { return service.id === identifier; });\n    };\n    /**\n     * Gets the value belonging to `serviceMetadata.id`.\n     *\n     * - if `serviceMetadata.value` is already set it is immediately returned\n     * - otherwise the requested type is resolved to the value saved to `serviceMetadata.value` and returned\n     */\n    ContainerInstance.prototype.getServiceValue = function (serviceMetadata) {\n        var _a;\n        var value = EMPTY_VALUE;\n        /**\n         * If the service value has been set to anything prior to this call we return that value.\n         * NOTE: This part builds on the assumption that transient dependencies has no value set ever.\n         */\n        if (serviceMetadata.value !== EMPTY_VALUE) {\n            return serviceMetadata.value;\n        }\n        /** If both factory and type is missing, we cannot resolve the requested ID. */\n        if (!serviceMetadata.factory && !serviceMetadata.type) {\n            throw new CannotInstantiateValueError(serviceMetadata.id);\n        }\n        /**\n         * If a factory is defined it takes priority over creating an instance via `new`.\n         * The return value of the factory is not checked, we believe by design that the user knows what he/she is doing.\n         */\n        if (serviceMetadata.factory) {\n            /**\n             * If we received the factory in the [Constructable<Factory>, \"functionName\"] format, we need to create the\n             * factory first and then call the specified function on it.\n             */\n            if (serviceMetadata.factory instanceof Array) {\n                var factoryInstance = void 0;\n                try {\n                    /** Try to get the factory from TypeDI first, if failed, fall back to simply initiating the class. */\n                    factoryInstance = this.get(serviceMetadata.factory[0]);\n                }\n                catch (error) {\n                    if (error instanceof ServiceNotFoundError) {\n                        factoryInstance = new serviceMetadata.factory[0]();\n                    }\n                    else {\n                        throw error;\n                    }\n                }\n                value = factoryInstance[serviceMetadata.factory[1]](this, serviceMetadata.id);\n            }\n            else {\n                /** If only a simple function was provided we simply call it. */\n                value = serviceMetadata.factory(this, serviceMetadata.id);\n            }\n        }\n        /**\n         * If no factory was provided and only then, we create the instance from the type if it was set.\n         */\n        if (!serviceMetadata.factory && serviceMetadata.type) {\n            var constructableTargetType = serviceMetadata.type;\n            // setup constructor parameters for a newly initialized service\n            var paramTypes = ((_a = Reflect) === null || _a === void 0 ? void 0 : _a.getMetadata('design:paramtypes', constructableTargetType)) || [];\n            var params = this.initializeParams(constructableTargetType, paramTypes);\n            // \"extra feature\" - always pass container instance as the last argument to the service function\n            // this allows us to support javascript where we don't have decorators and emitted metadata about dependencies\n            // need to be injected, and user can use provided container to get instances he needs\n            params.push(this);\n            value = new (constructableTargetType.bind.apply(constructableTargetType, __spreadArrays([void 0], params)))();\n            // TODO: Calling this here, leads to infinite loop, because @Inject decorator registerds a handler\n            // TODO: which calls Container.get, which will check if the requested type has a value set and if not\n            // TODO: it will start the instantiation process over. So this is currently called outside of the if branch\n            // TODO: after the current value has been assigned to the serviceMetadata.\n            // this.applyPropertyHandlers(constructableTargetType, value as Constructable<unknown>);\n        }\n        /** If this is not a transient service, and we resolved something, then we set it as the value. */\n        if (!serviceMetadata.transient && value !== EMPTY_VALUE) {\n            serviceMetadata.value = value;\n        }\n        if (value === EMPTY_VALUE) {\n            /** This branch should never execute, but better to be safe than sorry. */\n            throw new CannotInstantiateValueError(serviceMetadata.id);\n        }\n        if (serviceMetadata.type) {\n            this.applyPropertyHandlers(serviceMetadata.type, value);\n        }\n        return value;\n    };\n    /**\n     * Initializes all parameter types for a given target service class.\n     */\n    ContainerInstance.prototype.initializeParams = function (target, paramTypes) {\n        var _this = this;\n        return paramTypes.map(function (paramType, index) {\n            var paramHandler = Container.handlers.find(function (handler) {\n                /**\n                 * @Inject()-ed values are stored as parameter handlers and they reference their target\n                 * when created. So when a class is extended the @Inject()-ed values are not inherited\n                 * because the handler still points to the old object only.\n                 *\n                 * As a quick fix a single level parent lookup is added via `Object.getPrototypeOf(target)`,\n                 * however this should be updated to a more robust solution.\n                 *\n                 * TODO: Add proper inheritance handling: either copy the handlers when a class is registered what\n                 * TODO: has it's parent already registered as dependency or make the lookup search up to the base Object.\n                 */\n                return ((handler.object === target || handler.object === Object.getPrototypeOf(target)) && handler.index === index);\n            });\n            if (paramHandler)\n                return paramHandler.value(_this);\n            if (paramType && paramType.name && !_this.isPrimitiveParamType(paramType.name)) {\n                return _this.get(paramType);\n            }\n            return undefined;\n        });\n    };\n    /**\n     * Checks if given parameter type is primitive type or not.\n     */\n    ContainerInstance.prototype.isPrimitiveParamType = function (paramTypeName) {\n        return ['string', 'boolean', 'number', 'object'].includes(paramTypeName.toLowerCase());\n    };\n    /**\n     * Applies all registered handlers on a given target class.\n     */\n    ContainerInstance.prototype.applyPropertyHandlers = function (target, instance) {\n        var _this = this;\n        Container.handlers.forEach(function (handler) {\n            if (typeof handler.index === 'number')\n                return;\n            if (handler.object.constructor !== target && !(target.prototype instanceof handler.object.constructor))\n                return;\n            if (handler.propertyName) {\n                instance[handler.propertyName] = handler.value(_this);\n            }\n        });\n    };\n    /**\n     * Checks if the given service metadata contains a destroyable service instance and destroys it in place. If the service\n     * contains a callable function named `destroy` it is called but not awaited and the return value is ignored..\n     *\n     * @param serviceMetadata the service metadata containing the instance to destroy\n     * @param force when true the service will be always destroyed even if it's cannot be re-created\n     */\n    ContainerInstance.prototype.destroyServiceInstance = function (serviceMetadata, force) {\n        if (force === void 0) { force = false; }\n        /** We reset value only if we can re-create it (aka type or factory exists). */\n        var shouldResetValue = force || !!serviceMetadata.type || !!serviceMetadata.factory;\n        if (shouldResetValue) {\n            /** If we wound a function named destroy we call it without any params. */\n            if (typeof (serviceMetadata === null || serviceMetadata === void 0 ? void 0 : serviceMetadata.value)['destroy'] === 'function') {\n                try {\n                    serviceMetadata.value.destroy();\n                }\n                catch (error) {\n                    /** We simply ignore the errors from the destroy function. */\n                }\n            }\n            serviceMetadata.value = EMPTY_VALUE;\n        }\n    };\n    return ContainerInstance;\n}());\nexport { ContainerInstance };\n//# sourceMappingURL=container-instance.class.js.map","import { ContainerInstance } from './container-instance.class';\n/**\n * Service container.\n */\nvar Container = /** @class */ (function () {\n    function Container() {\n    }\n    /**\n     * Gets a separate container instance for the given instance id.\n     */\n    Container.of = function (containerId) {\n        if (containerId === void 0) { containerId = 'default'; }\n        if (containerId === 'default')\n            return this.globalInstance;\n        var container = this.instances.find(function (instance) { return instance.id === containerId; });\n        if (!container) {\n            container = new ContainerInstance(containerId);\n            this.instances.push(container);\n            // TODO: Why we are not reseting here? Let's reset here. (I have added the commented code.)\n            // container.reset();\n        }\n        return container;\n    };\n    Container.has = function (identifier) {\n        return this.globalInstance.has(identifier);\n    };\n    Container.get = function (identifier) {\n        return this.globalInstance.get(identifier);\n    };\n    Container.getMany = function (id) {\n        return this.globalInstance.getMany(id);\n    };\n    Container.set = function (identifierOrServiceMetadata, value) {\n        this.globalInstance.set(identifierOrServiceMetadata, value);\n        return this;\n    };\n    /**\n     * Removes services with a given service identifiers.\n     */\n    Container.remove = function (identifierOrIdentifierArray) {\n        this.globalInstance.remove(identifierOrIdentifierArray);\n        return this;\n    };\n    /**\n     * Completely resets the container by removing all previously registered services and handlers from it.\n     */\n    Container.reset = function (containerId) {\n        if (containerId === void 0) { containerId = 'default'; }\n        if (containerId == 'default') {\n            this.globalInstance.reset();\n            this.instances.forEach(function (instance) { return instance.reset(); });\n        }\n        else {\n            var instance = this.instances.find(function (instance) { return instance.id === containerId; });\n            if (instance) {\n                instance.reset();\n                this.instances.splice(this.instances.indexOf(instance), 1);\n            }\n        }\n        return this;\n    };\n    /**\n     * Registers a new handler.\n     */\n    Container.registerHandler = function (handler) {\n        this.handlers.push(handler);\n        return this;\n    };\n    /**\n     * Helper method that imports given services.\n     */\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    Container.import = function (services) {\n        return this;\n    };\n    /**\n     * All registered handlers. The @Inject() decorator uses handlers internally to mark a property for injection.\n     **/\n    Container.handlers = [];\n    /**  Global container instance. */\n    Container.globalInstance = new ContainerInstance('default');\n    /** Other containers created using Container.of method. */\n    Container.instances = [];\n    return Container;\n}());\nexport { Container };\n//# sourceMappingURL=container.class.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * Thrown when DI cannot inject value into property decorated by @Inject decorator.\n */\nvar CannotInjectValueError = /** @class */ (function (_super) {\n    __extends(CannotInjectValueError, _super);\n    function CannotInjectValueError(target, propertyName) {\n        var _this = _super.call(this) || this;\n        _this.target = target;\n        _this.propertyName = propertyName;\n        _this.name = 'CannotInjectValueError';\n        return _this;\n    }\n    Object.defineProperty(CannotInjectValueError.prototype, \"message\", {\n        get: function () {\n            return (\"Cannot inject value into \\\"\" + this.target.constructor.name + \".\" + this.propertyName + \"\\\". \" +\n                \"Please make sure you setup reflect-metadata properly and you don't use interfaces without service tokens as injection value.\");\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return CannotInjectValueError;\n}(Error));\nexport { CannotInjectValueError };\n//# sourceMappingURL=cannot-inject-value.error.js.map","import { Token } from '../token.class';\n/**\n * Helper function used in inject decorators to resolve the received identifier to\n * an eager type when possible or to a lazy type when cyclic dependencies are possibly involved.\n *\n * @param typeOrIdentifier a service identifier or a function returning a type acting as service identifier or nothing\n * @param target the class definition of the target of the decorator\n * @param propertyName the name of the property in case of a PropertyDecorator\n * @param index the index of the parameter in the constructor in case of ParameterDecorator\n */\nexport function resolveToTypeWrapper(typeOrIdentifier, target, propertyName, index) {\n    /**\n     * ? We want to error out as soon as possible when looking up services to inject, however\n     * ? we cannot determine the type at decorator execution when cyclic dependencies are involved\n     * ? because calling the received `() => MyType` function right away would cause a JS error:\n     * ? \"Cannot access 'MyType' before initialization\", so we need to execute the function in the handler,\n     * ? when the classes are already created. To overcome this, we use a wrapper:\n     * ?  - the lazyType is executed in the handler so we never have a JS error\n     * ?  - the eagerType is checked when decorator is running and an error is raised if an unknown type is encountered\n     */\n    var typeWrapper;\n    /** If requested type is explicitly set via a string ID or token, we set it explicitly. */\n    if ((typeOrIdentifier && typeof typeOrIdentifier === 'string') || typeOrIdentifier instanceof Token) {\n        typeWrapper = { eagerType: typeOrIdentifier, lazyType: function () { return typeOrIdentifier; } };\n    }\n    /** If requested type is explicitly set via a () => MyClassType format, we set it explicitly. */\n    if (typeOrIdentifier && typeof typeOrIdentifier === 'function') {\n        /** We set eagerType to null, preventing the raising of the CannotInjectValueError in decorators.  */\n        typeWrapper = { eagerType: null, lazyType: function () { return typeOrIdentifier(); } };\n    }\n    /** If no explicit type is set and handler registered for a class property, we need to get the property type. */\n    if (!typeOrIdentifier && propertyName) {\n        var identifier_1 = Reflect.getMetadata('design:type', target, propertyName);\n        typeWrapper = { eagerType: identifier_1, lazyType: function () { return identifier_1; } };\n    }\n    /** If no explicit type is set and handler registered for a constructor parameter, we need to get the parameter types. */\n    if (!typeOrIdentifier && typeof index == 'number' && Number.isInteger(index)) {\n        var paramTypes = Reflect.getMetadata('design:paramtypes', target, propertyName);\n        /** It's not guaranteed, that we find any types for the constructor. */\n        var identifier_2 = paramTypes === null || paramTypes === void 0 ? void 0 : paramTypes[index];\n        typeWrapper = { eagerType: identifier_2, lazyType: function () { return identifier_2; } };\n    }\n    return typeWrapper;\n}\n//# sourceMappingURL=resolve-to-type-wrapper.util.js.map","import { Container } from '../container.class';\nimport { CannotInjectValueError } from '../error/cannot-inject-value.error';\nimport { resolveToTypeWrapper } from '../utils/resolve-to-type-wrapper.util';\nexport function Inject(typeOrIdentifier) {\n    return function (target, propertyName, index) {\n        var typeWrapper = resolveToTypeWrapper(typeOrIdentifier, target, propertyName, index);\n        /** If no type was inferred, or the general Object type was inferred we throw an error. */\n        if (typeWrapper === undefined || typeWrapper.eagerType === undefined || typeWrapper.eagerType === Object) {\n            throw new CannotInjectValueError(target, propertyName);\n        }\n        Container.registerHandler({\n            object: target,\n            propertyName: propertyName,\n            index: index,\n            value: function (containerInstance) {\n                var evaluatedLazyType = typeWrapper.lazyType();\n                /** If no type was inferred lazily, or the general Object type was inferred we throw an error. */\n                if (evaluatedLazyType === undefined || evaluatedLazyType === Object) {\n                    throw new CannotInjectValueError(target, propertyName);\n                }\n                return containerInstance.get(evaluatedLazyType);\n            },\n        });\n    };\n}\n//# sourceMappingURL=inject.decorator.js.map","import { Container } from '../container.class';\nimport { CannotInjectValueError } from '../error/cannot-inject-value.error';\nimport { resolveToTypeWrapper } from '../utils/resolve-to-type-wrapper.util';\nexport function InjectMany(typeOrIdentifier) {\n    return function (target, propertyName, index) {\n        var typeWrapper = resolveToTypeWrapper(typeOrIdentifier, target, propertyName, index);\n        /** If no type was inferred, or the general Object type was inferred we throw an error. */\n        if (typeWrapper === undefined || typeWrapper.eagerType === undefined || typeWrapper.eagerType === Object) {\n            throw new CannotInjectValueError(target, propertyName);\n        }\n        Container.registerHandler({\n            object: target,\n            propertyName: propertyName,\n            index: index,\n            value: function (containerInstance) {\n                var evaluatedLazyType = typeWrapper.lazyType();\n                /** If no type was inferred lazily, or the general Object type was inferred we throw an error. */\n                if (evaluatedLazyType === undefined || evaluatedLazyType === Object) {\n                    throw new CannotInjectValueError(target, propertyName);\n                }\n                return containerInstance.getMany(evaluatedLazyType);\n            },\n        });\n    };\n}\n//# sourceMappingURL=inject-many.decorator.js.map","import { Container } from '../container.class';\nimport { Token } from '../token.class';\nimport { EMPTY_VALUE } from '../empty.const';\nexport function Service(optionsOrServiceIdentifier) {\n    return function (targetConstructor) {\n        var serviceMetadata = {\n            id: targetConstructor,\n            // TODO: Let's investigate why we receive Function type instead of a constructable.\n            type: targetConstructor,\n            factory: undefined,\n            multiple: false,\n            global: false,\n            eager: false,\n            transient: false,\n            value: EMPTY_VALUE,\n        };\n        if (optionsOrServiceIdentifier instanceof Token || typeof optionsOrServiceIdentifier === 'string') {\n            /** We received a Token or string ID. */\n            serviceMetadata.id = optionsOrServiceIdentifier;\n        }\n        else if (optionsOrServiceIdentifier) {\n            /** We received a ServiceOptions object. */\n            serviceMetadata.id = optionsOrServiceIdentifier.id || targetConstructor;\n            serviceMetadata.factory = optionsOrServiceIdentifier.factory || undefined;\n            serviceMetadata.multiple = optionsOrServiceIdentifier.multiple || false;\n            serviceMetadata.global = optionsOrServiceIdentifier.global || false;\n            serviceMetadata.eager = optionsOrServiceIdentifier.eager || false;\n            serviceMetadata.transient = optionsOrServiceIdentifier.transient || false;\n        }\n        Container.set(serviceMetadata);\n    };\n}\n//# sourceMappingURL=service.decorator.js.map"],"names":["extendStatics","Token","name","this","__extends","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__","constructor","create","ServiceNotFoundError","_super","identifier","_a","_b","_this","normalizedIdentifier","defineProperty","get","enumerable","configurable","Error","CannotInstantiateValueError","EMPTY_VALUE","Symbol","__assign","assign","t","s","i","n","arguments","length","apply","__spreadArrays","il","r","k","a","j","jl","ContainerInstance","id","services","has","findService","globalContainer","Container","of","undefined","globalService","scopedService","global","getServiceValue","clonedService","value","set","getMany","findAllServices","map","service","identifierOrServiceMetadata","forEach","data","type","factory","multiple","eager","transient","newService","push","remove","identifierOrIdentifierArray","isArray","filter","destroyServiceInstance","reset","options","strategy","find","serviceMetadata","factoryInstance","error","constructableTargetType","paramTypes","Reflect","getMetadata","params","initializeParams","bind","applyPropertyHandlers","target","paramType","index","paramHandler","handlers","handler","object","getPrototypeOf","isPrimitiveParamType","paramTypeName","includes","toLowerCase","instance","propertyName","force","destroy","containerId","globalInstance","container","instances","splice","indexOf","registerHandler","import","CannotInjectValueError","resolveToTypeWrapper","typeOrIdentifier","typeWrapper","eagerType","lazyType","identifier_1","Number","isInteger","identifier_2","containerInstance","evaluatedLazyType","optionsOrServiceIdentifier","targetConstructor"],"mappings":"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"}