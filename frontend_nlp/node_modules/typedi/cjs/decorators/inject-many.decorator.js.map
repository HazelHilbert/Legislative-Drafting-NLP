{"version":3,"file":"inject-many.decorator.js","sourceRoot":"","sources":["../../../src/decorators/inject-many.decorator.ts"],"names":[],"mappings":";;;AAAA,wDAA+C;AAE/C,kFAA4E;AAC5E,wFAA6E;AAW7E,SAAgB,UAAU,CACxB,gBAA0F;IAE1F,OAAO,UAAU,MAAc,EAAE,YAA6B,EAAE,KAAc;QAC5E,MAAM,WAAW,GAAG,mDAAoB,CAAC,gBAAgB,EAAE,MAAM,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;QAExF,0FAA0F;QAC1F,IAAI,WAAW,KAAK,SAAS,IAAI,WAAW,CAAC,SAAS,KAAK,SAAS,IAAI,WAAW,CAAC,SAAS,KAAK,MAAM,EAAE;YACxG,MAAM,IAAI,kDAAsB,CAAC,MAAgC,EAAE,YAAsB,CAAC,CAAC;SAC5F;QAED,2BAAS,CAAC,eAAe,CAAC;YACxB,MAAM,EAAE,MAAgC;YACxC,YAAY,EAAE,YAAsB;YACpC,KAAK,EAAE,KAAK;YACZ,KAAK,EAAE,iBAAiB,CAAC,EAAE;gBACzB,MAAM,iBAAiB,GAAG,WAAW,CAAC,QAAQ,EAAE,CAAC;gBAEjD,iGAAiG;gBACjG,IAAI,iBAAiB,KAAK,SAAS,IAAI,iBAAiB,KAAK,MAAM,EAAE;oBACnE,MAAM,IAAI,kDAAsB,CAAC,MAAgC,EAAE,YAAsB,CAAC,CAAC;iBAC5F;gBAED,OAAO,iBAAiB,CAAC,OAAO,CAAU,iBAAiB,CAAC,CAAC;YAC/D,CAAC;SACF,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC;AA3BD,gCA2BC","sourcesContent":["import { Container } from '../container.class';\nimport { Token } from '../token.class';\nimport { CannotInjectValueError } from '../error/cannot-inject-value.error';\nimport { resolveToTypeWrapper } from '../utils/resolve-to-type-wrapper.util';\nimport { Constructable } from '../types/constructable.type';\nimport { ServiceIdentifier } from '../types/service-identifier.type';\n\n/**\n * Injects a list of services into a class property or constructor parameter.\n */\nexport function InjectMany(): Function;\nexport function InjectMany(type?: (type?: any) => Function): Function;\nexport function InjectMany(serviceName?: string): Function;\nexport function InjectMany(token: Token<any>): Function;\nexport function InjectMany(\n  typeOrIdentifier?: ((type?: never) => Constructable<unknown>) | ServiceIdentifier<unknown>\n): Function {\n  return function (target: Object, propertyName: string | Symbol, index?: number): void {\n    const typeWrapper = resolveToTypeWrapper(typeOrIdentifier, target, propertyName, index);\n\n    /** If no type was inferred, or the general Object type was inferred we throw an error. */\n    if (typeWrapper === undefined || typeWrapper.eagerType === undefined || typeWrapper.eagerType === Object) {\n      throw new CannotInjectValueError(target as Constructable<unknown>, propertyName as string);\n    }\n\n    Container.registerHandler({\n      object: target as Constructable<unknown>,\n      propertyName: propertyName as string,\n      index: index,\n      value: containerInstance => {\n        const evaluatedLazyType = typeWrapper.lazyType();\n\n        /** If no type was inferred lazily, or the general Object type was inferred we throw an error. */\n        if (evaluatedLazyType === undefined || evaluatedLazyType === Object) {\n          throw new CannotInjectValueError(target as Constructable<unknown>, propertyName as string);\n        }\n\n        return containerInstance.getMany<unknown>(evaluatedLazyType);\n      },\n    });\n  };\n}\n"]}