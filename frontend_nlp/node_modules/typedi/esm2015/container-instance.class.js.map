{"version":3,"file":"container-instance.class.js","sourceRoot":"","sources":["../../src/container-instance.class.ts"],"names":[],"mappings":"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","sourcesContent":["import { Container } from './container.class';\nimport { ServiceNotFoundError } from './error/service-not-found.error';\nimport { CannotInstantiateValueError } from './error/cannot-instantiate-value.error';\nimport { Token } from './token.class';\nimport { Constructable } from './types/constructable.type';\nimport { AbstractConstructable } from './types/abstract-constructable.type';\nimport { ServiceIdentifier } from './types/service-identifier.type';\nimport { ServiceMetadata } from './interfaces/service-metadata.interface';\nimport { ServiceOptions } from './interfaces/service-options.interface';\nimport { EMPTY_VALUE } from './empty.const';\n\n/**\n * TypeDI can have multiple containers.\n * One container is ContainerInstance.\n */\nexport class ContainerInstance {\n  /** Container instance id. */\n  public readonly id!: string;\n\n  /** All registered services in the container. */\n  private services: ServiceMetadata<unknown>[] = [];\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  /**\n   * Checks if the service with given name or type is registered service container.\n   * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n   */\n  has<T>(type: Constructable<T>): boolean;\n  has<T>(id: string): boolean;\n  has<T>(id: Token<T>): boolean;\n  has<T>(identifier: ServiceIdentifier): boolean {\n    return !!this.findService(identifier);\n  }\n\n  /**\n   * Retrieves the service with given name or type from the service container.\n   * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n   */\n  get<T>(type: Constructable<T>): T;\n  get<T>(type: AbstractConstructable<T>): T;\n  get<T>(id: string): T;\n  get<T>(id: Token<T>): T;\n  get<T>(id: ServiceIdentifier<T>): T;\n  get<T>(identifier: ServiceIdentifier<T>): T {\n    const globalContainer = Container.of(undefined);\n    const globalService = globalContainer.findService(identifier);\n    const scopedService = this.findService(identifier);\n\n    if (globalService && globalService.global === true) return this.getServiceValue(globalService);\n\n    if (scopedService) return this.getServiceValue(scopedService);\n\n    /** If it's the first time requested in the child container we load it from parent and set it. */\n    if (globalService && this !== globalContainer) {\n      const clonedService = { ...globalService };\n      clonedService.value = EMPTY_VALUE;\n\n      /**\n       * We need to immediately set the empty value from the root container\n       * to prevent infinite lookup in cyclic dependencies.\n       */\n      this.set(clonedService);\n\n      const value = this.getServiceValue(clonedService);\n      this.set({ ...clonedService, value });\n\n      return value;\n    }\n\n    if (globalService) return this.getServiceValue(globalService);\n\n    throw new ServiceNotFoundError(identifier);\n  }\n\n  /**\n   * Gets all instances registered in the container of the given service identifier.\n   * Used when service defined with multiple: true flag.\n   */\n  getMany<T>(type: Constructable<T>): T[];\n  getMany<T>(type: AbstractConstructable<T>): T[];\n  getMany<T>(id: string): T[];\n  getMany<T>(id: Token<T>): T[];\n  getMany<T>(id: ServiceIdentifier<T>): T[];\n  getMany<T>(identifier: ServiceIdentifier<T>): T[] {\n    return this.findAllServices(identifier).map(service => this.getServiceValue(service));\n  }\n\n  /**\n   * Sets a value for the given type or service name in the container.\n   */\n  set<T = unknown>(service: ServiceMetadata<T>): this; // This should be hidden\n  set<T = unknown>(type: Constructable<T>, instance: T): this;\n  set<T = unknown>(type: AbstractConstructable<T>, instance: T): this;\n  set<T = unknown>(name: string, instance: T): this;\n  set<T = unknown>(token: Token<T>, instance: T): this;\n  set<T = unknown>(token: ServiceIdentifier, instance: T): this;\n  set<T = unknown>(metadata: ServiceOptions<T>): this;\n  set<T = unknown>(metadataArray: ServiceOptions<T>[]): this;\n  set<T = unknown>(\n    identifierOrServiceMetadata: ServiceIdentifier | ServiceOptions<T> | ServiceOptions<T>[],\n    value?: T\n  ): this {\n    if (identifierOrServiceMetadata instanceof Array) {\n      identifierOrServiceMetadata.forEach(data => this.set(data));\n\n      return this;\n    }\n\n    if (typeof identifierOrServiceMetadata === 'string' || identifierOrServiceMetadata instanceof Token) {\n      return this.set({\n        id: identifierOrServiceMetadata,\n        type: null,\n        value: value,\n        factory: undefined,\n        global: false,\n        multiple: false,\n        eager: false,\n        transient: false,\n      });\n    }\n\n    if (typeof identifierOrServiceMetadata === 'function') {\n      return this.set({\n        id: identifierOrServiceMetadata,\n        // TODO: remove explicit casting\n        type: identifierOrServiceMetadata as Constructable<unknown>,\n        value: value,\n        factory: undefined,\n        global: false,\n        multiple: false,\n        eager: false,\n        transient: false,\n      });\n    }\n\n    const newService: ServiceMetadata<T> = {\n      id: new Token('UNREACHABLE'),\n      type: null,\n      factory: undefined,\n      value: EMPTY_VALUE,\n      global: false,\n      multiple: false,\n      eager: false,\n      transient: false,\n      ...identifierOrServiceMetadata,\n    };\n\n    const service = this.findService(newService.id);\n\n    if (service && service.multiple !== true) {\n      Object.assign(service, newService);\n    } else {\n      this.services.push(newService);\n    }\n\n    if (newService.eager) {\n      this.get(newService.id);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes services with a given service identifiers.\n   */\n  public remove(identifierOrIdentifierArray: ServiceIdentifier | ServiceIdentifier[]): this {\n    if (Array.isArray(identifierOrIdentifierArray)) {\n      identifierOrIdentifierArray.forEach(id => this.remove(id));\n    } else {\n      this.services = this.services.filter(service => {\n        if (service.id === identifierOrIdentifierArray) {\n          this.destroyServiceInstance(service);\n          return false;\n        }\n\n        return true;\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Completely resets the container by removing all previously registered services from it.\n   */\n  public reset(options: { strategy: 'resetValue' | 'resetServices' } = { strategy: 'resetValue' }): this {\n    switch (options.strategy) {\n      case 'resetValue':\n        this.services.forEach(service => this.destroyServiceInstance(service));\n        break;\n      case 'resetServices':\n        this.services.forEach(service => this.destroyServiceInstance(service));\n        this.services = [];\n        break;\n      default:\n        throw new Error('Received invalid reset strategy.');\n    }\n    return this;\n  }\n\n  /**\n   * Returns all services registered with the given identifier.\n   */\n  private findAllServices(identifier: ServiceIdentifier): ServiceMetadata<unknown>[] {\n    return this.services.filter(service => service.id === identifier);\n  }\n\n  /**\n   * Finds registered service in the with a given service identifier.\n   */\n  private findService(identifier: ServiceIdentifier): ServiceMetadata<unknown> | undefined {\n    return this.services.find(service => service.id === identifier);\n  }\n\n  /**\n   * Gets the value belonging to `serviceMetadata.id`.\n   *\n   * - if `serviceMetadata.value` is already set it is immediately returned\n   * - otherwise the requested type is resolved to the value saved to `serviceMetadata.value` and returned\n   */\n  private getServiceValue(serviceMetadata: ServiceMetadata<unknown>): any {\n    let value: unknown = EMPTY_VALUE;\n\n    /**\n     * If the service value has been set to anything prior to this call we return that value.\n     * NOTE: This part builds on the assumption that transient dependencies has no value set ever.\n     */\n    if (serviceMetadata.value !== EMPTY_VALUE) {\n      return serviceMetadata.value;\n    }\n\n    /** If both factory and type is missing, we cannot resolve the requested ID. */\n    if (!serviceMetadata.factory && !serviceMetadata.type) {\n      throw new CannotInstantiateValueError(serviceMetadata.id);\n    }\n\n    /**\n     * If a factory is defined it takes priority over creating an instance via `new`.\n     * The return value of the factory is not checked, we believe by design that the user knows what he/she is doing.\n     */\n    if (serviceMetadata.factory) {\n      /**\n       * If we received the factory in the [Constructable<Factory>, \"functionName\"] format, we need to create the\n       * factory first and then call the specified function on it.\n       */\n      if (serviceMetadata.factory instanceof Array) {\n        let factoryInstance;\n\n        try {\n          /** Try to get the factory from TypeDI first, if failed, fall back to simply initiating the class. */\n          factoryInstance = this.get<any>(serviceMetadata.factory[0]);\n        } catch (error) {\n          if (error instanceof ServiceNotFoundError) {\n            factoryInstance = new serviceMetadata.factory[0]();\n          } else {\n            throw error;\n          }\n        }\n\n        value = factoryInstance[serviceMetadata.factory[1]](this, serviceMetadata.id);\n      } else {\n        /** If only a simple function was provided we simply call it. */\n        value = serviceMetadata.factory(this, serviceMetadata.id);\n      }\n    }\n\n    /**\n     * If no factory was provided and only then, we create the instance from the type if it was set.\n     */\n    if (!serviceMetadata.factory && serviceMetadata.type) {\n      const constructableTargetType: Constructable<unknown> = serviceMetadata.type;\n      // setup constructor parameters for a newly initialized service\n      const paramTypes = (Reflect as any)?.getMetadata('design:paramtypes', constructableTargetType) || [];\n      const params = this.initializeParams(constructableTargetType, paramTypes);\n\n      // \"extra feature\" - always pass container instance as the last argument to the service function\n      // this allows us to support javascript where we don't have decorators and emitted metadata about dependencies\n      // need to be injected, and user can use provided container to get instances he needs\n      params.push(this);\n\n      value = new constructableTargetType(...params);\n\n      // TODO: Calling this here, leads to infinite loop, because @Inject decorator registerds a handler\n      // TODO: which calls Container.get, which will check if the requested type has a value set and if not\n      // TODO: it will start the instantiation process over. So this is currently called outside of the if branch\n      // TODO: after the current value has been assigned to the serviceMetadata.\n      // this.applyPropertyHandlers(constructableTargetType, value as Constructable<unknown>);\n    }\n\n    /** If this is not a transient service, and we resolved something, then we set it as the value. */\n    if (!serviceMetadata.transient && value !== EMPTY_VALUE) {\n      serviceMetadata.value = value;\n    }\n\n    if (value === EMPTY_VALUE) {\n      /** This branch should never execute, but better to be safe than sorry. */\n      throw new CannotInstantiateValueError(serviceMetadata.id);\n    }\n\n    if (serviceMetadata.type) {\n      this.applyPropertyHandlers(serviceMetadata.type, value as Record<string, any>);\n    }\n\n    return value;\n  }\n\n  /**\n   * Initializes all parameter types for a given target service class.\n   */\n  private initializeParams(target: Function, paramTypes: any[]): unknown[] {\n    return paramTypes.map((paramType, index) => {\n      const paramHandler = Container.handlers.find(handler => {\n        /**\n         * @Inject()-ed values are stored as parameter handlers and they reference their target\n         * when created. So when a class is extended the @Inject()-ed values are not inherited\n         * because the handler still points to the old object only.\n         *\n         * As a quick fix a single level parent lookup is added via `Object.getPrototypeOf(target)`,\n         * however this should be updated to a more robust solution.\n         *\n         * TODO: Add proper inheritance handling: either copy the handlers when a class is registered what\n         * TODO: has it's parent already registered as dependency or make the lookup search up to the base Object.\n         */\n        return (\n          (handler.object === target || handler.object === Object.getPrototypeOf(target)) && handler.index === index\n        );\n      });\n      if (paramHandler) return paramHandler.value(this);\n\n      if (paramType && paramType.name && !this.isPrimitiveParamType(paramType.name)) {\n        return this.get(paramType);\n      }\n\n      return undefined;\n    });\n  }\n\n  /**\n   * Checks if given parameter type is primitive type or not.\n   */\n  private isPrimitiveParamType(paramTypeName: string): boolean {\n    return ['string', 'boolean', 'number', 'object'].includes(paramTypeName.toLowerCase());\n  }\n\n  /**\n   * Applies all registered handlers on a given target class.\n   */\n  private applyPropertyHandlers(target: Function, instance: { [key: string]: any }) {\n    Container.handlers.forEach(handler => {\n      if (typeof handler.index === 'number') return;\n      if (handler.object.constructor !== target && !(target.prototype instanceof handler.object.constructor)) return;\n\n      if (handler.propertyName) {\n        instance[handler.propertyName] = handler.value(this);\n      }\n    });\n  }\n\n  /**\n   * Checks if the given service metadata contains a destroyable service instance and destroys it in place. If the service\n   * contains a callable function named `destroy` it is called but not awaited and the return value is ignored..\n   *\n   * @param serviceMetadata the service metadata containing the instance to destroy\n   * @param force when true the service will be always destroyed even if it's cannot be re-created\n   */\n  private destroyServiceInstance(serviceMetadata: ServiceMetadata, force = false) {\n    /** We reset value only if we can re-create it (aka type or factory exists). */\n    const shouldResetValue = force || !!serviceMetadata.type || !!serviceMetadata.factory;\n\n    if (shouldResetValue) {\n      /** If we wound a function named destroy we call it without any params. */\n      if (typeof (serviceMetadata?.value as Record<string, unknown>)['destroy'] === 'function') {\n        try {\n          (serviceMetadata.value as { destroy: CallableFunction }).destroy();\n        } catch (error) {\n          /** We simply ignore the errors from the destroy function. */\n        }\n      }\n\n      serviceMetadata.value = EMPTY_VALUE;\n    }\n  }\n}\n"]}