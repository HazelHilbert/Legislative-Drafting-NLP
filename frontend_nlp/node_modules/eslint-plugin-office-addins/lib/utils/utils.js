Object.defineProperty(exports, "__esModule", { value: true });
exports.findPropertiesRead = exports.findOfficeApiReferences = exports.findCallExpression = exports.findTopMemberExpression = void 0;
const utils_1 = require("@typescript-eslint/utils");
const getFunction_1 = require("./getFunction");
const load_1 = require("./load");
function isContextSyncIdentifier(node) {
    var _a, _b;
    return (node.name === "context" &&
        ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.MemberExpression &&
        ((_b = node.parent.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.CallExpression &&
        node.parent.property.type === utils_1.AST_NODE_TYPES.Identifier &&
        node.parent.property.name === "sync");
}
function findTopMemberExpression(node) {
    while (node.parent && node.parent.type === utils_1.AST_NODE_TYPES.MemberExpression) {
        node = node.parent;
    }
    return node;
}
exports.findTopMemberExpression = findTopMemberExpression;
function findCallExpression(node) {
    var _a;
    while (node.parent && node.parent.type === utils_1.AST_NODE_TYPES.MemberExpression) {
        node = node.parent;
    }
    if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.CallExpression) {
        return node.parent;
    }
    return undefined;
}
exports.findCallExpression = findCallExpression;
let proxyVariables;
let apiReferences;
function findOfficeApiReferences(scope) {
    proxyVariables = new Set();
    apiReferences = [];
    findOfficeApiReferencesInScope(scope);
    return apiReferences;
}
exports.findOfficeApiReferences = findOfficeApiReferences;
function findOfficeApiReferencesInScope(scope) {
    scope.references.forEach((reference) => {
        const node = reference.identifier;
        if (reference.isWrite() &&
            reference.writeExpr &&
            (0, getFunction_1.isGetFunction)(reference.writeExpr) &&
            reference.resolved) {
            proxyVariables.add(reference.resolved);
            apiReferences.push({ operation: "Get", reference: reference });
        }
        else if (isContextSyncIdentifier(reference.identifier)) {
            apiReferences.push({ operation: "Sync", reference: reference });
        }
        else if (reference.isRead() &&
            reference.resolved &&
            proxyVariables.has(reference.resolved)) {
            if ((0, load_1.isLoadReference)(node)) {
                // <obj>.load(...)
                apiReferences.push({ operation: "Load", reference: reference });
            }
            else if ((0, load_1.isContextLoadArgumentReference)(node)) {
                // context.load(<obj>, ...)
                apiReferences.push({ operation: "Load", reference: reference });
            }
            else if (isMethodReference(node)) {
                apiReferences.push({ operation: "Method", reference: reference });
            }
            else {
                apiReferences.push({ operation: "Read", reference: reference });
            }
        }
    });
    scope.childScopes.forEach(findOfficeApiReferencesInScope);
}
function isMethod(node) {
    var _a;
    const topExpression = findTopMemberExpression(node);
    return (((_a = topExpression.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.CallExpression &&
        topExpression.parent.callee === topExpression);
}
function isMethodReference(node) {
    return (node.parent &&
        node.parent.type === utils_1.TSESTree.AST_NODE_TYPES.MemberExpression &&
        isMethod(node.parent));
}
function findPropertiesRead(node) {
    let propertyName = ""; // Will be a string combined with '/' for the case of navigation properties
    while (node) {
        if (node.type === utils_1.AST_NODE_TYPES.MemberExpression &&
            node.property.type === utils_1.AST_NODE_TYPES.Identifier &&
            !isMethod(node)) {
            propertyName += node.property.name + "/";
        }
        node = node.parent;
    }
    return propertyName.slice(0, -1);
}
exports.findPropertiesRead = findPropertiesRead;
//# sourceMappingURL=utils.js.map