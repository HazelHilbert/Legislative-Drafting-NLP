"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.assembleError = exports.InternalError = exports.ConcurrentError = exports.NotImplementedError = exports.EmptyOptionError = exports.UserCancelError = exports.AccessGithubError = exports.HttpServerError = exports.HttpClientError = exports.MissingRequiredFileError = exports.NoEnvFilesError = exports.InputValidationError = exports.MissingRequiredInputError = exports.InstallSoftwareError = exports.UnhandledUserError = exports.UnhandledError = exports.FilePermissionError = exports.WriteFileError = exports.ReadFileError = exports.JSONSyntaxError = exports.InjectAPIKeyActionFailedError = exports.MultipleServerError = exports.MultipleAuthError = exports.InvalidProjectError = exports.InvalidActionInputError = exports.MissingEnvironmentVariablesError = exports.FileNotFoundError = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const localizeUtils_1 = require("../common/localizeUtils");
const globalVars_1 = require("../core/globalVars");
const types_1 = require("./types");
class FileNotFoundError extends teamsfx_api_1.UserError {
    constructor(source, filePath, helpLink) {
        const key = "error.common.FileNotFoundError";
        const errorOptions = {
            source: lodash_1.camelCase(source),
            name: "FileNotFoundError",
            message: localizeUtils_1.getDefaultString(key, filePath),
            displayMessage: localizeUtils_1.getLocalizedString(key, filePath),
            helpLink: helpLink,
            categories: [types_1.ErrorCategory.Internal],
        };
        super(errorOptions);
    }
}
exports.FileNotFoundError = FileNotFoundError;
class MissingEnvironmentVariablesError extends teamsfx_api_1.UserError {
    constructor(source, variableNames, filePath, helpLink) {
        const templateFilePath = filePath || globalVars_1.globalVars.ymlFilePath || "";
        const envFilePath = globalVars_1.globalVars.envFilePath || "";
        const key = "error.common.MissingEnvironmentVariablesError";
        const errorOptions = {
            source: lodash_1.camelCase(source),
            name: "MissingEnvironmentVariablesError",
            message: localizeUtils_1.getDefaultString(key, variableNames, templateFilePath, envFilePath),
            displayMessage: localizeUtils_1.getLocalizedString(key, variableNames, templateFilePath, envFilePath),
            helpLink: helpLink || "https://aka.ms/teamsfx-v5.0-guide#environments",
            categories: [types_1.ErrorCategory.Internal],
        };
        super(errorOptions);
    }
}
exports.MissingEnvironmentVariablesError = MissingEnvironmentVariablesError;
class InvalidActionInputError extends teamsfx_api_1.UserError {
    constructor(actionName, parameters, helpLink) {
        const key = "error.yaml.InvalidActionInputError";
        const errorOptions = {
            source: lodash_1.camelCase(actionName),
            name: "InvalidActionInputError",
            message: localizeUtils_1.getDefaultString(key, actionName, parameters.join(","), globalVars_1.globalVars.ymlFilePath),
            displayMessage: localizeUtils_1.getLocalizedString(key, actionName, parameters.join(","), globalVars_1.globalVars.ymlFilePath),
            helpLink: helpLink || "https://aka.ms/teamsfx-actions",
            categories: [types_1.ErrorCategory.Internal],
        };
        super(errorOptions);
    }
}
exports.InvalidActionInputError = InvalidActionInputError;
class InvalidProjectError extends teamsfx_api_1.UserError {
    constructor() {
        super({
            message: localizeUtils_1.getDefaultString("error.common.InvalidProjectError"),
            displayMessage: localizeUtils_1.getLocalizedString("error.common.InvalidProjectError"),
            source: "coordinator",
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.InvalidProjectError = InvalidProjectError;
class MultipleAuthError extends teamsfx_api_1.UserError {
    constructor(authNames) {
        super({
            message: localizeUtils_1.getDefaultString("core.createProjectQuestion.apiSpec.operation.multipleAuth", Array.from(authNames).join(", ")),
            displayMessage: localizeUtils_1.getLocalizedString("core.createProjectQuestion.apiSpec.operation.multipleAuth", Array.from(authNames).join(", ")),
            source: "coordinator",
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.MultipleAuthError = MultipleAuthError;
class MultipleServerError extends teamsfx_api_1.UserError {
    constructor(serverUrls) {
        super({
            message: localizeUtils_1.getDefaultString("core.createProjectQuestion.apiSpec.operation.multipleServer", Array.from(serverUrls).join(", ")),
            displayMessage: localizeUtils_1.getLocalizedString("core.createProjectQuestion.apiSpec.operation.multipleServer", Array.from(serverUrls).join(", ")),
            source: "coordinator",
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.MultipleServerError = MultipleServerError;
class InjectAPIKeyActionFailedError extends teamsfx_api_1.UserError {
    constructor() {
        super({
            message: localizeUtils_1.getDefaultString("core.copilot.addAPI.InjectAPIKeyActionFailed"),
            displayMessage: localizeUtils_1.getLocalizedString("core.copilot.addAPI.InjectAPIKeyActionFailed"),
            source: "coordinator",
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.InjectAPIKeyActionFailedError = InjectAPIKeyActionFailedError;
class JSONSyntaxError extends teamsfx_api_1.UserError {
    constructor(filePathOrContent, error, source) {
        super({
            message: localizeUtils_1.getDefaultString("error.common.JSONSyntaxError", filePathOrContent, error.message),
            displayMessage: localizeUtils_1.getLocalizedString("error.common.JSONSyntaxError", filePathOrContent, error.message),
            source: source || "coordinator",
            error: error,
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.JSONSyntaxError = JSONSyntaxError;
class ReadFileError extends teamsfx_api_1.SystemError {
    constructor(e, source) {
        super({
            source: source || "unknown",
            message: e.message || localizeUtils_1.getDefaultString("error.common.ReadFileError", e.message),
            displayMessage: e.message || localizeUtils_1.getLocalizedString("error.common.ReadFileError", e.message),
            categories: [types_1.ErrorCategory.Internal],
            error: e,
        });
    }
}
exports.ReadFileError = ReadFileError;
class WriteFileError extends teamsfx_api_1.SystemError {
    constructor(e, source) {
        super({
            source: source || "unknown",
            message: e.message || localizeUtils_1.getDefaultString("error.common.WriteFileError", e.message),
            displayMessage: e.message || localizeUtils_1.getLocalizedString("error.common.WriteFileError", e.message),
            categories: [types_1.ErrorCategory.Internal],
            error: e,
        });
    }
}
exports.WriteFileError = WriteFileError;
class FilePermissionError extends teamsfx_api_1.UserError {
    constructor(e, source) {
        const msg = localizeUtils_1.getDefaultString("error.common.FilePermissionError", e.message);
        super({
            source: source || "unknown",
            message: msg,
            displayMessage: msg,
            error: e,
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.FilePermissionError = FilePermissionError;
class UnhandledError extends teamsfx_api_1.SystemError {
    constructor(e, source) {
        const errJson = JSON.stringify(e, Object.getOwnPropertyNames(e));
        const option = {
            source: lodash_1.camelCase(source) || "unknown",
            error: e,
            message: localizeUtils_1.getDefaultString("error.common.UnhandledError", source, errJson),
            displayMessage: localizeUtils_1.getLocalizedString("error.common.UnhandledError", source, e.message || errJson),
            categories: [types_1.ErrorCategory.Unhandled],
        };
        super(option);
    }
}
exports.UnhandledError = UnhandledError;
class UnhandledUserError extends teamsfx_api_1.UserError {
    constructor(e, source, helpLink) {
        source = source || "unknown";
        super({
            source: lodash_1.camelCase(source),
            message: localizeUtils_1.getDefaultString("error.common.UnhandledError", source, JSON.stringify(e, Object.getOwnPropertyNames(e))),
            displayMessage: localizeUtils_1.getLocalizedString("error.common.UnhandledError", source, e.message || JSON.stringify(e, Object.getOwnPropertyNames(e))),
            helpLink: helpLink,
            error: e,
            categories: [types_1.ErrorCategory.Unhandled],
        });
    }
}
exports.UnhandledUserError = UnhandledUserError;
class InstallSoftwareError extends teamsfx_api_1.UserError {
    constructor(source, nameAndVersion, helpLink) {
        super({
            source: lodash_1.camelCase(source || "common"),
            message: localizeUtils_1.getDefaultString("error.common.InstallSoftwareError", nameAndVersion),
            displayMessage: localizeUtils_1.getLocalizedString("error.common.InstallSoftwareError", nameAndVersion),
            categories: [types_1.ErrorCategory.External],
        });
        if (helpLink)
            this.helpLink = helpLink;
    }
}
exports.InstallSoftwareError = InstallSoftwareError;
class MissingRequiredInputError extends teamsfx_api_1.UserError {
    constructor(name, source) {
        super({
            source: source || "coordinator",
            message: localizeUtils_1.getDefaultString("error.common.MissingRequiredInputError", name),
            displayMessage: localizeUtils_1.getLocalizedString("error.common.MissingRequiredInputError", name),
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.MissingRequiredInputError = MissingRequiredInputError;
class InputValidationError extends teamsfx_api_1.UserError {
    constructor(name, reason, source) {
        super({
            source: source || "coordinator",
            message: localizeUtils_1.getDefaultString("error.common.InputValidationError", name, reason),
            displayMessage: localizeUtils_1.getLocalizedString("error.common.InputValidationError", name, reason),
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.InputValidationError = InputValidationError;
class NoEnvFilesError extends teamsfx_api_1.UserError {
    constructor(source) {
        const key = "error.common.NoEnvFilesError";
        const errorOptions = {
            source: lodash_1.camelCase(source),
            name: "NoEnvFilesError",
            message: localizeUtils_1.getDefaultString(key),
            displayMessage: localizeUtils_1.getLocalizedString(key),
            categories: [types_1.ErrorCategory.Internal],
        };
        super(errorOptions);
    }
}
exports.NoEnvFilesError = NoEnvFilesError;
class MissingRequiredFileError extends teamsfx_api_1.UserError {
    constructor(source, task, file) {
        const key = "error.common.MissingRequiredFileError";
        const errorOptions = {
            source: lodash_1.camelCase(source),
            name: "MissingRequiredFileError",
            message: localizeUtils_1.getDefaultString(key, task, file),
            displayMessage: localizeUtils_1.getLocalizedString(key, task, file),
            categories: [types_1.ErrorCategory.Internal],
        };
        super(errorOptions);
    }
}
exports.MissingRequiredFileError = MissingRequiredFileError;
class HttpClientError extends teamsfx_api_1.UserError {
    constructor(error, actionName, responseBody, helpLink) {
        const messageKey = "error.common.HttpClientError";
        super({
            source: lodash_1.camelCase(actionName),
            name: "HttpClientError",
            message: localizeUtils_1.getDefaultString(messageKey, actionName, responseBody),
            displayMessage: localizeUtils_1.getLocalizedString(messageKey, actionName, responseBody),
            helpLink: helpLink,
            error: error,
            categories: [types_1.ErrorCategory.External],
        });
    }
}
exports.HttpClientError = HttpClientError;
class HttpServerError extends teamsfx_api_1.SystemError {
    constructor(error, actionName, responseBody) {
        const messageKey = "error.common.HttpServerError";
        super({
            source: lodash_1.camelCase(actionName),
            name: "HttpServerError",
            message: localizeUtils_1.getDefaultString(messageKey, actionName, responseBody),
            displayMessage: localizeUtils_1.getLocalizedString(messageKey, actionName, responseBody),
            error: error,
            categories: [types_1.ErrorCategory.External],
        });
    }
}
exports.HttpServerError = HttpServerError;
class AccessGithubError extends teamsfx_api_1.UserError {
    constructor(url, source, error) {
        const messageKey = "error.common.AccessGithubError";
        super({
            source: source,
            name: "AccessGithubError",
            message: localizeUtils_1.getDefaultString(messageKey, url, error.message || JSON.stringify(error, Object.getOwnPropertyNames(error))),
            displayMessage: localizeUtils_1.getDefaultString(messageKey, url, JSON.stringify(error, Object.getOwnPropertyNames(error))),
            error: error,
            categories: [types_1.ErrorCategory.External],
        });
    }
}
exports.AccessGithubError = AccessGithubError;
class UserCancelError extends teamsfx_api_1.UserError {
    constructor(actionName) {
        super({
            source: actionName ? lodash_1.camelCase(actionName) : "ui",
            name: "UserCancel",
            message: "User canceled",
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.UserCancelError = UserCancelError;
class EmptyOptionError extends teamsfx_api_1.SystemError {
    constructor(name, source) {
        super({
            source: source ? lodash_1.camelCase(source) : "UI",
            message: `Select option is empty list for question name: ${name}`,
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.EmptyOptionError = EmptyOptionError;
class NotImplementedError extends teamsfx_api_1.SystemError {
    constructor(source, method) {
        super({
            source: source,
            message: `Method not implemented:${method}`,
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.NotImplementedError = NotImplementedError;
class ConcurrentError extends teamsfx_api_1.UserError {
    constructor(source) {
        super({
            source: source,
            message: localizeUtils_1.getLocalizedString("error.common.ConcurrentError"),
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.ConcurrentError = ConcurrentError;
class InternalError extends teamsfx_api_1.UserError {
    constructor(error, source) {
        super({
            source: source,
            error: error,
            categories: ["internal", error.code],
        });
    }
}
exports.InternalError = InternalError;
function assembleError(e, source) {
    if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError)
        return e;
    if (!source)
        source = "unknown";
    const type = typeof e;
    if (type === "string") {
        return new UnhandledError(new Error(e), source);
    }
    else {
        const code = e.code;
        if (code && (errnoCodes[code] || code.startsWith("ERR_"))) {
            // convert to internal error
            return new InternalError(e, source);
        }
        return new UnhandledError(e, source);
    }
}
exports.assembleError = assembleError;
const errnoCodes = {
    E2BIG: "Argument list too long",
    EACCES: "Permission denied",
    EADDRINUSE: "Address already in use",
    EADDRNOTAVAIL: "Address not available",
    EAFNOSUPPORT: "Address family not supported",
    EAGAIN: "Resource temporarily unavailable",
    EALREADY: "Operation already in progress",
    EBADF: "Bad file descriptor",
    EBADMSG: "Bad message",
    EBUSY: "Device or resource busy",
    ECANCELED: "Operation canceled",
    ECHILD: "No child processes",
    ECONNABORTED: "Connection aborted",
    ECONNREFUSED: "Connection refused",
    ECONNRESET: "Connection reset by peer",
    EDEADLK: "Resource deadlock would occur",
    EDESTADDRREQ: "Destination address required",
    EDOM: "Mathematics argument out of domain of function",
    EDQUOT: "Disk quota exceeded",
    EEXIST: "File exists",
    EFAULT: "Bad address",
    EFBIG: "File too large",
    EHOSTUNREACH: "Host is unreachable",
    EIDRM: "Identifier removed",
    EILSEQ: "Illegal byte sequence",
    EINPROGRESS: "Operation in progress",
    EINTR: "Interrupted system call",
    EINVAL: "Invalid argument",
    EIO: "I/O error",
    EISCONN: "Socket is already connected",
    EISDIR: "Is a directory",
    ELOOP: "Too many symbolic links encountered",
    EMFILE: "Too many open files",
    EMLINK: "Too many links",
    EMSGSIZE: "Message too long",
    EMULTIHOP: "Multihop attempted",
    ENAMETOOLONG: "File name too long",
    ENETDOWN: "Network is down",
    ENETRESET: "Network dropped connection because of reset",
    ENETUNREACH: "Network is unreachable",
    ENFILE: "Too many open files in system",
    ENOBUFS: "No buffer space available",
    ENODATA: "No message is available on the STREAM head read queue",
    ENODEV: "No such device",
    ENOENT: "No such file or directory",
    ENOEXEC: "Exec format error",
    ENOLCK: "No locks available",
    ENOLINK: "Link has been severed",
    ENOMEM: "Out of memory",
    ENOMSG: "No message of the desired type",
    ENOPROTOOPT: "Protocol not available",
    ENOSPC: "No space left on device",
    ENOSR: "No STREAM resources",
    ENOSTR: "Not a STREAM",
    ENOSYS: "Function not implemented",
    ENOTCONN: "Socket is not connected",
    ENOTDIR: "Not a directory",
    ENOTEMPTY: "Directory not empty",
    ENOTSOCK: "Socket operation on non-socket",
    ENOTSUP: "Operation not supported",
    ENOTTY: "Inappropriate ioctl for device",
    ENXIO: "No such device or address",
    EOPNOTSUPP: "Operation not supported on socket",
    EOVERFLOW: "Value too large to be stored in data type",
    EPERM: "Operation not permitted",
    EPIPE: "Broken pipe",
    EPROTO: "Protocol error",
    EPROTONOSUPPORT: "Protocol not supported",
    EPROTOTYPE: "Protocol wrong type for socket",
    ERANGE: "Result too large",
    EROFS: "Read-only file system",
    ESPIPE: "Invalid seek",
    ESRCH: "No such process",
    ESTALE: "Stale file handle",
    ETIME: "Timer expired",
    ETIMEDOUT: "Connection timed out",
    ETXTBSY: "Text file busy",
    EWOULDBLOCK: "Operation would block",
    EXDEV: "Cross-device link",
};
//# sourceMappingURL=common.js.map