"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.grantPermission = exports.checkPermission = exports.listCollaborator = exports.CollaborationUtil = exports.CollaborationConstants = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const axios_1 = tslib_1.__importDefault(require("axios"));
const dotenv = tslib_1.__importStar(require("dotenv"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const uuid_1 = require("uuid");
const constants_1 = require("../common/constants");
const localizeUtils_1 = require("../common/localizeUtils");
const permissionInterface_1 = require("../common/permissionInterface");
const tools_1 = require("../common/tools");
const constants_2 = require("../component/constants");
const collaboration_1 = require("../component/feature/collaboration");
const common_1 = require("../error/common");
const questionNames_1 = require("../question/questionNames");
const error_1 = require("./error");
class CollaborationConstants {
}
exports.CollaborationConstants = CollaborationConstants;
// Collaboartion CLI parameters
CollaborationConstants.TeamsAppId = "teamsAppId";
CollaborationConstants.AadObjectId = "aadObjectId";
CollaborationConstants.DotEnvFilePath = "dotEnvFilePath";
// Collaboration env key
CollaborationConstants.AadObjectIdEnv = "AAD_APP_OBJECT_ID";
CollaborationConstants.TeamsAppIdEnv = "TEAMS_APP_ID";
CollaborationConstants.TeamsAppTenantIdEnv = "TEAMS_APP_TENANT_ID";
// App Type Question
CollaborationConstants.AppType = "collaborationType";
CollaborationConstants.TeamsAppQuestionId = "teamsApp";
CollaborationConstants.AadAppQuestionId = "aadApp";
CollaborationConstants.placeholderRegex = /\$\{\{ *[a-zA-Z0-9_.-]* *\}\}/g;
class CollaborationUtil {
    static async getCurrentUserInfo(m365TokenProvider) {
        const user = await CollaborationUtil.getUserInfo(m365TokenProvider);
        if (!user) {
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.FailedToRetrieveUserInfo, "Failed to retrieve current user info from graph token."));
        }
        return teamsfx_api_1.ok(user);
    }
    static async getUserInfo(m365TokenProvider, email) {
        const currentUserRes = await (m365TokenProvider === null || m365TokenProvider === void 0 ? void 0 : m365TokenProvider.getJsonObject({ scopes: tools_1.GraphScopes }));
        const currentUser = (currentUserRes === null || currentUserRes === void 0 ? void 0 : currentUserRes.isOk()) ? currentUserRes.value : undefined;
        if (!currentUser) {
            return undefined;
        }
        const tenantId = currentUser["tid"];
        let aadId = currentUser["oid"];
        let userPrincipalName = currentUser["unique_name"];
        let displayName = currentUser["name"];
        const isAdministrator = true;
        if (email) {
            const graphTokenRes = await (m365TokenProvider === null || m365TokenProvider === void 0 ? void 0 : m365TokenProvider.getAccessToken({ scopes: tools_1.GraphScopes }));
            const graphToken = (graphTokenRes === null || graphTokenRes === void 0 ? void 0 : graphTokenRes.isOk()) ? graphTokenRes.value : undefined;
            const instance = axios_1.default.create({
                baseURL: "https://graph.microsoft.com/v1.0",
            });
            instance.defaults.headers.common["Authorization"] = `Bearer ${graphToken}`;
            const res = await instance.get(`/users?$filter=startsWith(mail,'${email}') or startsWith(userPrincipalName, '${email}')`);
            if (!res || !res.data || !res.data.value) {
                return undefined;
            }
            const collaborator = res.data.value.find((user) => {
                var _a, _b;
                return ((_a = user.mail) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === email.toLowerCase() ||
                    ((_b = user.userPrincipalName) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === email.toLowerCase();
            });
            if (!collaborator) {
                return undefined;
            }
            aadId = collaborator.id;
            userPrincipalName = collaborator.userPrincipalName;
            displayName = collaborator.displayName;
        }
        return {
            tenantId,
            aadId,
            userPrincipalName,
            displayName,
            isAdministrator,
        };
    }
    static async loadDotEnvFile(dotEnvFilePath) {
        try {
            const result = {};
            if (!(await fs_extra_1.default.pathExists(dotEnvFilePath))) {
                throw new common_1.FileNotFoundError("CollaboratorUtil", dotEnvFilePath);
            }
            const envs = dotenv.parse(await fs_extra_1.default.readFile(dotEnvFilePath));
            const entries = Object.entries(envs);
            for (const [key, value] of entries) {
                result[key] = value;
            }
            return teamsfx_api_1.ok(result);
        }
        catch (error) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.FailedToLoadDotEnvFile, localizeUtils_1.getLocalizedString("core.collaboration.error.failedToLoadDotEnvFile", error === null || error === void 0 ? void 0 : error.message)));
        }
    }
    // Priority parameter > dotenv > env
    static async getTeamsAppIdAndAadObjectId(inputs) {
        var _a, _b, _c, _d;
        let teamsAppId, aadObjectId;
        // load from parameter and dotenv only wroks for cli
        if ((inputs === null || inputs === void 0 ? void 0 : inputs.platform) == teamsfx_api_1.Platform.CLI) {
            // 1. Get from parameter
            teamsAppId = (_a = inputs === null || inputs === void 0 ? void 0 : inputs[CollaborationConstants.TeamsAppId]) !== null && _a !== void 0 ? _a : undefined;
            aadObjectId = (_b = inputs === null || inputs === void 0 ? void 0 : inputs[CollaborationConstants.AadObjectId]) !== null && _b !== void 0 ? _b : undefined;
            // Return if getting two app ids
            if (teamsAppId && aadObjectId) {
                return teamsfx_api_1.ok({
                    teamsAppId: teamsAppId,
                    aadObjectId: aadObjectId,
                });
            }
            // 2. Get from dotenv
            if (inputs === null || inputs === void 0 ? void 0 : inputs[CollaborationConstants.DotEnvFilePath]) {
                const loadDotEnvFileResult = await this.loadDotEnvFile(inputs === null || inputs === void 0 ? void 0 : inputs[CollaborationConstants.DotEnvFilePath]);
                if (loadDotEnvFileResult.isErr()) {
                    return teamsfx_api_1.err(loadDotEnvFileResult.error);
                }
                const dotEnv = loadDotEnvFileResult.value;
                teamsAppId = (_c = teamsAppId !== null && teamsAppId !== void 0 ? teamsAppId : dotEnv[CollaborationConstants.TeamsAppIdEnv]) !== null && _c !== void 0 ? _c : undefined;
                aadObjectId = (_d = aadObjectId !== null && aadObjectId !== void 0 ? aadObjectId : dotEnv[CollaborationConstants.AadObjectIdEnv]) !== null && _d !== void 0 ? _d : undefined;
                // Return if getting two app ids
                if (teamsAppId && aadObjectId) {
                    return teamsfx_api_1.ok({
                        teamsAppId: teamsAppId,
                        aadObjectId: aadObjectId,
                    });
                }
            }
        }
        // 3. load from env
        const teamsAppManifestFilePath = inputs === null || inputs === void 0 ? void 0 : inputs[questionNames_1.QuestionNames.TeamsAppManifestFilePath];
        const aadAppManifestFilePath = inputs === null || inputs === void 0 ? void 0 : inputs[questionNames_1.QuestionNames.AadAppManifestFilePath];
        if (teamsAppManifestFilePath && !teamsAppId) {
            const teamsAppIdRes = await this.loadManifestId(teamsAppManifestFilePath);
            if (teamsAppIdRes.isOk()) {
                teamsAppId = this.parseManifestId(teamsAppIdRes.value);
                if (!teamsAppId) {
                    return teamsfx_api_1.err(new error_1.FailedToLoadManifestId(teamsAppManifestFilePath));
                }
            }
            else {
                return teamsfx_api_1.err(teamsAppIdRes.error);
            }
        }
        if (aadAppManifestFilePath && !aadObjectId) {
            const aadObjectIdRes = await this.loadManifestId(aadAppManifestFilePath);
            if (aadObjectIdRes.isOk()) {
                aadObjectId = this.parseManifestId(aadObjectIdRes.value);
                if (!aadObjectId) {
                    return teamsfx_api_1.err(new error_1.FailedToLoadManifestId(aadAppManifestFilePath));
                }
            }
            else {
                return teamsfx_api_1.err(aadObjectIdRes.error);
            }
        }
        return teamsfx_api_1.ok({
            teamsAppId: teamsAppId,
            aadObjectId: aadObjectId,
        });
    }
    static async loadManifestId(manifestFilePath) {
        try {
            if (!manifestFilePath || !(await fs_extra_1.default.pathExists(manifestFilePath))) {
                return teamsfx_api_1.err(new common_1.FileNotFoundError(constants_2.SolutionSource, manifestFilePath));
            }
            const manifest = await fs_extra_1.default.readJson(manifestFilePath);
            if (!manifest || !manifest.id) {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.InvalidManifestError, localizeUtils_1.getLocalizedString("error.collaboration.InvalidManifestError", manifestFilePath)));
            }
            const id = manifest.id;
            return teamsfx_api_1.ok(id);
        }
        catch (error) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.FailedToLoadManifestFile, localizeUtils_1.getLocalizedString("error.collaboration.FailedToLoadManifest", manifestFilePath)));
        }
    }
    static requireEnvQuestion(appId) {
        return !!appId.match(CollaborationConstants.placeholderRegex);
    }
    static parseManifestId(appId) {
        var _a;
        // Hardcoded id in manifest
        if (uuid_1.validate(appId)) {
            return appId;
        }
        else if (appId.match(CollaborationConstants.placeholderRegex)) {
            // Reference value in .env file
            const envName = appId
                .replace(/\$*\{+/g, "")
                .replace(/\}+/g, "")
                .trim();
            return (_a = process.env[envName]) !== null && _a !== void 0 ? _a : undefined;
        }
        return undefined;
    }
}
exports.CollaborationUtil = CollaborationUtil;
async function listCollaborator(ctx, inputs, tokenProvider, telemetryProps) {
    var _a, _b, _c, _d;
    const result = await CollaborationUtil.getCurrentUserInfo(tokenProvider.m365TokenProvider);
    if (result.isErr()) {
        return teamsfx_api_1.err(result.error);
    }
    const user = result.value;
    const getAppIdsResult = await CollaborationUtil.getTeamsAppIdAndAadObjectId(inputs);
    if (getAppIdsResult.isErr()) {
        return teamsfx_api_1.err(getAppIdsResult.error);
    }
    const appIds = getAppIdsResult.value;
    const hasAad = appIds.aadObjectId != undefined;
    const hasTeams = appIds.teamsAppId != undefined;
    const teamsCollaboration = new collaboration_1.TeamsCollaboration(ctx, tokenProvider.m365TokenProvider);
    const aadCollaboration = new collaboration_1.AadCollaboration(tokenProvider.m365TokenProvider, ctx.logProvider);
    const appStudioRes = hasTeams
        ? await teamsCollaboration.listCollaborator(ctx, appIds.teamsAppId)
        : teamsfx_api_1.ok([]);
    if (appStudioRes.isErr())
        return teamsfx_api_1.err(appStudioRes.error);
    const teamsAppOwners = appStudioRes.value;
    const aadRes = hasAad
        ? await aadCollaboration.listCollaborator(ctx, appIds.aadObjectId)
        : teamsfx_api_1.ok([]);
    if (aadRes.isErr())
        return teamsfx_api_1.err(aadRes.error);
    const aadOwners = aadRes.value;
    const teamsAppId = (_b = (_a = teamsAppOwners[0]) === null || _a === void 0 ? void 0 : _a.resourceId) !== null && _b !== void 0 ? _b : "";
    const aadAppId = (_d = (_c = aadOwners[0]) === null || _c === void 0 ? void 0 : _c.resourceId) !== null && _d !== void 0 ? _d : "";
    const aadAppTenantId = user.tenantId;
    if (inputs.platform === teamsfx_api_1.Platform.CLI || inputs.platform === teamsfx_api_1.Platform.VSCode) {
        const message = [
            {
                content: localizeUtils_1.getLocalizedString("core.collaboration.ListingM365Permission"),
                color: teamsfx_api_1.Colors.BRIGHT_WHITE,
            },
            {
                content: localizeUtils_1.getLocalizedString("core.collaboration.AccountUsedToCheck"),
                color: teamsfx_api_1.Colors.BRIGHT_WHITE,
            },
            { content: user.userPrincipalName + "\n", color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
            { content: localizeUtils_1.getLocalizedString("core.collaboration.TenantId"), color: teamsfx_api_1.Colors.BRIGHT_WHITE },
            { content: aadAppTenantId + "\n", color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
        ];
        if (hasTeams) {
            message.push(...getPrintEnvMessage(inputs.env, localizeUtils_1.getLocalizedString("core.collaboration.StartingListAllTeamsAppOwners")), {
                content: localizeUtils_1.getLocalizedString("core.collaboration.M365TeamsAppId"),
                color: teamsfx_api_1.Colors.BRIGHT_WHITE,
            }, { content: teamsAppId, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA }, { content: `)\n`, color: teamsfx_api_1.Colors.BRIGHT_WHITE });
            for (const teamsAppOwner of teamsAppOwners) {
                message.push({
                    content: localizeUtils_1.getLocalizedString("core.collaboration.TeamsAppOwner"),
                    color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                }, { content: teamsAppOwner.userPrincipalName, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA }, { content: `.\n`, color: teamsfx_api_1.Colors.BRIGHT_WHITE });
            }
        }
        if (hasAad) {
            message.push(...getPrintEnvMessage(inputs.env, localizeUtils_1.getLocalizedString("core.collaboration.StartingListAllAadAppOwners")), {
                content: localizeUtils_1.getLocalizedString("core.collaboration.SsoAadAppId"),
                color: teamsfx_api_1.Colors.BRIGHT_WHITE,
            }, { content: aadAppId, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA }, { content: `)\n`, color: teamsfx_api_1.Colors.BRIGHT_WHITE });
            for (const aadOwner of aadOwners) {
                message.push({
                    content: localizeUtils_1.getLocalizedString("core.collaboration.AadAppOwner"),
                    color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                }, { content: aadOwner.userPrincipalName, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA }, { content: `.\n`, color: teamsfx_api_1.Colors.BRIGHT_WHITE });
            }
        }
        if (inputs.platform === teamsfx_api_1.Platform.CLI) {
            void ctx.userInteraction.showMessage("info", message, false);
        }
        else if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            void ctx.userInteraction.showMessage("info", localizeUtils_1.getLocalizedString("core.collaboration.ListCollaboratorsSuccess", constants_1.VSCodeExtensionCommand.showOutputChannel), false);
            void ctx.logProvider.info(message);
        }
    }
    const aadOwnerCount = hasAad ? aadOwners.length : -1;
    const teamsOwnerCount = hasTeams ? teamsAppOwners.length : -1;
    if (telemetryProps) {
        telemetryProps[constants_2.SolutionTelemetryProperty.Env] = inputs.env || "";
        telemetryProps[constants_2.SolutionTelemetryProperty.CollaboratorCount] = teamsOwnerCount.toString();
        telemetryProps[constants_2.SolutionTelemetryProperty.AadOwnerCount] = aadOwnerCount.toString();
    }
    return teamsfx_api_1.ok({
        state: permissionInterface_1.CollaborationState.OK,
    });
}
exports.listCollaborator = listCollaborator;
async function checkPermission(ctx, inputs, tokenProvider, telemetryProps) {
    var _a;
    const result = await CollaborationUtil.getCurrentUserInfo(tokenProvider.m365TokenProvider);
    if (result.isErr()) {
        return teamsfx_api_1.err(result.error);
    }
    const userInfo = result.value;
    if (inputs.platform === teamsfx_api_1.Platform.CLI) {
        // TODO: get tenant id from .env
        const aadAppTenantId = userInfo.tenantId;
        const message = [
            {
                content: localizeUtils_1.getLocalizedString("core.collaboration.AccountUsedToCheck"),
                color: teamsfx_api_1.Colors.BRIGHT_WHITE,
            },
            { content: userInfo.userPrincipalName + "\n", color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
            ...getPrintEnvMessage(inputs.env, localizeUtils_1.getLocalizedString("core.collaboration.StaringCheckPermission")),
            { content: localizeUtils_1.getLocalizedString("core.collaboration.TenantId"), color: teamsfx_api_1.Colors.BRIGHT_WHITE },
            { content: aadAppTenantId + "\n", color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
        ];
        void ctx.userInteraction.showMessage("info", message, false);
    }
    const getAppIdsResult = await CollaborationUtil.getTeamsAppIdAndAadObjectId(inputs);
    if (getAppIdsResult.isErr()) {
        return teamsfx_api_1.err(getAppIdsResult.error);
    }
    const appIds = getAppIdsResult.value;
    const teamsCollaboration = new collaboration_1.TeamsCollaboration(ctx, tokenProvider.m365TokenProvider);
    const aadCollaboration = new collaboration_1.AadCollaboration(tokenProvider.m365TokenProvider, ctx.logProvider);
    const isTeamsActivated = appIds.teamsAppId != undefined;
    const appStudioRes = isTeamsActivated
        ? await teamsCollaboration.checkPermission(ctx, appIds.teamsAppId, userInfo)
        : teamsfx_api_1.ok([]);
    if (appStudioRes.isErr()) {
        return teamsfx_api_1.err(appStudioRes.error);
    }
    const permissions = appStudioRes.value;
    const isAadActivated = appIds.aadObjectId != undefined;
    if (isAadActivated) {
        const aadRes = await aadCollaboration.checkPermission(ctx, appIds.aadObjectId, result.value.aadId);
        if (aadRes.isErr())
            return teamsfx_api_1.err(aadRes.error);
        aadRes.value.forEach((r) => {
            permissions.push(r);
        });
    }
    if (inputs.platform === teamsfx_api_1.Platform.CLI) {
        for (const permission of permissions) {
            const message = [
                {
                    content: localizeUtils_1.getLocalizedString("core.collaboration.CheckPermissionResourceId"),
                    color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                },
                {
                    content: (_a = permission.resourceId) !== null && _a !== void 0 ? _a : localizeUtils_1.getLocalizedString("core.collaboration.Undefined"),
                    color: teamsfx_api_1.Colors.BRIGHT_MAGENTA,
                },
                {
                    content: localizeUtils_1.getLocalizedString("core.collaboration.ResourceName"),
                    color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                },
                { content: permission.name, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                {
                    content: localizeUtils_1.getLocalizedString("core.collaboration.Permission"),
                    color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                },
                {
                    content: permission.roles
                        ? permission.roles.toString()
                        : localizeUtils_1.getLocalizedString("core.collaboration.Undefined") + "\n",
                    color: teamsfx_api_1.Colors.BRIGHT_MAGENTA,
                },
            ];
            void ctx.userInteraction.showMessage("info", message, false);
        }
    }
    const aadPermission = permissions.find((permission) => permission.name === "Azure AD App");
    const teamsAppPermission = permissions.find((permission) => permission.name === "Teams App");
    if (telemetryProps) {
        telemetryProps[constants_2.SolutionTelemetryProperty.AadPermission] = (aadPermission === null || aadPermission === void 0 ? void 0 : aadPermission.roles)
            ? aadPermission.roles.join(";")
            : localizeUtils_1.getLocalizedString("core.collaboration.Undefined");
        telemetryProps[constants_2.SolutionTelemetryProperty.TeamsAppPermission] = (teamsAppPermission === null || teamsAppPermission === void 0 ? void 0 : teamsAppPermission.roles)
            ? teamsAppPermission.roles.join(";")
            : localizeUtils_1.getLocalizedString("core.collaboration.Undefined");
    }
    return teamsfx_api_1.ok({
        state: permissionInterface_1.CollaborationState.OK,
        permissions,
    });
}
exports.checkPermission = checkPermission;
async function grantPermission(ctx, inputs, tokenProvider) {
    var _a;
    const progressBar = ctx.userInteraction.createProgressBar(localizeUtils_1.getLocalizedString("core.collaboration.GrantingPermission"), 1);
    try {
        const result = await CollaborationUtil.getCurrentUserInfo(tokenProvider.m365TokenProvider);
        if (result.isErr()) {
            return teamsfx_api_1.err(result.error);
        }
        const email = inputs.email;
        if (!email || email === result.value.userPrincipalName) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(error_1.CoreSource, constants_2.SolutionError.EmailCannotBeEmptyOrSame, localizeUtils_1.getDefaultString("core.collaboration.EmailCannotBeEmptyOrSame"), localizeUtils_1.getLocalizedString("core.collaboration.EmailCannotBeEmptyOrSame")));
        }
        const userInfo = await CollaborationUtil.getUserInfo(tokenProvider.m365TokenProvider, email);
        if (!userInfo) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(error_1.CoreSource, constants_2.SolutionError.CannotFindUserInCurrentTenant, localizeUtils_1.getDefaultString("core.collaboration.CannotFindUserInCurrentTenant"), localizeUtils_1.getLocalizedString("core.collaboration.CannotFindUserInCurrentTenant")));
        }
        await (progressBar === null || progressBar === void 0 ? void 0 : progressBar.start());
        await (progressBar === null || progressBar === void 0 ? void 0 : progressBar.next(localizeUtils_1.getLocalizedString("core.collaboration.GrantPermissionForUser", email)));
        const getAppIdsResult = await CollaborationUtil.getTeamsAppIdAndAadObjectId(inputs);
        if (getAppIdsResult.isErr()) {
            return teamsfx_api_1.err(getAppIdsResult.error);
        }
        const appIds = getAppIdsResult.value;
        if (inputs.platform === teamsfx_api_1.Platform.CLI) {
            // TODO: get tenant id from .env
            const aadAppTenantId = result.value.tenantId;
            const message = [
                {
                    content: localizeUtils_1.getLocalizedString("core.collaboration.AccountToGrantPermission"),
                    color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                },
                { content: userInfo.userPrincipalName + "\n", color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                ...getPrintEnvMessage(inputs.env, localizeUtils_1.getLocalizedString("core.collaboration.StartingGrantPermission")),
                { content: localizeUtils_1.getLocalizedString("core.collaboration.TenantId"), color: teamsfx_api_1.Colors.BRIGHT_WHITE },
                { content: aadAppTenantId + "\n", color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
            ];
            void ctx.userInteraction.showMessage("info", message, false);
        }
        const isAadActivated = appIds.aadObjectId != undefined;
        const isTeamsActivated = appIds.teamsAppId != undefined;
        const teamsCollaboration = new collaboration_1.TeamsCollaboration(ctx, tokenProvider.m365TokenProvider);
        const aadCollaboration = new collaboration_1.AadCollaboration(tokenProvider.m365TokenProvider, ctx.logProvider);
        const appStudioRes = isTeamsActivated
            ? await teamsCollaboration.grantPermission(ctx, appIds.teamsAppId, userInfo)
            : teamsfx_api_1.ok([]);
        if (appStudioRes.isErr()) {
            return teamsfx_api_1.err(appStudioRes.error);
        }
        const permissions = appStudioRes.value;
        if (isAadActivated) {
            const aadRes = await aadCollaboration.grantPermission(ctx, appIds.aadObjectId, userInfo.aadId);
            if (aadRes.isErr())
                return teamsfx_api_1.err(aadRes.error);
            aadRes.value.forEach((r) => {
                permissions.push(r);
            });
        }
        if (inputs.platform === teamsfx_api_1.Platform.CLI) {
            for (const permission of permissions) {
                const message = [
                    { content: `${(_a = permission.roles) === null || _a === void 0 ? void 0 : _a.join(",")} `, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                    {
                        content: localizeUtils_1.getLocalizedString("core.collaboration.PermissionHasBeenGrantTo"),
                        color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                    },
                    { content: permission.name, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                    {
                        content: localizeUtils_1.getLocalizedString("core.collaboration.GrantPermissionResourceId"),
                        color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                    },
                    { content: `${permission.resourceId}`, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                ];
                void ctx.userInteraction.showMessage("info", message, false);
            }
        }
        return teamsfx_api_1.ok({
            state: permissionInterface_1.CollaborationState.OK,
            userInfo: userInfo,
            permissions,
        });
    }
    finally {
        await (progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(true));
    }
}
exports.grantPermission = grantPermission;
function getPrintEnvMessage(env, message) {
    return env
        ? [
            {
                content: message,
                color: teamsfx_api_1.Colors.BRIGHT_WHITE,
            },
            { content: `${env}\n`, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
        ]
        : [];
}
//# sourceMappingURL=collaborator.js.map