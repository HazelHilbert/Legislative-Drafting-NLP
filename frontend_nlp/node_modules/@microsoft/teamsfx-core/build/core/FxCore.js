"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FxCore = void 0;
const tslib_1 = require("tslib");
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const url_1 = require("url");
const yaml_1 = require("yaml");
const constants_1 = require("../common/constants");
const localizeUtils_1 = require("../common/localizeUtils");
const launchHelper_1 = require("../common/m365/launchHelper");
const projectSettingsHelper_1 = require("../common/projectSettingsHelper");
const spec_parser_1 = require("../common/spec-parser");
const versionMetadata_1 = require("../common/versionMetadata");
const parser_1 = require("../component/configManager/parser");
const constants_2 = require("../component/constants");
const coordinator_1 = require("../component/coordinator");
const buildAadManifest_1 = require("../component/driver/aad/utility/buildAadManifest");
require("../component/driver/index");
require("../component/driver/script/scriptDriver");
const appStudio_1 = require("../component/driver/teamsApp/appStudio");
const teamsappMgr_1 = require("../component/driver/teamsApp/teamsappMgr");
const ManifestUtils_1 = require("../component/driver/teamsApp/utils/ManifestUtils");
const utils_1 = require("../component/driver/teamsApp/utils/utils");
const helper_1 = require("../component/generator/copilotPlugin/helper");
const envMW_1 = require("../component/middleware/envMW");
const questionMW_1 = require("../component/middleware/questionMW");
const utils_2 = require("../component/utils");
const envUtil_1 = require("../component/utils/envUtil");
const metadataUtil_1 = require("../component/utils/metadataUtil");
const pathUtils_1 = require("../component/utils/pathUtils");
const settingsUtil_1 = require("../component/utils/settingsUtil");
const common_1 = require("../error/common");
const upgrade_1 = require("../error/upgrade");
const yml_1 = require("../error/yml");
const create_1 = require("../question/create");
const other_1 = require("../question/other");
const questionNames_1 = require("../question/questionNames");
const callback_1 = require("./callback");
const collaborator_1 = require("./collaborator");
const crypto_1 = require("./crypto");
const environmentName_1 = require("./environmentName");
const error_1 = require("./error");
const globalVars_1 = require("./globalVars");
const concurrentLocker_1 = require("./middleware/concurrentLocker");
const contextInjector_1 = require("./middleware/contextInjector");
const errorHandler_1 = require("./middleware/errorHandler");
const projectMigratorV3_1 = require("./middleware/projectMigratorV3");
const v3MigrationUtils_1 = require("./middleware/utils/v3MigrationUtils");
const telemetry_1 = require("./telemetry");
const featureFlags_1 = require("../common/featureFlags");
require("../component/feature/sso");
class FxCore {
    constructor(tools) {
        globalVars_1.setTools(tools);
    }
    /**
     * @todo this's a really primitive implement. Maybe could use Subscription Model to
     * refactor later.
     */
    on(event, callback) {
        return callback_1.CallbackRegistry.set(event, callback);
    }
    async createProject(inputs) {
        const context = utils_2.createContextV3();
        inputs[questionNames_1.QuestionNames.Scratch] = create_1.ScratchOptions.yes().id;
        if (inputs.teamsAppFromTdp) {
            // should never happen as we do same check on Developer Portal.
            if (utils_1.containsUnsupportedFeature(inputs.teamsAppFromTdp)) {
                return teamsfx_api_1.err(error_1.InvalidInputError("Teams app contains unsupported features"));
            }
            else {
                context.telemetryReporter.sendTelemetryEvent(telemetry_1.CoreTelemetryEvent.CreateFromTdpStart, {
                    [telemetry_1.CoreTelemetryProperty.TdpTeamsAppFeatures]: utils_1.getFeaturesFromAppDefinition(inputs.teamsAppFromTdp).join(","),
                    [telemetry_1.CoreTelemetryProperty.TdpTeamsAppId]: inputs.teamsAppFromTdp.teamsAppId,
                });
            }
        }
        const res = await coordinator_1.coordinator.create(context, inputs);
        inputs.projectPath = context.projectPath;
        return res;
    }
    /**
     * lifecycle command: create new sample project
     */
    async createSampleProject(inputs) {
        const context = utils_2.createContextV3();
        inputs[questionNames_1.QuestionNames.Scratch] = create_1.ScratchOptions.no().id;
        const res = await coordinator_1.coordinator.create(context, inputs);
        inputs.projectPath = context.projectPath;
        return res;
    }
    /**
     * lifecycle commands: provision
     */
    async provisionResources(inputs, ctx) {
        inputs.stage = teamsfx_api_1.Stage.provision;
        const context = utils_2.createDriverContext(inputs);
        try {
            const res = await coordinator_1.coordinator.provision(context, inputs);
            if (res.isOk()) {
                ctx.envVars = res.value;
                return teamsfx_api_1.ok(undefined);
            }
            else {
                // for partial success scenario, output is set in inputs object
                ctx.envVars = inputs.envVars;
                return teamsfx_api_1.err(res.error);
            }
        }
        finally {
            //reset subscription
            try {
                await globalVars_1.TOOLS.tokenProvider.azureAccountProvider.setSubscription("");
            }
            catch (e) { }
        }
    }
    /**
     * lifecycle commands: deploy
     */
    async deployArtifacts(inputs, ctx) {
        inputs.stage = teamsfx_api_1.Stage.deploy;
        const context = utils_2.createDriverContext(inputs);
        const res = await coordinator_1.coordinator.deploy(context, inputs);
        if (res.isOk()) {
            ctx.envVars = res.value;
            return teamsfx_api_1.ok(undefined);
        }
        else {
            // for partial success scenario, output is set in inputs object
            ctx.envVars = inputs.envVars;
            return teamsfx_api_1.err(res.error);
        }
    }
    async localDebug(inputs) {
        inputs.env = environmentName_1.environmentNameManager.getLocalEnvName();
        return this.provisionResources(inputs);
    }
    /**
     * none lifecycle command, v3 only
     */
    async deployAadManifest(inputs) {
        inputs.stage = teamsfx_api_1.Stage.deployAad;
        const updateAadClient = typedi_1.Container.get("aadApp/update");
        // In V3, the aad.template.json exist at .fx folder, and output to root build folder.
        const manifestTemplatePath = inputs[questionNames_1.QuestionNames.AadAppManifestFilePath];
        if (!(await fs_extra_1.default.pathExists(manifestTemplatePath))) {
            return teamsfx_api_1.err(new common_1.FileNotFoundError("deployAadManifest", manifestTemplatePath));
        }
        let manifestOutputPath = manifestTemplatePath;
        if (inputs.env && (await other_1.isAadMainifestContainsPlaceholder(inputs))) {
            await fs_extra_1.default.ensureDir(path.join(inputs.projectPath, "build"));
            manifestOutputPath = path.join(inputs.projectPath, "build", `aad.manifest.${inputs.env}.json`);
        }
        const inputArgs = {
            manifestPath: manifestTemplatePath,
            outputFilePath: manifestOutputPath,
        };
        const Context = utils_2.createDriverContext(inputs);
        globalVars_1.setErrorContext({ component: "aadAppUpdate" });
        const res = await updateAadClient.execute(inputArgs, Context);
        if (res.result.isErr()) {
            return teamsfx_api_1.err(res.result.error);
        }
        if (Context.platform === teamsfx_api_1.Platform.CLI) {
            const msg = localizeUtils_1.getLocalizedString("core.deploy.aadManifestOnCLISuccessNotice");
            void Context.ui.showMessage("info", msg, false);
        }
        else {
            const msg = localizeUtils_1.getLocalizedString("core.deploy.aadManifestSuccessNotice");
            void Context.ui.showMessage("info", msg, false, localizeUtils_1.getLocalizedString("core.deploy.aadManifestLearnMore")).then((result) => {
                const userSelected = result.isOk() ? result.value : undefined;
                if (userSelected === localizeUtils_1.getLocalizedString("core.deploy.aadManifestLearnMore")) {
                    void Context.ui.openUrl(constants_2.ViewAadAppHelpLinkV5);
                }
            });
        }
        return teamsfx_api_1.ok(undefined);
    }
    /**
     * none lifecycle command, v3 only
     */
    async addWebpart(inputs) {
        globalVars_1.setErrorContext({ component: "spfxAdd", method: "run" });
        const driver = typedi_1.Container.get("spfx/add");
        const args = {
            manifestPath: inputs[constants_2.SPFxQuestionNames.ManifestPath],
            localManifestPath: inputs[constants_2.SPFxQuestionNames.LocalManifestPath],
            spfxFolder: inputs[constants_2.SPFxQuestionNames.SPFxFolder],
            webpartName: inputs[constants_2.SPFxQuestionNames.WebPartName],
            framework: inputs[questionNames_1.QuestionNames.SPFxFramework],
            spfxPackage: create_1.SPFxVersionOptionIds.installLocally,
        };
        const Context = utils_2.createDriverContext(inputs);
        const res = await driver.run(args, Context);
        if (res.isErr()) {
            return teamsfx_api_1.err(res.error);
        }
        return teamsfx_api_1.ok(undefined);
    }
    /**
     * lifecycle command: publish
     */
    async publishApplication(inputs, ctx) {
        inputs.stage = teamsfx_api_1.Stage.publish;
        const context = utils_2.createDriverContext(inputs);
        const res = await coordinator_1.coordinator.publish(context, inputs);
        if (res.isOk()) {
            ctx.envVars = res.value;
            return teamsfx_api_1.ok(undefined);
        }
        else {
            // for partial success scenario, output is set in inputs object
            ctx.envVars = inputs.envVars;
            return teamsfx_api_1.err(res.error);
        }
    }
    /**
     * most commands will be deprecated in V3
     */
    async executeUserTask(func, inputs) {
        let res = teamsfx_api_1.ok(undefined);
        const context = utils_2.createDriverContext(inputs);
        if (func.method === "addSso") {
            // used in v3 only in VS
            inputs.stage = teamsfx_api_1.Stage.addFeature;
            inputs[questionNames_1.QuestionNames.Features] = constants_2.SingleSignOnOptionItem.id;
            const component = typedi_1.Container.get("sso");
            globalVars_1.setErrorContext({ component: "sso", method: "add" });
            res = await component.add(context, inputs);
        }
        return res;
    }
    /**
     * v3 only none lifecycle command
     */
    async buildAadManifest(inputs) {
        const manifestTemplatePath = inputs.AAD_MANIFEST_FILE
            ? inputs.AAD_MANIFEST_FILE
            : path.join(inputs.projectPath, constants_2.AadConstants.DefaultTemplateFileName);
        if (!(await fs_extra_1.default.pathExists(manifestTemplatePath))) {
            return teamsfx_api_1.err(new common_1.FileNotFoundError("buildAadManifest", manifestTemplatePath));
        }
        await fs_extra_1.default.ensureDir(path.join(inputs.projectPath, "build"));
        const manifestOutputPath = path.join(inputs.projectPath, "build", 
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `aad.${inputs.env}.json`);
        const Context = utils_2.createDriverContext(inputs);
        await buildAadManifest_1.buildAadManifest(Context, manifestTemplatePath, manifestOutputPath);
        return teamsfx_api_1.ok(undefined);
    }
    /**
     * v3 only none lifecycle command
     */
    async deployTeamsManifest(inputs, ctx) {
        inputs.manifestTemplatePath = inputs[questionNames_1.QuestionNames.TeamsAppManifestFilePath];
        const context = utils_2.createContextV3();
        const res = await appStudio_1.updateManifestV3(context, inputs);
        if (res.isOk()) {
            ctx.envVars = envUtil_1.envUtil.map2object(res.value);
            return teamsfx_api_1.ok(undefined);
        }
        return teamsfx_api_1.err(res.error);
    }
    /******
     * CLI v3 commands
     */
    async updateTeamsAppCLIV3(inputs) {
        const res = await teamsappMgr_1.teamsappMgr.updateTeamsApp(inputs);
        return res;
    }
    /******
     * CLI v3 commands
     */
    async validateTeamsAppCLIV3(inputs) {
        const res = await teamsappMgr_1.teamsappMgr.validateTeamsApp(inputs);
        return res;
    }
    /******
     * CLI v3 commands
     */
    async packageTeamsAppCLIV3(inputs) {
        const res = await teamsappMgr_1.teamsappMgr.packageTeamsApp(inputs);
        if (res.isErr()) {
            return teamsfx_api_1.err(res.error);
        }
        return teamsfx_api_1.ok(undefined);
    }
    /******
     * CLI v3 commands
     */
    async publishTeamsAppCLIV3(inputs) {
        const res = await teamsappMgr_1.teamsappMgr.publishTeamsApp(inputs);
        return res;
    }
    /**
     * v3 only none lifecycle command
     */
    async validateApplication(inputs) {
        if (inputs["manifest-path"]) {
            return await this.validateManifest(inputs);
        }
        else {
            return await this.validateAppPackage(inputs);
        }
    }
    /**
     * v3 only none lifecycle command
     */
    async validateManifest(inputs) {
        inputs.stage = teamsfx_api_1.Stage.validateApplication;
        const context = utils_2.createDriverContext(inputs);
        const teamsAppManifestFilePath = inputs["manifest-path"];
        const args = {
            manifestPath: teamsAppManifestFilePath,
            showMessage: (inputs === null || inputs === void 0 ? void 0 : inputs.showMessage) != undefined ? inputs.showMessage : true,
        };
        const driver = typedi_1.Container.get("teamsApp/validateManifest");
        const result = await driver.execute(args, context);
        return result.result;
    }
    /**
     * v3 only none lifecycle command
     */
    async validateAppPackage(inputs) {
        inputs.stage = teamsfx_api_1.Stage.validateApplication;
        const context = utils_2.createDriverContext(inputs);
        const teamsAppPackageFilePath = inputs["app-package-file-path"];
        const args = {
            appPackagePath: teamsAppPackageFilePath,
            showMessage: true,
        };
        const driver = typedi_1.Container.get("teamsApp/validateAppPackage");
        return (await driver.execute(args, context)).result;
    }
    /**
     * v3 only none lifecycle command
     */
    async createAppPackage(inputs) {
        var _a, _b, _c;
        inputs.stage = teamsfx_api_1.Stage.createAppPackage;
        const context = utils_2.createDriverContext(inputs);
        const teamsAppManifestFilePath = inputs === null || inputs === void 0 ? void 0 : inputs[questionNames_1.QuestionNames.TeamsAppManifestFilePath];
        const driver = typedi_1.Container.get("teamsApp/zipAppPackage");
        const args = {
            manifestPath: teamsAppManifestFilePath,
            outputZipPath: (_a = inputs[questionNames_1.QuestionNames.OutputZipPathParamName]) !== null && _a !== void 0 ? _a : 
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${inputs.projectPath}/${teamsfx_api_1.AppPackageFolderName}/${teamsfx_api_1.BuildFolderName}/appPackage.${process.env
                .TEAMSFX_ENV}.zip`,
            outputJsonPath: (_b = inputs[questionNames_1.QuestionNames.OutputManifestParamName]) !== null && _b !== void 0 ? _b : 
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${inputs.projectPath}/${teamsfx_api_1.AppPackageFolderName}/${teamsfx_api_1.BuildFolderName}/manifest.${process.env
                .TEAMSFX_ENV}.json`,
        };
        const result = (await driver.execute(args, context)).result;
        if (context.platform === teamsfx_api_1.Platform.VSCode) {
            if (result.isOk()) {
                const isWindows = process.platform === "win32";
                let zipFileName = args.outputZipPath;
                if (!path.isAbsolute(zipFileName)) {
                    zipFileName = path.join(context.projectPath, zipFileName);
                }
                let builtSuccess = localizeUtils_1.getLocalizedString("plugins.appstudio.buildSucceedNotice.fallback", zipFileName);
                if (isWindows) {
                    const folderLink = url_1.pathToFileURL(path.dirname(zipFileName));
                    const appPackageLink = `${constants_1.VSCodeExtensionCommand.openFolder}?%5B%22${folderLink.toString()}%22%5D`;
                    builtSuccess = localizeUtils_1.getLocalizedString("plugins.appstudio.buildSucceedNotice", appPackageLink);
                }
                (_c = context.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", builtSuccess, false);
            }
        }
        return result;
    }
    /**
     * get url to preview the app, may prompt to select env, hub and Teams manifest
     * v3 only none lifecycle command
     * @param {Inputs} inputs
     * @returns the url to preview the app
     */
    async previewWithManifest(inputs) {
        inputs.stage = teamsfx_api_1.Stage.previewWithManifest;
        const hub = inputs[questionNames_1.QuestionNames.M365Host];
        const manifestFilePath = inputs[questionNames_1.QuestionNames.TeamsAppManifestFilePath];
        const manifestRes = await ManifestUtils_1.manifestUtils.getManifestV3(manifestFilePath, undefined, false);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        const teamsAppId = manifestRes.value.id;
        const properties = teamsfx_api_1.ManifestUtil.parseCommonProperties(manifestRes.value);
        const launchHelper = new launchHelper_1.LaunchHelper(globalVars_1.TOOLS.tokenProvider.m365TokenProvider, globalVars_1.TOOLS.logProvider);
        const result = await launchHelper.getLaunchUrl(hub, teamsAppId, properties.capabilities, true, properties.isApiME);
        return result;
    }
    /**
     * Warning: this API only works for CLI_HELP, it has no business with interactive run for CLI!
     */
    getQuestions(stage, inputs) {
        if (stage === teamsfx_api_1.Stage.create) {
            return teamsfx_api_1.ok(create_1.createProjectCliHelpNode());
        }
        return teamsfx_api_1.ok(undefined);
    }
    /**
     * get all dot envs
     */
    async getDotEnvs(inputs) {
        const envListRes = await envUtil_1.envUtil.listEnv(inputs.projectPath);
        if (envListRes.isErr()) {
            return teamsfx_api_1.err(envListRes.error);
        }
        const res = {};
        for (const env of envListRes.value) {
            const envRes = await envUtil_1.envUtil.readEnv(inputs.projectPath, env, false, false);
            if (envRes.isErr()) {
                return teamsfx_api_1.err(envRes.error);
            }
            res[env] = envRes.value;
        }
        return teamsfx_api_1.ok(res);
    }
    /**
     * given projectPath and filePath, return whether the filePath is a env file
     */
    async isEnvFile(projectPath, inputFile) {
        const inputFileName = path.basename(inputFile);
        const envName = envUtil_1.envUtil.extractEnvNameFromFileName(inputFileName);
        if (!envName)
            return teamsfx_api_1.ok(false);
        const folderRes = await pathUtils_1.pathUtils.getEnvFolderPath(projectPath);
        if (folderRes.isErr())
            return teamsfx_api_1.err(folderRes.error);
        const envFolderPath = folderRes.value;
        if (!envFolderPath)
            return teamsfx_api_1.ok(false);
        const inputFileDir = path.dirname(inputFile);
        if (path.resolve(inputFileDir) !== path.resolve(envFolderPath))
            return teamsfx_api_1.ok(false);
        return teamsfx_api_1.ok(true);
    }
    /**
     * get projectId
     */
    async getProjectId(projectPath) {
        const res = await this.getProjectMetadata(projectPath);
        if (res.isErr()) {
            return teamsfx_api_1.err(res.error);
        }
        return teamsfx_api_1.ok(res.value.projectId || "");
    }
    /**
     * @description get projectId and version from yml
     */
    async getProjectMetadata(projectPath) {
        try {
            const ymlPath = pathUtils_1.pathUtils.getYmlFilePath(projectPath, "dev");
            if (!ymlPath || !(await fs_extra_1.default.pathExists(ymlPath))) {
                return teamsfx_api_1.ok({});
            }
            const ymlContent = await fs_extra_1.default.readFile(ymlPath, "utf-8");
            const ymlObject = yaml_1.parse(ymlContent);
            return teamsfx_api_1.ok({
                projectId: (ymlObject === null || ymlObject === void 0 ? void 0 : ymlObject.projectId) ? ymlObject.projectId.toString() : "",
                version: (ymlObject === null || ymlObject === void 0 ? void 0 : ymlObject.version) ? ymlObject.version.toString() : "",
            });
        }
        catch (_a) {
            return teamsfx_api_1.ok({});
        }
    }
    /**
     * get Teams App Name from yml
     */
    async getTeamsAppName(projectPath) {
        var _a;
        const ymlPath = pathUtils_1.pathUtils.getYmlFilePath(projectPath, "dev");
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(ymlPath, "dev");
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        if (projectModel.provision) {
            const teamsAppCreate = (_a = projectModel.provision) === null || _a === void 0 ? void 0 : _a.driverDefs.find((d) => d.uses === "teamsApp/create");
            if (teamsAppCreate) {
                const name = teamsAppCreate.with.name;
                if (name) {
                    return teamsfx_api_1.ok(name.replace("-${{TEAMSFX_ENV}}", "").replace("${{APP_NAME_SUFFIX}}", ""));
                }
            }
        }
        return teamsfx_api_1.ok("");
    }
    /**
     * get project info
     */
    async getProjectInfo(projectPath, env) {
        var _a;
        const ymlPath = pathUtils_1.pathUtils.getYmlFilePath(projectPath, env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(ymlPath, env);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const readEnvRes = await envUtil_1.envUtil.readEnv(projectPath, env, false, true);
        if (readEnvRes.isErr()) {
            return teamsfx_api_1.err(readEnvRes.error);
        }
        const envObject = readEnvRes.value;
        const res = {
            projectId: projectModel.projectId || "",
            teamsAppId: "",
            teamsAppName: "",
            m365TenantId: envObject.TEAMS_APP_TENANT_ID || "",
        };
        if (projectModel.provision) {
            const teamsAppCreate = projectModel.provision.driverDefs.find((d) => d.uses === "teamsApp/create");
            if (teamsAppCreate) {
                const teamsAppIdEnvName = (_a = teamsAppCreate.writeToEnvironmentFile) === null || _a === void 0 ? void 0 : _a.teamsAppId;
                if (teamsAppIdEnvName) {
                    const teamsAppId = envObject[teamsAppIdEnvName];
                    res.teamsAppId = teamsAppId;
                }
                const name = teamsAppCreate.with.name;
                if (name) {
                    res.teamsAppName = name.replace("-${{TEAMSFX_ENV}}", "") || "";
                }
            }
        }
        return teamsfx_api_1.ok(res);
    }
    async grantPermission(inputs) {
        inputs.stage = teamsfx_api_1.Stage.grantPermission;
        const context = utils_2.createContextV3();
        globalVars_1.setErrorContext({ component: "collaborator" });
        const res = await collaborator_1.grantPermission(context, inputs, globalVars_1.TOOLS.tokenProvider);
        return res;
    }
    /**
     * none lifecycle command
     */
    async checkPermission(inputs) {
        inputs.stage = teamsfx_api_1.Stage.checkPermission;
        const context = utils_2.createContextV3();
        const res = await collaborator_1.checkPermission(context, inputs, globalVars_1.TOOLS.tokenProvider);
        return res;
    }
    /**
     * none lifecycle command
     */
    async listCollaborator(inputs) {
        inputs.stage = teamsfx_api_1.Stage.listCollaborator;
        const context = utils_2.createContextV3();
        const res = await collaborator_1.listCollaborator(context, inputs, globalVars_1.TOOLS.tokenProvider);
        return res;
    }
    getSelectedEnv(inputs) {
        return Promise.resolve(teamsfx_api_1.ok(inputs.env)); //work for both v2 and v3
    }
    async createLocalCrypto(projectPath) {
        const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath);
        if (settingsRes.isErr()) {
            return teamsfx_api_1.err(settingsRes.error);
        }
        const projectId = settingsRes.value.trackingId;
        const cryptoProvider = new crypto_1.LocalCrypto(projectId);
        return teamsfx_api_1.ok(cryptoProvider);
    }
    /**
     * only for vs code extension
     */
    async encrypt(plaintext, inputs) {
        const res = await this.createLocalCrypto(inputs.projectPath);
        if (res.isErr()) {
            return teamsfx_api_1.err(res.error);
        }
        return res.value.encrypt(plaintext);
    }
    /**
     * only for vs code extension
     */
    async decrypt(ciphertext, inputs) {
        const res = await this.createLocalCrypto(inputs.projectPath);
        if (res.isErr()) {
            return teamsfx_api_1.err(res.error);
        }
        return res.value.decrypt(ciphertext);
    }
    async createEnv(inputs) {
        return this.createEnvCopyV3(inputs[questionNames_1.QuestionNames.NewTargetEnvName], inputs[questionNames_1.QuestionNames.SourceEnvName], inputs.projectPath);
    }
    async createEnvCopyV3(targetEnvName, sourceEnvName, projectPath) {
        let res = await pathUtils_1.pathUtils.getEnvFilePath(projectPath, sourceEnvName);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        const sourceDotEnvFile = res.value;
        res = await pathUtils_1.pathUtils.getEnvFilePath(projectPath, targetEnvName);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        const targetDotEnvFile = res.value;
        if (!sourceDotEnvFile || !targetDotEnvFile)
            return teamsfx_api_1.err(new yml_1.YamlFieldMissingError("environmentFolderPath"));
        if (!(await fs_extra_1.default.pathExists(sourceDotEnvFile)))
            return teamsfx_api_1.err(new common_1.FileNotFoundError("createEnvCopyV3", sourceDotEnvFile));
        const source = await fs_extra_1.default.readFile(sourceDotEnvFile);
        const writeStream = fs_extra_1.default.createWriteStream(targetDotEnvFile);
        source
            .toString()
            .split(/\r?\n/)
            .forEach((line) => {
            const reg = /^([a-zA-Z_][a-zA-Z0-9_]*=)/g;
            const match = reg.exec(line);
            if (match) {
                if (match[1].startsWith("TEAMSFX_ENV=")) {
                    writeStream.write(`TEAMSFX_ENV=${targetEnvName}${os.EOL}`);
                }
                else {
                    writeStream.write(`${match[1]}${os.EOL}`);
                }
            }
            else {
                writeStream.write(`${line.trim()}${os.EOL}`);
            }
        });
        writeStream.end();
        globalVars_1.TOOLS.logProvider.info(`env file created: ${targetDotEnvFile}`);
        return teamsfx_api_1.ok(undefined);
    }
    // a phantom migration method for V3
    async phantomMigrationV3(inputs) {
        // If the project is invalid or upgraded, the ProjectMigratorMWV3 will not take action.
        // Check invaliad/upgraded project here before call ProjectMigratorMWV3
        const projectPath = inputs.projectPath || "";
        const version = await v3MigrationUtils_1.getProjectVersionFromPath(projectPath);
        if (version.source === versionMetadata_1.VersionSource.teamsapp) {
            return teamsfx_api_1.err(new upgrade_1.NoNeedUpgradeError());
        }
        else if (version.source === versionMetadata_1.VersionSource.projectSettings) {
            const isValid = await projectMigratorV3_1.checkActiveResourcePlugins(projectPath);
            if (!isValid) {
                return teamsfx_api_1.err(new common_1.InvalidProjectError());
            }
        }
        if (version.source === versionMetadata_1.VersionSource.unknown) {
            return teamsfx_api_1.err(new common_1.InvalidProjectError());
        }
        return this.innerMigrationV3(inputs);
    }
    innerMigrationV3(inputs) {
        return teamsfx_api_1.ok(undefined);
    }
    // a project version check
    async projectVersionCheck(inputs) {
        const projectPath = inputs.projectPath || "";
        if (projectSettingsHelper_1.isValidProjectV3(projectPath) || projectSettingsHelper_1.isValidProjectV2(projectPath)) {
            const versionInfo = await v3MigrationUtils_1.getProjectVersionFromPath(projectPath);
            if (!versionInfo.version) {
                return teamsfx_api_1.err(new common_1.InvalidProjectError());
            }
            const trackingId = await v3MigrationUtils_1.getTrackingIdFromPath(projectPath);
            const isSupport = v3MigrationUtils_1.getVersionState(versionInfo);
            // if the project is upgradeable, check whether the project is valid and invalid project should not show upgrade option.
            if (isSupport === versionMetadata_1.VersionState.upgradeable) {
                if (!(await projectMigratorV3_1.checkActiveResourcePlugins(projectPath))) {
                    return teamsfx_api_1.err(new common_1.InvalidProjectError());
                }
            }
            return teamsfx_api_1.ok({
                currentVersion: versionInfo.version,
                trackingId,
                isSupport,
                versionSource: versionMetadata_1.VersionSource[versionInfo.source],
            });
        }
        else {
            return teamsfx_api_1.err(new common_1.InvalidProjectError());
        }
    }
    // apply the given yaml template to current project.
    async apply(inputs, templatePath, lifecycleName) {
        if (!inputs.projectPath) {
            return teamsfx_api_1.err(error_1.InvalidInputError("invalid projectPath", inputs));
        }
        const projectPath = inputs.projectPath;
        if (!inputs.env) {
            return teamsfx_api_1.err(error_1.InvalidInputError("invalid env", inputs));
        }
        const env = inputs.env;
        const lifecycleName_ = lifecycleName;
        const result = await envUtil_1.envUtil.readEnv(projectPath, env);
        if (result.isErr()) {
            return teamsfx_api_1.err(result.error);
        }
        const parser = new parser_1.YamlParser();
        const maybeProjectModel = await parser.parse(templatePath);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const driverContext = {
            azureAccountProvider: globalVars_1.TOOLS.tokenProvider.azureAccountProvider,
            m365TokenProvider: globalVars_1.TOOLS.tokenProvider.m365TokenProvider,
            ui: globalVars_1.TOOLS.ui,
            progressBar: undefined,
            logProvider: globalVars_1.TOOLS.logProvider,
            telemetryReporter: globalVars_1.TOOLS.telemetryReporter,
            projectPath: projectPath,
            platform: inputs.platform,
        };
        const lifecycle = projectModel[lifecycleName_];
        if (lifecycle) {
            return this.runLifecycle(lifecycle, driverContext, env);
        }
        else {
            driverContext.logProvider.warning(`No definition found for ${lifecycleName}`);
            return teamsfx_api_1.ok(undefined);
        }
    }
    async runLifecycle(lifecycle, driverContext, env) {
        const r = await lifecycle.execute(driverContext);
        const runResult = r.result;
        if (runResult.isOk()) {
            driverContext.logProvider.info(`Lifecycle ${lifecycle.name} succeeded`);
            const writeResult = await envUtil_1.envUtil.writeEnv(driverContext.projectPath, env, envUtil_1.envUtil.map2object(runResult.value));
            return writeResult.map(() => undefined);
        }
        else {
            const error = runResult.error;
            if (error.kind === "Failure") {
                driverContext.logProvider.error(`Failed to run ${lifecycle.name} due to ${error.error.name}: ${error.error.message}`);
                return teamsfx_api_1.err(error.error);
            }
            else {
                try {
                    const failedDriver = error.reason.failedDriver;
                    if (error.reason.kind === "UnresolvedPlaceholders") {
                        const unresolved = error.reason.unresolvedPlaceHolders;
                        driverContext.logProvider.warning(`Unresolved placeholders: ${unresolved.join(",")} for driver ${failedDriver.uses}`);
                        return teamsfx_api_1.ok(undefined);
                    }
                    else {
                        driverContext.logProvider.error(`Failed to run ${lifecycle.name} due to ${error.reason.error.name}: ${error.reason.error.message}. Failed driver: ${failedDriver.uses}`);
                        return teamsfx_api_1.err(error.reason.error);
                    }
                }
                finally {
                    await envUtil_1.envUtil.writeEnv(driverContext.projectPath, env, envUtil_1.envUtil.map2object(error.env));
                }
            }
        }
    }
    async preProvisionForVS(inputs) {
        const context = utils_2.createDriverContext(inputs);
        return coordinator_1.coordinator.preProvisionForVS(context, inputs);
    }
    async preCheckYmlAndEnvForVS(inputs) {
        const context = utils_2.createDriverContext(inputs);
        const result = await coordinator_1.coordinator.preCheckYmlAndEnvForVS(context, inputs);
        return result;
    }
    async publishInDeveloperPortal(inputs) {
        inputs.stage = teamsfx_api_1.Stage.publishInDeveloperPortal;
        const context = utils_2.createContextV3();
        return await coordinator_1.coordinator.publishInDeveloperPortal(context, inputs);
    }
    async injectCreateAPIKeyAction(ymlPath, authName, specRelativePath) {
        var _a;
        const ymlContent = await fs_extra_1.default.readFile(ymlPath, "utf-8");
        const document = yaml_1.parseDocument(ymlContent);
        const provisionNode = document.get("provision");
        if (provisionNode) {
            const hasApiKeyAction = provisionNode.items.some((item) => { var _a; return item.get("uses") === "apiKey/register" && ((_a = item.get("with")) === null || _a === void 0 ? void 0 : _a.get("name")) === authName; });
            if (!hasApiKeyAction) {
                provisionNode.items = provisionNode.items.filter((item) => item.get("uses") !== "apiKey/register");
                let added = false;
                for (let i = 0; i < provisionNode.items.length; i++) {
                    const item = provisionNode.items[i];
                    if (item.get("uses") === "teamsApp/create") {
                        const teamsAppId = (_a = item.get("writeToEnvironmentFile")) === null || _a === void 0 ? void 0 : _a.get("teamsAppId");
                        if (teamsAppId) {
                            provisionNode.items.splice(i + 1, 0, {
                                uses: "apiKey/register",
                                with: {
                                    name: `${authName}`,
                                    appId: `\${{${teamsAppId}}}`,
                                    apiSpecPath: specRelativePath,
                                },
                                writeToEnvironmentFile: {
                                    registrationId: `${authName.toUpperCase()}_REGISTRATION_ID`,
                                },
                            });
                            added = true;
                            break;
                        }
                    }
                }
                if (!added) {
                    throw new common_1.InjectAPIKeyActionFailedError();
                }
                await fs_extra_1.default.writeFile(ymlPath, document.toString(), "utf8");
            }
        }
        else {
            throw new common_1.InjectAPIKeyActionFailedError();
        }
    }
    async copilotPluginAddAPI(inputs) {
        var _a, _b;
        const newOperations = inputs[questionNames_1.QuestionNames.ApiOperation];
        const url = (_a = inputs[questionNames_1.QuestionNames.ApiSpecLocation]) !== null && _a !== void 0 ? _a : (_b = inputs.openAIPluginManifest) === null || _b === void 0 ? void 0 : _b.api.url;
        const manifestPath = inputs[questionNames_1.QuestionNames.ManifestPath];
        // Get API spec file path from manifest
        const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(manifestPath);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        const apiSpecificationFile = manifestRes.value.composeExtensions[0].apiSpecificationFile;
        const outputAPISpecPath = path.join(path.dirname(manifestPath), apiSpecificationFile);
        // Merge existing operations in manifest.json
        const specParser = new spec_parser_1.SpecParser(url, { allowAPIKeyAuth: featureFlags_1.isApiKeyEnabled() });
        const existingOperationIds = ManifestUtils_1.manifestUtils.getOperationIds(manifestRes.value);
        const apiResultList = await specParser.list();
        const existingOperations = [];
        for (const id of existingOperationIds) {
            const operation = apiResultList.find((item) => item.operationId === id);
            if (operation) {
                existingOperations.push(operation.api);
            }
        }
        const operations = [...existingOperations, ...newOperations];
        const adaptiveCardFolder = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ResponseTemplatesFolderName);
        const context = utils_2.createContextV3();
        try {
            if (featureFlags_1.isApiKeyEnabled()) {
                const authNames = new Set();
                const serverUrls = new Set();
                for (const api of operations) {
                    const operation = apiResultList.find((op) => op.api === api);
                    if (operation) {
                        if (operation.auth) {
                            authNames.add(operation.auth.name);
                            serverUrls.add(operation.server);
                        }
                    }
                }
                if (authNames.size > 1) {
                    throw new common_1.MultipleAuthError(authNames);
                }
                if (serverUrls.size > 1) {
                    throw new common_1.MultipleServerError(serverUrls);
                }
                if (authNames.size === 1) {
                    const ymlPath = path.join(inputs.projectPath, versionMetadata_1.MetadataV3.configFile);
                    const localYamlPath = path.join(inputs.projectPath, versionMetadata_1.MetadataV3.localConfigFile);
                    const authName = [...authNames][0];
                    const relativeSpecPath = "./" + path.relative(inputs.projectPath, outputAPISpecPath).replace(/\\/g, "/");
                    await this.injectCreateAPIKeyAction(ymlPath, authName, relativeSpecPath);
                    if (await fs_extra_1.default.pathExists(localYamlPath)) {
                        await this.injectCreateAPIKeyAction(localYamlPath, authName, relativeSpecPath);
                    }
                }
            }
            const generateResult = await specParser.generate(manifestPath, operations, outputAPISpecPath, adaptiveCardFolder);
            // Send SpecParser.generate() warnings
            context.telemetryReporter.sendTelemetryEvent(helper_1.specParserGenerateResultTelemetryEvent, {
                [helper_1.specParserGenerateResultAllSuccessTelemetryProperty]: generateResult.allSuccess.toString(),
                [helper_1.specParserGenerateResultWarningsTelemetryProperty]: generateResult.warnings
                    .map((w) => w.type.toString() + ": " + w.content)
                    .join(";"),
                [telemetry_1.CoreTelemetryProperty.Component]: telemetry_1.CoreTelemetryComponentName,
            });
            if (generateResult.warnings && generateResult.warnings.length > 0) {
                const warnSummary = helper_1.generateScaffoldingSummary(generateResult.warnings, manifestRes.value, inputs.projectPath);
                context.logProvider.info(warnSummary);
            }
        }
        catch (e) {
            let error;
            if (e instanceof spec_parser_1.SpecParserError) {
                error = helper_1.convertSpecParserErrorToFxError(e);
            }
            else {
                error = common_1.assembleError(e);
            }
            return teamsfx_api_1.err(error);
        }
        const message = localizeUtils_1.getLocalizedString("core.copilot.addAPI.success", newOperations, inputs.projectPath);
        void context.userInteraction.showMessage("info", message, false);
        return teamsfx_api_1.ok(undefined);
    }
    async copilotPluginLoadOpenAIManifest(inputs) {
        try {
            return teamsfx_api_1.ok(await helper_1.OpenAIPluginManifestHelper.loadOpenAIPluginManifest(inputs.domain));
        }
        catch (error) {
            return teamsfx_api_1.err(error);
        }
    }
    async copilotPluginListOperations(inputs) {
        return await helper_1.listOperations(utils_2.createContextV3(), inputs.manifest, inputs.apiSpecUrl, inputs[questionNames_1.QuestionNames.ManifestPath], inputs.includeExistingAPIs, inputs.shouldLogWarning);
    }
}
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "createProject", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        questionMW_1.QuestionMW("createProject"),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createProject", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "createSampleProject", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        questionMW_1.QuestionMW("createSampleProject"),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createSampleProject", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "provision", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "provisionResources", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "deploy", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "deployArtifacts", null);
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ component: "FxCore", stage: "localDebug", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "localDebug", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "deployAadManifest", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        questionMW_1.QuestionMW("deployAadManifest"),
        envMW_1.EnvLoaderMW(true, true),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "deployAadManifest", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "addWebpart", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        questionMW_1.QuestionMW("addWebpart"),
        projectMigratorV3_1.ProjectMigratorMWV3,
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "addWebpart", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "publish", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "publishApplication", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "executeUserTask", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "executeUserTask", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "buildAadManifest", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "buildAadManifest", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "deployTeamsManifest", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        questionMW_1.QuestionMW("selectTeamsAppManifest"),
        envMW_1.EnvLoaderMW(true),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "deployTeamsManifest", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "updateTeamsAppCLIV3", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "updateTeamsAppCLIV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "validateTeamsAppCLIV3", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "validateTeamsAppCLIV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "packageTeamsAppCLIV3", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "packageTeamsAppCLIV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "publishTeamsAppCLIV3", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "publishTeamsAppCLIV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "validateApplication", reset: true }),
        questionMW_1.QuestionMW("validateTeamsApp"),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "validateApplication", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "validateManifest", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        envMW_1.EnvLoaderMW(true),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "validateManifest", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "validateAppPackage", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "validateAppPackage", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "createAppPackage", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        questionMW_1.QuestionMW("selectTeamsAppManifest"),
        envMW_1.EnvLoaderMW(true),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createAppPackage", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "preview", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        questionMW_1.QuestionMW("previewWithTeamsAppManifest"),
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "previewWithManifest", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "getDotEnvs", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getDotEnvs", null);
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ component: "FxCore", stage: "isEnvFile", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "isEnvFile", null);
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ component: "FxCore", stage: "getProjectId", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getProjectId", null);
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ component: "FxCore", stage: "getProjectMetadata", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getProjectMetadata", null);
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ component: "FxCore", stage: "getTeamsAppName", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getTeamsAppName", null);
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ component: "FxCore", stage: "getProjectInfo", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getProjectInfo", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "grantPermission", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        questionMW_1.QuestionMW("grantPermission"),
        envMW_1.EnvLoaderMW(false, true),
        concurrentLocker_1.ConcurrentLockerMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "grantPermission", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "checkPermission", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        questionMW_1.QuestionMW("listCollaborator"),
        envMW_1.EnvLoaderMW(false, true),
        concurrentLocker_1.ConcurrentLockerMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "checkPermission", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "listCollaborator", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        questionMW_1.QuestionMW("listCollaborator"),
        envMW_1.EnvLoaderMW(false, true),
        concurrentLocker_1.ConcurrentLockerMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "listCollaborator", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "getSelectedEnv", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        envMW_1.EnvLoaderMW(false),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getSelectedEnv", null);
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ component: "FxCore", stage: "createLocalCrypto" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createLocalCrypto", null);
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ component: "FxCore", stage: "encrypt", reset: true }), errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "encrypt", null);
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ component: "FxCore", stage: "decrypt", reset: true }), errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "decrypt", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "createEnv", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        questionMW_1.QuestionMW("createNewEnv"),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createEnv", null);
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ component: "FxCore", stage: "phantomMigrationV3", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "phantomMigrationV3", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, projectMigratorV3_1.ProjectMigratorMWV3]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Object)
], FxCore.prototype, "innerMigrationV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "projectVersionCheck", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "projectVersionCheck", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "preProvisionForVS" }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "preProvisionForVS", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "preCheckYmlAndEnvForVS" }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "preCheckYmlAndEnvForVS", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "publishInDeveloperPortal" }),
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "publishInDeveloperPortal", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "copilotPluginAddAPI" }),
        errorHandler_1.ErrorHandlerMW,
        questionMW_1.QuestionMW("copilotPluginAddAPI"),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "copilotPluginAddAPI", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "copilotPluginLoadOpenAIManifest" }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "copilotPluginLoadOpenAIManifest", null);
tslib_1.__decorate([
    hooks_1.hooks([
        globalVars_1.ErrorContextMW({ component: "FxCore", stage: "copilotPluginListOperations" }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "copilotPluginListOperations", null);
exports.FxCore = FxCore;
//# sourceMappingURL=FxCore.js.map