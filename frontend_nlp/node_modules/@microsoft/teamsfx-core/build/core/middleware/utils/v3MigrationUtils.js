"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildEnvUserFileName = exports.buildEnvFileName = exports.tryExtractEnvFromUserdata = exports.addMissingValidDomainForManifest = exports.isValidDomainForBotOutputKey = exports.updateAndSaveManifestForSpfx = exports.readAndConvertUserdata = exports.replaceAppIdUri = exports.generateAppIdUri = exports.getCapabilityStatus = exports.getParameterFromCxt = exports.getVersionState = exports.getTrackingIdFromPath = exports.getProjectVersionFromPath = exports.outputCancelMessage = exports.migrationNotificationMessage = exports.getProjectVersion = exports.jsonObjectNamesConvertV3 = exports.validDomain = exports.fsReadDirSync = exports.getTemplateFolderPath = exports.readBicepContent = exports.readJsonFile = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const MigrationUtils_1 = require("./MigrationUtils");
const os_1 = require("os");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const semver_1 = tslib_1.__importDefault(require("semver"));
const projectSettingsLoader_1 = require("../projectSettingsLoader");
const versionMetadata_1 = require("../../../common/versionMetadata");
const localizeUtils_1 = require("../../../common/localizeUtils");
const globalVars_1 = require("../../globalVars");
const settingsUtil_1 = require("../../../component/utils/settingsUtil");
const dotenv = tslib_1.__importStar(require("dotenv"));
const ManifestUtils_1 = require("../../../component/driver/teamsApp/utils/ManifestUtils");
// read json files in states/ folder
async function readJsonFile(context, filePath) {
    const filepath = path_1.default.join(context.projectPath, filePath);
    if (await fs_extra_1.default.pathExists(filepath)) {
        const obj = fs_extra_1.default.readJson(filepath);
        return obj;
    }
}
exports.readJsonFile = readJsonFile;
// read bicep file content
async function readBicepContent(context) {
    const bicepFilePath = path_1.default.join(getTemplateFolderPath(context), "azure", "provision.bicep");
    const bicepFileExists = await context.fsPathExists(bicepFilePath);
    return bicepFileExists
        ? fs_extra_1.default.readFileSync(path_1.default.join(context.projectPath, bicepFilePath), "utf8")
        : "";
}
exports.readBicepContent = readBicepContent;
// get template folder path
function getTemplateFolderPath(context) {
    const inputs = context.arguments[context.arguments.length - 1];
    return inputs.platform === teamsfx_api_1.Platform.VS ? "Templates" : "templates";
}
exports.getTemplateFolderPath = getTemplateFolderPath;
// read file names list under the given path
function fsReadDirSync(context, _path) {
    const dirPath = path_1.default.join(context.projectPath, _path);
    return fs_extra_1.default.readdirSync(dirPath);
}
exports.fsReadDirSync = fsReadDirSync;
// env variables in this list will be only convert into .env.{env} when migrating {env}.userdata
const skipList = [
    "state.fx-resource-aad-app-for-teams.clientSecret",
    "state.fx-resource-bot.botPassword",
    "state.fx-resource-apim.apimClientAADClientSecret",
    "state.fx-resource-azure-sql.adminPassword",
];
exports.validDomain = {
    botWithValid: "{{state.teams-bot.validDomain}}",
    tab: "{{state.teams-tab.domain}}",
    bot: "{{state.teams-bot.domain}}",
};
// convert any obj names if can be converted (used in states and configs migration)
function jsonObjectNamesConvertV3(obj, prefix, parentKeyName, filetype, bicepContent) {
    let returnData = "";
    if (lodash_1.isObject(obj)) {
        for (const keyName of Object.keys(obj)) {
            returnData +=
                parentKeyName === ""
                    ? jsonObjectNamesConvertV3(obj[keyName], prefix, prefix + keyName, filetype, bicepContent)
                    : jsonObjectNamesConvertV3(obj[keyName], prefix, parentKeyName + "." + keyName, filetype, bicepContent);
        }
    }
    else if (!skipList.includes(parentKeyName)) {
        const res = MigrationUtils_1.namingConverterV3(parentKeyName, filetype, bicepContent);
        if (res.isOk()) {
            let stateValue = obj;
            if (typeof obj === "string" && obj.includes("#")) {
                stateValue = `"${obj}"`;
            }
            return res.value + "=" + stateValue.toString() + os_1.EOL;
        }
    }
    else
        return "";
    return returnData;
}
exports.jsonObjectNamesConvertV3 = jsonObjectNamesConvertV3;
async function getProjectVersion(ctx) {
    const projectPath = getParameterFromCxt(ctx, "projectPath", "");
    return await getProjectVersionFromPath(projectPath);
}
exports.getProjectVersion = getProjectVersion;
function migrationNotificationMessage(versionForMigration) {
    if (versionForMigration.platform === teamsfx_api_1.Platform.VS) {
        return localizeUtils_1.getLocalizedString("core.migrationV3.VS.Message");
    }
    const res = localizeUtils_1.getLocalizedString("core.migrationV3.Message");
    return res;
}
exports.migrationNotificationMessage = migrationNotificationMessage;
function outputCancelMessage(version, platform) {
    globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.warning(`Upgrade cancelled.`);
    if (platform === teamsfx_api_1.Platform.VSCode) {
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.warning(`Notice upgrade to new configuration files is a must-have to continue to use current version Teams Toolkit. Learn more at ${versionMetadata_1.MetadataV3.v3UpgradeWikiLink}.`);
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.warning(`If you want to upgrade, please run command (Teams: Upgrade project) or click the "Upgrade project" button on Teams Toolkit sidebar to trigger the upgrade.`);
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.warning(`If you are not ready to upgrade, please continue to use the old version Teams Toolkit ${versionMetadata_1.MetadataV2.platformVersion[platform]}.`);
    }
    else if (platform === teamsfx_api_1.Platform.VS) {
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.warning(`Notice upgrade to new configuration files is a must-have to continue to use current version Teams Toolkit. Learn more at ${versionMetadata_1.MetadataV3.v3UpgradeWikiLink}.`);
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.warning(`If you want to upgrade, please trigger this command again.`);
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.warning(`If you are not ready to upgrade, please continue to use the old version Teams Toolkit.`);
    }
    else {
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.warning(`Notice upgrade to new configuration files is a must-have to continue to use current version Teams Toolkit CLI. Learn more at ${versionMetadata_1.MetadataV3.v3UpgradeWikiLink}.`);
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.warning(`If you want to upgrade, please trigger this command again.`);
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.warning(`If you are not ready to upgrade, please continue to use the old version Teams Toolkit CLI ${versionMetadata_1.MetadataV2.platformVersion[platform]}.`);
    }
}
exports.outputCancelMessage = outputCancelMessage;
async function getProjectVersionFromPath(projectPath) {
    const v3path = projectSettingsLoader_1.getProjectSettingsPath(projectPath);
    if (await fs_extra_1.default.pathExists(v3path)) {
        const readSettingsResult = await settingsUtil_1.settingsUtil.readSettings(projectPath, false);
        if (readSettingsResult.isOk()) {
            return {
                version: readSettingsResult.value.version || "",
                source: versionMetadata_1.VersionSource.teamsapp,
            };
        }
        else {
            throw readSettingsResult.error;
        }
    }
    const v2path = projectSettingsLoader_1.getProjectSettingPathV2(projectPath);
    if (await fs_extra_1.default.pathExists(v2path)) {
        const settings = await fs_extra_1.default.readJson(v2path);
        return {
            version: settings.version || "",
            source: versionMetadata_1.VersionSource.projectSettings,
        };
    }
    const abandonedPath = path_1.default.resolve(projectPath, versionMetadata_1.MetadataV3Abandoned.configFolder, versionMetadata_1.MetadataV3Abandoned.configFile);
    if (await fs_extra_1.default.pathExists(abandonedPath)) {
        return {
            version: versionMetadata_1.MetadataV3Abandoned.configFolder,
            source: versionMetadata_1.VersionSource.settings,
        };
    }
    return {
        version: "",
        source: versionMetadata_1.VersionSource.unknown,
    };
}
exports.getProjectVersionFromPath = getProjectVersionFromPath;
async function getTrackingIdFromPath(projectPath) {
    const v3path = projectSettingsLoader_1.getProjectSettingsPath(projectPath);
    if (await fs_extra_1.default.pathExists(v3path)) {
        const readSettingsResult = await settingsUtil_1.settingsUtil.readSettings(projectPath, false);
        if (readSettingsResult.isOk()) {
            return readSettingsResult.value.trackingId;
        }
        else {
            return "";
        }
    }
    const v2path = projectSettingsLoader_1.getProjectSettingPathV2(projectPath);
    if (await fs_extra_1.default.pathExists(v2path)) {
        const settings = await fs_extra_1.default.readJson(v2path);
        if (settings.projectId) {
            return settings.projectId || "";
        }
    }
    return "";
}
exports.getTrackingIdFromPath = getTrackingIdFromPath;
function getVersionState(info) {
    if (info.source === versionMetadata_1.VersionSource.projectSettings &&
        semver_1.default.gte(info.version, versionMetadata_1.MetadataV2.projectVersion) &&
        semver_1.default.lte(info.version, versionMetadata_1.MetadataV2.projectMaxVersion)) {
        return versionMetadata_1.VersionState.upgradeable;
    }
    else if (info.source === versionMetadata_1.VersionSource.teamsapp &&
        semver_1.default.valid(info.version) &&
        semver_1.default.lt(info.version, versionMetadata_1.MetadataV3.unSupprotVersion)) {
        return versionMetadata_1.VersionState.compatible;
    }
    else if (info.source === versionMetadata_1.VersionSource.teamsapp && !semver_1.default.valid(info.version)) {
        return versionMetadata_1.VersionState.compatible;
    }
    return versionMetadata_1.VersionState.unsupported;
}
exports.getVersionState = getVersionState;
function getParameterFromCxt(ctx, key, defaultValue) {
    const inputs = ctx.arguments[ctx.arguments.length - 1];
    const value = inputs[key] || defaultValue || "";
    return value;
}
exports.getParameterFromCxt = getParameterFromCxt;
function getCapabilityStatus(projectSettings) {
    const capabilities = projectSettings.solutionSettings.capabilities;
    const tabSso = capabilities.includes("TabSSO");
    const botSso = capabilities.includes("BotSSO");
    const tab = capabilities.includes("Tab");
    return {
        TabSso: tabSso,
        BotSso: botSso,
        Tab: tab,
    };
}
exports.getCapabilityStatus = getCapabilityStatus;
function generateAppIdUri(capabilities) {
    if (capabilities.TabSso && !capabilities.BotSso) {
        return "api://{{state.fx-resource-frontend-hosting.domain}}/{{state.fx-resource-aad-app-for-teams.clientId}}";
    }
    else if (capabilities.TabSso && capabilities.BotSso) {
        return "api://{{state.fx-resource-frontend-hosting.domain}}/botid-{{state.fx-resource-bot.botId}}";
    }
    else if (!capabilities.TabSso && capabilities.BotSso) {
        return "api://botid-{{state.fx-resource-bot.botId}}";
    }
    else {
        return "api://{{state.fx-resource-aad-app-for-teams.clientId}}";
    }
}
exports.generateAppIdUri = generateAppIdUri;
function replaceAppIdUri(manifest, appIdUri) {
    const appIdUriRegex = /{{+ *state\.fx\-resource\-aad\-app\-for\-teams\.applicationIdUris *}}+/g;
    if (manifest.match(appIdUriRegex)) {
        manifest = manifest.replace(appIdUriRegex, appIdUri);
    }
    return manifest;
}
exports.replaceAppIdUri = replaceAppIdUri;
async function readAndConvertUserdata(context, filePath, bicepContent) {
    let returnAnswer = "";
    const userdataContent = await fs_extra_1.default.readFile(path_1.default.join(context.projectPath, filePath), "utf8");
    const secretes = dotenv.parse(userdataContent);
    for (const secreteKey of Object.keys(secretes)) {
        const res = MigrationUtils_1.namingConverterV3("state." + secreteKey, MigrationUtils_1.FileType.USERDATA, bicepContent);
        if (res.isOk())
            returnAnswer += `${res.value}=${secretes[secreteKey]}${os_1.EOL}`;
    }
    return returnAnswer;
}
exports.readAndConvertUserdata = readAndConvertUserdata;
async function updateAndSaveManifestForSpfx(context, manifest) {
    const remoteTemplatePath = path_1.default.join(teamsfx_api_1.AppPackageFolderName, versionMetadata_1.MetadataV3.teamsManifestFileName);
    const localTemplatePath = path_1.default.join(teamsfx_api_1.AppPackageFolderName, "manifest.local.json");
    const contentRegex = /\"\{\{\^config\.isLocalDebug\}\}.*\{\{\/config\.isLocalDebug\}\}\"/g;
    const remoteRegex = /\{\{\^config\.isLocalDebug\}\}.*\{\{\/config\.isLocalDebug\}\}\{/g;
    const localRegex = /\}\{\{\#config\.isLocalDebug\}\}.*\{\{\/config\.isLocalDebug\}\}/g;
    let remoteTemplate = manifest, localTemplate = manifest;
    // Replace contentUrls
    const placeholders = manifest.match(contentRegex);
    if (placeholders) {
        for (const placeholder of placeholders) {
            // Replace with local and remote url
            // Will only replace if one match found
            const remoteUrl = placeholder.match(remoteRegex);
            if (remoteUrl && remoteUrl.length == 1) {
                remoteTemplate = remoteTemplate.replace(placeholder, `"${remoteUrl[0].substring(24, remoteUrl[0].length - 25)}"`);
            }
            const localUrl = placeholder.match(localRegex);
            if (localUrl && localUrl.length == 1) {
                localTemplate = localTemplate.replace(placeholder, `"${localUrl[0].substring(25, localUrl[0].length - 24)}"`);
            }
        }
    }
    await context.fsWriteFile(remoteTemplatePath, remoteTemplate);
    await context.fsWriteFile(localTemplatePath, localTemplate);
}
exports.updateAndSaveManifestForSpfx = updateAndSaveManifestForSpfx;
function isValidDomainForBotOutputKey(bicepContent) {
    // Match teams-bot or fx-resource-bot output obj
    const pluginRegex = new RegExp("output +(\\S+) +object += +{" + // Mataches start of output declaration and capture output name. Example: output functionOutput object = {
        "[^{]*" + // Matches everything between '{' and plugin id declaration. For example: comments, extra properties. Will match multilines.
        "teamsFxPluginId: +'(teams-bot|fx-resource-bot)'" + // Matches given plugin id == teams-bot or fx-resource-bot
        "[^}]*" + // Mathches anything except '}'
        "(validDomain|domain) *:" + // Matches domain key and tries not to mismatch key and value
        "[^}]*}", // Matches until end of obj as '}'
    "g");
    const outputContents = pluginRegex.exec(bicepContent);
    if (outputContents && outputContents[3] === "validDomain") {
        return true;
    }
    else {
        return false;
    }
}
exports.isValidDomainForBotOutputKey = isValidDomainForBotOutputKey;
async function addMissingValidDomainForManifest(manifestPath, tab, bot, isValidDomain) {
    var _a, _b, _c, _d;
    const teamsAppManifest = (await ManifestUtils_1.manifestUtils._readAppManifest(manifestPath))._unsafeUnwrap();
    teamsAppManifest.validDomains = (_a = teamsAppManifest.validDomains) !== null && _a !== void 0 ? _a : [];
    const shouldAddTabDomain = tab && !((_b = teamsAppManifest.validDomains) === null || _b === void 0 ? void 0 : _b.includes(exports.validDomain.tab));
    if (shouldAddTabDomain) {
        teamsAppManifest.validDomains.push(exports.validDomain.tab);
    }
    const shouldAddBotDomain = bot &&
        !((_c = teamsAppManifest.validDomains) === null || _c === void 0 ? void 0 : _c.includes(exports.validDomain.bot)) &&
        !((_d = teamsAppManifest.validDomains) === null || _d === void 0 ? void 0 : _d.includes(exports.validDomain.botWithValid));
    if (shouldAddBotDomain) {
        teamsAppManifest.validDomains.push(isValidDomain ? exports.validDomain.botWithValid : exports.validDomain.bot);
    }
    await ManifestUtils_1.manifestUtils._writeAppManifest(teamsAppManifest, manifestPath);
}
exports.addMissingValidDomainForManifest = addMissingValidDomainForManifest;
function tryExtractEnvFromUserdata(filename) {
    const userdataRegex = new RegExp(`([a-zA-Z0-9_-]*)\\.${versionMetadata_1.MetadataV2.userdataSuffix}`, "g");
    const regRes = userdataRegex.exec(filename);
    if (regRes != null) {
        return regRes[1];
    }
    return "";
}
exports.tryExtractEnvFromUserdata = tryExtractEnvFromUserdata;
function buildFileName(...parts) {
    return parts.join(".");
}
function buildEnvFileName(envName) {
    return buildFileName(versionMetadata_1.MetadataV3.envFilePrefix, envName);
}
exports.buildEnvFileName = buildEnvFileName;
function buildEnvUserFileName(envName) {
    return buildFileName(versionMetadata_1.MetadataV3.envFilePrefix, envName, versionMetadata_1.MetadataV3.secretFileSuffix);
}
exports.buildEnvUserFileName = buildEnvUserFileName;
//# sourceMappingURL=v3MigrationUtils.js.map