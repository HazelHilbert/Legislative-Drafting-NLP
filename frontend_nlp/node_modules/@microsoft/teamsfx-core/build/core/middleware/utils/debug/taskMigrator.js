"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateGetFuncPathCommand = exports.migrateNgrokStartCommand = exports.migrateNgrokStartTask = exports.migratePreDebugCheck = exports.migrateValidateLocalPrerequisites = exports.migrateBackendStart = exports.migrateBackendWatch = exports.migrateBotStart = exports.migrateAuthStart = exports.migrateFrontendStart = exports.migrateBackendExtensionsInstall = exports.migrateValidateDependencies = exports.migrateInstallAppInTeams = exports.migratePrepareManifest = exports.migrateSetUpSSO = exports.migrateSetUpBot = exports.migrateSetUpTab = exports.migrateTransparentNpmInstall = exports.migrateTransparentLocalTunnel = exports.migrateTransparentPrerequisite = void 0;
const tslib_1 = require("tslib");
const comment_json_1 = require("comment-json");
const local_1 = require("../../../../common/local");
const debugV3MigrationUtils_1 = require("./debugV3MigrationUtils");
const crypto_1 = require("../../../crypto");
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const nodeChecker_1 = require("../../../../common/deps-checker/internal/nodeChecker");
async function migrateTransparentPrerequisite(context) {
    for (const task of context.tasks) {
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.checkPrerequisites)) {
            continue;
        }
        if (debugV3MigrationUtils_1.isCommentObject(task["args"]) && debugV3MigrationUtils_1.isCommentArray(task["args"]["prerequisites"])) {
            const newPrerequisites = [];
            const toolsArgs = {};
            for (const prerequisite of task["args"]["prerequisites"]) {
                if (prerequisite === local_1.Prerequisite.nodejs) {
                    newPrerequisites.push(`"${local_1.Prerequisite.nodejs}", // Validate if Node.js is installed.`);
                }
                else if (prerequisite === local_1.Prerequisite.m365Account) {
                    newPrerequisites.push(`"${local_1.Prerequisite.m365Account}", // Sign-in prompt for Microsoft 365 account, then validate if the account enables the sideloading permission.`);
                }
                else if (prerequisite === local_1.Prerequisite.portOccupancy) {
                    newPrerequisites.push(`"${local_1.Prerequisite.portOccupancy}", // Validate available ports to ensure those debug ones are not occupied.`);
                }
                else if (prerequisite === local_1.Prerequisite.func) {
                    toolsArgs.func = {
                        version: await getFuncVersion(),
                        symlinkDir: debugV3MigrationUtils_1.defaultFuncSymlinkDir,
                    };
                }
                else if (prerequisite === local_1.Prerequisite.devCert) {
                    toolsArgs.devCert = { trust: true };
                }
                else if (prerequisite === local_1.Prerequisite.dotnet) {
                    toolsArgs.dotnet = true;
                }
            }
            task["args"]["prerequisites"] = comment_json_1.parse(`[
        ${newPrerequisites.join("\n  ")}
      ]`);
            if (Object.keys(toolsArgs).length > 0) {
                if (!context.appYmlConfig.deploy) {
                    context.appYmlConfig.deploy = {};
                }
                context.appYmlConfig.deploy.tools = toolsArgs;
            }
        }
    }
}
exports.migrateTransparentPrerequisite = migrateTransparentPrerequisite;
function migrateTransparentLocalTunnel(context) {
    var _a;
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.startLocalTunnel)) {
            ++index;
            continue;
        }
        if (debugV3MigrationUtils_1.isCommentObject(task["args"])) {
            if (typeof task["args"]["ngrokArgs"] === "string") {
                const portNumber = getNgrokPort(task["args"]["ngrokArgs"]);
                if (portNumber) {
                    task["args"] = generateLocalTunnelTaskArgs(context, portNumber);
                    const comment = `{
            // Start the local tunnel service to forward public URL to local port and inspect traffic.
            // See https://aka.ms/teamsfx-tasks/local-tunnel for the detailed args definitions.
          }`;
                    const comments = task[Symbol.for("before:label")];
                    comments === null || comments === void 0 ? void 0 : comments.splice(0, (_a = comments === null || comments === void 0 ? void 0 : comments.length) !== null && _a !== void 0 ? _a : 0);
                    comment_json_1.assign(task, comment_json_1.parse(comment));
                    ++index;
                    continue;
                }
            }
        }
        const comment = `{
          // Teams Toolkit now uses Dev Tunnel as default tunnel solution.
          // See https://aka.ms/teamsfx-tasks/local-tunnel for more details.
          // If you still prefer to use ngrok, please refer to https://aka.ms/teamsfx-tasks/customize-tunnel-service to learn how to use your own tunnel service.
        }`;
        const newTask = comment_json_1.assign(comment_json_1.parse(comment), {
            label: task["label"],
            type: "shell",
            command: "echo 'Teams Toolkit now uses Dev Tunnel as default tunnel solution. For manual updates, see https://aka.ms/teamsfx-tasks/local-tunnel.' && exit 1",
            windows: {
                options: {
                    shell: {
                        executable: "cmd.exe",
                        args: ["/d", "/c"],
                    },
                },
            },
        });
        context.tasks.splice(index, 1, newTask);
        ++index;
    }
    return Promise.resolve();
}
exports.migrateTransparentLocalTunnel = migrateTransparentLocalTunnel;
function getNgrokPort(ngrokCommand) {
    var _a, _b;
    const regex = /http\s+(?<port>\d+)\s+--log=stdout\s+--log-format=logfmt\s?/gm;
    const match = regex.exec(ngrokCommand);
    if (!match) {
        return undefined;
    }
    const portNumber = Number.parseInt((_b = (_a = match.groups) === null || _a === void 0 ? void 0 : _a.port) !== null && _b !== void 0 ? _b : "");
    return Number.isInteger(portNumber) ? portNumber : undefined;
}
function migrateTransparentNpmInstall(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.npmInstall)) {
            ++index;
            continue;
        }
        if (debugV3MigrationUtils_1.isCommentObject(task["args"]) && debugV3MigrationUtils_1.isCommentArray(task["args"]["projects"])) {
            for (const npmArgs of task["args"]["projects"]) {
                if (!debugV3MigrationUtils_1.isCommentObject(npmArgs) || !(typeof npmArgs["cwd"] === "string")) {
                    continue;
                }
                const npmInstallArg = { args: "install" };
                npmInstallArg.workingDirectory = npmArgs["cwd"].replace("${workspaceFolder}", ".");
                if (typeof npmArgs["npmInstallArgs"] === "string") {
                    npmInstallArg.args = `install ${npmArgs["npmInstallArgs"]}`;
                }
                else if (debugV3MigrationUtils_1.isCommentArray(npmArgs["npmInstallArgs"]) &&
                    npmArgs["npmInstallArgs"].length > 0) {
                    npmInstallArg.args = `install ${npmArgs["npmInstallArgs"].join(" ")}`;
                }
                if (!context.appYmlConfig.deploy) {
                    context.appYmlConfig.deploy = {};
                }
                if (!context.appYmlConfig.deploy.npmCommands) {
                    context.appYmlConfig.deploy.npmCommands = [];
                }
                context.appYmlConfig.deploy.npmCommands.push(npmInstallArg);
            }
        }
        if (typeof task["label"] === "string") {
            // TODO: remove preLaunchTask in launch.json
            replaceInDependsOn(task["label"], context.tasks);
        }
        context.tasks.splice(index, 1);
    }
    return Promise.resolve();
}
exports.migrateTransparentNpmInstall = migrateTransparentNpmInstall;
function migrateSetUpTab(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.setUpTab)) {
            ++index;
            continue;
        }
        let url = new URL("https://localhost:53000");
        if (debugV3MigrationUtils_1.isCommentObject(task["args"]) && typeof task["args"]["baseUrl"] === "string") {
            try {
                url = new URL(task["args"]["baseUrl"]);
            }
            catch (_a) { }
        }
        if (!context.appYmlConfig.provision.configureApp) {
            context.appYmlConfig.provision.configureApp = {};
        }
        if (!context.appYmlConfig.provision.configureApp.tab) {
            context.appYmlConfig.provision.configureApp.tab = {};
        }
        context.appYmlConfig.provision.configureApp.tab.domain = url.host;
        context.appYmlConfig.provision.configureApp.tab.endpoint = url.origin;
        if (!context.appYmlConfig.deploy) {
            context.appYmlConfig.deploy = {};
        }
        if (!context.appYmlConfig.deploy.tab) {
            context.appYmlConfig.deploy.tab = {};
        }
        context.appYmlConfig.deploy.tab.port = parseInt(url.port);
        const label = task["label"];
        index = handleProvisionAndDeploy(context, index, label);
    }
    return Promise.resolve();
}
exports.migrateSetUpTab = migrateSetUpTab;
async function migrateSetUpBot(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.setUpBot)) {
            ++index;
            continue;
        }
        context.appYmlConfig.provision.bot = {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            messagingEndpoint: `$\{{${context.placeholderMapping.botEndpoint}}}/api/messages`,
        };
        if (!context.appYmlConfig.deploy) {
            context.appYmlConfig.deploy = {};
        }
        context.appYmlConfig.deploy.bot = true;
        const envs = {};
        if (debugV3MigrationUtils_1.isCommentObject(task["args"])) {
            if (task["args"]["botId"] && typeof task["args"]["botId"] === "string") {
                envs["BOT_ID"] = task["args"]["botId"];
            }
            if (task["args"]["botPassword"] && typeof task["args"]["botPassword"] === "string") {
                const envReferencePattern = /^\$\{env:(.*)\}$/;
                const matchResult = task["args"]["botPassword"].match(envReferencePattern);
                const botPassword = matchResult ? process.env[matchResult[1]] : task["args"]["botPassword"];
                if (botPassword) {
                    const cryptoProvider = new crypto_1.LocalCrypto(context.oldProjectSettings.projectId);
                    const result = cryptoProvider.encrypt(botPassword);
                    if (result.isOk()) {
                        envs["SECRET_BOT_PASSWORD"] = result.value;
                    }
                }
            }
            if (task["args"]["botMessagingEndpoint"] &&
                typeof task["args"]["botMessagingEndpoint"] === "string") {
                if (task["args"]["botMessagingEndpoint"].startsWith("http")) {
                    context.appYmlConfig.provision.bot.messagingEndpoint =
                        task["args"]["botMessagingEndpoint"];
                }
                else if (task["args"]["botMessagingEndpoint"].startsWith("/")) {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    context.appYmlConfig.provision.bot.messagingEndpoint = `$\{{${context.placeholderMapping.botEndpoint}}}${task["args"]["botMessagingEndpoint"]}`;
                }
            }
        }
        await debugV3MigrationUtils_1.updateLocalEnv(context.migrationContext, envs);
        const label = task["label"];
        index = handleProvisionAndDeploy(context, index, label);
    }
}
exports.migrateSetUpBot = migrateSetUpBot;
async function migrateSetUpSSO(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.setUpSSO)) {
            ++index;
            continue;
        }
        if (!context.appYmlConfig.provision.registerApp) {
            context.appYmlConfig.provision.registerApp = {};
        }
        context.appYmlConfig.provision.registerApp.aad = true;
        if (!context.appYmlConfig.provision.configureApp) {
            context.appYmlConfig.provision.configureApp = {};
        }
        context.appYmlConfig.provision.configureApp.aad = true;
        if (!context.appYmlConfig.deploy) {
            context.appYmlConfig.deploy = {};
        }
        context.appYmlConfig.deploy.sso = true;
        const envs = {};
        if (debugV3MigrationUtils_1.isCommentObject(task["args"])) {
            if (task["args"]["objectId"] && typeof task["args"]["objectId"] === "string") {
                envs["AAD_APP_OBJECT_ID"] = task["args"]["objectId"];
            }
            if (task["args"]["clientId"] && typeof task["args"]["clientId"] === "string") {
                envs["AAD_APP_CLIENT_ID"] = task["args"]["clientId"];
            }
            if (task["args"]["clientSecret"] && typeof task["args"]["clientSecret"] === "string") {
                const envReferencePattern = /^\$\{env:(.*)\}$/;
                const matchResult = task["args"]["clientSecret"].match(envReferencePattern);
                const clientSecret = matchResult
                    ? process.env[matchResult[1]]
                    : task["args"]["clientSecret"];
                if (clientSecret) {
                    const cryptoProvider = new crypto_1.LocalCrypto(context.oldProjectSettings.projectId);
                    const result = cryptoProvider.encrypt(clientSecret);
                    if (result.isOk()) {
                        envs["SECRET_AAD_APP_CLIENT_SECRET"] = result.value;
                    }
                }
            }
            if (task["args"]["accessAsUserScopeId"] &&
                typeof task["args"]["accessAsUserScopeId"] === "string") {
                envs["AAD_APP_ACCESS_AS_USER_PERMISSION_ID"] = task["args"]["accessAsUserScopeId"];
            }
        }
        await debugV3MigrationUtils_1.updateLocalEnv(context.migrationContext, envs);
        const label = task["label"];
        index = handleProvisionAndDeploy(context, index, label);
    }
}
exports.migrateSetUpSSO = migrateSetUpSSO;
function migratePrepareManifest(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === local_1.TaskCommand.prepareManifest)) {
            ++index;
            continue;
        }
        let appPackagePath = undefined;
        if (debugV3MigrationUtils_1.isCommentObject(task["args"]) && typeof task["args"]["appPackagePath"] === "string") {
            appPackagePath = task["args"]["appPackagePath"];
        }
        if (!appPackagePath) {
            if (!context.appYmlConfig.provision.registerApp) {
                context.appYmlConfig.provision.registerApp = {};
            }
            context.appYmlConfig.provision.registerApp.teamsApp = true;
        }
        if (!context.appYmlConfig.provision.configureApp) {
            context.appYmlConfig.provision.configureApp = {};
        }
        if (!context.appYmlConfig.provision.configureApp.teamsApp) {
            context.appYmlConfig.provision.configureApp.teamsApp = {};
        }
        context.appYmlConfig.provision.configureApp.teamsApp.appPackagePath = appPackagePath;
        const label = task["label"];
        index = handleProvisionAndDeploy(context, index, label);
    }
    return Promise.resolve();
}
exports.migratePrepareManifest = migratePrepareManifest;
function migrateInstallAppInTeams(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "shell") ||
            !(typeof task["command"] === "string") ||
            !task["command"].includes("${command:fx-extension.install-app-in-teams}")) {
            ++index;
            continue;
        }
        const label = task["label"];
        if (typeof label === "string") {
            replaceInDependsOn(label, context.tasks);
        }
        context.tasks.splice(index, 1);
    }
    return Promise.resolve();
}
exports.migrateInstallAppInTeams = migrateInstallAppInTeams;
async function migrateValidateDependencies(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "shell") ||
            !(typeof task["command"] === "string") ||
            !task["command"].includes("${command:fx-extension.validate-dependencies}")) {
            ++index;
            continue;
        }
        const newTask = generatePrerequisiteTask(task, context);
        context.tasks.splice(index, 1, newTask);
        ++index;
        const toolsArgs = {};
        if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeTab(context.oldProjectSettings)) {
            toolsArgs.devCert = {
                trust: true,
            };
            if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeSSO(context.oldProjectSettings)) {
                toolsArgs.dotnet = true;
            }
        }
        if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeFunction(context.oldProjectSettings)) {
            toolsArgs.func = {
                version: await getFuncVersion(),
                symlinkDir: debugV3MigrationUtils_1.defaultFuncSymlinkDir,
            };
            toolsArgs.dotnet = true;
        }
        if (Object.keys(toolsArgs).length > 0) {
            if (!context.appYmlConfig.deploy) {
                context.appYmlConfig.deploy = {};
            }
            context.appYmlConfig.deploy.tools = toolsArgs;
        }
    }
}
exports.migrateValidateDependencies = migrateValidateDependencies;
function migrateBackendExtensionsInstall(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "shell") ||
            !(typeof task["command"] === "string" &&
                task["command"].includes("${command:fx-extension.backend-extensions-install}"))) {
            ++index;
            continue;
        }
        if (!context.appYmlConfig.deploy) {
            context.appYmlConfig.deploy = {};
        }
        context.appYmlConfig.deploy.dotnetCommand = {
            args: "build extensions.csproj -o ./bin --ignore-failed-sources",
            workingDirectory: `${local_1.FolderName.Function}`,
            execPath: "${{DOTNET_PATH}}",
        };
        const label = task["label"];
        if (typeof label === "string") {
            replaceInDependsOn(label, context.tasks);
        }
        context.tasks.splice(index, 1);
    }
    return Promise.resolve();
}
exports.migrateBackendExtensionsInstall = migrateBackendExtensionsInstall;
function migrateFrontendStart(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (debugV3MigrationUtils_1.isCommentObject(task) &&
            ((typeof task["dependsOn"] === "string" && task["dependsOn"] === "teamsfx: frontend start") ||
                (debugV3MigrationUtils_1.isCommentArray(task["dependsOn"]) &&
                    task["dependsOn"].includes("teamsfx: frontend start")))) {
            const newLabel = debugV3MigrationUtils_1.generateLabel("Start frontend", getLabels(context.tasks));
            const newTask = debugV3MigrationUtils_1.startFrontendTask(newLabel);
            context.tasks.splice(index + 1, 0, newTask);
            replaceInDependsOn("teamsfx: frontend start", context.tasks, newLabel);
            if (!context.appYmlConfig.deploy) {
                context.appYmlConfig.deploy = {};
            }
            context.appYmlConfig.deploy.frontendStart = {
                sso: debugV3MigrationUtils_1.OldProjectSettingsHelper.includeSSO(context.oldProjectSettings),
                functionName: debugV3MigrationUtils_1.OldProjectSettingsHelper.getFunctionName(context.oldProjectSettings),
            };
            if (!context.appYmlConfig.deploy.npmCommands) {
                context.appYmlConfig.deploy.npmCommands = [];
            }
            const existing = context.appYmlConfig.deploy.npmCommands.find((value) => value.args === "install -D env-cmd");
            if (!existing) {
                context.appYmlConfig.deploy.npmCommands.push({
                    args: "install -D env-cmd",
                    workingDirectory: ".",
                });
            }
            break;
        }
        else {
            ++index;
        }
    }
    return Promise.resolve();
}
exports.migrateFrontendStart = migrateFrontendStart;
function migrateAuthStart(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (debugV3MigrationUtils_1.isCommentObject(task) &&
            ((typeof task["dependsOn"] === "string" && task["dependsOn"] === "teamsfx: auth start") ||
                (debugV3MigrationUtils_1.isCommentArray(task["dependsOn"]) && task["dependsOn"].includes("teamsfx: auth start")))) {
            const newLabel = debugV3MigrationUtils_1.generateLabel("Start auth", getLabels(context.tasks));
            const newTask = debugV3MigrationUtils_1.startAuthTask(newLabel);
            context.tasks.splice(index + 1, 0, newTask);
            replaceInDependsOn("teamsfx: auth start", context.tasks, newLabel);
            if (!context.appYmlConfig.deploy) {
                context.appYmlConfig.deploy = {};
            }
            context.appYmlConfig.deploy.authStart = {
                appsettingsPath: path.join(os.homedir(), ".fx", "localauth", "appsettings.Development.json"),
            };
            break;
        }
        else {
            ++index;
        }
    }
    return Promise.resolve();
}
exports.migrateAuthStart = migrateAuthStart;
function migrateBotStart(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (debugV3MigrationUtils_1.isCommentObject(task) &&
            ((typeof task["dependsOn"] === "string" && task["dependsOn"] === "teamsfx: bot start") ||
                (debugV3MigrationUtils_1.isCommentArray(task["dependsOn"]) && task["dependsOn"].includes("teamsfx: bot start")))) {
            const newLabel = debugV3MigrationUtils_1.generateLabel("Start bot", getLabels(context.tasks));
            const newTask = debugV3MigrationUtils_1.startBotTask(newLabel, context.oldProjectSettings.programmingLanguage);
            context.tasks.splice(index + 1, 0, newTask);
            replaceInDependsOn("teamsfx: bot start", context.tasks, newLabel);
            if (!context.appYmlConfig.deploy) {
                context.appYmlConfig.deploy = {};
            }
            context.appYmlConfig.deploy.botStart = {
                tab: debugV3MigrationUtils_1.OldProjectSettingsHelper.includeTab(context.oldProjectSettings),
                function: debugV3MigrationUtils_1.OldProjectSettingsHelper.includeFunction(context.oldProjectSettings),
                sso: debugV3MigrationUtils_1.OldProjectSettingsHelper.includeSSO(context.oldProjectSettings),
            };
            if (!context.appYmlConfig.deploy.npmCommands) {
                context.appYmlConfig.deploy.npmCommands = [];
            }
            const existing = context.appYmlConfig.deploy.npmCommands.find((value) => value.args === "install -D env-cmd");
            if (!existing) {
                context.appYmlConfig.deploy.npmCommands.push({
                    args: "install -D env-cmd",
                    workingDirectory: ".",
                });
            }
            break;
        }
        else {
            ++index;
        }
    }
    return Promise.resolve();
}
exports.migrateBotStart = migrateBotStart;
function migrateBackendWatch(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (debugV3MigrationUtils_1.isCommentObject(task) &&
            ((typeof task["dependsOn"] === "string" && task["dependsOn"] === "teamsfx: backend watch") ||
                (debugV3MigrationUtils_1.isCommentArray(task["dependsOn"]) && task["dependsOn"].includes("teamsfx: backend watch")))) {
            const newLabel = debugV3MigrationUtils_1.generateLabel("Watch backend", getLabels(context.tasks));
            const newTask = debugV3MigrationUtils_1.watchBackendTask(newLabel);
            context.tasks.splice(index + 1, 0, newTask);
            replaceInDependsOn("teamsfx: backend watch", context.tasks, newLabel);
            break;
        }
        else {
            ++index;
        }
    }
    return Promise.resolve();
}
exports.migrateBackendWatch = migrateBackendWatch;
function migrateBackendStart(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (debugV3MigrationUtils_1.isCommentObject(task) &&
            ((typeof task["dependsOn"] === "string" && task["dependsOn"] === "teamsfx: backend start") ||
                (debugV3MigrationUtils_1.isCommentArray(task["dependsOn"]) && task["dependsOn"].includes("teamsfx: backend start")))) {
            const newLabel = debugV3MigrationUtils_1.generateLabel("Start backend", getLabels(context.tasks));
            const newTask = debugV3MigrationUtils_1.startBackendTask(newLabel, context.oldProjectSettings.programmingLanguage);
            context.tasks.splice(index + 1, 0, newTask);
            replaceInDependsOn("teamsfx: backend start", context.tasks, newLabel);
            if (!context.appYmlConfig.deploy) {
                context.appYmlConfig.deploy = {};
            }
            context.appYmlConfig.deploy.backendStart = true;
            if (!context.appYmlConfig.deploy.npmCommands) {
                context.appYmlConfig.deploy.npmCommands = [];
            }
            const existing = context.appYmlConfig.deploy.npmCommands.find((value) => value.args === "install -D env-cmd");
            if (!existing) {
                context.appYmlConfig.deploy.npmCommands.push({
                    args: "install -D env-cmd",
                    workingDirectory: ".",
                });
            }
            break;
        }
        else {
            ++index;
        }
    }
    return Promise.resolve();
}
exports.migrateBackendStart = migrateBackendStart;
async function migrateValidateLocalPrerequisites(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "shell") ||
            !(typeof task["command"] === "string" &&
                task["command"].includes("${command:fx-extension.validate-local-prerequisites}"))) {
            ++index;
            continue;
        }
        const newTask = generatePrerequisiteTask(task, context);
        context.tasks.splice(index, 1, newTask);
        ++index;
        const toolsArgs = {};
        const npmCommands = [];
        let dotnetCommand;
        if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeTab(context.oldProjectSettings)) {
            toolsArgs.devCert = {
                trust: true,
            };
            npmCommands.push({
                args: `install ${local_1.defaultNpmInstallArg}`,
                workingDirectory: `${local_1.FolderName.Frontend}`,
            });
        }
        if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeFunction(context.oldProjectSettings)) {
            toolsArgs.func = {
                version: await getFuncVersion(),
                symlinkDir: debugV3MigrationUtils_1.defaultFuncSymlinkDir,
            };
            toolsArgs.dotnet = true;
            npmCommands.push({
                args: `install ${local_1.defaultNpmInstallArg}`,
                workingDirectory: `${local_1.FolderName.Function}`,
            });
            dotnetCommand = {
                args: "build extensions.csproj -o ./bin --ignore-failed-sources",
                workingDirectory: `${local_1.FolderName.Function}`,
                execPath: "${{DOTNET_PATH}}",
            };
        }
        if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeBot(context.oldProjectSettings)) {
            if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeFuncHostedBot(context.oldProjectSettings)) {
                toolsArgs.func = {
                    version: await getFuncVersion(),
                    symlinkDir: debugV3MigrationUtils_1.defaultFuncSymlinkDir,
                };
            }
            npmCommands.push({
                args: `install ${local_1.defaultNpmInstallArg}`,
                workingDirectory: `${local_1.FolderName.Bot}`,
            });
        }
        if (Object.keys(toolsArgs).length > 0 || npmCommands.length > 0 || dotnetCommand) {
            if (!context.appYmlConfig.deploy) {
                context.appYmlConfig.deploy = {};
            }
            if (Object.keys(toolsArgs).length > 0) {
                context.appYmlConfig.deploy.tools = toolsArgs;
            }
            if (npmCommands.length > 0) {
                context.appYmlConfig.deploy.npmCommands = npmCommands;
            }
            context.appYmlConfig.deploy.dotnetCommand = dotnetCommand;
        }
    }
}
exports.migrateValidateLocalPrerequisites = migrateValidateLocalPrerequisites;
function migratePreDebugCheck(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "shell") ||
            !(typeof task["command"] === "string" &&
                task["command"].includes("${command:fx-extension.pre-debug-check}"))) {
            ++index;
            continue;
        }
        if (!context.appYmlConfig.provision.registerApp) {
            context.appYmlConfig.provision.registerApp = {};
        }
        if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeSSO(context.oldProjectSettings)) {
            context.appYmlConfig.provision.registerApp.aad = true;
        }
        context.appYmlConfig.provision.registerApp.teamsApp = true;
        if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeBot(context.oldProjectSettings)) {
            context.appYmlConfig.provision.bot = {
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                messagingEndpoint: `$\{{${context.placeholderMapping.botEndpoint}}}/api/messages`,
            };
        }
        if (!context.appYmlConfig.provision.configureApp) {
            context.appYmlConfig.provision.configureApp = {};
        }
        if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeTab(context.oldProjectSettings)) {
            context.appYmlConfig.provision.configureApp.tab = {
                domain: "localhost:53000",
                endpoint: "https://localhost:53000",
            };
        }
        if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeSSO(context.oldProjectSettings)) {
            context.appYmlConfig.provision.configureApp.aad = true;
        }
        if (!context.appYmlConfig.provision.configureApp.teamsApp) {
            context.appYmlConfig.provision.configureApp.teamsApp = {};
        }
        const validateLocalPrerequisitesTask = context.tasks.find((_task) => debugV3MigrationUtils_1.isCommentObject(_task) &&
            _task["type"] === "shell" &&
            typeof _task["command"] === "string" &&
            _task["command"].includes("${command:fx-extension.validate-local-prerequisites}"));
        if (validateLocalPrerequisitesTask) {
            if (!context.appYmlConfig.deploy) {
                context.appYmlConfig.deploy = {};
            }
            if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeTab(context.oldProjectSettings)) {
                context.appYmlConfig.deploy.tab = {
                    port: 53000,
                };
            }
            if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeBot(context.oldProjectSettings)) {
                context.appYmlConfig.deploy.bot = true;
            }
            if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeSSO(context.oldProjectSettings)) {
                context.appYmlConfig.deploy.sso = true;
            }
        }
        const existingLabels = getLabels(context.tasks);
        const createResourcesLabel = debugV3MigrationUtils_1.generateLabel("Provision", existingLabels);
        const setUpLocalProjectsLabel = debugV3MigrationUtils_1.generateLabel("Deploy", existingLabels);
        task["dependsOn"] = new comment_json_1.CommentArray(createResourcesLabel, setUpLocalProjectsLabel);
        task["dependsOrder"] = "sequence";
        const createResources = debugV3MigrationUtils_1.createResourcesTask(createResourcesLabel);
        context.tasks.splice(index + 1, 0, createResources);
        const setUpLocalProjects = debugV3MigrationUtils_1.setUpLocalProjectsTask(setUpLocalProjectsLabel);
        context.tasks.splice(index + 2, 0, setUpLocalProjects);
        delete task["type"];
        delete task["command"];
        delete task["presentation"];
        break;
    }
    return Promise.resolve();
}
exports.migratePreDebugCheck = migratePreDebugCheck;
function migrateNgrokStartTask(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (debugV3MigrationUtils_1.isCommentObject(task) &&
            ((typeof task["dependsOn"] === "string" && task["dependsOn"] === "teamsfx: ngrok start") ||
                (debugV3MigrationUtils_1.isCommentArray(task["dependsOn"]) && task["dependsOn"].includes("teamsfx: ngrok start")))) {
            const newTask = generateLocalTunnelTask(context);
            context.tasks.splice(index + 1, 0, newTask);
            break;
        }
        else {
            ++index;
        }
    }
    replaceInDependsOn("teamsfx: ngrok start", context.tasks, local_1.TaskLabel.StartLocalTunnel);
    return Promise.resolve();
}
exports.migrateNgrokStartTask = migrateNgrokStartTask;
function migrateNgrokStartCommand(context) {
    let index = 0;
    while (index < context.tasks.length) {
        const task = context.tasks[index];
        if (!debugV3MigrationUtils_1.isCommentObject(task) ||
            !(task["type"] === "teamsfx") ||
            !(task["command"] === "ngrok start")) {
            ++index;
            continue;
        }
        const newTask = generateLocalTunnelTask(context, task);
        context.tasks.splice(index, 1, newTask);
        ++index;
    }
    return Promise.resolve();
}
exports.migrateNgrokStartCommand = migrateNgrokStartCommand;
function migrateGetFuncPathCommand(context) {
    const getFuncPathCommand = "${command:fx-extension.get-func-path}";
    const getFuncPathDelimiterCommand = "${command:fx-extension.get-path-delimiter}";
    for (const task of context.tasks) {
        if (!debugV3MigrationUtils_1.isCommentObject(task)) {
            continue;
        }
        const generateNewValue = (oldStr) => {
            const newStr = oldStr.startsWith(getFuncPathCommand)
                ? oldStr.replace(getFuncPathCommand, `\${workspaceFolder}/devTools/func${getFuncPathDelimiterCommand}`)
                : oldStr;
            return newStr.replace(/\${command:fx-extension.get-func-path}/g, `${getFuncPathDelimiterCommand}\${workspaceFolder}/devTools/func${getFuncPathDelimiterCommand}`);
        };
        if (debugV3MigrationUtils_1.isCommentObject(task["options"]) && debugV3MigrationUtils_1.isCommentObject(task["options"]["env"])) {
            for (const [key, value] of Object.entries(task["options"]["env"])) {
                if (typeof value === "string") {
                    task["options"]["env"][key] = generateNewValue(value);
                }
            }
        }
        const platforms = ["windows", "linux", "osx"];
        platforms.forEach((platform) => {
            if (debugV3MigrationUtils_1.isCommentObject(task[platform]) &&
                debugV3MigrationUtils_1.isCommentObject(task[platform]["options"]) &&
                debugV3MigrationUtils_1.isCommentObject(task[platform]["options"]["env"])) {
                const envObj = task[platform]["options"]["env"];
                for (const [key, value] of Object.entries(envObj)) {
                    if (typeof value === "string") {
                        envObj[key] = generateNewValue(value);
                    }
                }
            }
        });
    }
    return Promise.resolve();
}
exports.migrateGetFuncPathCommand = migrateGetFuncPathCommand;
function generatePrerequisiteTask(task, context) {
    const comment = `{
    // Check if all required prerequisites are installed and will install them if not.
    // See https://aka.ms/teamsfx-check-prerequisites-task to know the details and how to customize the args.
  }`;
    const newTask = comment_json_1.assign(comment_json_1.parse(comment), task);
    newTask["type"] = "teamsfx";
    newTask["command"] = "debug-check-prerequisites";
    const prerequisites = [
        `"${local_1.Prerequisite.nodejs}", // Validate if Node.js is installed.`,
        `"${local_1.Prerequisite.m365Account}", // Sign-in prompt for Microsoft 365 account, then validate if the account enables the sideloading permission.`,
        `"${local_1.Prerequisite.portOccupancy}", // Validate available ports to ensure those debug ones are not occupied.`,
    ];
    const prerequisitesComment = `
  [
    ${prerequisites.join("\n  ")}
  ]`;
    const ports = [];
    if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeTab(context.oldProjectSettings)) {
        ports.push(`${local_1.TaskDefaultValue.checkPrerequisites.ports.tabService}, // tab service port`);
    }
    if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeBot(context.oldProjectSettings)) {
        ports.push(`${local_1.TaskDefaultValue.checkPrerequisites.ports.botService}, // bot service port`);
        ports.push(`${local_1.TaskDefaultValue.checkPrerequisites.ports.botDebug}, // bot inspector port for Node.js debugger`);
    }
    if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeFunction(context.oldProjectSettings)) {
        ports.push(`${local_1.TaskDefaultValue.checkPrerequisites.ports.backendService}, // backend service port`);
        ports.push(`${local_1.TaskDefaultValue.checkPrerequisites.ports.backendDebug}, // backend inspector port for Node.js debugger`);
    }
    const portsComment = `
  [
    ${ports.join("\n  ")}
  ]
  `;
    const args = {
        prerequisites: comment_json_1.parse(prerequisitesComment),
        portOccupancy: comment_json_1.parse(portsComment),
    };
    newTask["args"] = args;
    return newTask;
}
function generateLocalTunnelTask(context, task) {
    const comment = `{
        // Start the local tunnel service to forward public URL to local port and inspect traffic.
        // See https://aka.ms/teamsfx-tasks/local-tunnel for the detailed args definitions.
    }`;
    const newTask = comment_json_1.assign(task !== null && task !== void 0 ? task : comment_json_1.parse(`{"label": "${local_1.TaskLabel.StartLocalTunnel}"}`), {
        type: "teamsfx",
        command: local_1.TaskCommand.startLocalTunnel,
        args: generateLocalTunnelTaskArgs(context),
        isBackground: true,
        problemMatcher: "$teamsfx-local-tunnel-watch",
    });
    return comment_json_1.assign(comment_json_1.parse(comment), newTask);
}
function generateLocalTunnelTaskArgs(context, portNumnber = local_1.TaskDefaultValue.startLocalTunnel.devTunnel.bot.port) {
    const placeholderComment = `
    {
      // Keep consistency with upgraded configuration.
    }
  `;
    return comment_json_1.assign(comment_json_1.parse("{}"), {
        type: local_1.TunnelType.devTunnel,
        ports: [
            {
                portNumber: portNumnber,
                protocol: local_1.TaskDefaultValue.startLocalTunnel.devTunnel.bot.protocol,
                access: local_1.TaskDefaultValue.startLocalTunnel.devTunnel.bot.access,
                writeToEnvironmentFile: comment_json_1.assign(comment_json_1.parse(placeholderComment), {
                    endpoint: context.placeholderMapping.botEndpoint,
                    domain: context.placeholderMapping.botDomain,
                }),
            },
        ],
        env: "local",
    });
}
function handleProvisionAndDeploy(context, index, label) {
    context.tasks.splice(index, 1);
    const existingLabels = getLabels(context.tasks);
    const generatedBefore = context.generatedLabels.find((value) => value.startsWith("Provision"));
    const createResourcesLabel = generatedBefore || debugV3MigrationUtils_1.generateLabel("Provision", existingLabels);
    const setUpLocalProjectsLabel = context.generatedLabels.find((value) => value.startsWith("Deploy")) ||
        debugV3MigrationUtils_1.generateLabel("Deploy", existingLabels);
    if (!generatedBefore) {
        context.generatedLabels.push(createResourcesLabel);
        const createResources = debugV3MigrationUtils_1.createResourcesTask(createResourcesLabel);
        context.tasks.splice(index, 0, createResources);
        ++index;
        context.generatedLabels.push(setUpLocalProjectsLabel);
        const setUpLocalProjects = debugV3MigrationUtils_1.setUpLocalProjectsTask(setUpLocalProjectsLabel);
        context.tasks.splice(index, 0, setUpLocalProjects);
        ++index;
    }
    replaceInDependsOn(label, context.tasks, createResourcesLabel, setUpLocalProjectsLabel);
    return index;
}
function replaceInDependsOn(label, tasks, ...replacements) {
    for (const task of tasks) {
        if (debugV3MigrationUtils_1.isCommentObject(task) && task["dependsOn"]) {
            if (typeof task["dependsOn"] === "string") {
                if (task["dependsOn"] === label) {
                    if (replacements.length > 0) {
                        task["dependsOn"] = new comment_json_1.CommentArray(...replacements);
                    }
                    else {
                        delete task["dependsOn"];
                    }
                }
            }
            else if (Array.isArray(task["dependsOn"])) {
                const index = task["dependsOn"].findIndex((value) => value === label);
                if (index !== -1) {
                    if (replacements.length > 0 && !task["dependsOn"].includes(replacements[0])) {
                        task["dependsOn"].splice(index, 1, ...replacements);
                    }
                    else {
                        task["dependsOn"].splice(index, 1);
                    }
                }
            }
        }
    }
}
function getLabels(tasks) {
    const labels = [];
    for (const task of tasks) {
        if (debugV3MigrationUtils_1.isCommentObject(task) && typeof task["label"] === "string") {
            labels.push(task["label"]);
        }
    }
    return labels;
}
async function getFuncVersion() {
    var _a;
    const nodeVersion = (_a = (await nodeChecker_1.NodeChecker.getInstalledNodeVersion())) === null || _a === void 0 ? void 0 : _a.majorVersion;
    return !nodeVersion || Number.parseInt(nodeVersion) >= 18 ? "~4.0.5174" : "4";
}
//# sourceMappingURL=taskMigrator.js.map