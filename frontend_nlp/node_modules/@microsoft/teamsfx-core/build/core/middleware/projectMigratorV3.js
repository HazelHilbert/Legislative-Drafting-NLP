"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateGitignore = exports.checkActiveResourcePlugins = exports.generateApimPluginEnvContent = exports.checkapimPluginExists = exports.debugMigration = exports.userdataMigration = exports.statesMigration = exports.configsMigration = exports.showNotification = exports.azureParameterMigration = exports.manifestsMigration = exports.updateLaunchJson = exports.generateAppYml = exports.checkVersionForMigration = exports.preMigration = exports.migrate = exports.rollbackMigration = exports.buildErrorMessage = exports.wrapRunMigration = exports.ProjectMigratorMWV3 = exports.subMigrations = exports.moreInfoButton = exports.errorNames = exports.learnMoreLink = void 0;
const tslib_1 = require("tslib");
/**
 * @author xzf0587 <zhaofengxu@microsoft.com>
 */
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const migrationContext_1 = require("./utils/migrationContext");
const path = tslib_1.__importStar(require("path"));
const projectSettingsLoader_1 = require("./projectSettingsLoader");
const telemetry_1 = require("../../common/telemetry");
const globalVars_1 = require("../globalVars");
const error_1 = require("../error");
const appYmlGenerator_1 = require("./utils/appYmlGenerator");
const fs = tslib_1.__importStar(require("fs-extra"));
const constants_1 = require("../../component/driver/teamsApp/constants");
const MigrationUtils_1 = require("./utils/MigrationUtils");
const v3MigrationUtils_1 = require("./utils/v3MigrationUtils");
const commentJson = tslib_1.__importStar(require("comment-json"));
const debugMigrationContext_1 = require("./utils/debug/debugMigrationContext");
const debugV3MigrationUtils_1 = require("./utils/debug/debugV3MigrationUtils");
const taskMigrator_1 = require("./utils/debug/taskMigrator");
const appLocalYmlGenerator_1 = require("./utils/debug/appLocalYmlGenerator");
const os_1 = require("os");
const folder_1 = require("../../folder");
const versionMetadata_1 = require("../../common/versionMetadata");
const tools_1 = require("../../common/tools");
const localizeUtils_1 = require("../../common/localizeUtils");
const constants_2 = require("./utils/debug/constants");
const ManifestUtils_1 = require("../../component/driver/teamsApp/utils/ManifestUtils");
const error_2 = require("../../error");
const Constants = {
    vscodeProvisionBicepPath: "./templates/azure/provision.bicep",
    launchJsonPath: ".vscode/launch.json",
    tasksJsonPath: ".vscode/tasks.json",
    reportName: "upgradeReport.md",
    envWriteOption: {
        // .env.{env} file might be already exist, use append mode (flag: a+)
        encoding: "utf8",
        flag: "a+",
    },
    envFilePrefix: ".env.",
};
const Parameters = {
    skipUserConfirm: "skipUserConfirm",
    isNonmodalMessage: "isNonmodalMessage",
    confirmOnly: "confirmOnly",
};
const TelemetryPropertyKey = {
    button: "button",
    mode: "mode",
    upgradeVersion: "upgrade-version",
    projectId: "project-id",
    reason: "reason",
};
const TelemetryPropertyValue = {
    ok: "ok",
    learnMore: "learn-more",
    cancel: "cancel",
    modal: "modal",
    nonmodal: "nonmodal",
    confirmOnly: "confirm-only",
    skipUserConfirm: "skip-user-confirm",
    upgradeVersion: "5.0",
};
exports.learnMoreLink = "https://aka.ms/teams-toolkit-5.0-upgrade";
// MigrationError provides learnMoreLink as helplink for user. Remember add related error message in learnMoreLink when adding new error.
exports.errorNames = {
    manifestTemplateNotExist: "ManifestTemplateNotExist",
    manifestTemplateInvalid: "ManifestTemplateInvalid",
    aadManifestTemplateNotExist: "AadManifestTemplateNotExist",
};
const upgradeButton = localizeUtils_1.getLocalizedString("core.option.upgrade");
exports.moreInfoButton = localizeUtils_1.getLocalizedString("core.option.moreInfo");
const migrationMessageButtons = [upgradeButton, exports.moreInfoButton];
const telemetryProperties = {
    [TelemetryPropertyKey.upgradeVersion]: TelemetryPropertyValue.upgradeVersion,
};
exports.subMigrations = [
    preMigration,
    manifestsMigration,
    generateAppYml,
    configsMigration,
    statesMigration,
    userdataMigration,
    generateApimPluginEnvContent,
    updateLaunchJson,
    azureParameterMigration,
    debugMigration,
    updateGitignore,
];
const ProjectMigratorMWV3 = async (ctx, next) => {
    await setTelemetryProjectId(ctx);
    const versionForMigration = await checkVersionForMigration(ctx);
    // abandoned v3 project which will not be supported. Show user the message to create new project.
    if (versionForMigration.source === versionMetadata_1.VersionSource.settings) {
        await (globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.ui.showMessage("warn", localizeUtils_1.getLocalizedString("core.migrationV3.abandonedProject"), true));
        ctx.result = teamsfx_api_1.err(error_1.AbandonedProjectError());
        return;
    }
    const projectPath = v3MigrationUtils_1.getParameterFromCxt(ctx, "projectPath", "");
    const isValid = await checkActiveResourcePlugins(projectPath);
    const isUpgradeable = isValid && versionForMigration.state === versionMetadata_1.VersionState.upgradeable;
    if (isUpgradeable) {
        // in cli non interactive scenario, migration will return an error instead of popup dialog.
        const nonInteractive = v3MigrationUtils_1.getParameterFromCxt(ctx, "nonInteractive");
        if (nonInteractive) {
            ctx.result = teamsfx_api_1.err(new error_1.NotAllowedMigrationError());
            return;
        }
        const isRunMigration = await showNotification(ctx, versionForMigration);
        if (isRunMigration) {
            const isNonmodalMessage = v3MigrationUtils_1.getParameterFromCxt(ctx, Parameters.isNonmodalMessage);
            if (isNonmodalMessage) {
                const versionForMigration = await checkVersionForMigration(ctx);
                if (versionForMigration.state !== versionMetadata_1.VersionState.upgradeable) {
                    ctx.result = teamsfx_api_1.ok(undefined);
                    return;
                }
            }
            const migrationContext = await migrationContext_1.MigrationContext.create(ctx);
            await wrapRunMigration(migrationContext, migrate);
            ctx.result = teamsfx_api_1.ok(undefined);
        }
        return;
    }
    else {
        // continue next step only when:
        // 1. no need to upgrade the project;
        // 2. no need to update Teams Toolkit version;
        await next();
    }
};
exports.ProjectMigratorMWV3 = ProjectMigratorMWV3;
async function wrapRunMigration(context, exec) {
    try {
        sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorMigrateStart);
        await exec(context);
        await showSummaryReport(context);
        sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorMigrate, context.telemetryProperties);
    }
    catch (error) {
        const errorMessage = buildErrorMessage(error, context.currentStep);
        const fxError = error_2.assembleError(error, telemetry_1.Component.core);
        fxError.message = errorMessage;
        sendTelemetryErrorEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorError, fxError, context.telemetryProperties);
        await rollbackMigration(context);
        throw error;
    }
    await context.removeFxV2();
}
exports.wrapRunMigration = wrapRunMigration;
function buildErrorMessage(error, step) {
    let message = error.message;
    if (error.code === "ENOENT" && error.path) {
        const fileName = path.basename(error.path);
        message = `Missing file: ${fileName}\n${message}`;
    }
    if (step) {
        message = `MigrationStep: ${step}\n${message}`;
    }
    return message;
}
exports.buildErrorMessage = buildErrorMessage;
async function rollbackMigration(context) {
    await context.cleanModifiedPaths();
    await context.restoreBackup();
    await context.cleanBackup();
}
exports.rollbackMigration = rollbackMigration;
async function showSummaryReport(context) {
    var _a, _b;
    const summaryPath = path.join(context.backupPath, Constants.reportName);
    const templatePath = path.join(folder_1.getTemplatesFolder(), "core/v3Migration", Constants.reportName);
    const content = await fs.readFile(templatePath);
    await fs.writeFile(summaryPath, content);
    await ((_b = (_a = globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.ui) === null || _a === void 0 ? void 0 : _a.openFile) === null || _b === void 0 ? void 0 : _b.call(_a, summaryPath));
}
async function migrate(context) {
    for (const subMigration of exports.subMigrations) {
        context.currentStep = subMigration.name;
        await subMigration(context);
    }
}
exports.migrate = migrate;
async function preMigration(context) {
    await context.backup(versionMetadata_1.MetadataV2.configFolder);
}
exports.preMigration = preMigration;
async function checkVersionForMigration(ctx) {
    const versionInfo = await v3MigrationUtils_1.getProjectVersion(ctx);
    const versionState = v3MigrationUtils_1.getVersionState(versionInfo);
    const platform = v3MigrationUtils_1.getParameterFromCxt(ctx, "platform", teamsfx_api_1.Platform.VSCode);
    return {
        currentVersion: versionInfo.version,
        source: versionInfo.source,
        state: versionState,
        platform: platform,
    };
}
exports.checkVersionForMigration = checkVersionForMigration;
async function generateAppYml(context) {
    var _a;
    const bicepContent = await v3MigrationUtils_1.readBicepContent(context);
    const oldProjectSettings = await loadProjectSettings(context.projectPath);
    const appYmlGenerator = new appYmlGenerator_1.AppYmlGenerator(oldProjectSettings, bicepContent, context.projectPath);
    const appYmlString = await appYmlGenerator.generateAppYml();
    await context.fsWriteFile(versionMetadata_1.MetadataV3.configFile, appYmlString);
    if (((_a = oldProjectSettings.programmingLanguage) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "csharp") {
        const placeholderMappings = await debugV3MigrationUtils_1.getPlaceholderMappings(context);
        const appLocalYmlString = await appYmlGenerator.generateAppLocalYml(placeholderMappings);
        await context.fsWriteFile(versionMetadata_1.MetadataV3.localConfigFile, appLocalYmlString);
    }
}
exports.generateAppYml = generateAppYml;
async function updateLaunchJson(context) {
    const launchJsonPath = path.join(context.projectPath, Constants.launchJsonPath);
    if (await fs.pathExists(launchJsonPath)) {
        await context.backup(Constants.launchJsonPath);
        let launchJsonContent = await fs.readFile(launchJsonPath, "utf8");
        const oldProjectSettings = await loadProjectSettings(context.projectPath);
        if (oldProjectSettings.isM365) {
            const jsonObject = JSON.parse(launchJsonContent);
            jsonObject.configurations.push(debugV3MigrationUtils_1.launchRemote(constants_2.HubName.teams, constants_2.LaunchBrowser.edge, "Edge", constants_2.LaunchUrl.teamsRemote, 1));
            jsonObject.configurations.push(debugV3MigrationUtils_1.launchRemote(constants_2.HubName.teams, constants_2.LaunchBrowser.chrome, "Chrome", constants_2.LaunchUrl.teamsRemote, 1));
            if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeTab(oldProjectSettings)) {
                jsonObject.configurations.push(debugV3MigrationUtils_1.launchRemote(constants_2.HubName.outlook, constants_2.LaunchBrowser.edge, "Edge", constants_2.LaunchUrl.outlookRemoteTab, 2));
                jsonObject.configurations.push(debugV3MigrationUtils_1.launchRemote(constants_2.HubName.outlook, constants_2.LaunchBrowser.chrome, "Chrome", constants_2.LaunchUrl.outlookRemoteTab, 2));
                jsonObject.configurations.push(debugV3MigrationUtils_1.launchRemote(constants_2.HubName.office, constants_2.LaunchBrowser.edge, "Edge", constants_2.LaunchUrl.officeRemoteTab, 3));
                jsonObject.configurations.push(debugV3MigrationUtils_1.launchRemote(constants_2.HubName.office, constants_2.LaunchBrowser.chrome, "Chrome", constants_2.LaunchUrl.officeRemoteTab, 3));
            }
            else if (debugV3MigrationUtils_1.OldProjectSettingsHelper.includeBot(oldProjectSettings)) {
                jsonObject.configurations.push(debugV3MigrationUtils_1.launchRemote(constants_2.HubName.outlook, constants_2.LaunchBrowser.edge, "Edge", constants_2.LaunchUrl.outlookRemoteBot, 2));
                jsonObject.configurations.push(debugV3MigrationUtils_1.launchRemote(constants_2.HubName.outlook, constants_2.LaunchBrowser.chrome, "Chrome", constants_2.LaunchUrl.outlookRemoteBot, 2));
            }
            launchJsonContent = JSON.stringify(jsonObject, null, 4);
        }
        const result = launchJsonContent
            .replace(/\${teamsAppId}/g, "${{TEAMS_APP_ID}}")
            .replace(/\${teamsAppInternalId}/g, "${{M365_APP_ID}}") // For M365 apps
            .replace(/\${localTeamsAppId}/g, "${{local:TEAMS_APP_ID}}")
            .replace(/\${localTeamsAppInternalId}/g, "${{local:M365_APP_ID}}"); // For M365 apps
        await context.fsWriteFile(Constants.launchJsonPath, result);
    }
}
exports.updateLaunchJson = updateLaunchJson;
async function loadProjectSettings(projectPath) {
    const oldProjectSettings = await projectSettingsLoader_1.loadProjectSettingsByProjectPathV2(projectPath);
    if (oldProjectSettings.isOk()) {
        return oldProjectSettings.value;
    }
    else {
        throw oldProjectSettings.error;
    }
}
async function manifestsMigration(context) {
    // Check manifest existing
    const oldAppPackageFolderPath = path.join(v3MigrationUtils_1.getTemplateFolderPath(context), teamsfx_api_1.AppPackageFolderName);
    const oldManifestPath = path.join(oldAppPackageFolderPath, constants_1.MANIFEST_TEMPLATE_CONSOLIDATE);
    const oldManifestAbsolutePath = path.join(context.projectPath, oldManifestPath);
    const oldManifestExists = await fs.pathExists(oldManifestAbsolutePath);
    if (!oldManifestExists) {
        // templates/appPackage/manifest.template.json does not exist
        throw error_1.MigrationError(new Error(localizeUtils_1.getLocalizedString("core.migrationV3.manifestNotExist")), exports.errorNames.manifestTemplateNotExist, exports.learnMoreLink);
    }
    // Validate manifest template
    {
        const res = await ManifestUtils_1.manifestUtils._readAppManifest(path.join(context.projectPath, oldManifestPath));
        if (res.isErr()) {
            throw error_1.MigrationError(new Error(localizeUtils_1.getLocalizedString("core.migrationV3.manifestInvalid")), exports.errorNames.manifestTemplateInvalid);
        }
    }
    // Backup templates/appPackage
    await context.backup(oldAppPackageFolderPath);
    // Read Bicep
    const bicepContent = await v3MigrationUtils_1.readBicepContent(context);
    if (v3MigrationUtils_1.isValidDomainForBotOutputKey(bicepContent)) {
        context.isBotValidDomain = true;
    }
    // Ensure appPackage
    await context.fsEnsureDir(teamsfx_api_1.AppPackageFolderName);
    // copy other files from old path to new except manifest.template.json and aad.template.json
    const oldAppPackageFiles = await fs.readdir(path.join(context.projectPath, oldAppPackageFolderPath));
    for (const file of oldAppPackageFiles) {
        if (file !== constants_1.MANIFEST_TEMPLATE_CONSOLIDATE && file !== versionMetadata_1.MetadataV2.aadTemplateFileName) {
            await context.fsCopy(path.join(oldAppPackageFolderPath, file), path.join(teamsfx_api_1.AppPackageFolderName, file));
        }
    }
    // Read capability project settings
    const projectSettings = await loadProjectSettings(context.projectPath);
    const capabilities = v3MigrationUtils_1.getCapabilityStatus(projectSettings);
    const appIdUri = v3MigrationUtils_1.generateAppIdUri(capabilities);
    const isSpfx = tools_1.isSPFxProject(projectSettings);
    if (!isSpfx) {
        await v3MigrationUtils_1.addMissingValidDomainForManifest(path.join(context.projectPath, oldManifestPath), capabilities.Tab, capabilities.BotSso, context.isBotValidDomain);
    }
    // Read Teams app manifest and save to templates/appPackage/manifest.json
    const manifestPath = path.join(teamsfx_api_1.AppPackageFolderName, versionMetadata_1.MetadataV3.teamsManifestFileName);
    let oldManifest = await fs.readFile(path.join(context.projectPath, oldManifestPath), "utf8");
    oldManifest = v3MigrationUtils_1.replaceAppIdUri(oldManifest, appIdUri);
    const manifest = MigrationUtils_1.replacePlaceholdersForV3(oldManifest, bicepContent);
    if (isSpfx) {
        await v3MigrationUtils_1.updateAndSaveManifestForSpfx(context, manifest);
    }
    else {
        await context.fsWriteFile(manifestPath, manifest);
    }
    // Read Microsoft Entra app manifest and save to ./aad.manifest.json
    const oldAadManifestPath = path.join(oldAppPackageFolderPath, versionMetadata_1.MetadataV2.aadTemplateFileName);
    const oldAadManifestExists = await fs.pathExists(path.join(context.projectPath, oldAadManifestPath));
    const activeResourcePlugins = projectSettings.solutionSettings.activeResourcePlugins;
    const component = projectSettings.components;
    const aadRequired = (activeResourcePlugins && activeResourcePlugins.includes("fx-resource-aad-app-for-teams")) ||
        (component &&
            component.findIndex((component, index, obj) => {
                return component.name == "aad-app";
            }) >= 0);
    if (oldAadManifestExists && aadRequired) {
        let oldAadManifest = await fs.readFile(path.join(context.projectPath, oldAadManifestPath), "utf-8");
        oldAadManifest = v3MigrationUtils_1.replaceAppIdUri(oldAadManifest, appIdUri);
        const aadManifest = MigrationUtils_1.replacePlaceholdersForV3(oldAadManifest, bicepContent);
        await context.fsWriteFile(versionMetadata_1.MetadataV3.aadManifestFileName, aadManifest);
    }
    else if (aadRequired && !oldAadManifestExists) {
        throw error_1.MigrationError(new Error(localizeUtils_1.getLocalizedString("core.migrationV3.aadManifestNotExist")), exports.errorNames.aadManifestTemplateNotExist, exports.learnMoreLink);
    }
    await context.fsRemove(oldAppPackageFolderPath);
}
exports.manifestsMigration = manifestsMigration;
async function azureParameterMigration(context) {
    // Ensure `.fx/configs` exists
    const configFolderPath = path.join(".fx", "configs");
    const configFolderPathExists = await context.fsPathExists(configFolderPath);
    if (!configFolderPathExists) {
        // Keep same practice now. Needs dicussion whether to throw error.
        return;
    }
    // Read Bicep
    const azureFolderPath = path.join(v3MigrationUtils_1.getTemplateFolderPath(context), "azure");
    const bicepContent = await v3MigrationUtils_1.readBicepContent(context);
    const fileNames = v3MigrationUtils_1.fsReadDirSync(context, configFolderPath);
    for (const fileName of fileNames) {
        if (!fileName.startsWith("azure.parameters.")) {
            continue;
        }
        const content = await fs.readFile(path.join(context.projectPath, configFolderPath, fileName), "utf-8");
        const newContent = MigrationUtils_1.replacePlaceholdersForV3(content, bicepContent);
        await context.fsWriteFile(path.join(azureFolderPath, fileName), newContent);
    }
}
exports.azureParameterMigration = azureParameterMigration;
async function showNotification(ctx, versionForMigration) {
    const isNonmodalMessage = v3MigrationUtils_1.getParameterFromCxt(ctx, Parameters.isNonmodalMessage);
    if (isNonmodalMessage) {
        return await showNonmodalNotification(ctx, versionForMigration);
    }
    const confirmOnly = v3MigrationUtils_1.getParameterFromCxt(ctx, Parameters.confirmOnly);
    if (confirmOnly) {
        return await showConfirmOnlyNotification(ctx);
    }
    const skipUserConfirm = v3MigrationUtils_1.getParameterFromCxt(ctx, Parameters.skipUserConfirm);
    if (skipUserConfirm) {
        sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorNotification, {
            [TelemetryPropertyKey.button]: TelemetryPropertyValue.ok,
            [TelemetryPropertyKey.mode]: TelemetryPropertyValue.skipUserConfirm,
        });
        return true;
    }
    return await askUserConfirm(ctx, versionForMigration);
}
exports.showNotification = showNotification;
async function askUserConfirm(ctx, versionForMigration) {
    sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorNotificationStart);
    let answer;
    do {
        answer = await popupMessageModal(versionForMigration);
        if (answer === exports.moreInfoButton) {
            globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.ui.openUrl(exports.learnMoreLink);
            sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorNotification, {
                [TelemetryPropertyKey.button]: TelemetryPropertyValue.learnMore,
                [TelemetryPropertyKey.mode]: TelemetryPropertyValue.modal,
            });
        }
    } while (answer === exports.moreInfoButton);
    if (!answer || !migrationMessageButtons.includes(answer)) {
        sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorNotification, {
            [TelemetryPropertyKey.button]: TelemetryPropertyValue.cancel,
            [TelemetryPropertyKey.mode]: TelemetryPropertyValue.modal,
        });
        ctx.result = teamsfx_api_1.err(error_1.UpgradeV3CanceledError());
        v3MigrationUtils_1.outputCancelMessage(versionForMigration.currentVersion, versionForMigration.platform);
        return false;
    }
    sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorNotification, {
        [TelemetryPropertyKey.button]: TelemetryPropertyValue.ok,
        [TelemetryPropertyKey.mode]: TelemetryPropertyValue.modal,
    });
    return true;
}
async function showNonmodalNotification(ctx, versionForMigration) {
    sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorNotificationStart);
    const answer = await popupMessageNonmodal(versionForMigration);
    if (answer === exports.moreInfoButton) {
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.ui.openUrl(exports.learnMoreLink);
        sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorNotification, {
            [TelemetryPropertyKey.button]: TelemetryPropertyValue.learnMore,
            [TelemetryPropertyKey.mode]: TelemetryPropertyValue.nonmodal,
        });
        return false;
    }
    else if (answer === upgradeButton) {
        sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorNotification, {
            [TelemetryPropertyKey.button]: TelemetryPropertyValue.ok,
            [TelemetryPropertyKey.mode]: TelemetryPropertyValue.nonmodal,
        });
        return true;
    }
    return false;
}
async function showConfirmOnlyNotification(ctx) {
    sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorNotificationStart);
    const res = await (globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.ui.showMessage("info", localizeUtils_1.getLocalizedString("core.migrationV3.confirmOnly.Message"), true, "OK"));
    if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "OK") {
        sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorNotification, {
            [TelemetryPropertyKey.button]: TelemetryPropertyValue.ok,
            [TelemetryPropertyKey.mode]: TelemetryPropertyValue.confirmOnly,
        });
        return true;
    }
    else {
        sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorNotification, {
            [TelemetryPropertyKey.button]: TelemetryPropertyValue.cancel,
            [TelemetryPropertyKey.mode]: TelemetryPropertyValue.confirmOnly,
        });
        return false;
    }
}
async function popupMessageModal(versionForMigration) {
    return await popupMessage(versionForMigration, true);
}
async function popupMessageNonmodal(versionForMigration) {
    return await popupMessage(versionForMigration, false);
}
async function popupMessage(versionForMigration, isModal) {
    const res = await (globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.ui.showMessage("warn", v3MigrationUtils_1.migrationNotificationMessage(versionForMigration), isModal, ...migrationMessageButtons));
    return (res === null || res === void 0 ? void 0 : res.isOk()) ? res.value : undefined;
}
async function setTelemetryProjectId(context) {
    const projectPath = v3MigrationUtils_1.getParameterFromCxt(context, "projectPath", "");
    try {
        const projectId = await v3MigrationUtils_1.getTrackingIdFromPath(projectPath);
        telemetryProperties[TelemetryPropertyKey.projectId] = projectId;
    }
    catch (error) {
        // do not set trackingId if error happens
    }
}
async function configsMigration(context) {
    // general
    if (await context.fsPathExists(path.join(".fx", "configs"))) {
        // if ./fx/states/ exists
        const fileNames = v3MigrationUtils_1.fsReadDirSync(context, path.join(".fx", "configs")); // search all files, get file names
        for (const fileName of fileNames)
            if (fileName.startsWith("config.")) {
                const fileRegex = new RegExp("(config\\.)([a-zA-Z0-9_-]*)(\\.json)$", "g"); // config.*.json
                const fileNamesArray = fileRegex.exec(fileName);
                if (fileNamesArray != null) {
                    // get envName
                    const envName = fileNamesArray[2];
                    // create .env.{env} file if not exist
                    await context.fsEnsureDir(versionMetadata_1.MetadataV3.defaultEnvironmentFolder);
                    if (!(await context.fsPathExists(path.join(versionMetadata_1.MetadataV3.defaultEnvironmentFolder, Constants.envFilePrefix + envName)))) {
                        // create env file
                        await context.fsCreateFile(path.join(versionMetadata_1.MetadataV3.defaultEnvironmentFolder, Constants.envFilePrefix + envName));
                        // add first line of comment
                        await context.fsWriteFile(path.join(versionMetadata_1.MetadataV3.defaultEnvironmentFolder, Constants.envFilePrefix + envName), envName === "local" ? versionMetadata_1.MetadataV3.envFileLocalComment : versionMetadata_1.MetadataV3.envFileDevComment, Constants.envWriteOption);
                    }
                    const obj = await v3MigrationUtils_1.readJsonFile(context, path.join(".fx", "configs", "config." + envName + ".json"));
                    if (obj["manifest"]) {
                        const bicepContent = await v3MigrationUtils_1.readBicepContent(context);
                        const teamsfx_env = fs
                            .readFileSync(path.join(context.projectPath, versionMetadata_1.MetadataV3.defaultEnvironmentFolder, Constants.envFilePrefix + envName))
                            .toString()
                            .includes("TEAMSFX_ENV=")
                            ? ""
                            : "TEAMSFX_ENV=" + envName + os_1.EOL + "APP_NAME_SUFFIX=" + envName + os_1.EOL;
                        // convert every name and add the env name at the first line
                        const envData = teamsfx_env +
                            v3MigrationUtils_1.jsonObjectNamesConvertV3(obj["manifest"], "manifest.", "", MigrationUtils_1.FileType.CONFIG, bicepContent);
                        await context.fsWriteFile(path.join(versionMetadata_1.MetadataV3.defaultEnvironmentFolder, Constants.envFilePrefix + envName), envData, Constants.envWriteOption);
                    }
                }
            }
    }
}
exports.configsMigration = configsMigration;
async function statesMigration(context) {
    // general
    if (await context.fsPathExists(path.join(".fx", "states"))) {
        // if ./fx/states/ exists
        const fileNames = v3MigrationUtils_1.fsReadDirSync(context, path.join(".fx", "states")); // search all files, get file names
        for (const fileName of fileNames)
            if (fileName.startsWith("state.")) {
                const fileRegex = new RegExp("(state\\.)([a-zA-Z0-9_-]*)(\\.json)$", "g"); // state.*.json
                const fileNamesArray = fileRegex.exec(fileName);
                if (fileNamesArray != null) {
                    // get envName
                    const envName = fileNamesArray[2];
                    // create .env.{env} file if not exist
                    await context.fsEnsureDir(versionMetadata_1.MetadataV3.defaultEnvironmentFolder);
                    if (!(await context.fsPathExists(path.join(versionMetadata_1.MetadataV3.defaultEnvironmentFolder, Constants.envFilePrefix + envName)))) {
                        // create env file
                        await context.fsCreateFile(path.join(versionMetadata_1.MetadataV3.defaultEnvironmentFolder, Constants.envFilePrefix + envName));
                        // add first line of comment
                        await context.fsWriteFile(path.join(versionMetadata_1.MetadataV3.defaultEnvironmentFolder, Constants.envFilePrefix + envName), envName === "local" ? versionMetadata_1.MetadataV3.envFileLocalComment : versionMetadata_1.MetadataV3.envFileDevComment, Constants.envWriteOption);
                    }
                    const obj = await v3MigrationUtils_1.readJsonFile(context, path.join(".fx", "states", "state." + envName + ".json"));
                    if (obj) {
                        const bicepContent = await v3MigrationUtils_1.readBicepContent(context);
                        // convert every name
                        const envData = v3MigrationUtils_1.jsonObjectNamesConvertV3(obj, "state.", "", MigrationUtils_1.FileType.STATE, bicepContent);
                        await context.fsWriteFile(path.join(versionMetadata_1.MetadataV3.defaultEnvironmentFolder, Constants.envFilePrefix + envName), envData, Constants.envWriteOption);
                    }
                }
            }
    }
}
exports.statesMigration = statesMigration;
async function userdataMigration(context) {
    const stateFolder = path.join(versionMetadata_1.MetadataV2.configFolder, versionMetadata_1.MetadataV2.stateFolder);
    if (!(await context.fsPathExists(stateFolder))) {
        return;
    }
    await context.fsEnsureDir(versionMetadata_1.MetadataV3.defaultEnvironmentFolder);
    const stateFiles = v3MigrationUtils_1.fsReadDirSync(context, stateFolder); // search all files, get file names
    for (const stateFile of stateFiles) {
        const envName = v3MigrationUtils_1.tryExtractEnvFromUserdata(stateFile);
        if (envName) {
            // get envName
            const envFileName = v3MigrationUtils_1.buildEnvUserFileName(envName);
            const bicepContent = await v3MigrationUtils_1.readBicepContent(context);
            const envData = versionMetadata_1.MetadataV3.secretFileComment +
                os_1.EOL +
                versionMetadata_1.MetadataV3.secretComment +
                (await v3MigrationUtils_1.readAndConvertUserdata(context, path.join(stateFolder, stateFile), bicepContent));
            await context.fsWriteFile(path.join(versionMetadata_1.MetadataV3.defaultEnvironmentFolder, envFileName), envData, Constants.envWriteOption);
        }
    }
}
exports.userdataMigration = userdataMigration;
async function debugMigration(context) {
    // Backup vscode/tasks.json
    await context.backup(Constants.tasksJsonPath);
    // Read .vscode/tasks.json
    const tasksJsonContent = await debugV3MigrationUtils_1.readJsonCommentFile(path.join(context.projectPath, Constants.tasksJsonPath));
    if (!debugV3MigrationUtils_1.isCommentObject(tasksJsonContent) || !Array.isArray(tasksJsonContent["tasks"])) {
        // Invalid tasks.json content
        return;
    }
    // Migrate .vscode/tasks.json
    const migrateTaskFuncs = [
        taskMigrator_1.migrateTransparentPrerequisite,
        taskMigrator_1.migrateTransparentNpmInstall,
        taskMigrator_1.migrateTransparentLocalTunnel,
        taskMigrator_1.migrateSetUpTab,
        taskMigrator_1.migrateSetUpBot,
        taskMigrator_1.migrateSetUpSSO,
        taskMigrator_1.migratePrepareManifest,
        taskMigrator_1.migrateInstallAppInTeams,
        taskMigrator_1.migrateValidateDependencies,
        taskMigrator_1.migrateBackendExtensionsInstall,
        taskMigrator_1.migrateFrontendStart,
        taskMigrator_1.migrateAuthStart,
        taskMigrator_1.migrateBotStart,
        taskMigrator_1.migrateBackendWatch,
        taskMigrator_1.migrateBackendStart,
        taskMigrator_1.migratePreDebugCheck,
        taskMigrator_1.migrateValidateLocalPrerequisites,
        taskMigrator_1.migrateNgrokStartTask,
        taskMigrator_1.migrateNgrokStartCommand,
        taskMigrator_1.migrateGetFuncPathCommand,
    ];
    const oldProjectSettings = await loadProjectSettings(context.projectPath);
    const placeholderMappings = await debugV3MigrationUtils_1.getPlaceholderMappings(context);
    const debugContext = new debugMigrationContext_1.DebugMigrationContext(context, tasksJsonContent["tasks"], oldProjectSettings, placeholderMappings);
    for (const func of migrateTaskFuncs) {
        await func(debugContext);
    }
    // Write .vscode/tasks.json
    await context.fsWriteFile(Constants.tasksJsonPath, commentJson.stringify(tasksJsonContent, null, 4));
    // Generate app.local.yml
    const appYmlGenerator = new appLocalYmlGenerator_1.AppLocalYmlGenerator(oldProjectSettings, debugContext.appYmlConfig, placeholderMappings);
    const appYmlString = await appYmlGenerator.generateAppYml();
    await context.fsWriteFile(versionMetadata_1.MetadataV3.localConfigFile, appYmlString);
}
exports.debugMigration = debugMigration;
function checkapimPluginExists(pjSettings) {
    if (pjSettings && pjSettings["components"]) {
        for (const obj of pjSettings["components"])
            if (Object.keys(obj).includes("name") && obj["name"] === "apim")
                return true;
        return false;
    }
    else {
        return false;
    }
}
exports.checkapimPluginExists = checkapimPluginExists;
async function generateApimPluginEnvContent(context) {
    // general
    if (await context.fsPathExists(path.join(".fx", "configs", "projectSettings.json"))) {
        const projectSettingsContent = fs.readJsonSync(path.join(context.projectPath, ".fx", "configs", "projectSettings.json"));
        // judge if apim plugin exists
        if (checkapimPluginExists(projectSettingsContent)) {
            const fileNames = v3MigrationUtils_1.fsReadDirSync(context, path.join(".fx", "configs"));
            for (const fileName of fileNames)
                if (fileName.startsWith("config.")) {
                    const fileRegex = new RegExp("(config.)([a-zA-Z0-9_-]*)(.json)$", "g"); // config.*.json
                    const fileNamesArray = fileRegex.exec(fileName);
                    if (fileNamesArray != null) {
                        // get envName
                        const envName = fileNamesArray[2];
                        if (envName != "local") {
                            await context.fsEnsureDir(versionMetadata_1.MetadataV3.defaultEnvironmentFolder);
                            if (!(await context.fsPathExists(path.join(versionMetadata_1.MetadataV3.defaultEnvironmentFolder, Constants.envFilePrefix + envName))))
                                await context.fsCreateFile(path.join(versionMetadata_1.MetadataV3.defaultEnvironmentFolder, Constants.envFilePrefix + envName));
                            const apimPluginAppendContent = "APIM__PUBLISHEREMAIL= # Teams Toolkit does not record your mail to protect your privacy, please fill your mail address here before provision to avoid failures" +
                                os_1.EOL +
                                "APIM__PUBLISHERNAME= # Teams Toolkit does not record your name to protect your privacy, please fill your name here before provision to avoid failures" +
                                os_1.EOL;
                            await context.fsWriteFile(path.join(versionMetadata_1.MetadataV3.defaultEnvironmentFolder, Constants.envFilePrefix + envName), apimPluginAppendContent, Constants.envWriteOption);
                        }
                    }
                }
        }
    }
}
exports.generateApimPluginEnvContent = generateApimPluginEnvContent;
async function checkActiveResourcePlugins(projectPath) {
    try {
        const projectSettings = await loadProjectSettings(projectPath);
        const solutionSettings = projectSettings.solutionSettings;
        if (projectSettings && solutionSettings && solutionSettings.activeResourcePlugins) {
            return true;
        }
        else {
            sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorPrecheckFailed, {
                [TelemetryPropertyKey.reason]: "solutionSettings invalid",
            });
            return false;
        }
    }
    catch (error) {
        sendTelemetryEventForUpgrade(telemetry_1.Component.core, telemetry_1.TelemetryEvent.ProjectMigratorPrecheckFailed, {
            [TelemetryPropertyKey.reason]: error.message,
        });
        return false;
    }
}
exports.checkActiveResourcePlugins = checkActiveResourcePlugins;
async function updateGitignore(context) {
    const gitignoreFile = ".gitignore";
    const ignoreFileExist = await context.backup(gitignoreFile);
    if (!ignoreFileExist) {
        await context.fsCreateFile(gitignoreFile);
    }
    let ignoreFileContent = await fs.readFile(path.join(context.projectPath, gitignoreFile), "utf8");
    ignoreFileContent += os_1.EOL + `${versionMetadata_1.MetadataV3.defaultEnvironmentFolder}/${v3MigrationUtils_1.buildEnvUserFileName("*")}`;
    ignoreFileContent += os_1.EOL + `${versionMetadata_1.MetadataV3.defaultEnvironmentFolder}/${v3MigrationUtils_1.buildEnvFileName("local")}`;
    ignoreFileContent += os_1.EOL + `${migrationContext_1.backupFolder}/*`;
    ignoreFileContent += os_1.EOL + debugV3MigrationUtils_1.ignoreDevToolsDir;
    await context.fsWriteFile(gitignoreFile, ignoreFileContent);
}
exports.updateGitignore = updateGitignore;
function sendTelemetryEventForUpgrade(component, eventName, properties, measurements) {
    const mergedProperties = Object.assign(Object.assign({}, properties), telemetryProperties);
    telemetry_1.sendTelemetryEvent(component, eventName, mergedProperties, measurements);
}
function sendTelemetryErrorEventForUpgrade(component, eventName, fxError, properties) {
    const mergedProperties = Object.assign(Object.assign({}, properties), telemetryProperties);
    telemetry_1.sendTelemetryErrorEvent(component, eventName, fxError, mergedProperties);
}
//# sourceMappingURL=projectMigratorV3.js.map