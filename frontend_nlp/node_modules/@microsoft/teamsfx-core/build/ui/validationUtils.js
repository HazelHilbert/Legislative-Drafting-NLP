"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.validate = exports.getValidationFunction = exports.validationUtils = void 0;
const tslib_1 = require("tslib");
const common_1 = require("../error/common");
const jsonschema = tslib_1.__importStar(require("jsonschema"));
class ValidationUtils {
    async validateInputForSingleSelectQuestion(question, value, inputs) {
        let options = question.staticOptions;
        if (question.dynamicOptions) {
            options = await question.dynamicOptions(inputs);
        }
        return this.isAllowedValue(question.name, value, options, question.returnObject);
    }
    async validateInputForMultipleSelectQuestion(question, value, inputs) {
        let options = question.staticOptions;
        if (question.dynamicOptions) {
            options = await question.dynamicOptions(inputs);
        }
        for (const item of value) {
            const error = this.isAllowedValue(question.name, item, options, question.returnObject);
            if (error)
                return error;
        }
        return undefined;
    }
    formatInvalidInputError(key, value, options) {
        return `Invalid input '${key}':${JSON.stringify(value)}, allowed value: ${JSON.stringify(options)}`;
    }
    formatInvalidOptionsError(options) {
        return `Invalid question, expect input object, but allowed value: ${JSON.stringify(options)}`;
    }
    isAllowedValue(key, value, options, returnObject) {
        if (options.length === 0) {
            return new common_1.EmptyOptionError(key, "validationUtils").message;
        }
        const optionIsStringArray = typeof options[0] === "string";
        if (returnObject) {
            if (optionIsStringArray) {
                return this.formatInvalidOptionsError(options);
            }
            if (!value || typeof value === "string") {
                return this.formatInvalidInputError(key, value, options);
            }
            if (!options.find((item) => item.id === value.id)) {
                return this.formatInvalidInputError(key, value, options);
            }
        }
        else {
            if (!value || typeof value !== "string") {
                return this.formatInvalidInputError(key, value, options);
            }
            // value is string here
            const foundOption = optionIsStringArray
                ? options.find((item) => item === value)
                : options.find((item) => item.id === value);
            if (!foundOption) {
                return this.formatInvalidInputError(key, value, options);
            }
        }
    }
    /**
     * validate value against question model definition
     */
    async validateInputs(question, value, inputs) {
        if (question.type === "singleSelect") {
            if (question.skipValidation)
                return undefined;
            return await this.validateInputForSingleSelectQuestion(question, value, inputs);
        }
        else if (question.type === "multiSelect") {
            if (question.skipValidation)
                return undefined;
            return await this.validateInputForMultipleSelectQuestion(question, value, inputs);
        }
        else {
            if (question.validation) {
                const vFunc = getValidationFunction(question.validation, inputs);
                const res = await vFunc(value);
                if (res)
                    return res;
            }
            if (question.type === "text" && question.additionalValidationOnAccept) {
                const vFunc = getValidationFunction(question.additionalValidationOnAccept, inputs);
                const res = await vFunc(value);
                if (res)
                    return res;
            }
            return undefined;
        }
    }
}
exports.validationUtils = new ValidationUtils();
/**
 * A function to return a validation function according the validation schema
 * @param validation validation schema
 * @param inputs object to carry all user inputs
 * @returns a validation function
 */
function getValidationFunction(validation, inputs) {
    return function (input) {
        return validate(validation, input, inputs);
    };
}
exports.getValidationFunction = getValidationFunction;
/**
 * Implementation of validation function
 * @param validSchema validation schema
 * @param value value to validate
 * @param inputs user inputs object, which works as the context of the validation
 * @returns A human-readable string which is presented as diagnostic message.
 * Return `undefined` when 'value' is valid.
 */
async function validate(validSchema, value, inputs) {
    {
        //FuncValidation
        const funcValidation = validSchema;
        if (funcValidation.validFunc) {
            const res = await funcValidation.validFunc(value, inputs);
            return res;
        }
        else if (typeof funcValidation === "function") {
            const res = await funcValidation(inputs);
            if (res)
                return undefined;
            return "condition function is not met.";
        }
    }
    if (!value) {
        if (validSchema.required === true)
            return `input value is required.`;
    }
    const noneEmptyKeyNum = Object.keys(validSchema).filter((key) => validSchema[key] !== undefined).length;
    if (noneEmptyKeyNum === 0) {
        return undefined;
    }
    if (value === undefined &&
        (validSchema.required ||
            validSchema.equals ||
            validSchema.maxLength ||
            validSchema.minLength ||
            validSchema.pattern ||
            validSchema.enum ||
            validSchema.startsWith ||
            validSchema.endsWith ||
            validSchema.includes ||
            validSchema.maxItems ||
            validSchema.minItems ||
            validSchema.uniqueItems ||
            validSchema.contains ||
            validSchema.containsAll ||
            validSchema.containsAny)) {
        return `'undefined' does not meet condition:'${JSON.stringify(validSchema)}'`;
    }
    const jsonValue = JSON.stringify(value);
    {
        // StringValidation
        const stringValidation = validSchema;
        const strToValidate = value;
        if (strToValidate === undefined || typeof strToValidate === "string") {
            const schema = {};
            if (stringValidation.equals && typeof stringValidation.equals === "string") {
                if (strToValidate === undefined) {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    return `${jsonValue} does not meet equals:'${stringValidation.equals}'`;
                }
                schema.const = stringValidation.equals;
            }
            if (stringValidation.enum &&
                stringValidation.enum.length > 0 &&
                typeof stringValidation.enum[0] === "string")
                schema.enum = stringValidation.enum;
            if (stringValidation.minLength)
                schema.minLength = stringValidation.minLength;
            if (stringValidation.maxLength)
                schema.maxLength = stringValidation.maxLength;
            if (stringValidation.pattern)
                schema.pattern = stringValidation.pattern;
            if (Object.keys(schema).length > 0) {
                const validateResult = jsonschema.validate(strToValidate, schema);
                if (validateResult.errors && validateResult.errors.length > 0) {
                    return `${jsonValue} ${validateResult.errors[0].message}`;
                }
            }
            if (stringValidation.startsWith) {
                if (!strToValidate.startsWith(stringValidation.startsWith)) {
                    return `${jsonValue} does not meet startsWith:'${stringValidation.startsWith}'`;
                }
            }
            if (stringValidation.endsWith) {
                if (!strToValidate.endsWith(stringValidation.endsWith)) {
                    return `${jsonValue} does not meet endsWith:'${stringValidation.endsWith}'`;
                }
            }
            if (stringValidation.includes) {
                if (!strToValidate.includes(stringValidation.includes)) {
                    return `${jsonValue} does not meet includes:'${stringValidation.includes}'`;
                }
            }
            if (stringValidation.notEquals) {
                if (strToValidate === stringValidation.notEquals) {
                    return `${jsonValue} does not meet notEquals:'${stringValidation.notEquals}'`;
                }
            }
            if (stringValidation.excludesEnum) {
                if (stringValidation.excludesEnum.includes(strToValidate)) {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    return `${jsonValue} does not meet excludesEnum:'${stringValidation.excludesEnum}'`;
                }
            }
        }
    }
    //StringArrayValidation
    {
        const stringArrayValidation = validSchema;
        const arrayToValidate = value;
        if (arrayToValidate === undefined || arrayToValidate instanceof Array) {
            const schema = {};
            if (stringArrayValidation.maxItems)
                schema.maxItems = stringArrayValidation.maxItems;
            if (stringArrayValidation.minItems)
                schema.minItems = stringArrayValidation.minItems;
            if (stringArrayValidation.uniqueItems)
                schema.uniqueItems = stringArrayValidation.uniqueItems;
            if (Object.keys(schema).length > 0) {
                const validateResult = jsonschema.validate(arrayToValidate, schema);
                if (validateResult.errors && validateResult.errors.length > 0) {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    return `${jsonValue} ${validateResult.errors[0].message}`;
                }
            }
            if (stringArrayValidation.equals) {
                if (stringArrayValidation.equals instanceof Array) {
                    stringArrayValidation.enum = stringArrayValidation.equals;
                    stringArrayValidation.containsAll = stringArrayValidation.equals;
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    return `${jsonValue} does not equals to:'${stringArrayValidation.equals}'`;
                }
            }
            if (stringArrayValidation.enum && arrayToValidate) {
                for (const item of arrayToValidate) {
                    if (!stringArrayValidation.enum.includes(item)) {
                        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                        return `${jsonValue} does not meet with enum:'${stringArrayValidation.enum}'`;
                    }
                }
            }
            if (stringArrayValidation.excludes) {
                if (arrayToValidate && arrayToValidate.includes(stringArrayValidation.excludes)) {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    return `${jsonValue} does not meet with excludes:'${stringArrayValidation.excludes}'`;
                }
            }
            if (stringArrayValidation.contains) {
                if (arrayToValidate && !arrayToValidate.includes(stringArrayValidation.contains)) {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    return `${jsonValue} does not meet with contains:'${stringArrayValidation.contains}'`;
                }
            }
            if (stringArrayValidation.containsAll) {
                const containsAll = stringArrayValidation.containsAll;
                if (containsAll.length > 0) {
                    for (const i of containsAll) {
                        if (arrayToValidate && !arrayToValidate.includes(i)) {
                            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                            return `${jsonValue} does not meet with containsAll:'${containsAll}'`;
                        }
                    }
                }
            }
            if (stringArrayValidation.containsAny) {
                const containsAny = stringArrayValidation.containsAny;
                if (containsAny.length > 0) {
                    // let array = valueToValidate as string[];
                    let found = false;
                    for (const i of containsAny) {
                        if (arrayToValidate && arrayToValidate.includes(i)) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                        return `${jsonValue} does not meet containsAny:'${containsAny}'`;
                    }
                }
            }
        }
    }
    return undefined;
}
exports.validate = validate;
//# sourceMappingURL=validationUtils.js.map