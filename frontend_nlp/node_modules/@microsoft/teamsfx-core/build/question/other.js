"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.apiSpecApiKeyQuestion = exports.resourceGroupQuestionNode = exports.newResourceGroupNameQuestion = exports.validateResourceGroupName = exports.newResourceGroupOption = exports.createNewEnvQuestionNode = exports.selectSourceEnvQuestion = exports.newTargetEnvQuestion = exports.newEnvNameValidation = exports.envQuestionCondition = exports.selectAadManifestQuestion = exports.isAadMainifestContainsPlaceholder = exports.inputUserEmailQuestion = exports.selectTargetEnvQuestion = exports.previewWithTeamsAppManifestQuestionNode = exports.HubOptions = exports.HubTypes = exports.selectTeamsAppPackageQuestionNode = exports.TeamsAppValidationOptions = exports.copilotPluginAddAPIQuestionNode = exports.selectLocalTeamsAppManifestQuestion = exports.selectTeamsAppManifestQuestion = exports.addWebPartQuestionNode = exports.selectAadAppManifestQuestionNode = exports.selectTeamsAppManifestQuestionNode = exports.validateTeamsAppQuestionNode = exports.deployAadManifestQuestionNode = exports.grantPermissionQuestionNode = exports.listCollaboratorQuestionNode = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const constants_1 = require("../common/constants");
const localizeUtils_1 = require("../common/localizeUtils");
const tools_1 = require("../common/tools");
const ResourceGroupHelper_1 = require("../component/utils/ResourceGroupHelper");
const envUtil_1 = require("../component/utils/envUtil");
const collaborator_1 = require("../core/collaborator");
const globalVars_1 = require("../core/globalVars");
const create_1 = require("./create");
const questionNames_1 = require("./questionNames");
const environmentName_1 = require("../core/environmentName");
const constants_2 = require("../component/driver/add/utility/constants");
const featureFlags_1 = require("../common/featureFlags");
function listCollaboratorQuestionNode() {
    const selectTeamsAppNode = selectTeamsAppManifestQuestionNode();
    selectTeamsAppNode.condition = { contains: collaborator_1.CollaborationConstants.TeamsAppQuestionId };
    selectTeamsAppNode.children.push({
        condition: envQuestionCondition,
        data: selectTargetEnvQuestion(questionNames_1.QuestionNames.Env, false, false, ""),
    });
    const selectAadAppNode = selectAadAppManifestQuestionNode();
    selectAadAppNode.condition = { contains: collaborator_1.CollaborationConstants.AadAppQuestionId };
    selectAadAppNode.children.push({
        condition: envQuestionCondition,
        data: selectTargetEnvQuestion(questionNames_1.QuestionNames.Env, false, false, ""),
    });
    return {
        data: { type: "group" },
        children: [
            {
                condition: (inputs) => teamsfx_api_1.DynamicPlatforms.includes(inputs.platform),
                data: selectAppTypeQuestion(),
                cliOptionDisabled: "self",
                inputsDisabled: "self",
                children: [selectTeamsAppNode, selectAadAppNode],
            },
        ],
    };
}
exports.listCollaboratorQuestionNode = listCollaboratorQuestionNode;
function grantPermissionQuestionNode() {
    const selectTeamsAppNode = selectTeamsAppManifestQuestionNode();
    selectTeamsAppNode.condition = { contains: collaborator_1.CollaborationConstants.TeamsAppQuestionId };
    selectTeamsAppNode.children.push({
        condition: envQuestionCondition,
        data: selectTargetEnvQuestion(questionNames_1.QuestionNames.Env, false, false, ""),
    });
    const selectAadAppNode = selectAadAppManifestQuestionNode();
    selectAadAppNode.condition = { contains: collaborator_1.CollaborationConstants.AadAppQuestionId };
    selectAadAppNode.children.push({
        condition: envQuestionCondition,
        data: selectTargetEnvQuestion(questionNames_1.QuestionNames.Env, false, false, ""),
    });
    return {
        data: { type: "group" },
        children: [
            {
                condition: (inputs) => teamsfx_api_1.DynamicPlatforms.includes(inputs.platform),
                data: selectAppTypeQuestion(),
                cliOptionDisabled: "self",
                inputsDisabled: "self",
                children: [
                    selectTeamsAppNode,
                    selectAadAppNode,
                    {
                        data: inputUserEmailQuestion(),
                    },
                ],
            },
        ],
    };
}
exports.grantPermissionQuestionNode = grantPermissionQuestionNode;
function deployAadManifestQuestionNode() {
    return {
        data: { type: "group" },
        children: [
            {
                condition: (inputs) => teamsfx_api_1.DynamicPlatforms.includes(inputs.platform),
                data: selectAadManifestQuestion(),
                children: [
                    {
                        condition: (inputs) => inputs.platform === teamsfx_api_1.Platform.VSCode && // confirm question only works for VSC
                            inputs.projectPath !== undefined &&
                            path.resolve(inputs[questionNames_1.QuestionNames.AadAppManifestFilePath]) !==
                                path.join(inputs.projectPath, "aad.manifest.json"),
                        data: confirmManifestQuestion(false, false),
                        cliOptionDisabled: "self",
                        inputsDisabled: "self",
                    },
                    {
                        condition: isAadMainifestContainsPlaceholder,
                        data: selectTargetEnvQuestion(questionNames_1.QuestionNames.Env, false, false, ""),
                    },
                ],
            },
        ],
    };
}
exports.deployAadManifestQuestionNode = deployAadManifestQuestionNode;
function validateTeamsAppQuestionNode() {
    return {
        data: selectTeamsAppValidationMethodQuestion(),
        cliOptionDisabled: "self",
        inputsDisabled: "self",
        children: [
            {
                condition: { equals: TeamsAppValidationOptions.schema().id },
                data: selectTeamsAppManifestQuestion(),
            },
            {
                condition: { equals: TeamsAppValidationOptions.package().id },
                data: selectTeamsAppPackageQuestion(),
            },
        ],
    };
}
exports.validateTeamsAppQuestionNode = validateTeamsAppQuestionNode;
function selectTeamsAppManifestQuestionNode() {
    return {
        data: selectTeamsAppManifestQuestion(),
        children: [
            {
                condition: (inputs) => confirmCondition(inputs, false),
                data: confirmManifestQuestion(true, false),
                cliOptionDisabled: "self",
                inputsDisabled: "self",
            },
        ],
    };
}
exports.selectTeamsAppManifestQuestionNode = selectTeamsAppManifestQuestionNode;
function selectAadAppManifestQuestionNode() {
    return {
        data: selectAadManifestQuestion(),
        children: [
            {
                condition: (inputs) => inputs.platform === teamsfx_api_1.Platform.VSCode && // confirm question only works for VSC
                    inputs.projectPath &&
                    inputs[questionNames_1.QuestionNames.AadAppManifestFilePath] &&
                    path.resolve(inputs[questionNames_1.QuestionNames.AadAppManifestFilePath]) !==
                        path.join(inputs.projectPath, "aad.manifest.json"),
                data: confirmManifestQuestion(false, false),
                cliOptionDisabled: "self",
                inputsDisabled: "self",
            },
        ],
    };
}
exports.selectAadAppManifestQuestionNode = selectAadAppManifestQuestionNode;
function confirmCondition(inputs, isLocal) {
    return (inputs.platform === teamsfx_api_1.Platform.VSCode && // confirm question only works for VSC
        inputs.projectPath &&
        inputs[isLocal ? questionNames_1.QuestionNames.LocalTeamsAppManifestFilePath : questionNames_1.QuestionNames.TeamsAppManifestFilePath] &&
        path.resolve(inputs[isLocal
            ? questionNames_1.QuestionNames.LocalTeamsAppManifestFilePath
            : questionNames_1.QuestionNames.TeamsAppManifestFilePath]) !==
            path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, isLocal ? "manifest.local.json" : "manifest.json"));
}
async function spfxFrameworkExist(inputs) {
    if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
        return false;
    }
    const yorcPath = path.join(inputs[questionNames_1.QuestionNames.SPFxFolder], constants_2.Constants.YO_RC_FILE);
    if (!(await fs_extra_1.default.pathExists(yorcPath))) {
        return false;
    }
    const yorcJson = (await fs_extra_1.default.readJson(yorcPath));
    if (!yorcJson["@microsoft/generator-sharepoint"]) {
        return false;
    }
    return yorcJson["@microsoft/generator-sharepoint"]["template"];
}
function addWebPartQuestionNode() {
    return {
        data: create_1.SPFxImportFolderQuestion(true),
        children: [
            {
                data: create_1.SPFxWebpartNameQuestion(),
                children: [
                    {
                        data: create_1.SPFxFrameworkQuestion(),
                        condition: async (inputs) => {
                            return !(await spfxFrameworkExist(inputs));
                        },
                    },
                    {
                        data: selectTeamsAppManifestQuestion(),
                        children: [
                            {
                                condition: (inputs) => confirmCondition(inputs, false),
                                data: confirmManifestQuestion(true, false),
                                cliOptionDisabled: "self",
                                inputsDisabled: "self",
                            },
                            {
                                data: selectLocalTeamsAppManifestQuestion(),
                                children: [
                                    {
                                        condition: (inputs) => confirmCondition(inputs, true),
                                        data: confirmManifestQuestion(true, true),
                                        cliOptionDisabled: "self",
                                        inputsDisabled: "self",
                                    },
                                ],
                            },
                        ],
                    },
                ],
            },
        ],
    };
}
exports.addWebPartQuestionNode = addWebPartQuestionNode;
function selectTeamsAppManifestQuestion() {
    return {
        name: questionNames_1.QuestionNames.TeamsAppManifestFilePath,
        cliName: "teams-manifest-file",
        cliShortName: "t",
        cliDescription: "Specifies the Microsoft Teams app manifest template file path, it can be either absolute path or relative path to project root folder, defaults to './appPackage/manifest.json'",
        title: localizeUtils_1.getLocalizedString("core.selectTeamsAppManifestQuestion.title"),
        type: "singleFile",
        default: (inputs) => {
            if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
                return "./appPackage/manifest.json";
            }
            else {
                if (!inputs.projectPath)
                    return undefined;
                const manifestPath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, "manifest.json");
                if (fs_extra_1.default.pathExistsSync(manifestPath)) {
                    return manifestPath;
                }
                else {
                    return undefined;
                }
            }
        },
    };
}
exports.selectTeamsAppManifestQuestion = selectTeamsAppManifestQuestion;
function selectLocalTeamsAppManifestQuestion() {
    return {
        name: questionNames_1.QuestionNames.LocalTeamsAppManifestFilePath,
        cliName: "local-teams-manifest-file",
        cliShortName: "l",
        cliDescription: "Specifies the Microsoft Teams app manifest template file path for local environment, it can be either absolute path or relative path to project root folder.",
        title: localizeUtils_1.getLocalizedString("core.selectLocalTeamsAppManifestQuestion.title"),
        type: "singleFile",
        default: (inputs) => {
            if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
                return "./appPackage/manifest.local.json";
            }
            else {
                if (!inputs.projectPath)
                    return undefined;
                const manifestPath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, "manifest.local.json");
                if (fs_extra_1.default.pathExistsSync(manifestPath)) {
                    return manifestPath;
                }
                else {
                    return undefined;
                }
            }
        },
    };
}
exports.selectLocalTeamsAppManifestQuestion = selectLocalTeamsAppManifestQuestion;
function confirmManifestQuestion(isTeamsApp = true, isLocal = false) {
    const map = {
        true_true: questionNames_1.QuestionNames.ConfirmLocalManifest,
        true_false: questionNames_1.QuestionNames.ConfirmManifest,
        false_true: questionNames_1.QuestionNames.ConfirmAadManifest,
        false_false: questionNames_1.QuestionNames.ConfirmAadManifest,
    };
    const name = map[`${isTeamsApp.toString()}_${isLocal.toString()}`];
    return {
        name: name,
        title: isTeamsApp
            ? localizeUtils_1.getLocalizedString(isLocal
                ? "core.selectLocalTeamsAppManifestQuestion.title"
                : "core.selectTeamsAppManifestQuestion.title")
            : localizeUtils_1.getLocalizedString("core.selectAadAppManifestQuestion.title"),
        type: "singleSelect",
        staticOptions: [],
        skipSingleOption: false,
        placeholder: localizeUtils_1.getLocalizedString("core.confirmManifestQuestion.placeholder"),
        dynamicOptions: (inputs) => {
            return [
                {
                    id: "manifest",
                    label: `$(file) ${path.basename(isTeamsApp
                        ? inputs[isLocal
                            ? questionNames_1.QuestionNames.LocalTeamsAppManifestFilePath
                            : questionNames_1.QuestionNames.TeamsAppManifestFilePath]
                        : inputs[questionNames_1.QuestionNames.AadAppManifestFilePath])}`,
                    description: path.dirname(isTeamsApp
                        ? inputs[isLocal
                            ? questionNames_1.QuestionNames.LocalTeamsAppManifestFilePath
                            : questionNames_1.QuestionNames.TeamsAppManifestFilePath]
                        : inputs[questionNames_1.QuestionNames.AadAppManifestFilePath]),
                },
            ];
        },
    };
}
function selectTeamsAppValidationMethodQuestion() {
    return {
        name: questionNames_1.QuestionNames.ValidateMethod,
        title: localizeUtils_1.getLocalizedString("core.selectValidateMethodQuestion.validate.selectTitle"),
        staticOptions: [TeamsAppValidationOptions.schema(), TeamsAppValidationOptions.package()],
        type: "singleSelect",
    };
}
function copilotPluginAddAPIQuestionNode() {
    return {
        data: create_1.apiSpecLocationQuestion(false),
        children: [
            {
                data: create_1.apiOperationQuestion(false),
            },
        ],
    };
}
exports.copilotPluginAddAPIQuestionNode = copilotPluginAddAPIQuestionNode;
class TeamsAppValidationOptions {
    static schema() {
        return {
            id: "validateAgainstSchema",
            label: localizeUtils_1.getLocalizedString("core.selectValidateMethodQuestion.validate.schemaOption"),
            description: localizeUtils_1.getLocalizedString("core.selectValidateMethodQuestion.validate.schemaOptionDescription"),
        };
    }
    static package() {
        return {
            id: "validateAgainstPackage",
            label: localizeUtils_1.getLocalizedString("core.selectValidateMethodQuestion.validate.appPackageOption"),
            description: localizeUtils_1.getLocalizedString("core.selectValidateMethodQuestion.validate.appPackageOptionDescription"),
        };
    }
}
exports.TeamsAppValidationOptions = TeamsAppValidationOptions;
function selectTeamsAppPackageQuestion() {
    return {
        name: questionNames_1.QuestionNames.TeamsAppPackageFilePath,
        title: localizeUtils_1.getLocalizedString("core.selectTeamsAppPackageQuestion.title"),
        cliDescription: "Specifies the zipped Microsoft Teams app package path, it's a relative path to project root folder, defaults to '${folder}/appPackage/build/appPackage.${env}.zip'",
        cliName: "app-package-file",
        cliShortName: "p",
        type: "singleFile",
        default: (inputs) => {
            if (!inputs.projectPath)
                return undefined;
            const appPackagePath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.BuildFolderName, "appPackage.dev.zip");
            if (fs_extra_1.default.pathExistsSync(appPackagePath)) {
                return appPackagePath;
            }
            else {
                return undefined;
            }
        },
    };
}
function selectTeamsAppPackageQuestionNode() {
    return {
        data: selectTeamsAppPackageQuestion(),
    };
}
exports.selectTeamsAppPackageQuestionNode = selectTeamsAppPackageQuestionNode;
var HubTypes;
(function (HubTypes) {
    HubTypes["teams"] = "teams";
    HubTypes["outlook"] = "outlook";
    HubTypes["office"] = "office";
})(HubTypes = exports.HubTypes || (exports.HubTypes = {}));
class HubOptions {
    static teams() {
        return {
            id: "teams",
            label: "Teams",
        };
    }
    static outlook() {
        return {
            id: "outlook",
            label: "Outlook",
        };
    }
    static office() {
        return {
            id: "office",
            label: "the Microsoft 365 app",
        };
    }
    static all() {
        return [this.teams(), this.outlook(), this.office()];
    }
}
exports.HubOptions = HubOptions;
function selectM365HostQuestion() {
    return {
        name: questionNames_1.QuestionNames.M365Host,
        cliShortName: "m",
        cliDescription: "Preview the application in Teams, Outlook or the Microsoft 365 app.",
        title: localizeUtils_1.getLocalizedString("core.M365HostQuestion.title"),
        default: HubOptions.teams().id,
        type: "singleSelect",
        staticOptions: HubOptions.all(),
        placeholder: localizeUtils_1.getLocalizedString("core.M365HostQuestion.placeholder"),
    };
}
function previewWithTeamsAppManifestQuestionNode() {
    return {
        data: { type: "group" },
        children: [
            {
                data: selectM365HostQuestion(),
            },
            selectTeamsAppManifestQuestionNode(),
        ],
    };
}
exports.previewWithTeamsAppManifestQuestionNode = previewWithTeamsAppManifestQuestionNode;
function selectTargetEnvQuestion(questionName = questionNames_1.QuestionNames.TargetEnvName, remoteOnly = true, throwErrorIfNoEnv = false, defaultValueIfNoEnv = environmentName_1.environmentNameManager.getDefaultEnvName()) {
    return {
        type: "singleSelect",
        name: questionName,
        title: localizeUtils_1.getLocalizedString("core.QuestionSelectTargetEnvironment.title"),
        cliName: "env",
        cliDescription: "Specifies the environment name for the project.",
        staticOptions: [],
        dynamicOptions: async (inputs) => {
            if (!inputs.projectPath)
                return [];
            const res = await envUtil_1.envUtil.listEnv(inputs.projectPath, remoteOnly);
            if (res.isErr()) {
                if (throwErrorIfNoEnv)
                    throw res.error;
                return [defaultValueIfNoEnv];
            }
            return res.value;
        },
        skipSingleOption: true,
        forgetLastValue: true,
    };
}
exports.selectTargetEnvQuestion = selectTargetEnvQuestion;
async function getDefaultUserEmail() {
    if (!(globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.tokenProvider.m365TokenProvider))
        return undefined;
    const jsonObjectRes = await globalVars_1.TOOLS.tokenProvider.m365TokenProvider.getJsonObject({
        scopes: tools_1.AppStudioScopes,
    });
    if (jsonObjectRes.isErr()) {
        throw jsonObjectRes.error;
    }
    const jsonObject = jsonObjectRes.value;
    const currentUserEmail = jsonObject.upn;
    let defaultUserEmail = "";
    if (currentUserEmail && currentUserEmail.indexOf("@") > 0) {
        defaultUserEmail = "[UserName]@" + currentUserEmail.split("@")[1];
    }
    return defaultUserEmail;
}
function inputUserEmailQuestion() {
    return {
        name: questionNames_1.QuestionNames.UserEmail,
        type: "text",
        title: localizeUtils_1.getLocalizedString("core.getUserEmailQuestion.title"),
        cliDescription: "Email address of the collaborator.",
        default: getDefaultUserEmail,
        validation: {
            validFunc: async (input, previousInputs) => {
                if (!input || input.trim() === "") {
                    return localizeUtils_1.getLocalizedString("core.getUserEmailQuestion.validation1");
                }
                input = input.trim();
                const defaultUserEmail = await getDefaultUserEmail();
                if (input === defaultUserEmail) {
                    return localizeUtils_1.getLocalizedString("core.getUserEmailQuestion.validation2");
                }
                const re = /\S+@\S+\.\S+/;
                if (!re.test(input)) {
                    return localizeUtils_1.getLocalizedString("core.getUserEmailQuestion.validation3");
                }
                return undefined;
            },
        },
    };
}
exports.inputUserEmailQuestion = inputUserEmailQuestion;
async function isAadMainifestContainsPlaceholder(inputs) {
    const aadManifestPath = inputs === null || inputs === void 0 ? void 0 : inputs[questionNames_1.QuestionNames.AadAppManifestFilePath];
    const placeholderRegex = /\$\{\{ *[a-zA-Z0-9_.-]* *\}\}/g;
    const regexObj = new RegExp(placeholderRegex);
    try {
        if (!aadManifestPath || !(await fs_extra_1.default.pathExists(aadManifestPath))) {
            return false;
        }
        const manifest = await fs_extra_1.default.readFile(aadManifestPath, constants_1.ConstantString.UTF8Encoding);
        if (regexObj.test(manifest)) {
            return true;
        }
    }
    catch (e) {
        return false;
    }
    return false;
}
exports.isAadMainifestContainsPlaceholder = isAadMainifestContainsPlaceholder;
function selectAadManifestQuestion() {
    return {
        name: questionNames_1.QuestionNames.AadAppManifestFilePath,
        cliName: featureFlags_1.isCliV3Enabled() ? "entra-app-manifest-file" : "aad-manifest-file",
        cliShortName: featureFlags_1.isCliV3Enabled() ? "e" : "a",
        cliDescription: "Specifies the Microsoft Entra app manifest file path, can be either absolute path or relative path to project root folder.",
        title: localizeUtils_1.getLocalizedString("core.selectAadAppManifestQuestion.title"),
        type: "singleFile",
        default: (inputs) => {
            if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
                return "./aad.manifest.json";
            }
            else {
                if (!inputs.projectPath)
                    return undefined;
                const manifestPath = path.join(inputs.projectPath, "aad.manifest.json");
                if (fs_extra_1.default.pathExistsSync(manifestPath)) {
                    return manifestPath;
                }
                else {
                    return undefined;
                }
            }
        },
    };
}
exports.selectAadManifestQuestion = selectAadManifestQuestion;
function selectAppTypeQuestion() {
    return {
        name: questionNames_1.QuestionNames.collaborationAppType,
        title: localizeUtils_1.getLocalizedString("core.selectCollaborationAppTypeQuestion.title"),
        type: "multiSelect",
        staticOptions: [
            {
                id: collaborator_1.CollaborationConstants.AadAppQuestionId,
                label: localizeUtils_1.getLocalizedString("core.aadAppQuestion.label"),
                description: localizeUtils_1.getLocalizedString("core.aadAppQuestion.description"),
            },
            {
                id: collaborator_1.CollaborationConstants.TeamsAppQuestionId,
                label: localizeUtils_1.getLocalizedString("core.teamsAppQuestion.label"),
                description: localizeUtils_1.getLocalizedString("core.teamsAppQuestion.description"),
            },
        ],
        validation: { minItems: 1 },
        validationHelp: "Please select at least one app type.",
    };
}
async function envQuestionCondition(inputs) {
    const appType = inputs[collaborator_1.CollaborationConstants.AppType];
    const requireAad = appType === null || appType === void 0 ? void 0 : appType.includes(collaborator_1.CollaborationConstants.AadAppQuestionId);
    const requireTeams = appType === null || appType === void 0 ? void 0 : appType.includes(collaborator_1.CollaborationConstants.TeamsAppQuestionId);
    const aadManifestPath = inputs[questionNames_1.QuestionNames.AadAppManifestFilePath];
    const teamsManifestPath = inputs[questionNames_1.QuestionNames.TeamsAppManifestFilePath];
    // When both is selected, only show the question once at the end
    if ((requireAad && !aadManifestPath) || (requireTeams && !teamsManifestPath)) {
        return false;
    }
    // Only show env question when manifest id is referencing value from .env file
    let requireEnv = false;
    if (requireTeams && teamsManifestPath) {
        const teamsAppIdRes = await collaborator_1.CollaborationUtil.loadManifestId(teamsManifestPath);
        if (teamsAppIdRes.isOk()) {
            requireEnv = collaborator_1.CollaborationUtil.requireEnvQuestion(teamsAppIdRes.value);
            if (requireEnv) {
                return true;
            }
        }
        else {
            return false;
        }
    }
    if (requireAad && aadManifestPath) {
        const aadAppIdRes = await collaborator_1.CollaborationUtil.loadManifestId(aadManifestPath);
        if (aadAppIdRes.isOk()) {
            requireEnv = collaborator_1.CollaborationUtil.requireEnvQuestion(aadAppIdRes.value);
            if (requireEnv) {
                return true;
            }
        }
        else {
            return false;
        }
    }
    return false;
}
exports.envQuestionCondition = envQuestionCondition;
async function newEnvNameValidation(input, inputs) {
    const targetEnvName = input;
    const match = targetEnvName.match(environmentName_1.environmentNameManager.envNameRegex);
    if (!match) {
        return localizeUtils_1.getLocalizedString("core.getQuestionNewTargetEnvironmentName.validation1");
    }
    if (!environmentName_1.environmentNameManager.isRemoteEnvironment(targetEnvName)) {
        return localizeUtils_1.getLocalizedString("core.getQuestionNewTargetEnvironmentName.validation3", targetEnvName);
    }
    if (!(inputs === null || inputs === void 0 ? void 0 : inputs.projectPath))
        return "Project path is not defined";
    const envListRes = await envUtil_1.envUtil.listEnv(inputs.projectPath, true);
    if (envListRes.isErr()) {
        return localizeUtils_1.getLocalizedString("core.getQuestionNewTargetEnvironmentName.validation4");
    }
    inputs.existingEnvNames = envListRes.value; //cache existing env names
    const found = envListRes.value.find((env) => env.localeCompare(targetEnvName, undefined, { sensitivity: "base" }) === 0) !== undefined;
    if (found) {
        return localizeUtils_1.getLocalizedString("core.getQuestionNewTargetEnvironmentName.validation5", targetEnvName);
    }
    else {
        return undefined;
    }
}
exports.newEnvNameValidation = newEnvNameValidation;
function newTargetEnvQuestion() {
    return {
        type: "text",
        name: questionNames_1.QuestionNames.NewTargetEnvName,
        cliName: "name",
        cliDescription: "Specifies the new environment name.",
        cliType: "argument",
        title: localizeUtils_1.getLocalizedString("core.getQuestionNewTargetEnvironmentName.title"),
        validation: {
            validFunc: newEnvNameValidation,
        },
        placeholder: localizeUtils_1.getLocalizedString("core.getQuestionNewTargetEnvironmentName.placeholder"),
    };
}
exports.newTargetEnvQuestion = newTargetEnvQuestion;
// export const lastUsedMark = " (last used)";
// let lastUsedEnv: string | undefined;
// export function reOrderEnvironments(environments: Array<string>): Array<string> {
//   if (!lastUsedEnv) {
//     return environments;
//   }
//   const index = environments.indexOf(lastUsedEnv);
//   if (index === -1) {
//     return environments;
//   }
//   return [lastUsedEnv + lastUsedMark]
//     .concat(environments.slice(0, index))
//     .concat(environments.slice(index + 1));
// }
function selectSourceEnvQuestion() {
    return {
        type: "singleSelect",
        name: questionNames_1.QuestionNames.SourceEnvName,
        cliName: "env",
        title: localizeUtils_1.getLocalizedString("core.QuestionSelectSourceEnvironment.title"),
        cliDescription: "Specifies an existing environment name to copy from.",
        staticOptions: [],
        dynamicOptions: async (inputs) => {
            if (inputs.existingEnvNames) {
                const envList = inputs.existingEnvNames;
                return envList;
            }
            else if (inputs.projectPath) {
                const envListRes = await envUtil_1.envUtil.listEnv(inputs.projectPath, true);
                if (envListRes.isErr()) {
                    throw envListRes.error;
                }
                return envListRes.value;
            }
            return [];
        },
        skipSingleOption: true,
        forgetLastValue: true,
    };
}
exports.selectSourceEnvQuestion = selectSourceEnvQuestion;
function createNewEnvQuestionNode() {
    return {
        data: newTargetEnvQuestion(),
        children: [
            {
                data: selectSourceEnvQuestion(),
            },
        ],
    };
}
exports.createNewEnvQuestionNode = createNewEnvQuestionNode;
exports.newResourceGroupOption = "+ New resource group";
/**
 * select existing resource group or create new resource group
 */
function selectResourceGroupQuestion(azureAccountProvider, subscriptionId) {
    return {
        type: "singleSelect",
        name: questionNames_1.QuestionNames.TargetResourceGroupName,
        title: localizeUtils_1.getLocalizedString("core.QuestionSelectResourceGroup.title"),
        staticOptions: [{ id: exports.newResourceGroupOption, label: exports.newResourceGroupOption }],
        dynamicOptions: async (inputs) => {
            const rmClient = await ResourceGroupHelper_1.resourceGroupHelper.createRmClient(azureAccountProvider, subscriptionId);
            const listRgRes = await ResourceGroupHelper_1.resourceGroupHelper.listResourceGroups(rmClient);
            if (listRgRes.isErr())
                throw listRgRes.error;
            const rgList = listRgRes.value;
            const options = rgList.map((rg) => {
                return {
                    id: rg[0],
                    label: rg[0],
                    description: rg[1],
                };
            });
            const existingResourceGroupNames = rgList.map((rg) => rg[0]);
            inputs.existingResourceGroupNames = existingResourceGroupNames; // cache existing resource group names for valiation usage
            return [{ id: exports.newResourceGroupOption, label: exports.newResourceGroupOption }, ...options];
        },
        skipSingleOption: true,
        returnObject: true,
        forgetLastValue: true,
    };
}
function validateResourceGroupName(input, inputs) {
    const name = input;
    // https://docs.microsoft.com/en-us/rest/api/resources/resource-groups/create-or-update#uri-parameters
    const match = name.match(/^[-\w._()]+$/);
    if (!match) {
        return localizeUtils_1.getLocalizedString("core.QuestionNewResourceGroupName.validation");
    }
    // To avoid the issue in CLI that using async func for validation and filter will make users input answers twice,
    // we check the existence of a resource group from the list rather than call the api directly for now.
    // Bug: https://msazure.visualstudio.com/Microsoft%20Teams%20Extensibility/_workitems/edit/15066282
    // GitHub issue: https://github.com/SBoudrias/Inquirer.js/issues/1136
    if (inputs === null || inputs === void 0 ? void 0 : inputs.existingResourceGroupNames) {
        const maybeExist = inputs.existingResourceGroupNames.findIndex((o) => o.toLowerCase() === input.toLowerCase()) >= 0;
        if (maybeExist) {
            return `resource group already exists: ${name}`;
        }
    }
    return undefined;
}
exports.validateResourceGroupName = validateResourceGroupName;
function newResourceGroupNameQuestion(defaultResourceGroupName) {
    return {
        type: "text",
        name: questionNames_1.QuestionNames.NewResourceGroupName,
        title: localizeUtils_1.getLocalizedString("core.QuestionNewResourceGroupName.title"),
        placeholder: localizeUtils_1.getLocalizedString("core.QuestionNewResourceGroupName.placeholder"),
        // default resource group name will change with env name
        forgetLastValue: true,
        default: defaultResourceGroupName,
        validation: {
            validFunc: validateResourceGroupName,
        },
    };
}
exports.newResourceGroupNameQuestion = newResourceGroupNameQuestion;
function selectResourceGroupLocationQuestion(azureAccountProvider, subscriptionId) {
    return {
        type: "singleSelect",
        name: questionNames_1.QuestionNames.NewResourceGroupLocation,
        title: localizeUtils_1.getLocalizedString("core.QuestionNewResourceGroupLocation.title"),
        staticOptions: [],
        dynamicOptions: async (inputs) => {
            const rmClient = await ResourceGroupHelper_1.resourceGroupHelper.createRmClient(azureAccountProvider, subscriptionId);
            const getLocationsRes = await ResourceGroupHelper_1.resourceGroupHelper.getLocations(azureAccountProvider, rmClient);
            if (getLocationsRes.isErr()) {
                throw getLocationsRes.error;
            }
            const recommended = getLocationsRes.value.filter((location) => {
                return ResourceGroupHelper_1.recommendedLocations.indexOf(location) >= 0;
            });
            const others = getLocationsRes.value.filter((location) => {
                return ResourceGroupHelper_1.recommendedLocations.indexOf(location) < 0;
            });
            return [
                ...recommended.map((location) => {
                    return {
                        id: location,
                        label: location,
                        groupName: localizeUtils_1.getLocalizedString("core.QuestionNewResourceGroupLocation.group.recommended"),
                    };
                }),
                ...others.map((location) => {
                    return {
                        id: location,
                        label: location,
                        groupName: localizeUtils_1.getLocalizedString("core.QuestionNewResourceGroupLocation.group.others"),
                    };
                }),
            ];
        },
        default: "Central US",
    };
}
function resourceGroupQuestionNode(azureAccountProvider, subscriptionId, defaultResourceGroupName) {
    return {
        data: selectResourceGroupQuestion(azureAccountProvider, subscriptionId),
        children: [
            {
                condition: { equals: exports.newResourceGroupOption },
                data: newResourceGroupNameQuestion(defaultResourceGroupName),
                children: [
                    {
                        data: selectResourceGroupLocationQuestion(azureAccountProvider, subscriptionId),
                    },
                ],
            },
        ],
    };
}
exports.resourceGroupQuestionNode = resourceGroupQuestionNode;
function apiSpecApiKeyQuestion() {
    return {
        data: {
            type: "text",
            name: questionNames_1.QuestionNames.ApiSpecApiKey,
            cliShortName: "k",
            title: localizeUtils_1.getLocalizedString("core.createaProjectQuestion.ApiKey"),
            cliDescription: "Api key for OpenAPI spec.",
            forgetLastValue: true,
            validation: {
                validFunc: (input) => {
                    const pattern = /^(\w){10,128}/g;
                    const match = pattern.test(input);
                    const result = match
                        ? undefined
                        : localizeUtils_1.getLocalizedString("core.createProjectQuestion.invalidApiKey.message");
                    return result;
                },
            },
            additionalValidationOnAccept: {
                validFunc: (input, inputs) => {
                    if (!inputs) {
                        throw new Error("inputs is undefined"); // should never happen
                    }
                    process.env[questionNames_1.QuestionNames.ApiSpecApiKey] = input;
                    return;
                },
            },
        },
        condition: (inputs) => {
            return (inputs.outputEnvVarNames &&
                !process.env[inputs.outputEnvVarNames.get("registrationId")] &&
                !inputs.clientSecret);
        },
    };
}
exports.apiSpecApiKeyQuestion = apiSpecApiKeyQuestion;
//# sourceMappingURL=other.js.map