"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateInputs = exports.generateCliOptions = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path_1 = tslib_1.__importDefault(require("path"));
const ts_morph_1 = require("ts-morph");
const _1 = require(".");
const validationUtils_1 = require("../ui/validationUtils");
const samples_1 = require("../common/samples");
async function collectNodesForCliOptions(node, nodeList) {
    if (node.cliOptionDisabled === "all")
        return;
    if (node.data.type !== "group" &&
        (!node.cliOptionDisabled || node.cliOptionDisabled !== "self")) {
        nodeList.push(node);
    }
    let currentOptions = [];
    if (node.data.type === "singleSelect" || node.data.type === "multiSelect") {
        currentOptions = node.data.staticOptions.map((option) => typeof option === "string" ? option : option.id);
    }
    if (node.children && (!node.cliOptionDisabled || node.cliOptionDisabled !== "children")) {
        for (const child of node.children) {
            if (child.condition && typeof child.condition !== "function" && currentOptions.length > 0) {
                // try to exclude one case: parent value has a range, child condition is not functional condition,
                // and none of the value in the range satisfies the condition
                let someChoiceIsValid = false;
                for (const parentValue of currentOptions) {
                    const res = await validationUtils_1.validate(child.condition, parentValue);
                    if (res === undefined) {
                        someChoiceIsValid = true;
                        break;
                    }
                }
                if (someChoiceIsValid) {
                    await collectNodesForCliOptions(child, nodeList);
                }
                // if all choices are invalid, trim the child node
            }
            else {
                await collectNodesForCliOptions(child, nodeList);
            }
        }
    }
}
async function collectNodesForInputs(node, nodeList) {
    if (node.inputsDisabled === "all")
        return;
    if (node.data.type !== "group" && (!node.inputsDisabled || node.inputsDisabled !== "self")) {
        nodeList.push(node);
    }
    let currentOptions = [];
    if (node.data.type === "singleSelect" || node.data.type === "multiSelect") {
        currentOptions = node.data.staticOptions.map((option) => typeof option === "string" ? option : option.id);
    }
    if (node.children && (!node.inputsDisabled || node.inputsDisabled !== "children")) {
        for (const child of node.children) {
            if (child.condition && typeof child.condition !== "function" && currentOptions.length > 0) {
                // try to exclude one case: parent value has a range, child condition is not functional condition,
                // and none of the value in the range satisfies the condition
                let someChoiceIsValid = false;
                for (const parentValue of currentOptions) {
                    const res = await validationUtils_1.validate(child.condition, parentValue);
                    if (res === undefined) {
                        someChoiceIsValid = true;
                        break;
                    }
                }
                if (someChoiceIsValid) {
                    await collectNodesForInputs(child, nodeList);
                }
                // if all choices are invalid, trim the child node
            }
            else {
                await collectNodesForInputs(child, nodeList);
            }
        }
    }
}
async function computeRequired(node) {
    // console.log("computeRequired", node.data.name, "required:", (node.data as any).required);
    if (node.children) {
        const parentRequired = node.data.required || false;
        for (const child of node.children) {
            let childRequired = child.data.required || false;
            if (!childRequired) {
                if (!child.condition && parentRequired) {
                    childRequired = true;
                }
                else {
                    if (typeof child.condition === "function") {
                        const isValid = await child.condition({
                            platform: teamsfx_api_1.Platform.CLI_HELP,
                        });
                        if (isValid && parentRequired) {
                            childRequired = true;
                        }
                    }
                }
            }
            if (childRequired)
                child.data.required = true;
            // console.log(
            //   child.data.name,
            //   "parent required:",
            //   parentRequired,
            //   "child required:",
            //   (child.data as any).required,
            //   "child condition:",
            //   child.condition,
            //   "computed required:",
            //   (child.data as any).required
            // );
            await computeRequired(child);
        }
    }
}
const notice = "/****************************************************************************************\n" +
    " *                            NOTICE: AUTO-GENERATED                                    *\n" +
    " ****************************************************************************************\n" +
    ` * This file is automatically generated by script "./src/question/generator.ts".        *\n` +
    " * Please don't manually change its contents, as any modifications will be overwritten! *\n" +
    " ***************************************************************************************/\n\n\n";
async function generateCliOptions(node, name, optionFolder = "./src/question/options", excludes) {
    // initialize
    const project = new ts_morph_1.Project({
        manipulationSettings: {
            indentationText: ts_morph_1.IndentationText.TwoSpaces, // Set the indentation to 2 spaces
        },
    });
    const optionFile = project.createSourceFile(path_1.default.join(optionFolder, `${name}Options.ts`), "", {
        overwrite: true,
    });
    const cliNodeList = [];
    await collectNodesForCliOptions(node, cliNodeList);
    // console.log(`node collected: ${nodeList.map((n) => n.data.name).join(",")}`);
    node.data.required = true;
    await computeRequired(node);
    const questionNames = new Set();
    const cliOptions = [];
    const cliArguments = [];
    for (const node of cliNodeList) {
        const data = node.data;
        const questionName = data.name;
        const cliName = data.cliName || questionName;
        if (excludes === null || excludes === void 0 ? void 0 : excludes.includes(cliName))
            continue;
        if (questionNames.has(questionName)) {
            continue;
        }
        const title = data.title
            ? typeof data.title !== "function"
                ? data.title
                : await data.title({ platform: teamsfx_api_1.Platform.CLI_HELP })
            : undefined;
        const defaultValue = data.default
            ? typeof data.default !== "function"
                ? data.default
                : await data.default({ platform: teamsfx_api_1.Platform.CLI_HELP })
            : undefined;
        const propDocDescription = title || data.name;
        const option = {
            name: cliName,
            questionName: questionName === cliName ? undefined : questionName,
            type: getOptionType(data),
            shortName: data.cliShortName,
            description: data.cliDescription || propDocDescription,
            required: data.required,
            default: data.isBoolean ? Boolean(defaultValue) : defaultValue,
        };
        if (data.cliHidden) {
            option.hidden = data.cliHidden;
        }
        if (data.type === "singleSelect" || data.type === "multiSelect") {
            const selection = data;
            const options = selection.staticOptions;
            if (data.isBoolean) {
            }
            else if (options.length > 0) {
                const choices = options.map((o) => (typeof o === "string" ? o : o.id));
                option.choices = choices;
            }
            option.choiceListCommand =
                selection.cliChoiceListCommand;
            if (selection.skipValidation)
                option.skipValidation = selection.skipValidation;
        }
        questionNames.add(questionName);
        if (data.cliType !== "argument") {
            cliOptions.push(option);
        }
        else {
            cliArguments.push(option);
        }
    }
    const optionInitializerCode = JSON.stringify(cliOptions, null, 2)
        .replace(/"([^"]+)":/g, "$1:")
        .replace(/\\"/g, '"')
        .replace(/\n}$/g, ",\n}");
    const argumentInitializerCode = JSON.stringify(cliArguments, null, 2)
        .replace(/"([^"]+)":/g, "$1:")
        .replace(/\\"/g, '"');
    optionFile.addVariableStatement({
        declarationKind: ts_morph_1.VariableDeclarationKind.Const,
        isExported: true,
        declarations: [
            {
                name: name + "Options",
                type: "CLICommandOption[]",
                initializer: optionInitializerCode,
            },
        ],
    });
    optionFile.addVariableStatement({
        declarationKind: ts_morph_1.VariableDeclarationKind.Const,
        isExported: true,
        declarations: [
            {
                name: name + "Arguments",
                type: "CLICommandArgument[]",
                initializer: argumentInitializerCode,
            },
        ],
    });
    optionFile.addImportDeclaration({
        namedImports: ["CLICommandOption", "CLICommandArgument"],
        moduleSpecifier: "@microsoft/teamsfx-api",
    });
    optionFile.insertText(0, "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n" + notice);
    optionFile.formatText();
    await updateExports("./src/question/options/index.ts", `export * from "./${name}Options";`);
    await project.save();
}
exports.generateCliOptions = generateCliOptions;
async function generateInputs(node, name, inputsFolder = "./src/question/inputs", excludes = ["folder"]) {
    // initialize
    const project = new ts_morph_1.Project({
        manipulationSettings: {
            indentationText: ts_morph_1.IndentationText.TwoSpaces, // Set the indentation to 2 spaces
        },
    });
    const inputsFile = project.createSourceFile(path_1.default.join(inputsFolder, `${name}Inputs.ts`), "", {
        overwrite: true,
    });
    const inputsNodeList = [];
    await collectNodesForInputs(node, inputsNodeList);
    // console.log(`node collected: ${nodeList.map((n) => n.data.name).join(",")}`);
    node.data.required = true;
    await computeRequired(node);
    const questionNames = new Set();
    const properties = [];
    for (const node of inputsNodeList) {
        const data = node.data;
        const questionName = data.name;
        const cliName = data.cliName || questionName;
        if (excludes.includes(cliName))
            continue;
        if (questionNames.has(questionName)) {
            continue;
        }
        let type = "string";
        const title = data.title
            ? typeof data.title !== "function"
                ? data.title
                : await data.title({ platform: teamsfx_api_1.Platform.CLI_HELP })
            : undefined;
        const propDocDescription = title || data.name;
        if (data.type === "singleSelect" || data.type === "multiSelect") {
            const selection = data;
            const options = selection.staticOptions;
            if (data.isBoolean) {
                type = "boolean";
            }
            else if (options.length > 0) {
                const optionStrings = options.map((o) => (typeof o === "string" ? o : o.id));
                type = selection.skipValidation ? "string" : optionStrings.map((i) => `"${i}"`).join(" | ");
            }
            else {
                type = "string";
            }
            if (data.type === "multiSelect") {
                type += "[]";
            }
        }
        const inputPropName = questionName.includes("-") ? `"${questionName}"` : questionName;
        properties.push({
            name: inputPropName,
            type: type,
            hasQuestionToken: true,
            docs: [`@description ${propDocDescription}`],
        });
        questionNames.add(questionName);
    }
    inputsFile.addInterface({
        name: name + "Inputs",
        isExported: true,
        properties: properties,
        extends: ["Inputs"],
    });
    inputsFile.addImportDeclaration({
        namedImports: ["Inputs"],
        moduleSpecifier: "@microsoft/teamsfx-api",
    });
    inputsFile.insertText(0, "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n" + notice);
    inputsFile.formatText();
    await updateExports("./src/question/inputs/index.ts", `export * from "./${name}Inputs";`);
    await project.save();
}
exports.generateInputs = generateInputs;
function getOptionType(question) {
    if (question.isBoolean)
        return "boolean";
    if (question.type === "multiSelect") {
        return "array";
    }
    return "string";
}
async function updateExports(filePath, exportStatement) {
    const project = new ts_morph_1.Project();
    try {
        const sourceFile = project.addSourceFileAtPathIfExists(filePath);
        if (!sourceFile)
            return;
        const hasExport = sourceFile.getStatements().some((statement) => {
            return (statement.getKind() === ts_morph_1.SyntaxKind.ExportDeclaration &&
                statement.getText().trim() === exportStatement);
        });
        if (!hasExport) {
            sourceFile.addStatements([exportStatement]);
            await sourceFile.save();
            console.log(`Export statement '${exportStatement}' added successfully.`);
        }
    }
    catch (err) {
        console.error("Error occurred:", err);
        return;
    }
}
async function batchGenerate() {
    await generateCliOptions(_1.questionNodes.createProject(), "CreateProject");
    await generateInputs(_1.questionNodes.createProject(), "CreateProject");
    await samples_1.sampleProvider.fetchSampleConfig();
    await generateCliOptions(_1.questionNodes.createSampleProject(), "CreateSampleProject");
    await generateInputs(_1.questionNodes.createSampleProject(), "CreateSampleProject");
    await generateCliOptions(_1.questionNodes.addWebpart(), "SPFxAddWebpart");
    await generateInputs(_1.questionNodes.addWebpart(), "SPFxAddWebpart");
    await generateCliOptions(_1.questionNodes.createNewEnv(), "CreateEnv");
    await generateInputs(_1.questionNodes.createNewEnv(), "CreateEnv");
    await generateCliOptions(_1.questionNodes.selectTeamsAppManifest(), "SelectTeamsManifest");
    await generateInputs(_1.questionNodes.selectTeamsAppManifest(), "SelectTeamsManifest");
    await generateCliOptions(_1.questionNodes.validateTeamsApp(), "ValidateTeamsApp");
    await generateInputs(_1.questionNodes.validateTeamsApp(), "ValidateTeamsApp");
    await generateCliOptions(_1.questionNodes.previewWithTeamsAppManifest(), "PreviewTeamsApp");
    await generateInputs(_1.questionNodes.previewWithTeamsAppManifest(), "PreviewTeamsApp");
    await generateCliOptions(_1.questionNodes.grantPermission(), "PermissionGrant");
    await generateInputs(_1.questionNodes.grantPermission(), "PermissionGrant");
    await generateCliOptions(_1.questionNodes.listCollaborator(), "PermissionList");
    await generateInputs(_1.questionNodes.listCollaborator(), "PermissionList");
    await generateCliOptions(_1.questionNodes.deployAadManifest(), "DeployAadManifest");
    await generateInputs(_1.questionNodes.deployAadManifest(), "DeployAadManifest");
}
void batchGenerate();
//# sourceMappingURL=generator.js.map