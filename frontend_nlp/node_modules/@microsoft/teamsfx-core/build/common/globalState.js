"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.globalStateUpdate = exports.globalStateGet = void 0;
const tslib_1 = require("tslib");
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const proper_lockfile_1 = tslib_1.__importDefault(require("proper-lockfile"));
const tools_1 = require("./tools");
const GlobalStateFileName = "state.json";
/**
 * Return a value.
 *
 * @param key A string.
 * @return The stored value or `undefined`.
 */
async function globalStateGet(key, defaultValue) {
    const filePath = getGlobalStateFile();
    ensureGlobalStateFileExists(filePath);
    const lockFileDir = getLockFolder(filePath);
    const lockfilePath = path.join(lockFileDir, `${teamsfx_api_1.ConfigFolderName}.lock`);
    await fs.ensureDir(lockFileDir);
    const retryNum = 10;
    for (let i = 0; i < retryNum; ++i) {
        try {
            await proper_lockfile_1.default.lock(filePath, { lockfilePath: lockfilePath });
            let value = undefined;
            try {
                const config = await fs.readJSON(filePath);
                value = config[key];
                if (value === undefined) {
                    value = defaultValue;
                }
            }
            finally {
                await proper_lockfile_1.default.unlock(filePath, { lockfilePath: lockfilePath });
            }
            return value;
        }
        catch (e) {
            if (e["code"] === "ELOCKED") {
                await tools_1.waitSeconds(1);
                continue;
            }
            return undefined;
        }
    }
}
exports.globalStateGet = globalStateGet;
/**
 * Store a value. The value must be JSON-stringifyable.
 *
 * @param key A string.
 * @param value A value. MUST not contain cyclic references.
 */
async function globalStateUpdate(key, value) {
    const filePath = getGlobalStateFile();
    ensureGlobalStateFileExists(filePath);
    const lockFileDir = getLockFolder(filePath);
    const lockfilePath = path.join(lockFileDir, `${teamsfx_api_1.ConfigFolderName}.lock`);
    await fs.ensureDir(lockFileDir);
    const retryNum = 10;
    for (let i = 0; i < retryNum; ++i) {
        try {
            await proper_lockfile_1.default.lock(filePath, { lockfilePath: lockfilePath });
            try {
                const config = await fs.readJSON(filePath);
                config[key] = value;
                await fs.writeJson(filePath, config);
            }
            finally {
                await proper_lockfile_1.default.unlock(filePath, { lockfilePath: lockfilePath });
            }
            break;
        }
        catch (e) {
            if (e["code"] === "ELOCKED") {
                await tools_1.waitSeconds(1);
                continue;
            }
            throw e;
        }
    }
}
exports.globalStateUpdate = globalStateUpdate;
function getGlobalStateFile() {
    const homeDir = os.homedir();
    return path.join(homeDir, `.${teamsfx_api_1.ConfigFolderName}`, GlobalStateFileName);
}
function ensureGlobalStateFileExists(filePath) {
    if (!fs.pathExistsSync(path.dirname(filePath))) {
        fs.mkdirpSync(path.dirname(filePath));
    }
    if (!fs.existsSync(filePath)) {
        fs.writeJSONSync(filePath, {});
    }
}
function getLockFolder(projectPath) {
    return path.join(os.tmpdir(), `${teamsfx_api_1.ProductName}-${crypto_1.default.createHash("md5").update(projectPath).digest("hex")}`);
}
//# sourceMappingURL=globalState.js.map