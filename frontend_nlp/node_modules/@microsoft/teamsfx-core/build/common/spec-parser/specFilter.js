// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.specFilter = void 0;
const utils_1 = require("./utils");
const specParserError_1 = require("./specParserError");
const interfaces_1 = require("./interfaces");
const constants_1 = require("./constants");
function specFilter(filter, unResolveSpec, resolvedSpec, allowMissingId, allowAPIKeyAuth) {
    try {
        const newSpec = Object.assign({}, unResolveSpec);
        const newPaths = {};
        for (const filterItem of filter) {
            const [method, path] = filterItem.split(" ");
            const methodName = method.toLowerCase();
            if (!utils_1.isSupportedApi(methodName, path, resolvedSpec, allowMissingId, allowAPIKeyAuth)) {
                continue;
            }
            if (!newPaths[path]) {
                newPaths[path] = Object.assign({}, unResolveSpec.paths[path]);
                for (const m of constants_1.ConstantString.AllOperationMethods) {
                    delete newPaths[path][m];
                }
            }
            newPaths[path][methodName] = unResolveSpec.paths[path][methodName];
            // Add the operationId if missing
            if (!newPaths[path][methodName].operationId) {
                newPaths[path][methodName].operationId = `${methodName}${utils_1.convertPathToCamelCase(path)}`;
            }
        }
        newSpec.paths = newPaths;
        return newSpec;
    }
    catch (err) {
        throw new specParserError_1.SpecParserError(err.toString(), interfaces_1.ErrorType.FilterSpecFailed);
    }
}
exports.specFilter = specFilter;
//# sourceMappingURL=specFilter.js.map