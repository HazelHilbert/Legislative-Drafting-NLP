// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSafeRegistrationIdEnvName = exports.format = exports.validateSpec = exports.listSupportedAPIs = exports.parseApiInfo = exports.generateParametersFromSchema = exports.isWellKnownName = exports.validateServer = exports.checkServerUrl = exports.resolveServerUrl = exports.getUrlProtocol = exports.convertPathToCamelCase = exports.getResponseJson = exports.updateFirstLetter = exports.getAPIKeyAuthArray = exports.isSupportedApi = exports.checkPostBody = exports.checkParameters = void 0;
const constants_1 = require("./constants");
const interfaces_1 = require("./interfaces");
function checkParameters(paramObject) {
    const paramResult = {
        requiredNum: 0,
        optionalNum: 0,
        isValid: true,
    };
    if (!paramObject) {
        return paramResult;
    }
    for (let i = 0; i < paramObject.length; i++) {
        const param = paramObject[i];
        const schema = param.schema;
        const isRequiredWithoutDefault = param.required && schema.default === undefined;
        if (param.in === "header" || param.in === "cookie") {
            if (isRequiredWithoutDefault) {
                paramResult.isValid = false;
            }
            continue;
        }
        if (schema.type !== "boolean" &&
            schema.type !== "string" &&
            schema.type !== "number" &&
            schema.type !== "integer") {
            if (isRequiredWithoutDefault) {
                paramResult.isValid = false;
            }
            continue;
        }
        if (param.in === "query" || param.in === "path") {
            if (isRequiredWithoutDefault) {
                paramResult.requiredNum = paramResult.requiredNum + 1;
            }
            else {
                paramResult.optionalNum = paramResult.optionalNum + 1;
            }
        }
    }
    return paramResult;
}
exports.checkParameters = checkParameters;
function checkPostBody(schema, isRequired = false) {
    var _a;
    const paramResult = {
        requiredNum: 0,
        optionalNum: 0,
        isValid: true,
    };
    if (Object.keys(schema).length === 0) {
        return paramResult;
    }
    const isRequiredWithoutDefault = isRequired && schema.default === undefined;
    if (schema.type === "string" ||
        schema.type === "integer" ||
        schema.type === "boolean" ||
        schema.type === "number") {
        if (isRequiredWithoutDefault) {
            paramResult.requiredNum = paramResult.requiredNum + 1;
        }
        else {
            paramResult.optionalNum = paramResult.optionalNum + 1;
        }
    }
    else if (schema.type === "object") {
        const { properties } = schema;
        for (const property in properties) {
            let isRequired = false;
            if (schema.required && ((_a = schema.required) === null || _a === void 0 ? void 0 : _a.indexOf(property)) >= 0) {
                isRequired = true;
            }
            const result = checkPostBody(properties[property], isRequired);
            paramResult.requiredNum += result.requiredNum;
            paramResult.optionalNum += result.optionalNum;
            paramResult.isValid = paramResult.isValid && result.isValid;
        }
    }
    else {
        if (isRequiredWithoutDefault) {
            paramResult.isValid = false;
        }
    }
    return paramResult;
}
exports.checkPostBody = checkPostBody;
/**
 * Checks if the given API is supported.
 * @param {string} method - The HTTP method of the API.
 * @param {string} path - The path of the API.
 * @param {OpenAPIV3.Document} spec - The OpenAPI specification document.
 * @returns {boolean} - Returns true if the API is supported, false otherwise.
 * @description The following APIs are supported:
 * 1. only support Get/Post operation without auth property
 * 2. parameter inside query or path only support string, number, boolean and integer
 * 3. parameter inside post body only support string, number, boolean, integer and object
 * 4. request body + required parameters <= 1
 * 5. response body should be “application/json” and not empty, and response code should be 20X
 * 6. only support request body with “application/json” content type
 */
function isSupportedApi(method, path, spec, allowMissingId, allowAPIKeyAuth) {
    const pathObj = spec.paths[path];
    method = method.toLocaleLowerCase();
    if (pathObj) {
        if ((method === constants_1.ConstantString.PostMethod || method === constants_1.ConstantString.GetMethod) &&
            pathObj[method]) {
            const securities = pathObj[method].security;
            const apiKeyAuthArr = getAPIKeyAuthArray(securities, spec);
            if (!allowAPIKeyAuth && securities) {
                return false;
            }
            if (allowAPIKeyAuth && securities && apiKeyAuthArr.length === 0) {
                return false;
            }
            // Currently we don't support multiple apiKey auth
            if (apiKeyAuthArr.length > 0 && apiKeyAuthArr.every((auths) => auths.length > 1)) {
                return false;
            }
            const operationObject = pathObj[method];
            if (!allowMissingId && !operationObject.operationId) {
                return false;
            }
            const paramObject = operationObject.parameters;
            const requestBody = operationObject.requestBody;
            const requestJsonBody = requestBody === null || requestBody === void 0 ? void 0 : requestBody.content["application/json"];
            const responseJson = getResponseJson(operationObject);
            if (Object.keys(responseJson).length === 0) {
                return false;
            }
            let requestBodyParamResult = {
                requiredNum: 0,
                optionalNum: 0,
                isValid: true,
            };
            if (requestJsonBody) {
                const requestBodySchema = requestJsonBody.schema;
                requestBodyParamResult = checkPostBody(requestBodySchema, requestBody.required);
            }
            if (!requestBodyParamResult.isValid) {
                return false;
            }
            const paramResult = checkParameters(paramObject);
            if (!paramResult.isValid) {
                return false;
            }
            if (requestBodyParamResult.requiredNum + paramResult.requiredNum > 1) {
                return false;
            }
            else if (requestBodyParamResult.requiredNum +
                requestBodyParamResult.optionalNum +
                paramResult.requiredNum +
                paramResult.optionalNum ===
                0) {
                return false;
            }
            else {
                return true;
            }
        }
    }
    return false;
}
exports.isSupportedApi = isSupportedApi;
function getAPIKeyAuthArray(securities, spec) {
    var _a;
    const result = [];
    const securitySchemas = (_a = spec.components) === null || _a === void 0 ? void 0 : _a.securitySchemes;
    if (securities && securitySchemas) {
        for (let i = 0; i < securities.length; i++) {
            const security = securities[i];
            let apiKeyAuthArray = [];
            for (const name in security) {
                const auth = securitySchemas[name];
                if (auth.type === "apiKey") {
                    apiKeyAuthArray.push(auth);
                }
                else {
                    apiKeyAuthArray = [];
                    break;
                }
            }
            if (apiKeyAuthArray.length > 0) {
                result.push(apiKeyAuthArray);
            }
        }
    }
    result.sort((a, b) => a[0].name.localeCompare(b[0].name));
    return result;
}
exports.getAPIKeyAuthArray = getAPIKeyAuthArray;
function updateFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
exports.updateFirstLetter = updateFirstLetter;
function getResponseJson(operationObject) {
    var _a, _b;
    let json = {};
    for (const code of constants_1.ConstantString.ResponseCodeFor20X) {
        const responseObject = (_a = operationObject === null || operationObject === void 0 ? void 0 : operationObject.responses) === null || _a === void 0 ? void 0 : _a[code];
        if ((_b = responseObject === null || responseObject === void 0 ? void 0 : responseObject.content) === null || _b === void 0 ? void 0 : _b["application/json"]) {
            json = responseObject.content["application/json"];
            break;
        }
    }
    return json;
}
exports.getResponseJson = getResponseJson;
function convertPathToCamelCase(path) {
    const pathSegments = path.split(/[./{]/);
    const camelCaseSegments = pathSegments.map((segment) => {
        segment = segment.replace(/}/g, "");
        return segment.charAt(0).toUpperCase() + segment.slice(1);
    });
    const camelCasePath = camelCaseSegments.join("");
    return camelCasePath;
}
exports.convertPathToCamelCase = convertPathToCamelCase;
function getUrlProtocol(urlString) {
    try {
        const url = new URL(urlString);
        return url.protocol;
    }
    catch (err) {
        return undefined;
    }
}
exports.getUrlProtocol = getUrlProtocol;
function resolveServerUrl(url) {
    const placeHolderReg = /\${{\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*}}/g;
    let matches = placeHolderReg.exec(url);
    let newUrl = url;
    while (matches != null) {
        const envVar = matches[1];
        const envVal = process.env[envVar];
        if (!envVal) {
            throw new Error(format(constants_1.ConstantString.ResolveServerUrlFailed, envVar));
        }
        else {
            newUrl = newUrl.replace(matches[0], envVal);
        }
        matches = placeHolderReg.exec(url);
    }
    return newUrl;
}
exports.resolveServerUrl = resolveServerUrl;
function checkServerUrl(servers) {
    const errors = [];
    let serverUrl;
    try {
        serverUrl = resolveServerUrl(servers[0].url);
    }
    catch (err) {
        errors.push({
            type: interfaces_1.ErrorType.ResolveServerUrlFailed,
            content: err.message,
            data: servers,
        });
        return errors;
    }
    const protocol = getUrlProtocol(serverUrl);
    if (!protocol) {
        // Relative server url is not supported
        errors.push({
            type: interfaces_1.ErrorType.RelativeServerUrlNotSupported,
            content: constants_1.ConstantString.RelativeServerUrlNotSupported,
            data: servers,
        });
    }
    else if (protocol !== "https:") {
        // Http server url is not supported
        const protocolString = protocol.slice(0, -1);
        errors.push({
            type: interfaces_1.ErrorType.UrlProtocolNotSupported,
            content: format(constants_1.ConstantString.UrlProtocolNotSupported, protocol.slice(0, -1)),
            data: protocolString,
        });
    }
    return errors;
}
exports.checkServerUrl = checkServerUrl;
function validateServer(spec, allowMissingId, allowAPIKeyAuth) {
    const errors = [];
    let hasTopLevelServers = false;
    let hasPathLevelServers = false;
    let hasOperationLevelServers = false;
    if (spec.servers && spec.servers.length >= 1) {
        hasTopLevelServers = true;
        // for multiple server, we only use the first url
        const serverErrors = checkServerUrl(spec.servers);
        errors.push(...serverErrors);
    }
    const paths = spec.paths;
    for (const path in paths) {
        const methods = paths[path];
        if ((methods === null || methods === void 0 ? void 0 : methods.servers) && methods.servers.length >= 1) {
            hasPathLevelServers = true;
            const serverErrors = checkServerUrl(methods.servers);
            errors.push(...serverErrors);
        }
        for (const method in methods) {
            const operationObject = methods[method];
            if (isSupportedApi(method, path, spec, allowMissingId, allowAPIKeyAuth)) {
                if ((operationObject === null || operationObject === void 0 ? void 0 : operationObject.servers) && operationObject.servers.length >= 1) {
                    hasOperationLevelServers = true;
                    const serverErrors = checkServerUrl(operationObject.servers);
                    errors.push(...serverErrors);
                }
            }
        }
    }
    if (!hasTopLevelServers && !hasPathLevelServers && !hasOperationLevelServers) {
        errors.push({
            type: interfaces_1.ErrorType.NoServerInformation,
            content: constants_1.ConstantString.NoServerInformation,
        });
    }
    return errors;
}
exports.validateServer = validateServer;
function isWellKnownName(name, wellknownNameList) {
    for (let i = 0; i < wellknownNameList.length; i++) {
        name = name.replace(/_/g, "").replace(/-/g, "");
        if (name.toLowerCase().includes(wellknownNameList[i])) {
            return true;
        }
    }
    return false;
}
exports.isWellKnownName = isWellKnownName;
function generateParametersFromSchema(schema, name, isRequired = false) {
    var _a, _b;
    const requiredParams = [];
    const optionalParams = [];
    if (schema.type === "string" ||
        schema.type === "integer" ||
        schema.type === "boolean" ||
        schema.type === "number") {
        const parameter = {
            name: name,
            title: updateFirstLetter(name).slice(0, constants_1.ConstantString.ParameterTitleMaxLens),
            description: ((_a = schema.description) !== null && _a !== void 0 ? _a : "").slice(0, constants_1.ConstantString.ParameterDescriptionMaxLens),
        };
        if (isRequired && schema.default === undefined) {
            requiredParams.push(parameter);
        }
        else {
            optionalParams.push(parameter);
        }
    }
    else if (schema.type === "object") {
        const { properties } = schema;
        for (const property in properties) {
            let isRequired = false;
            if (schema.required && ((_b = schema.required) === null || _b === void 0 ? void 0 : _b.indexOf(property)) >= 0) {
                isRequired = true;
            }
            const [requiredP, optionalP] = generateParametersFromSchema(properties[property], property, isRequired);
            requiredParams.push(...requiredP);
            optionalParams.push(...optionalP);
        }
    }
    return [requiredParams, optionalParams];
}
exports.generateParametersFromSchema = generateParametersFromSchema;
function parseApiInfo(operationItem) {
    var _a, _b;
    const requiredParams = [];
    const optionalParams = [];
    const paramObject = operationItem.parameters;
    if (paramObject) {
        paramObject.forEach((param) => {
            var _a;
            const parameter = {
                name: param.name,
                title: updateFirstLetter(param.name).slice(0, constants_1.ConstantString.ParameterTitleMaxLens),
                description: ((_a = param.description) !== null && _a !== void 0 ? _a : "").slice(0, constants_1.ConstantString.ParameterDescriptionMaxLens),
            };
            const schema = param.schema;
            if (param.in !== "header" && param.in !== "cookie") {
                if (param.required && (schema === null || schema === void 0 ? void 0 : schema.default) === undefined) {
                    requiredParams.push(parameter);
                }
                else {
                    optionalParams.push(parameter);
                }
            }
        });
    }
    if (operationItem.requestBody) {
        const requestBody = operationItem.requestBody;
        const requestJson = requestBody.content["application/json"];
        if (Object.keys(requestJson).length !== 0) {
            const schema = requestJson.schema;
            const [requiredP, optionalP] = generateParametersFromSchema(schema, "requestBody", requestBody.required);
            requiredParams.push(...requiredP);
            optionalParams.push(...optionalP);
        }
    }
    const operationId = operationItem.operationId;
    const parameters = [];
    if (requiredParams.length !== 0) {
        parameters.push(...requiredParams);
    }
    else {
        parameters.push(optionalParams[0]);
    }
    const command = {
        context: ["compose"],
        type: "query",
        title: ((_a = operationItem.summary) !== null && _a !== void 0 ? _a : "").slice(0, constants_1.ConstantString.CommandTitleMaxLens),
        id: operationId,
        parameters: parameters,
        description: ((_b = operationItem.description) !== null && _b !== void 0 ? _b : "").slice(0, constants_1.ConstantString.CommandDescriptionMaxLens),
    };
    let warning = undefined;
    if (requiredParams.length === 0 && optionalParams.length > 1) {
        warning = {
            type: interfaces_1.WarningType.OperationOnlyContainsOptionalParam,
            content: format(constants_1.ConstantString.OperationOnlyContainsOptionalParam, operationId),
            data: operationId,
        };
    }
    return [command, warning];
}
exports.parseApiInfo = parseApiInfo;
function listSupportedAPIs(spec, allowMissingId, allowAPIKeyAuth) {
    const paths = spec.paths;
    const result = {};
    for (const path in paths) {
        const methods = paths[path];
        for (const method in methods) {
            // For developer preview, only support GET operation with only 1 parameter without auth
            if (isSupportedApi(method, path, spec, allowMissingId, allowAPIKeyAuth)) {
                const operationObject = methods[method];
                result[`${method.toUpperCase()} ${path}`] = operationObject;
            }
        }
    }
    return result;
}
exports.listSupportedAPIs = listSupportedAPIs;
function validateSpec(spec, parser, isSwaggerFile, allowMissingId, allowAPIKeyAuth) {
    const errors = [];
    const warnings = [];
    if (isSwaggerFile) {
        warnings.push({
            type: interfaces_1.WarningType.ConvertSwaggerToOpenAPI,
            content: constants_1.ConstantString.ConvertSwaggerToOpenAPI,
        });
    }
    // Server validation
    const serverErrors = validateServer(spec, allowMissingId, allowAPIKeyAuth);
    errors.push(...serverErrors);
    // Remote reference not supported
    const refPaths = parser.$refs.paths();
    // refPaths [0] is the current spec file path
    if (refPaths.length > 1) {
        errors.push({
            type: interfaces_1.ErrorType.RemoteRefNotSupported,
            content: format(constants_1.ConstantString.RemoteRefNotSupported, refPaths.join(", ")),
            data: refPaths,
        });
    }
    // No supported API
    const apiMap = listSupportedAPIs(spec, allowMissingId, allowAPIKeyAuth);
    if (Object.keys(apiMap).length === 0) {
        errors.push({
            type: interfaces_1.ErrorType.NoSupportedApi,
            content: constants_1.ConstantString.NoSupportedApi,
        });
    }
    // OperationId missing
    const apisMissingOperationId = [];
    for (const key in apiMap) {
        const pathObjectItem = apiMap[key];
        if (!pathObjectItem.operationId) {
            apisMissingOperationId.push(key);
        }
    }
    if (apisMissingOperationId.length > 0) {
        warnings.push({
            type: interfaces_1.WarningType.OperationIdMissing,
            content: format(constants_1.ConstantString.MissingOperationId, apisMissingOperationId.join(", ")),
            data: apisMissingOperationId,
        });
    }
    let status = interfaces_1.ValidationStatus.Valid;
    if (warnings.length > 0 && errors.length === 0) {
        status = interfaces_1.ValidationStatus.Warning;
    }
    else if (errors.length > 0) {
        status = interfaces_1.ValidationStatus.Error;
    }
    return {
        status,
        warnings,
        errors,
    };
}
exports.validateSpec = validateSpec;
function format(str, ...args) {
    let index = 0;
    return str.replace(/%s/g, () => {
        const arg = args[index++];
        return arg !== undefined ? arg : "";
    });
}
exports.format = format;
function getSafeRegistrationIdEnvName(authName) {
    if (!authName) {
        return "";
    }
    let safeRegistrationIdEnvName = authName.toUpperCase().replace(/[^A-Z0-9_]/g, "_");
    if (!safeRegistrationIdEnvName.match(/^[A-Z]/)) {
        safeRegistrationIdEnvName = "PREFIX_" + safeRegistrationIdEnvName;
    }
    return safeRegistrationIdEnvName;
}
exports.getSafeRegistrationIdEnvName = getSafeRegistrationIdEnvName;
//# sourceMappingURL=utils.js.map