// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.inferPreviewCardTemplate = exports.wrapAdaptiveCard = void 0;
const constants_1 = require("./constants");
const utils_1 = require("./utils");
function wrapAdaptiveCard(card, jsonPath) {
    const result = {
        version: constants_1.ConstantString.WrappedCardVersion,
        $schema: constants_1.ConstantString.WrappedCardSchema,
        jsonPath: jsonPath,
        responseLayout: constants_1.ConstantString.WrappedCardResponseLayout,
        responseCardTemplate: card,
        previewCardTemplate: inferPreviewCardTemplate(card),
    };
    return result;
}
exports.wrapAdaptiveCard = wrapAdaptiveCard;
/**
 * Infers the preview card template from an Adaptive Card and a JSON path.
 * The preview card template includes a title and an optional subtitle and image.
 * It populates the preview card template with the first text block that matches
 * each well-known name, in the order of title, subtitle, and image.
 * If no text block matches the title or subtitle, it uses the first two text block as the title and subtitle.
 * If the title is still empty and the subtitle is not empty, it uses subtitle as the title.
 * @param card The Adaptive Card to infer the preview card template from.
 * @param jsonPath The JSON path to the root object in the card body.
 * @returns The inferred preview card template.
 */
function inferPreviewCardTemplate(card) {
    var _a;
    const result = {
        title: "",
    };
    const textBlockElements = new Set();
    let rootObject;
    if (((_a = card.body[0]) === null || _a === void 0 ? void 0 : _a.type) === constants_1.ConstantString.ContainerType) {
        rootObject = card.body[0].items;
    }
    else {
        rootObject = card.body;
    }
    for (const element of rootObject) {
        if (element.type === constants_1.ConstantString.TextBlockType) {
            const textElement = element;
            const index = textElement.text.indexOf("${if(");
            if (index > 0) {
                textElement.text = textElement.text.substring(index);
                textBlockElements.add(textElement);
            }
        }
    }
    for (const element of textBlockElements) {
        const text = element.text;
        if (!result.title && utils_1.isWellKnownName(text, constants_1.ConstantString.WellknownTitleName)) {
            result.title = text;
            textBlockElements.delete(element);
        }
        else if (!result.subtitle && utils_1.isWellKnownName(text, constants_1.ConstantString.WellknownSubtitleName)) {
            result.subtitle = text;
            textBlockElements.delete(element);
        }
        else if (!result.image && utils_1.isWellKnownName(text, constants_1.ConstantString.WellknownImageName)) {
            const match = text.match(/\${if\(([^,]+),/);
            const property = match ? match[1] : "";
            if (property) {
                result.image = {
                    url: `\${${property}}`,
                    alt: text,
                    $when: `\${${property} != null}`,
                };
            }
            textBlockElements.delete(element);
        }
    }
    for (const element of textBlockElements) {
        const text = element.text;
        if (!result.title) {
            result.title = text;
            textBlockElements.delete(element);
        }
        else if (!result.subtitle) {
            result.subtitle = text;
            textBlockElements.delete(element);
        }
    }
    if (!result.title && result.subtitle) {
        result.title = result.subtitle;
        delete result.subtitle;
    }
    if (!result.title) {
        result.title = "result";
    }
    return result;
}
exports.inferPreviewCardTemplate = inferPreviewCardTemplate;
//# sourceMappingURL=adaptiveCardWrapper.js.map