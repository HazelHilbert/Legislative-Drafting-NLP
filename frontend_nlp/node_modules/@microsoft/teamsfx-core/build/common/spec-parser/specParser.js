// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpecParser = void 0;
const tslib_1 = require("tslib");
const swagger_parser_1 = tslib_1.__importDefault(require("@apidevtools/swagger-parser"));
const swagger2openapi_1 = tslib_1.__importDefault(require("swagger2openapi"));
const js_yaml_1 = tslib_1.__importDefault(require("js-yaml"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const interfaces_1 = require("./interfaces");
const constants_1 = require("./constants");
const specParserError_1 = require("./specParserError");
const specFilter_1 = require("./specFilter");
const utils_1 = require("./utils");
const manifestUpdater_1 = require("./manifestUpdater");
const adaptiveCardGenerator_1 = require("./adaptiveCardGenerator");
const adaptiveCardWrapper_1 = require("./adaptiveCardWrapper");
/**
 * A class that parses an OpenAPI specification file and provides methods to validate, list, and generate artifacts.
 */
class SpecParser {
    /**
     * Creates a new instance of the SpecParser class.
     * @param pathOrDoc The path to the OpenAPI specification file or the OpenAPI specification object.
     * @param options The options for parsing the OpenAPI specification file.
     */
    constructor(pathOrDoc, options) {
        this.defaultOptions = {
            allowMissingId: true,
            allowSwagger: true,
            allowAPIKeyAuth: false,
        };
        this.pathOrSpec = pathOrDoc;
        this.parser = new swagger_parser_1.default();
        this.options = Object.assign(Object.assign({}, this.defaultOptions), (options !== null && options !== void 0 ? options : {}));
    }
    /**
     * Validates the OpenAPI specification file and returns a validation result.
     *
     * @returns A validation result object that contains information about any errors or warnings in the specification file.
     */
    async validate() {
        try {
            try {
                await this.loadSpec();
                await this.parser.validate(this.spec);
            }
            catch (e) {
                return {
                    status: interfaces_1.ValidationStatus.Error,
                    warnings: [],
                    errors: [{ type: interfaces_1.ErrorType.SpecNotValid, content: e.toString() }],
                };
            }
            if (!this.options.allowSwagger && this.isSwaggerFile) {
                return {
                    status: interfaces_1.ValidationStatus.Error,
                    warnings: [],
                    errors: [
                        { type: interfaces_1.ErrorType.SwaggerNotSupported, content: constants_1.ConstantString.SwaggerNotSupported },
                    ],
                };
            }
            return utils_1.validateSpec(this.spec, this.parser, !!this.isSwaggerFile, this.options.allowMissingId, this.options.allowAPIKeyAuth);
        }
        catch (err) {
            throw new specParserError_1.SpecParserError(err.toString(), interfaces_1.ErrorType.ValidateFailed);
        }
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async listSupportedAPIInfo() {
        throw new Error("Method not implemented.");
    }
    /**
     * Lists all the OpenAPI operations in the specification file.
     * @returns A string array that represents the HTTP method and path of each operation, such as ['GET /pets/{petId}', 'GET /user/{userId}']
     * according to copilot plugin spec, only list get and post method without auth
     */
    async list() {
        var _a;
        try {
            await this.loadSpec();
            const spec = this.spec;
            const apiMap = this.getAllSupportedAPIs(spec);
            const result = [];
            for (const apiKey in apiMap) {
                const apiResult = {
                    api: "",
                    server: "",
                    operationId: "",
                };
                const [method, path] = apiKey.split(" ");
                const operation = apiMap[apiKey];
                const rootServer = spec.servers && spec.servers[0];
                const methodServer = spec.paths[path].servers && ((_a = spec.paths[path]) === null || _a === void 0 ? void 0 : _a.servers[0]);
                const operationServer = operation.servers && operation.servers[0];
                const serverUrl = operationServer || methodServer || rootServer;
                if (!serverUrl) {
                    throw new specParserError_1.SpecParserError(constants_1.ConstantString.NoServerInformation, interfaces_1.ErrorType.NoServerInformation);
                }
                apiResult.server = serverUrl.url;
                let operationId = operation.operationId;
                if (!operationId) {
                    operationId = `${method.toLowerCase()}${utils_1.convertPathToCamelCase(path)}`;
                }
                apiResult.operationId = operationId;
                const apiKeyAuthArray = utils_1.getAPIKeyAuthArray(operation.security, spec);
                for (const apiKeyAuth of apiKeyAuthArray) {
                    if (apiKeyAuth.length === 1) {
                        apiResult.auth = apiKeyAuth[0];
                        break;
                    }
                }
                apiResult.api = apiKey;
                result.push(apiResult);
            }
            return result;
        }
        catch (err) {
            if (err instanceof specParserError_1.SpecParserError) {
                throw err;
            }
            throw new specParserError_1.SpecParserError(err.toString(), interfaces_1.ErrorType.ListFailed);
        }
    }
    /**
     * Generates and update artifacts from the OpenAPI specification file. Generate Adaptive Cards, update Teams app manifest, and generate a new OpenAPI specification file.
     * @param manifestPath A file path of the Teams app manifest file to update.
     * @param filter An array of strings that represent the filters to apply when generating the artifacts. If filter is empty, it would process nothing.
     * @param outputSpecPath File path of the new OpenAPI specification file to generate. If not specified or empty, no spec file will be generated.
     * @param adaptiveCardFolder Folder path where the Adaptive Card files will be generated. If not specified or empty, Adaptive Card files will not be generated.
     */
    async generate(manifestPath, filter, outputSpecPath, adaptiveCardFolder, signal) {
        const result = {
            allSuccess: true,
            warnings: [],
        };
        try {
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new specParserError_1.SpecParserError(constants_1.ConstantString.CancelledMessage, interfaces_1.ErrorType.Cancelled);
            }
            await this.loadSpec();
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new specParserError_1.SpecParserError(constants_1.ConstantString.CancelledMessage, interfaces_1.ErrorType.Cancelled);
            }
            const newUnResolvedSpec = specFilter_1.specFilter(filter, this.unResolveSpec, this.spec, this.options.allowMissingId, this.options.allowAPIKeyAuth);
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new specParserError_1.SpecParserError(constants_1.ConstantString.CancelledMessage, interfaces_1.ErrorType.Cancelled);
            }
            const newSpec = (await this.parser.dereference(newUnResolvedSpec));
            const operationIdToAPIAuthKey = new Map();
            let hasMultipleAPIKeyAuth = false;
            let firstAuthKey;
            for (const url in newSpec.paths) {
                for (const method in newSpec.paths[url]) {
                    const operation = newSpec.paths[url][method];
                    const apiKeyAuthArr = utils_1.getAPIKeyAuthArray(operation.security, newSpec);
                    // Currently we don't support multiple apiKey auth
                    if (apiKeyAuthArr.length > 0 && apiKeyAuthArr.every((auths) => auths.length > 1)) {
                        hasMultipleAPIKeyAuth = true;
                        break;
                    }
                    if (apiKeyAuthArr && apiKeyAuthArr.length > 0) {
                        if (!firstAuthKey) {
                            firstAuthKey = apiKeyAuthArr[0][0];
                        }
                        else if (firstAuthKey.name !== apiKeyAuthArr[0][0].name) {
                            hasMultipleAPIKeyAuth = true;
                            break;
                        }
                        operationIdToAPIAuthKey.set(operation.operationId, apiKeyAuthArr[0][0]);
                    }
                }
            }
            if (hasMultipleAPIKeyAuth) {
                throw new specParserError_1.SpecParserError(constants_1.ConstantString.MultipleAPIKeyNotSupported, interfaces_1.ErrorType.MultipleAPIKeyNotSupported);
            }
            let resultStr;
            if (outputSpecPath.endsWith(".yaml") || outputSpecPath.endsWith(".yml")) {
                resultStr = js_yaml_1.default.dump(newUnResolvedSpec);
            }
            else {
                resultStr = JSON.stringify(newUnResolvedSpec, null, 2);
            }
            await fs_extra_1.default.outputFile(outputSpecPath, resultStr);
            for (const url in newSpec.paths) {
                for (const method in newSpec.paths[url]) {
                    const operation = newSpec.paths[url][method];
                    try {
                        const [card, jsonPath] = adaptiveCardGenerator_1.generateAdaptiveCard(operation);
                        const fileName = path_1.default.join(adaptiveCardFolder, `${operation.operationId}.json`);
                        const wrappedCard = adaptiveCardWrapper_1.wrapAdaptiveCard(card, jsonPath);
                        await fs_extra_1.default.outputJSON(fileName, wrappedCard, { spaces: 2 });
                    }
                    catch (err) {
                        result.allSuccess = false;
                        result.warnings.push({
                            type: interfaces_1.WarningType.GenerateCardFailed,
                            content: err.toString(),
                            data: operation.operationId,
                        });
                    }
                }
            }
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new specParserError_1.SpecParserError(constants_1.ConstantString.CancelledMessage, interfaces_1.ErrorType.Cancelled);
            }
            const [updatedManifest, warnings] = await manifestUpdater_1.updateManifest(manifestPath, outputSpecPath, adaptiveCardFolder, newSpec, firstAuthKey === null || firstAuthKey === void 0 ? void 0 : firstAuthKey.name);
            await fs_extra_1.default.outputJSON(manifestPath, updatedManifest, { spaces: 2 });
            result.warnings.push(...warnings);
        }
        catch (err) {
            if (err instanceof specParserError_1.SpecParserError) {
                throw err;
            }
            throw new specParserError_1.SpecParserError(err.toString(), interfaces_1.ErrorType.GenerateFailed);
        }
        return result;
    }
    async loadSpec() {
        if (!this.spec) {
            this.unResolveSpec = (await this.parser.parse(this.pathOrSpec));
            // Convert swagger 2.0 to openapi 3.0
            if (!this.unResolveSpec.openapi && this.unResolveSpec.swagger === "2.0") {
                const specObj = await swagger2openapi_1.default.convert(this.unResolveSpec, {});
                this.unResolveSpec = specObj.openapi;
                this.isSwaggerFile = true;
            }
            const clonedUnResolveSpec = JSON.parse(JSON.stringify(this.unResolveSpec));
            this.spec = (await this.parser.dereference(clonedUnResolveSpec));
        }
    }
    getAllSupportedAPIs(spec) {
        if (this.apiMap !== undefined) {
            return this.apiMap;
        }
        const result = utils_1.listSupportedAPIs(spec, this.options.allowMissingId, this.options.allowAPIKeyAuth);
        this.apiMap = result;
        return result;
    }
}
exports.SpecParser = SpecParser;
//# sourceMappingURL=specParser.js.map