// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpecParser = void 0;
const tslib_1 = require("tslib");
const swagger_parser_1 = tslib_1.__importDefault(require("@apidevtools/swagger-parser"));
const interfaces_1 = require("./interfaces");
const specParserError_1 = require("./specParserError");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
/**
 * A class that parses an OpenAPI specification file and provides methods to validate, list, and generate artifacts.
 */
class SpecParser {
    /**
     * Creates a new instance of the SpecParser class.
     * @param pathOrDoc The path to the OpenAPI specification file or the OpenAPI specification object.
     * @param options The options for parsing the OpenAPI specification file.
     */
    constructor(pathOrDoc, options) {
        this.defaultOptions = {
            allowMissingId: false,
            allowSwagger: false,
            allowAPIKeyAuth: false,
        };
        this.pathOrSpec = pathOrDoc;
        this.parser = new swagger_parser_1.default();
        this.options = Object.assign(Object.assign({}, this.defaultOptions), (options !== null && options !== void 0 ? options : {}));
    }
    /**
     * Validates the OpenAPI specification file and returns a validation result.
     *
     * @returns A validation result object that contains information about any errors or warnings in the specification file.
     */
    async validate() {
        try {
            try {
                await this.loadSpec();
                await this.parser.validate(this.spec);
            }
            catch (e) {
                return {
                    status: interfaces_1.ValidationStatus.Error,
                    warnings: [],
                    errors: [{ type: interfaces_1.ErrorType.SpecNotValid, content: e.toString() }],
                };
            }
            if (!this.options.allowSwagger && this.isSwaggerFile) {
                return {
                    status: interfaces_1.ValidationStatus.Error,
                    warnings: [],
                    errors: [
                        { type: interfaces_1.ErrorType.SwaggerNotSupported, content: constants_1.ConstantString.SwaggerNotSupported },
                    ],
                };
            }
            return utils_1.validateSpec(this.spec, this.parser, !!this.isSwaggerFile, this.options.allowMissingId, this.options.allowAPIKeyAuth);
        }
        catch (err) {
            throw new specParserError_1.SpecParserError(err.toString(), interfaces_1.ErrorType.ValidateFailed);
        }
    }
    async listSupportedAPIInfo() {
        try {
            await this.loadSpec();
            const apiMap = this.getAllSupportedAPIs(this.spec);
            const apiInfos = [];
            for (const key in apiMap) {
                const pathObjectItem = apiMap[key];
                const [method, path] = key.split(" ");
                const operationId = pathObjectItem.operationId;
                // In Browser environment, this api is by default not support api without operationId
                if (!operationId) {
                    continue;
                }
                const [command, warning] = utils_1.parseApiInfo(pathObjectItem);
                const apiInfo = {
                    method: method,
                    path: path,
                    title: command.title,
                    id: operationId,
                    parameters: command.parameters,
                    description: command.description,
                };
                if (warning) {
                    apiInfo.warning = warning;
                }
                apiInfos.push(apiInfo);
            }
            return apiInfos;
        }
        catch (err) {
            throw new specParserError_1.SpecParserError(err.toString(), interfaces_1.ErrorType.listSupportedAPIInfoFailed);
        }
    }
    /**
     * Lists all the OpenAPI operations in the specification file.
     * @returns A string array that represents the HTTP method and path of each operation, such as ['GET /pets/{petId}', 'GET /user/{userId}']
     * according to copilot plugin spec, only list get and post method without auth
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async list() {
        throw new Error("Method not implemented.");
    }
    /**
     * Generates and update artifacts from the OpenAPI specification file. Generate Adaptive Cards, update Teams app manifest, and generate a new OpenAPI specification file.
     * @param manifestPath A file path of the Teams app manifest file to update.
     * @param filter An array of strings that represent the filters to apply when generating the artifacts. If filter is empty, it would process nothing.
     * @param outputSpecPath File path of the new OpenAPI specification file to generate. If not specified or empty, no spec file will be generated.
     * @param adaptiveCardFolder Folder path where the Adaptive Card files will be generated. If not specified or empty, Adaptive Card files will not be generated.
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async generate(manifestPath, filter, outputSpecPath, adaptiveCardFolder, signal) {
        throw new Error("Method not implemented.");
    }
    async loadSpec() {
        if (!this.spec) {
            this.unResolveSpec = (await this.parser.parse(this.pathOrSpec));
            if (!this.unResolveSpec.openapi && this.unResolveSpec.swagger === "2.0") {
                this.isSwaggerFile = true;
            }
            const clonedUnResolveSpec = JSON.parse(JSON.stringify(this.unResolveSpec));
            this.spec = (await this.parser.dereference(clonedUnResolveSpec));
        }
    }
    getAllSupportedAPIs(spec) {
        if (this.apiMap !== undefined) {
            return this.apiMap;
        }
        const result = utils_1.listSupportedAPIs(spec, this.options.allowMissingId, this.options.allowAPIKeyAuth);
        this.apiMap = result;
        return result;
    }
}
exports.SpecParser = SpecParser;
//# sourceMappingURL=specParser.browser.js.map