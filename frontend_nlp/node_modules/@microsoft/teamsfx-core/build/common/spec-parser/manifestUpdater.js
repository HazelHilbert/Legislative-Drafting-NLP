// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRelativePath = exports.generateCommands = exports.updateManifest = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const interfaces_1 = require("./interfaces");
const utils_1 = require("./utils");
const specParserError_1 = require("./specParserError");
const constants_1 = require("./constants");
async function updateManifest(manifestPath, outputSpecPath, adaptiveCardFolder, spec, apiKeyAuthName) {
    var _a, _b;
    try {
        const originalManifest = await fs_extra_1.default.readJSON(manifestPath);
        const [commands, warnings] = await generateCommands(spec, adaptiveCardFolder, manifestPath);
        const ComposeExtension = {
            composeExtensionType: "apiBased",
            apiSpecificationFile: getRelativePath(manifestPath, outputSpecPath),
            commands: commands,
        };
        if (apiKeyAuthName) {
            const safeApiSecretRegistrationId = utils_1.getSafeRegistrationIdEnvName(`${apiKeyAuthName}_${constants_1.ConstantString.RegistrationIdPostfix}`);
            ComposeExtension.authorization = {
                authType: "apiSecretServiceAuth",
                apiSecretServiceAuthConfiguration: {
                    apiSecretRegistrationId: `\${{${safeApiSecretRegistrationId}}}`,
                },
            };
        }
        const updatedPart = {
            description: {
                short: spec.info.title.slice(0, constants_1.ConstantString.ShortDescriptionMaxLens),
                full: (_b = ((_a = spec.info.description) !== null && _a !== void 0 ? _a : originalManifest.description.full)) === null || _b === void 0 ? void 0 : _b.slice(0, constants_1.ConstantString.FullDescriptionMaxLens),
            },
            composeExtensions: [ComposeExtension],
        };
        const updatedManifest = Object.assign(Object.assign({}, originalManifest), updatedPart);
        return [updatedManifest, warnings];
    }
    catch (err) {
        throw new specParserError_1.SpecParserError(err.toString(), interfaces_1.ErrorType.UpdateManifestFailed);
    }
}
exports.updateManifest = updateManifest;
async function generateCommands(spec, adaptiveCardFolder, manifestPath) {
    const paths = spec.paths;
    const commands = [];
    const warnings = [];
    if (paths) {
        for (const pathUrl in paths) {
            const pathItem = paths[pathUrl];
            if (pathItem) {
                const operations = pathItem;
                // Currently only support GET and POST method
                for (const method in operations) {
                    if (method === constants_1.ConstantString.PostMethod || method === constants_1.ConstantString.GetMethod) {
                        const operationItem = operations[method];
                        if (operationItem) {
                            const [command, warning] = utils_1.parseApiInfo(operationItem);
                            const adaptiveCardPath = path_1.default.join(adaptiveCardFolder, command.id + ".json");
                            command.apiResponseRenderingTemplateFile = (await fs_extra_1.default.pathExists(adaptiveCardPath))
                                ? getRelativePath(manifestPath, adaptiveCardPath)
                                : "";
                            if (warning) {
                                warnings.push(warning);
                            }
                            commands.push(command);
                        }
                    }
                }
            }
        }
    }
    return [commands, warnings];
}
exports.generateCommands = generateCommands;
function getRelativePath(from, to) {
    const relativePath = path_1.default.relative(path_1.default.dirname(from), to);
    return path_1.default.normalize(relativePath).replace(/\\/g, "/");
}
exports.getRelativePath = getRelativePath;
//# sourceMappingURL=manifestUpdater.js.map