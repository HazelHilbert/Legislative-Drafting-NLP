// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalEnvManager = void 0;
const tslib_1 = require("tslib");
const commentJson = tslib_1.__importStar(require("comment-json"));
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const npmLogHelper_1 = require("./npmLogHelper");
const portChecker_1 = require("./portChecker");
class LocalEnvManager {
    constructor(logger, telemetry, ui) {
        this.logger = logger;
        this.telemetry = telemetry;
        this.ui = ui;
    }
    async getNpmInstallLogInfo() {
        return await npmLogHelper_1.getNpmInstallLogInfo();
    }
    async getPortsInUse(ports) {
        return await portChecker_1.getPortsInUse(ports, this.logger);
    }
    async getTaskJson(projectPath) {
        try {
            const taskFilePath = path.resolve(projectPath, ".vscode", "tasks.json");
            const content = await fs.readFile(taskFilePath, "utf-8");
            return commentJson.parse(content);
        }
        catch (_a) {
            return undefined;
        }
    }
    // Test Tool log format:
    //  error Some error happens
    //  warn Some warning happens
    async getTestToolLogInfo(projectPath) {
        const logPath = path.resolve(projectPath, "devTools", "teamsapptesttool.log");
        const resultLines = [];
        try {
            const logs = await fs.readFile(logPath, "utf-8");
            // send only error logs without multi-line stack to minimize GDPR issue
            for (const line of logs.split(/\r?\n/)) {
                if (line.match(/^error .*/i)) {
                    resultLines.push(line);
                }
            }
            return resultLines.join("\n");
        }
        catch (_a) {
            // ignore telemetry error
            return undefined;
        }
    }
}
exports.LocalEnvManager = LocalEnvManager;
//# sourceMappingURL=localEnvManager.js.map