// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkNpmDependencies = exports.loadTeamsFxDevScript = exports.loadPackageJson = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const Arborist = require("@npmcli/arborist");
const npmRunDevRegex = /npm[\s]+run[\s]+dev/im;
async function loadPackageJson(path, logger) {
    if (!(await fs.pathExists(path))) {
        logger === null || logger === void 0 ? void 0 : logger.error(`Cannot load package.json from ${path}. File not found.`);
        return undefined;
    }
    const rpj = require("read-package-json-fast");
    try {
        return await rpj(path);
    }
    catch (error) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        logger === null || logger === void 0 ? void 0 : logger.error(`Cannot load package.json from ${path}. Error: ${error}`);
        return undefined;
    }
}
exports.loadPackageJson = loadPackageJson;
async function loadTeamsFxDevScript(componentRoot) {
    const packageJson = await loadPackageJson(path.join(componentRoot, "package.json"));
    if (packageJson && packageJson.scripts && packageJson.scripts["dev:teamsfx"]) {
        const devTeamsfx = packageJson.scripts["dev:teamsfx"];
        return npmRunDevRegex.test(devTeamsfx) ? packageJson.scripts["dev"] : devTeamsfx;
    }
    else {
        return undefined;
    }
}
exports.loadTeamsFxDevScript = loadTeamsFxDevScript;
async function checkNpmDependencies(folder) {
    var _a;
    if (await fs.pathExists(folder)) {
        const packageJson = await loadPackageJson(path.join(folder, "package.json"));
        if (((packageJson === null || packageJson === void 0 ? void 0 : packageJson.dependencies) && Object.keys(packageJson === null || packageJson === void 0 ? void 0 : packageJson.dependencies).length > 0) ||
            ((packageJson === null || packageJson === void 0 ? void 0 : packageJson.devDependencies) && Object.keys(packageJson === null || packageJson === void 0 ? void 0 : packageJson.devDependencies).length > 0)) {
            // load deps from node_modules
            const arb = new Arborist({ path: folder });
            try {
                await arb.loadActual();
            }
            catch (error) {
                return false;
            }
            // check if any missing dependency
            const dependencies = ((_a = arb.actualTree) === null || _a === void 0 ? void 0 : _a.edgesOut) === undefined ? [] : [...arb.actualTree.edgesOut.values()];
            return !dependencies.some((dependency) => dependency.error === "MISSING");
        }
        else {
            // treat no deps as npm installed
            return true;
        }
    }
    // treat missing folder as npm installed
    return true;
}
exports.checkNpmDependencies = checkNpmDependencies;
//# sourceMappingURL=packageJsonHelper.js.map