// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalCertificateManager = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const node_forge_1 = require("node-forge");
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const uuid_1 = require("uuid");
const constants_1 = require("./constants");
const ps = tslib_1.__importStar(require("./process"));
const error_1 = require("../../core/error");
const localizeUtils_1 = require("../localizeUtils");
const installText = () => localizeUtils_1.getLocalizedString("debug.install");
const learnMoreText = () => localizeUtils_1.getLocalizedString("core.provision.learnMore");
// TODO(xiaofhua): update help link for v3
const learnMoreUrl = "https://aka.ms/teamsfx-ca-certificate";
const warningMessage = () => localizeUtils_1.getLocalizedString("debug.warningMessage");
const confirmMessage = () => warningMessage() + localizeUtils_1.getLocalizedString("debug.warningMessage2");
const trustCertificateCancelError = () => new teamsfx_api_1.UserError({
    source: error_1.CoreSource,
    name: "TrustCertificateCancelError",
    helpLink: learnMoreUrl,
    message: localizeUtils_1.getDefaultString("error.TrustCertificateCancelError"),
    displayMessage: localizeUtils_1.getLocalizedString("error.TrustCertificateCancelError"),
});
class LocalCertificateManager {
    constructor(ui, logger) {
        this.ui = ui;
        this.logger = logger;
        this.certFolder = path
            .normalize(`${os.homedir()}/.${teamsfx_api_1.ConfigFolderName}/certificate`)
            .split(path.sep)
            .join(path.posix.sep);
    }
    /**
     * Local certificates are located at {home}/.fx/certificate/
     * Public certificate should be trusted into user"s certificate store.
     *
     * - Check and generate cert and key files (subject, usage, expiration, ...)
     * - Check cert store if trusted (thumbprint, expiration)
     * - Add to cert store if not trusted (friendly name as well)
     */
    async setupCertificate(needTrust, checkOnly = false) {
        var _a;
        const certFilePath = `${this.certFolder}/${constants_1.LocalDebugCertificate.CertFileName}`;
        const keyFilePath = `${this.certFolder}/${constants_1.LocalDebugCertificate.KeyFileName}`;
        const localCert = {
            certPath: certFilePath,
            keyPath: keyFilePath,
        };
        try {
            let certThumbprint = undefined;
            await fs.ensureDir(this.certFolder);
            if ((await fs.pathExists(certFilePath)) && (await fs.pathExists(keyFilePath))) {
                const certContent = await fs.readFile(certFilePath, { encoding: "utf8" });
                const keyContent = await fs.readFile(keyFilePath, { encoding: "utf8" });
                const verifyRes = this.verifyCertificateContent(certContent, keyContent);
                if (verifyRes[1]) {
                    certThumbprint = verifyRes[0];
                }
            }
            localCert.found = !!certThumbprint;
            if (!certThumbprint) {
                if (checkOnly) {
                    return localCert;
                }
                // generate cert and key
                certThumbprint = await this.generateCertificate(certFilePath, keyFilePath);
            }
            if (needTrust) {
                if (await this.verifyCertificateInStore(certThumbprint)) {
                    // already trusted
                    localCert.isTrusted = true;
                    localCert.alreadyTrusted = true;
                }
                else {
                    localCert.alreadyTrusted = false;
                    if (checkOnly) {
                        return localCert;
                    }
                    await this.trustCertificate(localCert, certThumbprint, constants_1.LocalDebugCertificate.FriendlyName);
                }
            }
        }
        catch (error) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warning(`Failed to setup certificate. Error: ${error}`);
            localCert.isTrusted = false;
            localCert.error = new teamsfx_api_1.UserError({
                error,
                source: error_1.CoreSource,
                name: "SetupCertificateError",
                helpLink: learnMoreUrl,
            });
        }
        finally {
            return localCert;
        }
    }
    async generateCertificate(certFile, keyFile) {
        // prepare attributes and extensions
        const now = new Date();
        const expiry = new Date();
        expiry.setFullYear(expiry.getFullYear() + 1);
        const serialNumber = uuid_1.v4().replace(/-/g, "");
        const attrs = [
            {
                name: "commonName",
                value: "localhost",
            },
        ];
        const exts = [
            {
                name: "basicConstraints",
                cA: false,
            },
            {
                name: "extKeyUsage",
                serverAuth: true,
            },
            {
                name: "subjectAltName",
                altNames: [
                    {
                        type: 2,
                        value: "localhost",
                    },
                ],
            },
        ];
        // generate key and cert
        const keys = node_forge_1.pki.rsa.generateKeyPair({
            bits: 4096,
            algorithm: "sha256",
        });
        const cert = node_forge_1.pki.createCertificate();
        cert.publicKey = keys.publicKey;
        cert.serialNumber = serialNumber;
        cert.validity.notBefore = now;
        cert.validity.notAfter = expiry;
        cert.setSubject(attrs);
        cert.setIssuer(attrs);
        cert.setExtensions(exts);
        cert.sign(keys.privateKey, node_forge_1.md.sha256.create());
        // get thumbprint
        const der = node_forge_1.asn1.toDer(node_forge_1.pki.certificateToAsn1(cert)).getBytes();
        const m = node_forge_1.md.sha1.create();
        m.update(der);
        const thumbprint = m.digest().toHex();
        // output
        const certContent = node_forge_1.pki.certificateToPem(cert);
        const keyContent = node_forge_1.pki.privateKeyToPem(keys.privateKey);
        await fs.writeFile(certFile, certContent, { encoding: "utf8" });
        await fs.writeFile(keyFile, keyContent, { encoding: "utf8" });
        return thumbprint;
    }
    verifyCertificateContent(certContent, keyContent) {
        const thumbprint = undefined;
        try {
            const cert = node_forge_1.pki.certificateFromPem(certContent);
            const privateKey = node_forge_1.pki.privateKeyFromPem(keyContent);
            // get thumbprint
            const der = node_forge_1.asn1.toDer(node_forge_1.pki.certificateToAsn1(cert)).getBytes();
            const m = node_forge_1.md.sha1.create();
            m.update(der);
            const thumbprint = m.digest().toHex();
            // verify key pair
            const expectedPublicKey = node_forge_1.pki.rsa.setPublicKey(privateKey.n, privateKey.e);
            if (node_forge_1.pki.publicKeyToPem(expectedPublicKey) !== node_forge_1.pki.publicKeyToPem(cert.publicKey)) {
                return [thumbprint, false];
            }
            // verify subject and issuer
            const subject = cert.subject.getField("CN");
            if ("localhost" !== subject.value) {
                return [thumbprint, false];
            }
            const issuer = cert.issuer.getField("CN");
            if ("localhost" !== issuer.value) {
                return [thumbprint, false];
            }
            // verify date, add one day buffer
            const now = new Date();
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            const notBefore = cert.validity.notBefore;
            const notAfter = cert.validity.notAfter;
            if (notBefore > now || notAfter < tomorrow) {
                return [thumbprint, false];
            }
            // verify extension
            const basicConstraints = cert.getExtension("basicConstraints");
            if (basicConstraints === undefined ||
                basicConstraints.cA === undefined ||
                basicConstraints.cA) {
                return [thumbprint, false];
            }
            const extKeyUsage = cert.getExtension("extKeyUsage");
            if (extKeyUsage === undefined ||
                extKeyUsage.serverAuth === undefined ||
                !extKeyUsage.serverAuth) {
                return [thumbprint, false];
            }
            const subjectAltName = cert.getExtension("subjectAltName");
            if (subjectAltName === undefined ||
                subjectAltName.altNames === undefined ||
                !subjectAltName.altNames.some((a) => a.type === 2 && a.value === "localhost")) {
                return [thumbprint, false];
            }
            return [thumbprint, true];
        }
        catch (error) {
            // treat any error as not verified, to not block the main progress
            return [thumbprint, false];
        }
    }
    async verifyCertificateInStore(thumbprint) {
        var _a;
        try {
            if (os.type() === "Windows_NT") {
                return await this.checkCertificateWindows(thumbprint);
            }
            else if (os.type() === "Darwin") {
                const listCertCommand = `security find-certificate -c localhost -a -Z -p "${os.homedir()}/Library/Keychains/login.keychain-db"`;
                const existingCertificates = await ps.execShell(listCertCommand);
                if (existingCertificates) {
                    const thumbprintRegex = /SHA-1 hash: ([0-9A-Z]+)/g;
                    let match = undefined;
                    while ((match = thumbprintRegex.exec(existingCertificates))) {
                        const existingThumbprint = match[1];
                        if (existingThumbprint.toUpperCase() === thumbprint.toUpperCase()) {
                            return true;
                        }
                    }
                }
                return false;
            }
            else {
                // TODO: Linux
                return undefined;
            }
        }
        catch (error) {
            // treat any error as not verified, to not block the main progress
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(`Certificate unverified. Details: ${error}`);
            return false;
        }
    }
    async trustCertificate(localCert, thumbprint, friendlyName) {
        var _a;
        try {
            if (os.type() === "Windows_NT") {
                if (!(await this.waitForUserConfirm())) {
                    localCert.isTrusted = false;
                    localCert.error = trustCertificateCancelError();
                    return;
                }
                await this.trustCertificateWindows(localCert, thumbprint, friendlyName);
                localCert.isTrusted = true;
                return;
            }
            else if (os.type() === "Darwin") {
                if (!(await this.waitForUserConfirm())) {
                    localCert.isTrusted = false;
                    localCert.error = trustCertificateCancelError();
                    return;
                }
                await ps.execShell(`security add-trusted-cert -p ssl -k "${os.homedir()}/Library/Keychains/login.keychain-db" "${localCert.certPath}"`);
                localCert.isTrusted = true;
                return;
            }
            else {
                // TODO: Linux
                localCert.isTrusted = undefined;
                return;
            }
        }
        catch (error) {
            // treat any error as install failure, to not block the main progress
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warning(`Failed to install certificate. Error: ${error}`);
            localCert.isTrusted = false;
            localCert.error = new teamsfx_api_1.UserError({
                error,
                source: error_1.CoreSource,
                name: "TrustCertificateError",
                helpLink: learnMoreUrl,
            });
            return;
        }
    }
    async waitForUserConfirm() {
        if (this.ui) {
            let userSelected;
            do {
                const res = await this.ui.showMessage("info", confirmMessage(), true, learnMoreText(), installText());
                userSelected = res.isOk() ? res.value : undefined;
                if (userSelected === learnMoreText()) {
                    void this.ui.openUrl(learnMoreUrl);
                }
            } while (userSelected === learnMoreText());
            return userSelected === installText();
        }
        // No dialog, always return true;
        return true;
    }
    async checkCertificateWindows(thumbprint) {
        try {
            // try powershell first
            const getCertCommand = `Get-ChildItem -Path Cert:\\CurrentUser\\Root | Where-Object { $_.Thumbprint -match '${thumbprint}' }`;
            const getCertRes = await ps.execPowerShell(getCertCommand);
            return getCertRes.toUpperCase().includes(thumbprint.toUpperCase());
        }
        catch (error) {
            // if any error, try certutil
            const getCertCommand = `certutil -user -verifystore root ${thumbprint}`;
            const getCertRes = (await ps.execShell(getCertCommand)).trim();
            return getCertRes.toUpperCase().includes(thumbprint.toUpperCase());
        }
    }
    async trustCertificateWindows(localCert, thumbprint, friendlyName) {
        try {
            // try powershell first
            const installCertCommand = `Import-Certificate -FilePath '${localCert.certPath}' -CertStoreLocation Cert:\\CurrentUser\\Root`;
            await ps.execPowerShell(installCertCommand);
            try {
                const friendlyNameCommand = `(Get-ChildItem -Path Cert:\\CurrentUser\\Root\\${thumbprint}).FriendlyName='${friendlyName}'`;
                await ps.execPowerShell(friendlyNameCommand);
            }
            catch (e) {
                // ignore friendly name failure
            }
        }
        catch (error) {
            // if any error, try certutil
            const installCertCommand = `certutil -user -addstore root "${localCert.certPath}"`;
            await ps.execShell(installCertCommand);
            try {
                const certInfPath = path.join(path.dirname(localCert.certPath), "localhost.inf");
                await fs.writeFile(certInfPath, [
                    "[Version]",
                    `Signature = "$Windows NT$"`,
                    "[Properties]",
                    `11 = {text}${friendlyName}`,
                ].join(os.EOL));
                const friendlyNameCommand = `certutil -user -repairstore root ${thumbprint} "${certInfPath}"`;
                await ps.execShell(friendlyNameCommand);
            }
            catch (e) {
                // ignore friendly name failure
            }
        }
    }
}
exports.LocalCertificateManager = LocalCertificateManager;
//# sourceMappingURL=localCertificateManager.js.map