import { FxError, Result } from "@microsoft/teamsfx-api";
export interface TelemetryContext {
    properties: Record<string, string>;
    measurements: Record<string | "duration", number>;
    errorProps: string[];
}
export interface ToolTelemetryReporter {
    sendTelemetryErrorEvent(eventName: string, error: FxError, properties?: {
        [key: string]: string;
    }, measurements?: {
        [key: string]: number;
    }, errorProps?: string[]): void;
    sendTelemetryEvent(eventName: string, properties?: {
        [p: string]: string;
    }, measurements?: {
        [p: string]: number;
    }): void;
}
export declare class LocalTelemetryReporter {
    static readonly NoLastEventName = "no-last-event";
    static readonly PropertyDebugLastEventName = "debug-last-event-name";
    static readonly PropertyDuration = "duration";
    private static readonly ComponentName;
    private static readonly StartEventSuffix;
    private readonly reporter;
    private lastEventName;
    private saveEventTime?;
    constructor(reporter: ToolTelemetryReporter, saveEventTime?: (eventName: string, time: number) => void);
    /**
     * Same as `runWithTelemetryProperties` but without `initialProperties`.
     */
    runWithTelemetry<T>(eventName: string, action: (ctx: TelemetryContext) => Promise<Result<T, FxError>>): Promise<Result<T, FxError>>;
    /**
     * Same as `runWithTelemetry` but use exception. Not recommended.
     */
    runWithTelemetryException<T>(eventName: string, action: (ctx: TelemetryContext) => Promise<T>): Promise<T>;
    runWithTelemetryExceptionProperties<T>(eventName: string, initialProperties: {
        [key: string]: string;
    }, action: (ctx: TelemetryContext) => Promise<T>): Promise<T>;
    /**
     * Ensure "{eventName}-start" and "{eventName}" telemetry events with the following properties/measurements to be sent on start/end/exception.
     *
     * @param action: The actual action. User can set additional properties in execution into ctx.properties and ctx.measurements.
     * The `ctx` parameter has higher priority over `initialProperties` and auto-generated properties.
     * @param initialProperties: If specified, "{eventName}-start" and "{eventName}" will contain these properties.
     * User may return anything and errors are handled by exception.
     */
    runWithTelemetryProperties<T>(eventName: string, initialProperties: {
        [key: string]: string;
    }, action: (ctx: TelemetryContext) => Promise<Result<T, FxError>>): Promise<Result<T, FxError>>;
    /**
     * Same as `runWithTelemtry()` but supports any return type.
     * User need to specify `getResultForTelemetry` to convert the result to `Result<T, FxError>`, so it can send correct telemetry.
     */
    runWithTelemetryGeneric<T>(eventName: string, action: (ctx: TelemetryContext) => Promise<T>, getResultForTelemetry: (result: T, ctx: TelemetryContext) => FxError | undefined, initialProperties?: {
        [key: string]: string;
    }): Promise<T>;
    getLastEventName(): string;
    sendTelemetryEvent(eventName: string, properties?: {
        [key: string]: string;
    }, measurements?: {
        [key: string]: number;
    }): void;
    sendTelemetryErrorEvent(eventName: string, error: FxError, properties?: {
        [p: string]: string;
    }, measurements?: {
        [p: string]: number;
    }, errorProps?: string[]): void;
}
//# sourceMappingURL=localTelemetryReporter.d.ts.map