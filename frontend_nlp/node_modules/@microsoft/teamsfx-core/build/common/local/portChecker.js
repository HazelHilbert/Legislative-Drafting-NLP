// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPortsInUse = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const detect_port_1 = tslib_1.__importDefault(require("detect-port"));
const error_1 = require("../../core/error");
const telemetry_1 = require("../telemetry");
async function detectPortListening(port, logger) {
    try {
        telemetry_1.sendTelemetryEvent(telemetry_1.Component.core, telemetry_1.TelemetryEvent.DetectPortStart, { port: port.toString() });
        const race = Promise.race([
            detect_port_1.default(port),
            // in case `detectPort` hangs, set 10 seconds timeout
            new Promise((resolve) => setTimeout(() => resolve(port), 10 * 1000)),
        ]);
        const portChosen = await race;
        telemetry_1.sendTelemetryEvent(telemetry_1.Component.core, telemetry_1.TelemetryEvent.DetectPort, {
            portChosen: portChosen.toString(),
            port: port.toString(),
        });
        return portChosen !== port;
    }
    catch (error) {
        // ignore any error to not block debugging
        telemetry_1.sendTelemetryErrorEvent(telemetry_1.Component.core, telemetry_1.TelemetryEvent.DetectPort, new teamsfx_api_1.UserError({ error, source: error_1.CoreSource, name: "DetectPortError" }));
        logger === null || logger === void 0 ? void 0 : logger.warning(`Failed to detect port. ${error === null || error === void 0 ? void 0 : error.message} `);
        return false;
    }
}
async function getPortsInUse(ports, logger) {
    const portsInUse = [];
    for (const port of ports) {
        if (await detectPortListening(port, logger)) {
            portsInUse.push(port);
        }
    }
    return portsInUse;
}
exports.getPortsInUse = getPortsInUse;
//# sourceMappingURL=portChecker.js.map