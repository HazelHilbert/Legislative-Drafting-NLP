"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalTelemetryReporter = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const perf_hooks_1 = require("perf_hooks");
const telemetry_1 = require("../telemetry");
const common_1 = require("../../error/common");
// Telemetry utility for local debug/preview in vsc/cli
class LocalTelemetryReporter {
    constructor(reporter, saveEventTime) {
        this.reporter = reporter;
        this.saveEventTime = saveEventTime;
    }
    /**
     * Same as `runWithTelemetryProperties` but without `initialProperties`.
     */
    async runWithTelemetry(eventName, action) {
        return await this.runWithTelemetryProperties(eventName, {}, action);
    }
    /**
     * Same as `runWithTelemetry` but use exception. Not recommended.
     */
    async runWithTelemetryException(eventName, action) {
        return await this.runWithTelemetryGeneric(eventName, action, () => undefined);
    }
    async runWithTelemetryExceptionProperties(eventName, initialProperties, action) {
        return await this.runWithTelemetryGeneric(eventName, action, () => undefined, initialProperties);
    }
    /**
     * Ensure "{eventName}-start" and "{eventName}" telemetry events with the following properties/measurements to be sent on start/end/exception.
     *
     * @param action: The actual action. User can set additional properties in execution into ctx.properties and ctx.measurements.
     * The `ctx` parameter has higher priority over `initialProperties` and auto-generated properties.
     * @param initialProperties: If specified, "{eventName}-start" and "{eventName}" will contain these properties.
     * User may return anything and errors are handled by exception.
     */
    async runWithTelemetryProperties(eventName, initialProperties, action) {
        return await this.runWithTelemetryGeneric(eventName, action, (value) => {
            return value.isErr() ? value.error : undefined;
        }, initialProperties);
    }
    /**
     * Same as `runWithTelemtry()` but supports any return type.
     * User need to specify `getResultForTelemetry` to convert the result to `Result<T, FxError>`, so it can send correct telemetry.
     */
    async runWithTelemetryGeneric(eventName, action, getResultForTelemetry, initialProperties) {
        const startMillis = perf_hooks_1.performance.now();
        this.sendTelemetryEvent(eventName + LocalTelemetryReporter.StartEventSuffix, initialProperties);
        const ctx = {
            properties: initialProperties || {},
            measurements: {},
            errorProps: [],
        };
        // 3 cases in one result: Result<[actual result, FxError], exception>
        let result;
        try {
            const value = await action(ctx);
            const resultForTelemetry = getResultForTelemetry(value, ctx);
            result = teamsfx_api_1.ok([value, resultForTelemetry]);
        }
        catch (error) {
            result = teamsfx_api_1.err(error);
        }
        const endMillis = perf_hooks_1.performance.now();
        const durationSeconds = (endMillis - startMillis) / 1000;
        const properties = Object.assign({}, ctx.properties);
        const measurements = Object.assign({
            [LocalTelemetryReporter.PropertyDuration]: durationSeconds,
        }, ctx.measurements);
        const errorProps = [...ctx.errorProps];
        if (result.isErr()) {
            // exception
            const error = common_1.assembleError(result.error, LocalTelemetryReporter.ComponentName);
            properties[telemetry_1.TelemetryProperty.Success] = telemetry_1.TelemetrySuccess.No;
            this.sendTelemetryErrorEvent(eventName, error, properties, measurements, errorProps);
            // Propagate exception because wrapper function should not change original behavior.
            throw result.error;
        }
        else if (result.value[1] !== undefined) {
            // FxError
            properties[telemetry_1.TelemetryProperty.Success] = telemetry_1.TelemetrySuccess.No;
            this.sendTelemetryErrorEvent(eventName, result.value[1], properties, measurements, errorProps);
            return result.value[0];
        }
        else {
            // success
            properties[telemetry_1.TelemetryProperty.Success] = telemetry_1.TelemetrySuccess.Yes;
            this.sendTelemetryEvent(eventName, properties, measurements);
            return result.value[0];
        }
    }
    getLastEventName() {
        return this.lastEventName === undefined
            ? LocalTelemetryReporter.NoLastEventName
            : this.lastEventName;
    }
    sendTelemetryEvent(eventName, properties, measurements) {
        var _a;
        this.lastEventName = eventName;
        (_a = this.saveEventTime) === null || _a === void 0 ? void 0 : _a.call(this, eventName, perf_hooks_1.performance.now());
        this.reporter.sendTelemetryEvent(eventName, properties, measurements);
    }
    sendTelemetryErrorEvent(eventName, error, properties, measurements, errorProps) {
        var _a;
        if ((properties === null || properties === void 0 ? void 0 : properties[LocalTelemetryReporter.PropertyDebugLastEventName]) === undefined) {
            if (properties === undefined) {
                properties = {};
            }
            properties[LocalTelemetryReporter.PropertyDebugLastEventName] = this.getLastEventName();
        }
        this.lastEventName = eventName;
        (_a = this.saveEventTime) === null || _a === void 0 ? void 0 : _a.call(this, eventName, perf_hooks_1.performance.now());
        this.reporter.sendTelemetryErrorEvent(eventName, error, properties, measurements, errorProps);
    }
}
exports.LocalTelemetryReporter = LocalTelemetryReporter;
LocalTelemetryReporter.NoLastEventName = "no-last-event";
LocalTelemetryReporter.PropertyDebugLastEventName = "debug-last-event-name";
LocalTelemetryReporter.PropertyDuration = "duration";
LocalTelemetryReporter.ComponentName = "local-debug";
LocalTelemetryReporter.StartEventSuffix = "-start";
//# sourceMappingURL=localTelemetryReporter.js.map