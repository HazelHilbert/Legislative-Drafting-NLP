"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DepsManager = void 0;
const depsLogger_1 = require("./depsLogger");
const depsChecker_1 = require("./depsChecker");
const checkerFactory_1 = require("./checkerFactory");
class DepsManager {
    constructor(logger, telemetry) {
        if (!logger) {
            throw Error("Logger is undefined.");
        }
        if (!telemetry) {
            throw Error("Logger is undefined.");
        }
        this.logger = logger;
        this.telemetry = telemetry;
        this.emptyLogger = new depsLogger_1.EmptyLogger();
    }
    /**
     * Ensure dependencies installed.
     * Installation Orders:
     *      Node, Dotnet, FuncCoreTools, Ngrok
     * @param dependencies Dependency types. If it is empty, do nothing.
     * @param options If fastFail is false, it will continue even if one of the dependencies fails to install. Default value is true.
     */
    async ensureDependencies(dependencies, { fastFail = true, doctor = false }) {
        if (!dependencies || dependencies.length == 0) {
            return [];
        }
        const orderedDeps = DepsManager.sortBySequence(dependencies);
        const result = [];
        let shouldInstall = true;
        for (const type of orderedDeps) {
            const status = await this.resolve(type, shouldInstall, doctor);
            result.push(status);
            if (fastFail && !status.isInstalled) {
                shouldInstall = false;
            }
        }
        return result;
    }
    async ensureDependency(depsType, doctor = false, options) {
        return await this.resolve(depsType, true, doctor, options);
    }
    /**
     * @deprecated
     * Get status without installOptions. Only used in legacy code.
     */
    async getStatus(depsTypes) {
        if (!depsTypes || depsTypes.length == 0) {
            return [];
        }
        const result = [];
        for (const dep of depsTypes) {
            result.push(await this.resolve(dep, false));
        }
        return result;
    }
    async getStatusWithInstallOptions(depsType, options) {
        return await this.resolve(depsType, false, undefined, options);
    }
    async resolve(depsType, shouldInstall, doctor = false, installOptions) {
        const checker = checkerFactory_1.CheckerFactory.createChecker(depsType, doctor ? this.emptyLogger : this.logger, this.telemetry);
        if (shouldInstall) {
            return await checker.resolve(installOptions);
        }
        else {
            return await checker.getInstallationInfo(installOptions);
        }
    }
    static sortBySequence(dependencies) {
        return dependencies
            .filter((value) => value != null)
            .sort((a, b) => DepsManager.depsOrders.indexOf(a) - DepsManager.depsOrders.indexOf(b));
    }
}
exports.DepsManager = DepsManager;
DepsManager.depsOrders = [
    depsChecker_1.DepsType.Dotnet,
    depsChecker_1.DepsType.FuncCoreTools,
    depsChecker_1.DepsType.VxTestApp,
];
//# sourceMappingURL=depsManager.js.map