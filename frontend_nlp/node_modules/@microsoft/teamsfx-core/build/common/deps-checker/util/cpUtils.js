"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.cpUtils = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-namespace */
const cp = tslib_1.__importStar(require("child_process"));
const os = tslib_1.__importStar(require("os"));
var cpUtils;
(function (cpUtils) {
    async function executeCommand(workingDirectory, logger, options, command, ...args) {
        const result = await tryExecuteCommand(workingDirectory, logger, options, command, ...args);
        if (result.code !== 0) {
            const errorMessage = `Failed to run command: "${command} ${result.formattedArgs}", code: "${result.code}",
                            output: "${result.cmdOutput}", error: "${result.cmdOutputIncludingStderr}"`;
            logger === null || logger === void 0 ? void 0 : logger.debug(errorMessage);
            throw new Error(errorMessage);
        }
        else {
            logger === null || logger === void 0 ? void 0 : logger.debug(`Finished running command: "${command} ${result.formattedArgs}".`);
        }
        return result.cmdOutput;
    }
    cpUtils.executeCommand = executeCommand;
    async function tryExecuteCommand(workingDirectory, logger, additionalOptions, command, ...args) {
        return await new Promise((resolve, reject) => {
            var _a, _b;
            let cmdOutput = "";
            let cmdOutputIncludingStderr = "";
            const formattedArgs = args.join(" ");
            workingDirectory = workingDirectory || os.tmpdir();
            const options = {
                cwd: workingDirectory,
                shell: true,
            };
            Object.assign(options, additionalOptions);
            const childProc = cp.spawn(command, args, options);
            let timer;
            if (options.timeout && options.timeout > 0) {
                // timeout only exists for exec not spawn
                timer = setTimeout(() => {
                    childProc.kill();
                    logger === null || logger === void 0 ? void 0 : logger.debug(`Stop exec due to timeout, command: "${command} ${formattedArgs}", options = '${JSON.stringify(options)}'`);
                    reject(new Error(`Exec command: "${command} ${formattedArgs}" timeout, ${options.timeout || 0} ms`));
                }, options.timeout);
            }
            logger === null || logger === void 0 ? void 0 : logger.debug(`Running command: "${command} ${formattedArgs}", options = '${JSON.stringify(options)}'`);
            (_a = childProc.stdout) === null || _a === void 0 ? void 0 : _a.on("data", (data) => {
                data = data.toString();
                cmdOutput = cmdOutput.concat(data);
                cmdOutputIncludingStderr = cmdOutputIncludingStderr.concat(data);
            });
            (_b = childProc.stderr) === null || _b === void 0 ? void 0 : _b.on("data", (data) => {
                data = data.toString();
                cmdOutputIncludingStderr = cmdOutputIncludingStderr.concat(data);
            });
            childProc.on("error", (error) => {
                logger === null || logger === void 0 ? void 0 : logger.debug(`Failed to run command '${command} ${formattedArgs}': cmdOutputIncludingStderr: '${cmdOutputIncludingStderr}', error: ${error.toString()}`);
                if (timer) {
                    clearTimeout(timer);
                }
                reject(error);
            });
            childProc.on("close", (code) => {
                logger === null || logger === void 0 ? void 0 : logger.debug(`Command finished with outputs, cmdOutputIncludingStderr: '${cmdOutputIncludingStderr}'`);
                if (timer) {
                    clearTimeout(timer);
                }
                resolve({
                    code,
                    cmdOutput,
                    cmdOutputIncludingStderr,
                    formattedArgs,
                });
            });
        });
    }
    cpUtils.tryExecuteCommand = tryExecuteCommand;
    const quotationMark = process.platform === "win32" ? '"' : "'";
    /**
     * Ensures spaces and special characters (most notably $) are preserved
     */
    function wrapArgInQuotes(arg) {
        return quotationMark + arg + quotationMark;
    }
    cpUtils.wrapArgInQuotes = wrapArgInQuotes;
    /**
     * timeout with millisecond
     */
    function withTimeout(millis, promise, msg) {
        return Promise.race([
            promise,
            new Promise((resolve, reject) => setTimeout(() => reject(new Error(`${msg}, ${millis} ms`)), millis)),
        ]);
    }
    cpUtils.withTimeout = withTimeout;
})(cpUtils = exports.cpUtils || (exports.cpUtils = {}));
//# sourceMappingURL=cpUtils.js.map