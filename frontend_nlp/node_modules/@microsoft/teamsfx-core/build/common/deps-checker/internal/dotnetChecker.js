"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DotnetChecker = exports.DotnetVersion = void 0;
const tslib_1 = require("tslib");
const os = tslib_1.__importStar(require("os"));
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const child_process = tslib_1.__importStar(require("child_process"));
const util = tslib_1.__importStar(require("util"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const perf_hooks_1 = require("perf_hooks");
const helpLink_1 = require("../constant/helpLink");
const depsError_1 = require("../depsError");
const progressIndicator_1 = require("../util/progressIndicator");
const cpUtils_1 = require("../util/cpUtils");
const system_1 = require("../util/system");
const telemetry_1 = require("../constant/telemetry");
const depsChecker_1 = require("../depsChecker");
const message_1 = require("../constant/message");
const folder_1 = require("../../../folder");
const localizeUtils_1 = require("../../localizeUtils");
const execFile = util.promisify(child_process.execFile);
var DotnetVersion;
(function (DotnetVersion) {
    DotnetVersion["v21"] = "2.1";
    DotnetVersion["v31"] = "3.1";
    DotnetVersion["v50"] = "5.0";
    DotnetVersion["v60"] = "6.0";
})(DotnetVersion = exports.DotnetVersion || (exports.DotnetVersion = {}));
const DotnetCoreSDKName = ".NET Core SDK";
const installVersion = system_1.isMacOS() && system_1.isArm64() ? DotnetVersion.v60 : DotnetVersion.v31;
const supportedVersions = [DotnetVersion.v31, DotnetVersion.v50, DotnetVersion.v60];
const installedNameWithVersion = `${DotnetCoreSDKName} (v${DotnetVersion.v31})`;
class DotnetChecker {
    constructor(logger, telemetry) {
        this._logger = logger;
        this._telemetry = telemetry;
    }
    async getDepsInfo(isInstalled, error) {
        const execPath = await this.getDotnetExecPathFromConfig();
        return {
            name: DotnetCoreSDKName,
            type: depsChecker_1.DepsType.Dotnet,
            isInstalled: isInstalled,
            command: await this.command(),
            details: {
                isLinuxSupported: false,
                installVersion: `${installVersion}`,
                supportedVersions: supportedVersions,
                binFolders: execPath ? [execPath] : undefined,
            },
            error: error,
        };
    }
    async getInstallationInfo() {
        const configPath = DotnetChecker.getDotnetConfigPath();
        this._logger.debug(`[start] read dotnet path from '${configPath}'`);
        const dotnetPath = await this.getDotnetExecPathFromConfig();
        this._logger.debug(`[end] read dotnet path from '${configPath}', dotnetPath = '${dotnetPath || ""}'`);
        this._logger.debug(`[start] check dotnet version`);
        if (dotnetPath !== null && (await this.isDotnetInstalledCorrectly())) {
            // filter out global sdk
            if (dotnetPath.includes(`.${teamsfx_api_1.ConfigFolderName}`)) {
                this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.dotnetInstallCompleted);
            }
            return await this.getDepsInfo(true);
        }
        this._logger.debug(`[end] check dotnet version`);
        if ((await this.tryAcquireGlobalDotnetSdk()) && (await this.validate())) {
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.dotnetAlreadyInstalled);
            this._logger.info(`${message_1.Messages.useGlobalDotnet()} '${(await this.getDotnetExecPathFromConfig()) || ""}'`);
            return await this.getDepsInfo(true);
        }
        return await this.getDepsInfo(false);
    }
    async resolve() {
        try {
            let installationInfo = await this.getInstallationInfo();
            if (!installationInfo.isInstalled) {
                await this.install();
                installationInfo = await this.getInstallationInfo();
            }
            return installationInfo;
        }
        catch (error) {
            this._logger.printDetailLog();
            this._logger.error(`${error.message}, error = '${error.toString()}'`);
            if (error instanceof depsError_1.DepsCheckerError) {
                return await this.getDepsInfo(false, error);
            }
            return await this.getDepsInfo(false, new depsError_1.DepsCheckerError(error.message, helpLink_1.dotnetFailToInstallHelpLink));
        }
        finally {
            this._logger.cleanup();
        }
    }
    async install() {
        if (system_1.isLinux()) {
            throw new depsError_1.LinuxNotSupportedError(message_1.Messages.linuxDepsNotFound().split("@SupportedPackages").join(installedNameWithVersion), helpLink_1.dotnetExplanationHelpLink);
        }
        this._logger.debug(`[start] cleanup bin/dotnet and config`);
        await DotnetChecker.cleanup();
        this._logger.debug(`[end] cleanup bin/dotnet and config`);
        const installDir = DotnetChecker.getDefaultInstallPath();
        this._logger.debug(`[start] install dotnet ${installVersion}`);
        this._logger.debug(message_1.Messages.dotnetNotFound()
            .replace("@NameVersion", installedNameWithVersion)
            .replace("@HelpLink", helpLink_1.dotnetExplanationHelpLink));
        this._logger.info(message_1.Messages.downloadDotnet()
            .replace("@NameVersion", installedNameWithVersion)
            .replace("@InstallDir", installDir));
        // TODO add progress log
        await progressIndicator_1.runWithProgressIndicator(async () => {
            await this.handleInstall(installVersion, installDir);
        }, this._logger);
        this._logger.debug(`[end] install dotnet ${installVersion}`);
        this._logger.debug(`[start] validate dotnet version`);
        if (!(await this.validate())) {
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.dotnetInstallError);
            throw new depsError_1.DepsCheckerError(localizeUtils_1.getLocalizedString("error.common.InstallSoftwareError", installedNameWithVersion), helpLink_1.dotnetFailToInstallHelpLink);
        }
        this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.dotnetInstallCompleted);
    }
    async command() {
        const execPath = await this.getDotnetExecPathFromConfig();
        return execPath || "dotnet";
    }
    static escapeFilePath(path) {
        if (system_1.isWindows()) {
            // Need to escape apostrophes with two apostrophes
            const dotnetInstallDirEscaped = path.replace(/'/g, `''`);
            // Surround with single quotes instead of double quotes (see https://github.com/dotnet/cli/issues/11521)
            return `'${dotnetInstallDirEscaped}'`;
        }
        else {
            return `"${path}"`;
        }
    }
    static getDotnetConfigPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "dotnet.json");
    }
    async getDotnetExecPathFromConfig() {
        try {
            const config = await fs.readJson(DotnetChecker.getDotnetConfigPath(), {
                encoding: DotnetChecker.encoding,
            });
            if (typeof config.dotnetExecutablePath === "string") {
                return config.dotnetExecutablePath;
            }
            this._logger.debug(`invalid dotnet config file format, config: '${JSON.stringify(config)}' `);
        }
        catch (error) {
            this._logger.debug(`get dotnet path failed, error: '${error.toString()}'`);
        }
        return null;
    }
    // Do not print info level log in this method because it runs concurrently with the progress bar
    async handleInstall(version, installDir) {
        try {
            if (system_1.isLinux()) {
                await this.handleLinuxDependency();
            }
            // NOTE: we don't need to handle directory creation since dotnet-install script will handle it.
            await this.runDotnetInstallScript(version, installDir);
            this._logger.debug(`[start] write dotnet path to config`);
            const dotnetExecPath = DotnetChecker.getDotnetExecPathFromDotnetInstallationDir(installDir);
            await DotnetChecker.persistDotnetExecPath(dotnetExecPath);
            this._logger.debug(`[end] write dotnet path to config`);
            this._logger.info(message_1.Messages.finishInstallDotnet().replace("@NameVersion", installedNameWithVersion));
        }
        catch (error) {
            this._logger.error(`${localizeUtils_1.getLocalizedString("error.common.InstallSoftwareError", installedNameWithVersion)}, error = '${error.toString()}'`);
        }
    }
    static async persistDotnetExecPath(dotnetExecPath) {
        const configPath = DotnetChecker.getDotnetConfigPath();
        await fs.ensureFile(configPath);
        await fs.writeJson(configPath, { dotnetExecutablePath: dotnetExecPath }, {
            encoding: DotnetChecker.encoding,
            spaces: 4,
            EOL: os.EOL,
        });
    }
    async handleLinuxDependency() {
        // do nothing
    }
    static async cleanup() {
        await fs.remove(DotnetChecker.getDotnetConfigPath());
        await fs.emptyDir(DotnetChecker.getDefaultInstallPath());
    }
    // from: https://github.com/dotnet/vscode-dotnet-runtime/blob/main/vscode-dotnet-runtime-library/src/Acquisition/AcquisitionInvoker.ts
    async runDotnetInstallScript(version, installDir) {
        const command = this.getInstallCommand(version, installDir);
        const cwd = this.getResourceDir();
        const options = {
            cwd: cwd,
            maxBuffer: DotnetChecker.maxBuffer,
            timeout: DotnetChecker.timeout,
            killSignal: "SIGKILL",
            shell: false,
        };
        const start = perf_hooks_1.performance.now();
        try {
            fs.chmodSync(this.getDotnetInstallScriptPath(), "755");
            const { stdout, stderr } = await execFile(command[0], command.slice(1), options);
            this._logger.debug(`Finished running dotnet-install script, command = '${command.join(" ")}', options = '${JSON.stringify(options)}', stdout = '${stdout}', stderr = '${stderr}'`);
            const timecost = Number(((perf_hooks_1.performance.now() - start) / 1000).toFixed(2));
            if (stderr && stderr.length > 0) {
                const errorMessage = `${localizeUtils_1.getLocalizedString("error.common.InstallSoftwareError", installedNameWithVersion)} ${message_1.Messages.dotnetInstallStderr()} stdout = '${stdout}', stderr = '${stderr}', timecost = '${timecost}s'`;
                this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.dotnetInstallScriptError, telemetry_1.TelemtryMessages.failedToExecDotnetScript, errorMessage);
                this._logger.error(errorMessage);
            }
            else {
                this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.dotnetInstallScriptCompleted, {}, timecost);
            }
        }
        catch (error) {
            const timecost = Number(((perf_hooks_1.performance.now() - start) / 1000).toFixed(2));
            const errorMessage = `${localizeUtils_1.getLocalizedString("error.common.InstallSoftwareError", installedNameWithVersion)} ${message_1.Messages.dotnetInstallErrorCode()}, ` +
                `command = '${command.join(" ")}', options = '${JSON.stringify(options
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                )}', error = '${error}', stdout = '${error.stdout}', stderr = '${
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                error.stderr}', timecost = '${timecost}s'`;
            this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.dotnetInstallScriptError, telemetry_1.TelemtryMessages.failedToExecDotnetScript, errorMessage);
            // swallow the exception since later validate will find out the errors anyway
            this._logger.error(errorMessage);
        }
    }
    async isDotnetInstalledCorrectly() {
        try {
            const dotnetExecPath = await this.getDotnetExecPathFromConfig();
            const dotnetSdks = await this.searchDotnetSdks(dotnetExecPath);
            const installedVersions = dotnetSdks
                .map((sdk) => DotnetChecker.parseDotnetVersion(sdk.version))
                .filter((version) => version !== null);
            return this.isDotnetVersionsInstalled(installedVersions);
        }
        catch (error) {
            const errorMessage = `validate private install failed, error = '${error.toString()}'`;
            this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.dotnetValidationError, telemetry_1.TelemtryMessages.failedToValidateDotnet, errorMessage);
            this._logger.debug(errorMessage);
            return false;
        }
    }
    isDotnetVersionsInstalled(installedVersions) {
        try {
            const validVersions = DotnetChecker.arrayIntersection(installedVersions, supportedVersions);
            // return validVersions.length > 0;
            return Promise.resolve(validVersions.length > 0);
        }
        catch (error) {
            this._logger.error(`failed to check .NET, installedVersions = '${installedVersions.toString()}', supportedVersions = '${supportedVersions.toString()}', error = '${error.toString()}'`);
            return Promise.resolve(false);
        }
    }
    static arrayIntersection(lhs, rhs) {
        return lhs.filter((value) => rhs.includes(value));
    }
    static isPrivateInstall(sdk) {
        const privateInstallPath = DotnetChecker.getDotnetExecPathFromDotnetInstallationDir(DotnetChecker.getDefaultInstallPath());
        return path.dirname(privateInstallPath) == path.dirname(sdk.path) && sdk.version !== null;
    }
    async getGlobalDotnetSdks() {
        const globalSdks = await this.searchDotnetSdks("dotnet");
        return globalSdks.filter((sdk) => !DotnetChecker.isPrivateInstall(sdk));
    }
    async searchDotnetSdks(dotnetExecPath) {
        if (!dotnetExecPath) {
            return [];
        }
        const sdks = [];
        try {
            // shell = false to prevent shell escape issues in dotnetExecPath
            const dotnetListSdksOutput = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { shell: false }, dotnetExecPath, "--list-sdks");
            // dotnet --list-sdks sample output:
            // > 5.0.200 [C:\Program Files\dotnet\sdk]
            // > 3.1.200 [C:\Program Files\dotnet\sdk]
            const regex = /(?<version>\d+\.\d+\.\d+)\s+\[(?<installPath>[^\]]+)\]/;
            // NOTE(aochengwang):
            // for default installation, we expect our dotnet should be installVersion.
            // for user specified dotnet path, check that installVersion exists in any dotnet installation from dotnet --list-sdks.
            dotnetListSdksOutput.split(/\r?\n/).forEach((line) => {
                const match = regex.exec(line.trim());
                if (match && match.groups) {
                    const path = match.groups.installPath;
                    const version = match.groups.version;
                    if (DotnetChecker.isFullSdkVersion(version) && path) {
                        sdks.push({ version: version, path: path });
                    }
                }
            });
        }
        catch (error) {
            const errorMessage = `Failed to search dotnet sdk by dotnetPath = '${dotnetExecPath}', error = '${error.toString()}'`;
            this._logger.debug(errorMessage);
            this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.dotnetSearchDotnetSdks, telemetry_1.TelemtryMessages.failedToSearchDotnetSdks, errorMessage);
        }
        return sdks;
    }
    static isFullSdkVersion(version) {
        const regex = /(?<major_version>\d+)\.(?<minor_version>\d+)\.(?<patch_version>\d+)/gm;
        const match = regex.exec(version);
        return match !== null && match.length > 0;
    }
    static getDotnetExecPathFromDotnetInstallationDir(installDir) {
        return path.join(installDir, system_1.isWindows() ? "dotnet.exe" : "dotnet");
    }
    getDotnetInstallScriptPath() {
        return path.join(this.getResourceDir(), this.getDotnetInstallScriptName());
    }
    getResourceDir() {
        return path.resolve(path.join(folder_1.getResourceFolder(), "deps-checker"));
    }
    getDotnetInstallScriptName() {
        return system_1.isWindows() ? "dotnet-install.ps1" : "dotnet-install.sh";
    }
    static getDefaultInstallPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", "dotnet");
    }
    getInstallCommand(version, dotnetInstallDir) {
        if (system_1.isWindows()) {
            const command = [
                DotnetChecker.escapeFilePath(this.getDotnetInstallScriptPath()),
                "-InstallDir",
                DotnetChecker.escapeFilePath(dotnetInstallDir),
                "-Channel",
                version,
            ];
            return [
                "powershell.exe",
                "-NoProfile",
                "-ExecutionPolicy",
                "unrestricted",
                "-Command",
                `& { [Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls12 ; & ${command.join(" ")} }`,
            ];
        }
        else {
            return [
                "bash",
                this.getDotnetInstallScriptPath(),
                "-InstallDir",
                dotnetInstallDir,
                "-Channel",
                version,
            ];
        }
    }
    async validate() {
        const isInstallationValid = (await this.isDotnetInstalledCorrectly()) && (await this.validateWithHelloWorld());
        if (!isInstallationValid) {
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.dotnetValidationError);
            await DotnetChecker.cleanup();
        }
        return isInstallationValid;
    }
    async validateWithHelloWorld() {
        const dotnetPath = await this.getDotnetExecPathFromConfig();
        if (!dotnetPath) {
            return false;
        }
        const samplePath = path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "dotnetSample");
        try {
            await fs.remove(samplePath);
            await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { shell: false }, dotnetPath, "new", "console", "--output", `${samplePath}`, "--force");
            await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { shell: false }, dotnetPath, "run", "--project", `${samplePath}`, "--force");
            return true;
        }
        catch (error) {
            this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.dotnetValidationError, telemetry_1.TelemtryMessages.failedToValidateDotnet, error);
            this._logger.debug(`Failed to run hello world, dotnetPath = ${dotnetPath}, error = ${error.toString()}`);
        }
        finally {
            await fs.remove(samplePath);
        }
        return false;
    }
    async tryAcquireGlobalDotnetSdk() {
        try {
            const sdks = await this.getGlobalDotnetSdks();
            if (!sdks || sdks.length == 0) {
                return false;
            }
            // todo: by far, use first valid dotnet sdk
            // todo: write dotnetExecPath into user settings instead of into .fx/dotnet.json
            const selectedSdk = sdks[0];
            const dotnetExecPath = DotnetChecker.getDotnetExecPathFromDotnetInstallationDir(path.resolve(selectedSdk.path, ".."));
            await DotnetChecker.persistDotnetExecPath(dotnetExecPath);
            return true;
        }
        catch (error) {
            this._logger.debug(`Failed to acquire global dotnet sdk, error = '${error.toString()}'`);
            return false;
        }
    }
    static parseDotnetVersion(output) {
        var _a, _b;
        const regex = /(?<major_version>\d+)\.(?<minor_version>\d+)\.(?<patch_version>\d+)/gm;
        const match = regex.exec(output);
        if (!match) {
            return null;
        }
        return (((_a = match.groups) === null || _a === void 0 ? void 0 : _a.major_version) || "") + "." + (((_b = match.groups) === null || _b === void 0 ? void 0 : _b.minor_version) || "");
    }
}
exports.DotnetChecker = DotnetChecker;
DotnetChecker.encoding = "utf-8";
DotnetChecker.timeout = 5 * 60 * 1000; // same as vscode-dotnet-runtime
DotnetChecker.maxBuffer = 500 * 1024;
//# sourceMappingURL=dotnetChecker.js.map