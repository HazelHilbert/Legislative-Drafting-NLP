"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VxTestAppChecker = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const os = tslib_1.__importStar(require("os"));
const tmp = tslib_1.__importStar(require("tmp"));
const util = tslib_1.__importStar(require("util"));
const axios_1 = tslib_1.__importDefault(require("axios"));
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constant_1 = require("../constant");
const depsError_1 = require("../depsError");
const depsChecker_1 = require("../depsChecker");
const util_1 = require("../util");
const fileHelper_1 = require("../util/fileHelper");
const VxTestAppName = "Video Extensibility Test App";
// https://www.electronjs.org/docs/latest/tutorial/application-distribution#manual-packaging
const VxTestAppExecutableName = util_1.isWindows()
    ? "video-extensibility-test-app.exe"
    : util_1.isMacOS()
        ? "video-extensibility-test-app.app"
        : "video-extensibility-test-app";
const VxTestAppDirRelPath = path.join(".tools", "video-extensibility-test-app");
const VxTestAppGlobalBasePath = path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, `bin`, `video-extensibility-test-app`);
const VxTestAppDownloadTimeoutMillis = 5 * 60 * 1000;
// TODO: change to GitHub release after new VxTestApp is released.
const VxTestAppDownloadUrlTemplate = "https://github.com/microsoft/teams-videoapp-sample/releases/download/testApp-v@version/video-extensibility-test-app-@platform-@arch-portable.zip";
/**
 * Download a file from URL and save to a temporary file.
 * The temp file can only be used during callback. After that the temp file is deleted.
 *  */
async function downloadToTempFile(url, callback) {
    // name is full path
    const { name, removeCallback } = tmp.fileSync();
    try {
        const writer = fs.createWriteStream(name, { flags: "w" /* Open for write */ });
        const response = await axios_1.default.get(url, {
            responseType: "stream",
            timeout: VxTestAppDownloadTimeoutMillis,
        });
        response.data.pipe(writer);
        if (response.status !== 200) {
            throw new Error(constant_1.Messages.failToDownloadFromUrl()
                .replace(/@Url/g, url)
                .replace(/@Status/g, response.status.toString()));
        }
        await new Promise((resolve, reject) => {
            writer.on("error", (err) => {
                reject(err);
            });
            writer.on("finish", () => {
                resolve();
            });
        });
        await callback(name);
    }
    finally {
        removeCallback();
    }
}
async function unzip(zipFilePath, destinationPath) {
    // Create all parent dirs of destinationPath.
    await fs.mkdir(destinationPath, { recursive: true });
    const zip = new adm_zip_1.default(zipFilePath);
    await util.promisify(zip.extractAllToAsync)(destinationPath, true);
}
class VxTestAppChecker {
    constructor(logger, telemetry) {
        this._logger = logger;
        this._telemetry = telemetry;
    }
    async resolve(installOptions) {
        if (!this.isValidInstallOptions(installOptions)) {
            return VxTestAppChecker.newDependencyStatusForInstallError(new depsError_1.VxTestAppCheckError(constant_1.Messages.failToValidateVxTestAppInstallOptions(), constant_1.vxTestAppInstallHelpLink));
        }
        // check installation in project dir
        const installInfo = await this.getInstallationInfo(installOptions);
        if (installInfo.isInstalled) {
            return installInfo;
        }
        // ensure vxTestApp is installed in global dir
        const globalInstallDir = path.join(VxTestAppGlobalBasePath, installOptions.version);
        if (!(await this.isValidInstalltion(globalInstallDir, installOptions.version))) {
            await fs.remove(globalInstallDir);
            await this.installVersion(installOptions.version, globalInstallDir);
        }
        // ensure vxTestApp is installed in project dir
        const projectInstallDir = path.join(installOptions.projectPath, VxTestAppDirRelPath);
        await fileHelper_1.createSymlink(globalInstallDir, projectInstallDir);
        // TODO: need to chmod to add executable permission for non-Windows OS
        if (!(await this.isValidInstalltion(projectInstallDir, installOptions.version))) {
            return VxTestAppChecker.newDependencyStatusForInstallError(new depsError_1.VxTestAppCheckError(constant_1.Messages.failToValidateVxTestApp(), constant_1.vxTestAppInstallHelpLink));
        }
        return {
            name: VxTestAppName,
            type: depsChecker_1.DepsType.VxTestApp,
            isInstalled: true,
            command: VxTestAppExecutableName,
            details: {
                isLinuxSupported: false,
                supportedVersions: [installOptions.version],
                binFolders: [projectInstallDir],
            },
            error: undefined,
        };
    }
    async getInstallationInfo(installOptions) {
        if (!this.isValidInstallOptions(installOptions)) {
            return VxTestAppChecker.newDependencyStatusForInstallError(new depsError_1.VxTestAppCheckError(constant_1.Messages.failToValidateVxTestAppInstallOptions(), constant_1.vxTestAppInstallHelpLink));
        }
        const installDir = path.join(installOptions.projectPath, VxTestAppDirRelPath);
        if (!(await this.isValidInstalltion(installDir, installOptions.version))) {
            return VxTestAppChecker.newDependencyStatusForNotInstalled(installOptions.version);
        }
        const projectInstallDir = path.join(installOptions.projectPath, VxTestAppDirRelPath);
        return {
            name: VxTestAppName,
            type: depsChecker_1.DepsType.VxTestApp,
            isInstalled: true,
            command: VxTestAppExecutableName,
            details: {
                isLinuxSupported: false,
                supportedVersions: [installOptions.version],
                binFolders: [projectInstallDir],
            },
            error: undefined,
        };
    }
    async installVersion(version, installDir) {
        const downloadUrl = this.getDownloadUrl(version);
        await downloadToTempFile(downloadUrl, async (zipFilePath) => {
            await unzip(zipFilePath, installDir);
        });
    }
    getDownloadUrl(version) {
        const url = VxTestAppDownloadUrlTemplate.replace(/@version/g, version)
            .replace(/@platform/g, os.platform())
            .replace(/@arch/g, os.arch());
        return url;
    }
    async isValidInstalltion(installDir, version) {
        const vxTestAppExecutable = path.join(installDir, VxTestAppExecutableName);
        if (!(await fs.pathExists(vxTestAppExecutable))) {
            return false;
        }
        // TODO(aochengwang):
        //   1. check executable permission for non-Windows OS
        //   2. check whether installed version is correct?
        return true;
    }
    isValidInstallOptions(installOptions) {
        return !((installOptions === null || installOptions === void 0 ? void 0 : installOptions.projectPath) === undefined && (installOptions === null || installOptions === void 0 ? void 0 : installOptions.version) === undefined);
    }
    static newDependencyStatusForNotInstalled(version) {
        return {
            name: VxTestAppName,
            type: depsChecker_1.DepsType.VxTestApp,
            isInstalled: false,
            command: VxTestAppExecutableName,
            details: {
                isLinuxSupported: false,
                supportedVersions: version === undefined ? [] : [version],
            },
            error: undefined,
        };
    }
    static newDependencyStatusForInstallError(error, version) {
        return {
            name: VxTestAppName,
            type: depsChecker_1.DepsType.VxTestApp,
            isInstalled: false,
            command: VxTestAppExecutableName,
            details: {
                isLinuxSupported: false,
                supportedVersions: version === undefined ? [] : [version],
            },
            error: error,
        };
    }
}
exports.VxTestAppChecker = VxTestAppChecker;
//# sourceMappingURL=vxTestAppChecker.js.map