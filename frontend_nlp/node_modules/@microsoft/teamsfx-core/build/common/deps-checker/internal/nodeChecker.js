"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectNodeChecker = exports.LtsNodeChecker = exports.NodeChecker = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const helpLink_1 = require("../constant/helpLink");
const message_1 = require("../constant/message");
const telemetry_1 = require("../constant/telemetry");
const depsChecker_1 = require("../depsChecker");
const depsError_1 = require("../depsError");
const cpUtils_1 = require("../util/cpUtils");
const NodeName = "Node.js";
class NodeVersion {
    constructor(version, majorVersion) {
        this.version = version;
        this.majorVersion = majorVersion;
    }
}
class NodeChecker {
    constructor(logger, telemetry) {
        this._logger = logger;
        this._telemetry = telemetry;
    }
    async getInstallationInfo(installOptions) {
        let supportedVersions = [];
        try {
            supportedVersions = await this.getSupportedVersions(installOptions === null || installOptions === void 0 ? void 0 : installOptions.projectPath);
            this._logger.debug(`NodeChecker checking for supported versions: '${JSON.stringify(supportedVersions)}'`);
            const currentVersion = await NodeChecker.getInstalledNodeVersion();
            if (currentVersion === null) {
                this._telemetry.sendUserErrorEvent(telemetry_1.DepsCheckerEvent.nodeNotFound, "Node.js can't be found.");
                const error = new depsError_1.NodeNotFoundError(message_1.Messages.NodeNotFound(), this._nodeNotFoundHelpLink);
                return await this.getDepsInfo(false, supportedVersions, undefined, error);
            }
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.nodeVersion, {
                "global-version": `${currentVersion.version}`,
                "global-major-version": `${currentVersion.majorVersion}`,
            });
            if (!this.isVersionSupported(supportedVersions, currentVersion)) {
                this._telemetry.sendUserErrorEvent(this._nodeNotSupportedEvent, `Node.js ${currentVersion.version} is not supported.`);
                return await this.getDepsInfo(!NodeChecker.isVersionError(this._minErrorVersion, this._maxErrorVersion, currentVersion), supportedVersions, currentVersion.version, this.getVersionNotSupportedError(supportedVersions, currentVersion));
            }
            return await this.getDepsInfo(true, supportedVersions, currentVersion.version);
        }
        catch (error) {
            return await this.getDepsInfo(false, supportedVersions, undefined, new depsError_1.DepsCheckerError(error.message, helpLink_1.nodeNotFoundHelpLink));
        }
    }
    async resolve(installOptions) {
        const installationInfo = await this.getInstallationInfo(installOptions);
        if (installationInfo.error) {
            this._logger.printDetailLog();
            this._logger.error(`${installationInfo.error.message}, error = '${installationInfo.error.toString()}'`);
        }
        this._logger.cleanup();
        return installationInfo;
    }
    async install() {
        return Promise.resolve();
    }
    async getDepsInfo(isInstalled, supportedVersions, installVersion, error) {
        return {
            name: NodeName,
            type: this._type,
            isInstalled: isInstalled,
            command: await this.command(),
            details: {
                isLinuxSupported: true,
                supportedVersions: supportedVersions,
                installVersion: installVersion,
            },
            error: error,
        };
    }
    static isVersionError(minErrorVersion, maxErrorVersion, version) {
        const majorVersion = Number.parseInt(version.majorVersion);
        return (!Number.isInteger(majorVersion) ||
            majorVersion <= minErrorVersion ||
            majorVersion >= maxErrorVersion);
    }
    command() {
        return Promise.resolve("node");
    }
    static async getInstalledNodeVersion() {
        try {
            const output = await cpUtils_1.cpUtils.executeCommand(undefined, undefined, undefined, "node", "--version");
            return getNodeVersion(output);
        }
        catch (error) {
            return null;
        }
    }
}
exports.NodeChecker = NodeChecker;
function getNodeVersion(output) {
    var _a;
    const regex = /v(?<major_version>\d+)\.(?<minor_version>\d+)\.(?<patch_version>\d+)/gm;
    const match = regex.exec(output);
    if (!match) {
        return null;
    }
    const majorVersion = (_a = match.groups) === null || _a === void 0 ? void 0 : _a.major_version;
    if (!majorVersion) {
        return null;
    }
    return new NodeVersion(match[0], majorVersion);
}
class LtsNodeChecker extends NodeChecker {
    constructor() {
        super(...arguments);
        this._nodeNotFoundHelpLink = helpLink_1.v3NodeNotFoundHelpLink;
        this._nodeNotSupportedEvent = telemetry_1.DepsCheckerEvent.nodeNotLts;
        this._type = depsChecker_1.DepsType.LtsNode;
        this._minErrorVersion = Number.MIN_SAFE_INTEGER;
        this._maxErrorVersion = Number.MAX_SAFE_INTEGER;
    }
    getSupportedVersions() {
        return Promise.resolve(["16", "18"]);
    }
    isVersionSupported(supportedVersions, version) {
        return supportedVersions.includes(version.majorVersion);
    }
    getVersionNotSupportedError(supportedVersions, version) {
        const supportedVersionsString = supportedVersions.map((v) => "v" + v).join(", ");
        return new depsError_1.NodeNotLtsError(message_1.Messages.NodeNotLts(version.version, supportedVersionsString), helpLink_1.v3NodeNotLtsHelpLink);
    }
}
exports.LtsNodeChecker = LtsNodeChecker;
class ProjectNodeChecker extends NodeChecker {
    constructor() {
        super(...arguments);
        this._nodeNotFoundHelpLink = helpLink_1.v3NodeNotFoundHelpLink;
        this._nodeNotSupportedEvent = telemetry_1.DepsCheckerEvent.nodeNotSupportedForProject;
        this._type = depsChecker_1.DepsType.ProjectNode;
        this._minErrorVersion = Number.MIN_SAFE_INTEGER;
        this._maxErrorVersion = Number.MAX_SAFE_INTEGER;
    }
    getNodeNotSupportedHelpLink() {
        return Promise.resolve(helpLink_1.v3NodeNotSupportedHelpLink);
    }
    async getSupportedVersions(projectPath) {
        if (!projectPath) {
            return [];
        }
        const supportedVersion = await this.getSupportedVersion(projectPath);
        return supportedVersion ? [supportedVersion] : [];
    }
    async getSupportedVersion(projectPath) {
        var _a;
        try {
            const packageJson = await fs.readJSON(path.join(projectPath, "package.json"));
            const node = (_a = packageJson === null || packageJson === void 0 ? void 0 : packageJson.engines) === null || _a === void 0 ? void 0 : _a.node;
            if (typeof node !== "string") {
                return undefined;
            }
            return node;
        }
        catch (_b) {
            return undefined;
        }
    }
    isVersionSupported(supportedVersions, version) {
        if (supportedVersions.length == 0) {
            return true;
        }
        const supportedVersion = supportedVersions[0];
        return semver_1.default.satisfies(version.version, supportedVersion);
    }
    getVersionNotSupportedError(supportedVersions, version) {
        const supportedVersionsString = supportedVersions.join(", ");
        return new depsError_1.V3NodeNotSupportedError(message_1.Messages.V3NodeNotSupported(version.version, supportedVersionsString), helpLink_1.v3NodeNotSupportedHelpLink);
    }
}
exports.ProjectNodeChecker = ProjectNodeChecker;
//# sourceMappingURL=nodeChecker.js.map