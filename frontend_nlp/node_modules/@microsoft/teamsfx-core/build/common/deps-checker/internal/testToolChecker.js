"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestToolChecker = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const url = tslib_1.__importStar(require("url"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const uuid = tslib_1.__importStar(require("uuid"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const localizeUtils_1 = require("../../localizeUtils");
const helpLink_1 = require("../constant/helpLink");
const message_1 = require("../constant/message");
const depsChecker_1 = require("../depsChecker");
const depsError_1 = require("../depsError");
const fileHelper_1 = require("../util/fileHelper");
const system_1 = require("../util/system");
const telemetry_1 = require("../constant/telemetry");
const util_1 = require("../util");
var InstallType;
(function (InstallType) {
    InstallType["Global"] = "global";
    InstallType["Portable"] = "portable";
})(InstallType || (InstallType = {}));
class TestToolChecker {
    constructor() {
        this.name = "Teams App Test Tool";
        this.npmPackageName = "@microsoft/teams-app-test-tool";
        this.timeout = 5 * 60 * 1000;
        this.checkUpdateTimeout = 10 * 1000;
        this.commandName = system_1.isWindows() ? "teamsapptester.cmd" : "teamsapptester";
        this.portableDirName = "testTool";
        // 7 days
        this.defaultUpdateInterval = 7 * 24 * 60 * 60 * 1000;
        this.telemetryProperties = {};
    }
    async getInstallationInfo(installOptions) {
        const symlinkDir = path.resolve(installOptions.projectPath, installOptions.symlinkDir);
        // check version in project devTools
        const versionRes = await this.checkVersion(installOptions.versionRange, this.getBinFolder(symlinkDir));
        if (versionRes.isOk()) {
            this.telemetryProperties[telemetry_1.TelemetryProperties.SymlinkTestToolVersion] = versionRes.value;
            return await this.getSuccessDepsInfo(versionRes.value, symlinkDir);
        }
        else {
            this.telemetryProperties[telemetry_1.TelemetryProperties.SymlinkTestToolVersionError] =
                versionRes.error.message;
            await fileHelper_1.unlinkSymlink(symlinkDir);
        }
        // check version in ${HOME}/.fx/bin
        const version = await this.findLatestInstalledPortableVersion(installOptions.versionRange);
        if (version) {
            const portablePath = path.join(this.getPortableVersionsDir(), version);
            this.telemetryProperties[telemetry_1.TelemetryProperties.SelectedPortableTestToolVersion] = version;
            await fileHelper_1.createSymlink(portablePath, symlinkDir);
            return await this.getSuccessDepsInfo(version, symlinkDir);
        }
        // check global version in PATH
        const globalVersionRes = await this.checkVersion(installOptions.versionRange);
        if (globalVersionRes.isOk()) {
            const version = globalVersionRes.value;
            this.telemetryProperties[telemetry_1.TelemetryProperties.GlobalTestToolVersion] = version;
            return this.getSuccessDepsInfo(version, undefined);
        }
        else {
            this.telemetryProperties[telemetry_1.TelemetryProperties.GlobalTestToolVersionError] =
                globalVersionRes.error.message;
        }
        return this.createFailureDepsInfo(installOptions.versionRange, undefined);
    }
    async resolve(installOptions) {
        let installationInfo;
        try {
            if (!(await this.hasNode())) {
                throw new depsError_1.NodeNotFoundError(message_1.Messages.NodeNotFound(), helpLink_1.v3NodeNotFoundHelpLink);
            }
            installationInfo = await this.getInstallationInfo(installOptions);
            if (!installationInfo.isInstalled) {
                const symlinkDir = path.resolve(installOptions.projectPath, installOptions.symlinkDir);
                installationInfo = await this.install(installOptions.projectPath, installOptions.versionRange, symlinkDir);
            }
            else {
                if (installationInfo.installType === InstallType.Portable) {
                    const updateInstallationInfo = await this.autoUpdate(installOptions);
                    if (updateInstallationInfo) {
                        installationInfo = updateInstallationInfo;
                    }
                }
            }
            return installationInfo;
        }
        catch (error) {
            if (error instanceof depsError_1.DepsCheckerError) {
                return await this.createFailureDepsInfo(installOptions.versionRange, error);
            }
            return await this.createFailureDepsInfo(installOptions.versionRange, new depsError_1.DepsCheckerError(error.message, helpLink_1.v3DefaultHelpLink));
        }
    }
    async install(projectPath, versionRange, symlinkDir) {
        if (!(await this.hasNPM())) {
            throw new depsError_1.DepsCheckerError(message_1.Messages.needInstallNpm(), helpLink_1.v3DefaultHelpLink);
        }
        const tmpVersion = `tmp-${uuid.v4().slice(0, 6)}`;
        const tmpPath = this.getPortableInstallPath(tmpVersion);
        await this.npmInstall(projectPath, tmpPath, versionRange);
        const versionRes = await this.checkVersion(versionRange, this.getBinFolder(tmpPath));
        if (versionRes.isErr()) {
            await fileHelper_1.cleanup(tmpPath);
            this.telemetryProperties[telemetry_1.TelemetryProperties.InstallTestToolError] = versionRes.error.message;
            throw new depsError_1.DepsCheckerError(message_1.Messages.failToValidateTestTool(versionRes.error.message), helpLink_1.v3DefaultHelpLink);
        }
        const actualVersion = versionRes.value;
        this.telemetryProperties[telemetry_1.TelemetryProperties.InstalledTestToolVersion] = actualVersion;
        const actualPath = this.getPortableInstallPath(actualVersion);
        await fileHelper_1.rename(tmpPath, actualPath);
        await fileHelper_1.createSymlink(actualPath, symlinkDir);
        await this.writeInstallInfoFile(projectPath);
        return await this.getSuccessDepsInfo(versionRes.value, symlinkDir);
    }
    async hasNewVersionReleasedInRange(latestInstalledVersion, versionRange) {
        try {
            const result = await util_1.cpUtils.executeCommand(undefined, undefined, 
            // avoid powershell execution policy issue.
            { shell: system_1.isWindows() ? "cmd.exe" : true, timeout: this.checkUpdateTimeout }, "npm", "view", `"${this.npmPackageName}@${versionRange}"`, "version", "--json");
            // when there are one result, it will return string
            // when there are multiple results, it will return array of strings
            let versionList = JSON.parse(result);
            if (typeof versionList === "string") {
                versionList = [versionList];
            }
            if (!Array.isArray(versionList)) {
                // do update if npm returned invalid result
                return true;
            }
            return versionList.filter((v) => semver_1.default.gt(v, latestInstalledVersion)).length > 0;
        }
        catch (_a) {
            // just a best effort optimization to save one download if no recent version has been released
            // do update if check failed
            return true;
        }
    }
    // return undefined if not updated or update failure
    async autoUpdate(installOptions) {
        var _a;
        const installInfo = await this.readInstallInfoFile(installOptions.projectPath);
        const now = new Date().getTime();
        const updateExpired = !installInfo || now > installInfo.lastCheckTimestamp + this.defaultUpdateInterval;
        if (!updateExpired) {
            return undefined;
        }
        const latestInstalledVersion = await this.findLatestInstalledPortableVersion(installOptions.versionRange);
        if (latestInstalledVersion !== undefined &&
            !(await this.hasNewVersionReleasedInRange(latestInstalledVersion, installOptions.versionRange))) {
            return undefined;
        }
        this.telemetryProperties[telemetry_1.TelemetryProperties.TestToolLastUpdateTimestamp] =
            ((_a = installInfo === null || installInfo === void 0 ? void 0 : installInfo.lastCheckTimestamp) === null || _a === void 0 ? void 0 : _a.toString()) || "<never>";
        this.telemetryProperties[telemetry_1.TelemetryProperties.TestToolUpdatePreviousVersion] =
            latestInstalledVersion || "<undefined>";
        const symlinkDir = path.resolve(installOptions.projectPath, installOptions.symlinkDir);
        try {
            return await this.install(installOptions.projectPath, installOptions.versionRange, symlinkDir);
        }
        catch (e) {
            // ignore update failure and use existing version
            if (e instanceof Error) {
                this.telemetryProperties[telemetry_1.TelemetryProperties.TestToolUpdateError] = e.message;
            }
            await this.writeInstallInfoFile(installOptions.projectPath);
            return undefined;
        }
    }
    validateInstallInfoFile(data) {
        if ("lastCheckTimestamp" in data) {
            if (typeof data.lastCheckTimestamp === "number") {
                return true;
            }
        }
        return false;
    }
    async readInstallInfoFile(projectPath) {
        const installInfoPath = this.getInstallInfoPath(projectPath);
        try {
            const data = await fs.readJson(installInfoPath);
            if (this.validateInstallInfoFile(data)) {
                return data;
            }
        }
        catch (_a) {
            // ignore invalid installation info file
        }
        await fileHelper_1.cleanup(installInfoPath);
        return undefined;
    }
    async writeInstallInfoFile(projectPath) {
        const projectInfoPath = this.getInstallInfoPath(projectPath);
        const installInfo = {
            lastCheckTimestamp: new Date().getTime(),
        };
        await fs.ensureDir(path.dirname(projectInfoPath));
        await fs.writeJson(projectInfoPath, installInfo);
    }
    async findLatestInstalledPortableVersion(versionRange) {
        var _a;
        let portablePath;
        try {
            const portableVersionsDir = this.getPortableVersionsDir();
            const dirs = await fs.readdir(portableVersionsDir, { withFileTypes: true });
            const satisfiedVersions = dirs
                .filter((dir) => dir.isDirectory() && semver_1.default.valid(dir.name) && semver_1.default.satisfies(dir.name, versionRange))
                .map((dir) => dir.name);
            // sort by version desc
            satisfiedVersions.sort((a, b) => semver_1.default.rcompare(a, b));
            // find the latest version that is working
            for (const version of satisfiedVersions) {
                portablePath = path.join(portableVersionsDir, version);
                const checkVersionRes = await this.checkVersion(versionRange, this.getBinFolder(portablePath));
                if (checkVersionRes.isOk()) {
                    return version;
                }
                this.telemetryProperties[telemetry_1.TelemetryProperties.VersioningFuncVersionError] =
                    ((_a = this.telemetryProperties[telemetry_1.TelemetryProperties.VersioningFuncVersionError]) !== null && _a !== void 0 ? _a : "") +
                        `[${version}] ${checkVersionRes.error.message}`;
            }
        }
        catch (_b) {
            // ignore errors if portable dir doesn't exist
        }
        return undefined;
    }
    async checkVersion(versionRange, binFolder) {
        try {
            const actualVersion = await this.queryVersion(binFolder);
            if (semver_1.default.satisfies(actualVersion, versionRange)) {
                return teamsfx_api_1.ok(actualVersion);
            }
            else {
                return teamsfx_api_1.err(new depsError_1.DepsCheckerError(message_1.Messages.testToolVersionNotMatch(actualVersion, versionRange), helpLink_1.v3DefaultHelpLink));
            }
        }
        catch (error) {
            return teamsfx_api_1.err(new depsError_1.DepsCheckerError(error.message, helpLink_1.v3DefaultHelpLink));
        }
    }
    async queryVersion(binFolder) {
        const execPath = binFolder ? path.resolve(binFolder, this.commandName) : this.commandName;
        const output = await util_1.cpUtils.executeCommand(undefined, undefined, 
        // avoid powershell execution policy issue.
        { shell: system_1.isWindows() ? "cmd.exe" : true, timeout: this.timeout }, `"${execPath}"`, "--version");
        return output.trim();
    }
    async hasNode() {
        try {
            await util_1.cpUtils.executeCommand(undefined, undefined, { shell: true }, "node", "--version");
            return true;
        }
        catch (error) {
            return false;
        }
    }
    async hasNPM() {
        try {
            await util_1.cpUtils.executeCommand(undefined, undefined, { shell: true }, "npm", "--version");
            return true;
        }
        catch (error) {
            return false;
        }
    }
    async npmInstall(projectPath, prefix, versionRange) {
        var _a, _b;
        let pkg;
        // Before we release package to npm registry we can use tgz to test
        pkg || (pkg = await this.findLocalNpmPackage(projectPath));
        pkg || (pkg = await this.findLocalNpmPackage(path.join(projectPath, "devTools")));
        pkg || (pkg = `${this.npmPackageName}@${versionRange}`);
        try {
            await util_1.cpUtils.executeCommand(undefined, undefined, 
            // avoid powershell execution policy issue.
            { shell: system_1.isWindows() ? "cmd.exe" : true, timeout: this.timeout }, `npm`, "install", `"${pkg}"`, "--prefix", `"${prefix}"`, "--no-audit");
        }
        catch (error) {
            await fileHelper_1.cleanup(prefix);
            // @ is incorrectly identified as an email format.
            this.telemetryProperties[telemetry_1.TelemetryProperties.InstallTestToolError] = (_b = (_a = error.message) === null || _a === void 0 ? void 0 : _a.split(pkg)) === null || _b === void 0 ? void 0 : _b.join(pkg);
            throw new depsError_1.DepsCheckerError(localizeUtils_1.getLocalizedString("error.common.InstallSoftwareError", this.name), helpLink_1.v3DefaultHelpLink);
        }
    }
    // TODO: remove after release to npm
    async findLocalNpmPackage(dir) {
        try {
            const files = await fs.readdir(dir);
            for (const fileName of files) {
                const fullPath = path.join(dir, fileName);
                if (fileName.match(/microsoft-teams-app-test-tool.*\.tgz/i)) {
                    try {
                        const st = await fs.stat(fullPath);
                        if (st.isFile()) {
                            // encode special characters in path
                            return url.pathToFileURL(fullPath).toString();
                        }
                    }
                    catch (_a) {
                        // ignore invalid files
                    }
                }
            }
        }
        catch (_b) {
            // local npm package error should not block
        }
        return undefined;
    }
    getBinFolder(installPath) {
        return path.join(installPath, "node_modules", ".bin");
    }
    getPortableVersionsDir() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", this.portableDirName);
    }
    getPortableInstallPath(version) {
        return path.join(this.getPortableVersionsDir(), version);
    }
    getInstallInfoPath(projectDir) {
        return path.join(projectDir, "devTools", ".testTool.installInfo.json");
    }
    async getSuccessDepsInfo(version, binFolder) {
        return Promise.resolve({
            name: this.name,
            type: depsChecker_1.DepsType.TestTool,
            isInstalled: true,
            command: this.commandName,
            details: {
                isLinuxSupported: true,
                supportedVersions: [],
                binFolders: binFolder ? [binFolder] : [],
                installVersion: version,
            },
            telemetryProperties: this.telemetryProperties,
            error: undefined,
            installType: binFolder ? InstallType.Portable : InstallType.Global,
        });
    }
    async createFailureDepsInfo(version, error) {
        return Promise.resolve({
            name: this.name,
            type: depsChecker_1.DepsType.TestTool,
            isInstalled: false,
            command: this.commandName,
            details: {
                isLinuxSupported: true,
                supportedVersions: [],
                binFolders: [],
                installVersion: version,
            },
            telemetryProperties: this.telemetryProperties,
            error: error,
        });
    }
}
exports.TestToolChecker = TestToolChecker;
//# sourceMappingURL=testToolChecker.js.map