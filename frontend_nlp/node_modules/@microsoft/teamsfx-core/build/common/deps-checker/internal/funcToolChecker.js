"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FuncToolChecker = void 0;
const tslib_1 = require("tslib");
/**
 * @author Xiaofu Huang <xiaofhua@microsoft.com>
 */
const fs = tslib_1.__importStar(require("fs-extra"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const uuid = tslib_1.__importStar(require("uuid"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const localizeUtils_1 = require("../../localizeUtils");
const helpLink_1 = require("../constant/helpLink");
const message_1 = require("../constant/message");
const depsChecker_1 = require("../depsChecker");
const depsError_1 = require("../depsError");
const cpUtils_1 = require("../util/cpUtils");
const fileHelper_1 = require("../util/fileHelper");
const system_1 = require("../util/system");
const nodeChecker_1 = require("./nodeChecker");
const telemetry_1 = require("../constant/telemetry");
const nodeFuncVersionRangeMapping = {
    "12": "3",
    "14": "3 || 4",
    "16": ">=4",
    "18": ">=4.0.4670",
};
const funcPackageName = "azure-functions-core-tools";
const funcToolName = "Azure Functions Core Tools";
const timeout = 5 * 60 * 1000;
class FuncToolChecker {
    constructor(logger, telemetry) {
        this.telemetryProperties = {};
    }
    async getDepsInfo(funcVersion, binFolder, error) {
        var _a;
        return Promise.resolve({
            name: funcToolName,
            type: depsChecker_1.DepsType.FuncCoreTools,
            isInstalled: !!funcVersion,
            command: "func",
            details: {
                isLinuxSupported: false,
                installVersion: (_a = funcVersion === null || funcVersion === void 0 ? void 0 : funcVersion.versionStr) !== null && _a !== void 0 ? _a : undefined,
                supportedVersions: [],
                binFolders: binFolder ? [binFolder] : undefined,
            },
            telemetryProperties: this.telemetryProperties,
            error: error,
        });
    }
    async resolve(installOptions) {
        let installationInfo;
        try {
            const nodeVersion = await this.getNodeVersion();
            installationInfo = await this.getInstallationInfo(installOptions);
            if (!installationInfo.isInstalled) {
                const symlinkDir = installOptions.symlinkDir
                    ? path.resolve(installOptions.projectPath, installOptions.symlinkDir)
                    : undefined;
                installationInfo = await this.install(installOptions.version, symlinkDir);
            }
            if (!installationInfo.error &&
                installationInfo.isInstalled &&
                installationInfo.details.installVersion) {
                const expectedFuncNodeError = this.checkExpectedFuncAndNode(installationInfo.details.installVersion, nodeVersion);
                if (expectedFuncNodeError) {
                    installationInfo.error = expectedFuncNodeError;
                }
            }
            return installationInfo;
        }
        catch (error) {
            if (error instanceof depsError_1.DepsCheckerError) {
                return await this.getDepsInfo(undefined, undefined, error);
            }
            return await this.getDepsInfo(undefined, undefined, new depsError_1.DepsCheckerError(error.message, helpLink_1.v3DefaultHelpLink));
        }
    }
    async getInstallationInfo(installOptions) {
        const symlinkDir = installOptions.symlinkDir
            ? path.resolve(installOptions.projectPath, installOptions.symlinkDir)
            : undefined;
        if (symlinkDir) {
            const symlinkFuncRes = await this.checkFuncVersion(installOptions.version, symlinkDir, undefined);
            if (symlinkFuncRes.isOk()) {
                this.telemetryProperties[telemetry_1.TelemetryProperties.SymlinkFuncVersion] =
                    symlinkFuncRes.value.versionStr;
                return await this.getDepsInfo(symlinkFuncRes.value, symlinkDir);
            }
            else {
                this.telemetryProperties[telemetry_1.TelemetryProperties.SymlinkFuncVersionError] =
                    symlinkFuncRes.error.message;
                await fileHelper_1.unlinkSymlink(symlinkDir);
            }
        }
        const portableFunc = await this.checkPortableFuncVersion(installOptions.version);
        if (portableFunc) {
            this.telemetryProperties[telemetry_1.TelemetryProperties.SelectedPortableFuncVersion] =
                portableFunc.funcVersion.versionStr;
            if (symlinkDir) {
                await fileHelper_1.createSymlink(portableFunc.binFolder, symlinkDir);
                return await this.getDepsInfo(portableFunc.funcVersion, symlinkDir);
            }
            return await this.getDepsInfo(portableFunc.funcVersion, portableFunc.binFolder);
        }
        const globalFuncRes = await this.checkFuncVersion(installOptions.version, undefined, undefined);
        if (globalFuncRes.isOk()) {
            this.telemetryProperties[telemetry_1.TelemetryProperties.GlobalFuncVersion] =
                globalFuncRes.value.versionStr;
            return await this.getDepsInfo(globalFuncRes.value, undefined);
        }
        else {
            this.telemetryProperties[telemetry_1.TelemetryProperties.GlobalFuncVersionError] =
                globalFuncRes.error.message;
            return await this.getDepsInfo(undefined, undefined);
        }
    }
    async getNodeVersion() {
        var _a;
        const nodeVersion = (_a = (await nodeChecker_1.NodeChecker.getInstalledNodeVersion())) === null || _a === void 0 ? void 0 : _a.majorVersion;
        if (!nodeVersion) {
            throw new depsError_1.NodeNotFoundError(message_1.Messages.NodeNotFound(), helpLink_1.v3NodeNotFoundHelpLink);
        }
        return nodeVersion;
    }
    checkExpectedFuncAndNode(funcVersion, nodeVersion) {
        const funcVersionRange = nodeFuncVersionRangeMapping[nodeVersion];
        if (funcVersionRange && !semver_1.default.satisfies(funcVersion, funcVersionRange)) {
            return new depsError_1.DepsCheckerError(message_1.Messages.portableFuncNodeNotMatched(nodeVersion, funcVersion), helpLink_1.v3DefaultHelpLink);
        }
        return undefined;
    }
    async checkPortableFuncVersion(expectedFuncVersion) {
        try {
            const historyFuncBinFolder = FuncToolChecker.getPortableFuncBinFolder(undefined);
            const historyFuncRes = await this.checkFuncVersion(expectedFuncVersion, historyFuncBinFolder, FuncToolChecker.getHistorySentinelPath());
            if (historyFuncRes.isOk()) {
                this.telemetryProperties[telemetry_1.TelemetryProperties.HistoryFuncVersion] =
                    historyFuncRes.value.versionStr;
            }
            else {
                this.telemetryProperties[telemetry_1.TelemetryProperties.HistoryFuncVersionError] =
                    historyFuncRes.error.message;
            }
            const versioningFuncStatus = await this.getVersioningPortableFunc(expectedFuncVersion);
            if (versioningFuncStatus &&
                (historyFuncRes.isErr() ||
                    semver_1.default.gte(versioningFuncStatus.funcVersion.versionStr, historyFuncRes.value.versionStr))) {
                return versioningFuncStatus;
            }
            else if (historyFuncRes.isOk()) {
                return { funcVersion: historyFuncRes.value, binFolder: historyFuncBinFolder };
            }
        }
        catch (error) {
            // do nothing
        }
        return undefined;
    }
    async checkFuncVersion(expectedFuncVersion, binFolder, sentinelPath) {
        try {
            const funcVersion = await this.queryFuncVersion(binFolder);
            // For portable func, avoid "func -v" and "func new" work well, but "func start" fail.
            const hasSentinel = sentinelPath ? await fs.pathExists(sentinelPath) : true;
            if (!hasSentinel) {
                return teamsfx_api_1.err(new depsError_1.DepsCheckerError(message_1.Messages.noSentinelFile(), helpLink_1.v3DefaultHelpLink));
            }
            const funcVersionSupport = isFuncVersionSupport(funcVersion, expectedFuncVersion);
            if (!funcVersionSupport) {
                return teamsfx_api_1.err(new depsError_1.DepsCheckerError(message_1.Messages.funcVersionNotMatch(funcVersion.versionStr, expectedFuncVersion), helpLink_1.v3DefaultHelpLink));
            }
            return teamsfx_api_1.ok(funcVersion);
        }
        catch (error) {
            return teamsfx_api_1.err(new depsError_1.DepsCheckerError(error.message, helpLink_1.v3DefaultHelpLink));
        }
    }
    async getVersioningPortableFunc(expectedFuncVersion) {
        var _a;
        const files = await fs.readdir(FuncToolChecker.getDefaultInstallPath(), {
            withFileTypes: true,
        });
        const funcDictionaries = files
            .filter((f) => f.isDirectory() && semver_1.default.valid(f.name))
            .map((f) => f.name);
        this.telemetryProperties[telemetry_1.TelemetryProperties.VersioningFuncVersions] =
            JSON.stringify(funcDictionaries);
        while (funcDictionaries.length > 0) {
            const matchedVersion = semver_1.default.maxSatisfying(funcDictionaries, expectedFuncVersion);
            if (!matchedVersion) {
                return undefined;
            }
            const binFolder = FuncToolChecker.getPortableFuncBinFolder(matchedVersion);
            const actualFuncRes = await this.checkFuncVersion(expectedFuncVersion, binFolder, FuncToolChecker.getVersioningSentinelPath(matchedVersion));
            if (actualFuncRes.isOk() && actualFuncRes.value.versionStr === matchedVersion) {
                return {
                    funcVersion: actualFuncRes.value,
                    binFolder: binFolder,
                };
            }
            if (actualFuncRes.isErr()) {
                this.telemetryProperties[telemetry_1.TelemetryProperties.VersioningFuncVersionError] =
                    ((_a = this.telemetryProperties[telemetry_1.TelemetryProperties.VersioningFuncVersionError]) !== null && _a !== void 0 ? _a : "") +
                        `[${matchedVersion}] ${actualFuncRes.error.message}`;
            }
            const matchedVersionIndex = funcDictionaries.indexOf(matchedVersion);
            if (matchedVersionIndex < 0) {
                return undefined;
            }
            funcDictionaries.splice(matchedVersionIndex, 1);
        }
        return undefined;
    }
    async install(expectedFuncVersion, symlinkDir) {
        if (system_1.isLinux()) {
            throw new depsError_1.LinuxNotSupportedError(message_1.Messages.linuxDepsNotFound().split("@SupportedPackages").join(funcToolName), helpLink_1.v3DefaultHelpLink);
        }
        if (!(await this.hasNPM())) {
            throw new depsError_1.DepsCheckerError(message_1.Messages.needInstallNpm(), helpLink_1.v3DefaultHelpLink);
        }
        const tmpVersion = `tmp-${uuid.v4().slice(0, 6)}`;
        await this.installFunc(tmpVersion, expectedFuncVersion);
        const funcVersionRes = await this.checkFuncVersion(expectedFuncVersion, FuncToolChecker.getPortableFuncBinFolder(tmpVersion), FuncToolChecker.getVersioningSentinelPath(tmpVersion));
        if (funcVersionRes.isErr()) {
            await this.cleanup(tmpVersion);
            this.telemetryProperties[telemetry_1.TelemetryProperties.InstallFuncError] = funcVersionRes.error.message;
            throw new depsError_1.DepsCheckerError(message_1.Messages.failToValidateFuncCoreTool() + " " + funcVersionRes.error.message, helpLink_1.v3DefaultHelpLink);
        }
        this.telemetryProperties[telemetry_1.TelemetryProperties.InstalledFuncVersion] =
            funcVersionRes.value.versionStr;
        await fileHelper_1.rename(FuncToolChecker.getFuncInstallPath(tmpVersion), FuncToolChecker.getFuncInstallPath(funcVersionRes.value.versionStr));
        const binFolder = FuncToolChecker.getPortableFuncBinFolder(funcVersionRes.value.versionStr);
        if (symlinkDir) {
            await fileHelper_1.createSymlink(binFolder, symlinkDir);
            return await this.getDepsInfo(funcVersionRes.value, symlinkDir);
        }
        return await this.getDepsInfo(funcVersionRes.value, binFolder);
    }
    static getDefaultInstallPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", "azfunc");
    }
    static getFuncInstallPath(versionStr) {
        return versionStr
            ? path.join(this.getDefaultInstallPath(), versionStr)
            : path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", "func");
    }
    static getVersioningSentinelPath(versionStr) {
        return path.join(FuncToolChecker.getPortableFuncBinFolder(versionStr), "func-sentinel");
    }
    static getHistorySentinelPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "func-sentinel");
    }
    static getPortableFuncBinFolder(versionStr) {
        return path.resolve(FuncToolChecker.getFuncInstallPath(versionStr), "node_modules", "azure-functions-core-tools", "bin");
    }
    async queryFuncVersion(funcBinFolder) {
        const execPath = funcBinFolder ? path.resolve(funcBinFolder, "func") : "func";
        const output = await cpUtils_1.cpUtils.executeCommand(undefined, undefined, 
        // same as backend start, avoid powershell execution policy issue.
        { shell: system_1.isWindows() ? "cmd.exe" : true }, `"${execPath}"`, "--version");
        return mapToFuncToolsVersion(output);
    }
    async hasNPM() {
        try {
            await cpUtils_1.cpUtils.executeCommand(undefined, undefined, { shell: true }, "npm", "--version");
            return true;
        }
        catch (error) {
            return false;
        }
    }
    async cleanup(tmpVersionStr) {
        try {
            await fs.remove(FuncToolChecker.getFuncInstallPath(tmpVersionStr));
        }
        catch (_a) { }
    }
    async installFunc(tmpVersion, expectedFuncVersion) {
        var _a, _b;
        try {
            const tmpFolder = FuncToolChecker.getFuncInstallPath(tmpVersion);
            await cpUtils_1.cpUtils.executeCommand(undefined, undefined, { timeout: timeout, shell: false }, this.getExecCommand("npm"), "install", 
            // not use -f, to avoid npm@6 bug: exit code = 0, even if install fail
            `${funcPackageName}@${expectedFuncVersion}`, "--prefix", `${tmpFolder}`, "--no-audit");
            await fs.ensureFile(FuncToolChecker.getVersioningSentinelPath(tmpVersion));
        }
        catch (error) {
            await this.cleanup(tmpVersion);
            // ${funcPackageName}@${expectedFuncVersion} is incorrectly identified as an email format.
            this.telemetryProperties[telemetry_1.TelemetryProperties.InstallFuncError] = (_b = (_a = error.message) === null || _a === void 0 ? void 0 : _a.split(`${funcPackageName}@${expectedFuncVersion}`)) === null || _b === void 0 ? void 0 : _b.join(`${funcPackageName}{at}${expectedFuncVersion}`);
            throw new depsError_1.DepsCheckerError(localizeUtils_1.getLocalizedString("error.common.InstallSoftwareError", funcToolName), helpLink_1.v3DefaultHelpLink);
        }
    }
    getExecCommand(command) {
        return system_1.isWindows() ? `${command}.cmd` : command;
    }
}
exports.FuncToolChecker = FuncToolChecker;
function mapToFuncToolsVersion(output) {
    var _a, _b, _c, _d, _e, _f;
    const regex = /(?<major_version>\d+)\.(?<minor_version>\d+)\.(?<patch_version>\d+)/gm;
    const match = regex.exec(output);
    if (!match) {
        throw new depsError_1.DepsCheckerError(message_1.Messages.invalidFuncVersion(output), helpLink_1.v3DefaultHelpLink);
    }
    const majorVersion = Number.parseInt((_b = (_a = match.groups) === null || _a === void 0 ? void 0 : _a.major_version) !== null && _b !== void 0 ? _b : "");
    const minorVersion = Number.parseInt((_d = (_c = match.groups) === null || _c === void 0 ? void 0 : _c.minor_version) !== null && _d !== void 0 ? _d : "");
    const patchVersion = Number.parseInt((_f = (_e = match.groups) === null || _e === void 0 ? void 0 : _e.patch_version) !== null && _f !== void 0 ? _f : "");
    if (!Number.isInteger(majorVersion) ||
        !Number.isInteger(minorVersion) ||
        !Number.isInteger(patchVersion)) {
        throw new depsError_1.DepsCheckerError(message_1.Messages.invalidFuncVersion(output), helpLink_1.v3DefaultHelpLink);
    }
    return {
        majorVersion: majorVersion,
        minorVersion: minorVersion,
        patchVersion: patchVersion,
        versionStr: `${majorVersion}.${minorVersion}.${patchVersion}`,
    };
}
function isFuncVersionSupport(actualFuncVersion, expectedFuncVersion) {
    return semver_1.default.satisfies(actualFuncVersion.versionStr, expectedFuncVersion);
}
//# sourceMappingURL=funcToolChecker.js.map