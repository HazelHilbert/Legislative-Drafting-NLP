"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listDevTunnels = exports.getFixedCommonProjectSettings = exports.ConvertTokenToJson = exports.setRegion = exports.getSPFxToken = exports.getSPFxTenant = exports.AzureScopes = exports.SPFxScopes = exports.GraphReadUserScopes = exports.GraphScopes = exports.AuthSvcScopes = exports.AppStudioScopes = exports.getSideloadingStatus = exports.getCopilotStatus = exports.getAllowedAppMaps = exports.getHashedEnv = exports.isVideoFilterProject = exports.isSPFxProject = exports.getUuid = exports.waitSeconds = exports.parseFromResourceId = exports.getResourceGroupNameFromResourceId = exports.compileHandlebarsTemplateString = exports.getResourceGroupInPortal = exports.askSubscription = exports.isCheckAccountError = exports.isUserCancelError = exports.deepCopy = void 0;
const tslib_1 = require("tslib");
const dev_tunnels_management_1 = require("@microsoft/dev-tunnels-management");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const axios_1 = tslib_1.__importDefault(require("axios"));
const crypto = tslib_1.__importStar(require("crypto"));
const fs = tslib_1.__importStar(require("fs-extra"));
const Handlebars = tslib_1.__importStar(require("handlebars"));
const uuid = tslib_1.__importStar(require("uuid"));
const yaml_1 = require("yaml");
const constants_1 = require("../component/constants");
const appStudioClient_1 = require("../component/driver/teamsApp/clients/appStudioClient");
const authSvcClient_1 = require("../component/driver/teamsApp/clients/authSvcClient");
const constants_2 = require("../component/driver/teamsApp/constants");
const ManifestUtils_1 = require("../component/driver/teamsApp/utils/ManifestUtils");
const appStudioClient_2 = require("../component/resource/botService/appStudio/appStudioClient");
const error_1 = require("../core/error");
const projectSettingsLoader_1 = require("../core/middleware/projectSettingsLoader");
const common_1 = require("../error/common");
const constants_3 = require("./constants");
const localizeUtils_1 = require("./localizeUtils");
const packageService_1 = require("./m365/packageService");
Handlebars.registerHelper("contains", (value, array) => {
    array = array instanceof Array ? array : [array];
    return array.indexOf(value) > -1 ? this : "";
});
Handlebars.registerHelper("notContains", (value, array) => {
    array = array instanceof Array ? array : [array];
    return array.indexOf(value) == -1 ? this : "";
});
Handlebars.registerHelper("equals", (value, target) => {
    return value === target ? this : "";
});
const AzurePortalUrl = "https://portal.azure.com";
const deepCopy = (target) => {
    if (target === null) {
        return target;
    }
    if (target instanceof Date) {
        return new Date(target.getTime());
    }
    if (target instanceof Array) {
        const cp = [];
        target.forEach((v) => {
            cp.push(v);
        });
        return cp.map((n) => exports.deepCopy(n));
    }
    if (typeof target === "object" && Object.keys(target).length) {
        const cp = Object.assign({}, target);
        Object.keys(cp).forEach((k) => {
            cp[k] = exports.deepCopy(cp[k]);
        });
        return cp;
    }
    return target;
};
exports.deepCopy = deepCopy;
function isUserCancelError(error) {
    const errorName = "name" in error ? error["name"] : "";
    return (errorName === "User Cancel" || errorName === "CancelProvision" || errorName === "UserCancel");
}
exports.isUserCancelError = isUserCancelError;
function isCheckAccountError(error) {
    const errorName = "name" in error ? error["name"] : "";
    return (errorName === constants_1.SolutionError.TeamsAppTenantIdNotRight ||
        errorName === constants_1.SolutionError.SubscriptionNotFound);
}
exports.isCheckAccountError = isCheckAccountError;
async function askSubscription(azureAccountProvider, ui, activeSubscriptionId) {
    const subscriptions = await azureAccountProvider.listSubscriptions();
    if (subscriptions.length === 0) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError("Core", "NoSubscriptionFound", localizeUtils_1.getDefaultString("error.NoSubscriptionFound"), localizeUtils_1.getLocalizedString("error.NoSubscriptionFound")));
    }
    let resultSub = subscriptions.find((sub) => sub.subscriptionId === activeSubscriptionId);
    if (activeSubscriptionId === undefined || resultSub === undefined) {
        let selectedSub = undefined;
        if (subscriptions.length === 1) {
            selectedSub = subscriptions[0];
        }
        else {
            const options = subscriptions.map((sub) => {
                return {
                    id: sub.subscriptionId,
                    label: sub.subscriptionName,
                    data: sub.tenantId,
                };
            });
            const askRes = await ui.selectOption({
                name: "subscription",
                title: "Select a subscription",
                options: options,
                returnObject: true,
            });
            if (askRes.isErr())
                return teamsfx_api_1.err(askRes.error);
            const subItem = askRes.value.result;
            selectedSub = {
                subscriptionId: subItem.id,
                subscriptionName: subItem.label,
                tenantId: subItem.data,
            };
        }
        if (selectedSub === undefined) {
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError("Core", "NoSubscriptionFound", localizeUtils_1.getDefaultString("error.NoSubscriptionFound"), localizeUtils_1.getLocalizedString("error.NoSubscriptionFound")));
        }
        resultSub = selectedSub;
    }
    return teamsfx_api_1.ok(resultSub);
}
exports.askSubscription = askSubscription;
function getResourceGroupInPortal(subscriptionId, tenantId, resourceGroupName) {
    if (subscriptionId && tenantId && resourceGroupName) {
        return `${AzurePortalUrl}/#@${tenantId}/resource/subscriptions/${subscriptionId}/resourceGroups/${resourceGroupName}`;
    }
    else {
        return undefined;
    }
}
exports.getResourceGroupInPortal = getResourceGroupInPortal;
function compileHandlebarsTemplateString(templateString, context) {
    const template = Handlebars.compile(templateString);
    return template(context);
}
exports.compileHandlebarsTemplateString = compileHandlebarsTemplateString;
function getResourceGroupNameFromResourceId(resourceId) {
    const result = parseFromResourceId(/\/resourceGroups\/([^\/]*)\//i, resourceId);
    if (!result) {
        throw error_1.FailedToParseResourceIdError("resource group name", resourceId);
    }
    return result;
}
exports.getResourceGroupNameFromResourceId = getResourceGroupNameFromResourceId;
function parseFromResourceId(pattern, resourceId) {
    const result = resourceId.match(pattern);
    return result ? result[1].trim() : "";
}
exports.parseFromResourceId = parseFromResourceId;
async function waitSeconds(second) {
    return new Promise((resolve) => setTimeout(resolve, second * 1000));
}
exports.waitSeconds = waitSeconds;
function getUuid() {
    return uuid.v4();
}
exports.getUuid = getUuid;
function isSPFxProject(projectSettings) {
    const solutionSettings = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.solutionSettings;
    if (solutionSettings) {
        const selectedPlugins = solutionSettings.activeResourcePlugins;
        return selectedPlugins && selectedPlugins.indexOf("fx-resource-spfx") !== -1;
    }
    return false;
}
exports.isSPFxProject = isSPFxProject;
async function isVideoFilterProject(projectPath) {
    var _a;
    let manifestResult;
    try {
        manifestResult = await ManifestUtils_1.manifestUtils.readAppManifest(projectPath);
    }
    catch (e) {
        return teamsfx_api_1.err(common_1.assembleError(e));
    }
    if (manifestResult.isErr()) {
        return teamsfx_api_1.err(manifestResult.error);
    }
    const manifest = manifestResult.value;
    return teamsfx_api_1.ok(((_a = manifest.meetingExtensionDefinition) === null || _a === void 0 ? void 0 : _a.videoFiltersConfigurationUrl) !== undefined);
}
exports.isVideoFilterProject = isVideoFilterProject;
function getHashedEnv(envName) {
    return crypto.createHash("sha256").update(envName).digest("hex");
}
exports.getHashedEnv = getHashedEnv;
function getAllowedAppMaps() {
    return {
        [constants_3.TeamsClientId.MobileDesktop]: localizeUtils_1.getLocalizedString("core.common.TeamsMobileDesktopClientName"),
        [constants_3.TeamsClientId.Web]: localizeUtils_1.getLocalizedString("core.common.TeamsWebClientName"),
        [constants_3.OfficeClientId.Desktop]: localizeUtils_1.getLocalizedString("core.common.OfficeDesktopClientName"),
        [constants_3.OfficeClientId.Web1]: localizeUtils_1.getLocalizedString("core.common.OfficeWebClientName1"),
        [constants_3.OfficeClientId.Web2]: localizeUtils_1.getLocalizedString("core.common.OfficeWebClientName2"),
        [constants_3.OutlookClientId.Desktop]: localizeUtils_1.getLocalizedString("core.common.OutlookDesktopClientName"),
        [constants_3.OutlookClientId.Web1]: localizeUtils_1.getLocalizedString("core.common.OutlookWebClientName1"),
        [constants_3.OutlookClientId.Web2]: localizeUtils_1.getLocalizedString("core.common.OutlookWebClientName2"),
    };
}
exports.getAllowedAppMaps = getAllowedAppMaps;
function getCopilotStatus(token) {
    return packageService_1.PackageService.GetSharedInstance().getCopilotStatus(token);
}
exports.getCopilotStatus = getCopilotStatus;
async function getSideloadingStatus(token) {
    return appStudioClient_1.AppStudioClient.getSideloadingStatus(token);
}
exports.getSideloadingStatus = getSideloadingStatus;
exports.AppStudioScopes = [`${constants_2.getAppStudioEndpoint()}/AppDefinitions.ReadWrite`];
exports.AuthSvcScopes = ["https://api.spaces.skype.com/Region.ReadWrite"];
exports.GraphScopes = ["Application.ReadWrite.All", "TeamsAppInstallation.ReadForUser"];
exports.GraphReadUserScopes = ["https://graph.microsoft.com/User.ReadBasic.All"];
const SPFxScopes = (tenant) => [`${tenant}/Sites.FullControl.All`];
exports.SPFxScopes = SPFxScopes;
exports.AzureScopes = ["https://management.core.windows.net/user_impersonation"];
async function getSPFxTenant(graphToken) {
    const GRAPH_TENANT_ENDPT = "https://graph.microsoft.com/v1.0/sites/root?$select=webUrl";
    if (graphToken.length > 0) {
        const response = await axios_1.default.get(GRAPH_TENANT_ENDPT, {
            headers: { Authorization: `Bearer ${graphToken}` },
        });
        return response.data.webUrl;
    }
    return "";
}
exports.getSPFxTenant = getSPFxTenant;
async function getSPFxToken(m365TokenProvider) {
    const graphTokenRes = await m365TokenProvider.getAccessToken({
        scopes: exports.GraphReadUserScopes,
    });
    let spoToken = undefined;
    if (graphTokenRes && graphTokenRes.isOk()) {
        const tenant = await getSPFxTenant(graphTokenRes.value);
        const spfxTokenRes = await m365TokenProvider.getAccessToken({
            scopes: exports.SPFxScopes(tenant),
        });
        spoToken = spfxTokenRes.isOk() ? spfxTokenRes.value : undefined;
    }
    return spoToken;
}
exports.getSPFxToken = getSPFxToken;
/**
 * Get and set regin for App Studio client
 * @param m365TokenProvider
 */
async function setRegion(authSvcToken) {
    const region = await authSvcClient_1.AuthSvcClient.getRegion(authSvcToken);
    if (region) {
        // Do not set region for INT env
        const appStudioEndpoint = constants_2.getAppStudioEndpoint();
        if (appStudioEndpoint.includes("dev-int")) {
            return;
        }
        appStudioClient_1.AppStudioClient.setRegion(region);
        appStudioClient_2.AppStudioClient.setRegion(region);
    }
}
exports.setRegion = setRegion;
function ConvertTokenToJson(token) {
    const array = token.split(".");
    const buff = Buffer.from(array[1], "base64");
    return JSON.parse(buff.toString("utf8"));
}
exports.ConvertTokenToJson = ConvertTokenToJson;
function getFixedCommonProjectSettings(rootPath) {
    var _a;
    if (!rootPath) {
        return undefined;
    }
    try {
        const settingsPath = projectSettingsLoader_1.getProjectSettingsPath(rootPath);
        if (!settingsPath || !fs.pathExistsSync(settingsPath)) {
            return undefined;
        }
        const settingsContent = fs.readFileSync(settingsPath, "utf-8");
        const settings = yaml_1.parse(settingsContent);
        return {
            projectId: (_a = settings === null || settings === void 0 ? void 0 : settings.projectId) !== null && _a !== void 0 ? _a : undefined,
        };
    }
    catch (_b) {
        return undefined;
    }
}
exports.getFixedCommonProjectSettings = getFixedCommonProjectSettings;
// this function will be deleted after VS has added get dev tunnel and list dev tunnels API
const TunnelManagementUserAgent = { name: "Teams-Toolkit" };
async function listDevTunnels(token) {
    try {
        const tunnelManagementClientImpl = new dev_tunnels_management_1.TunnelManagementHttpClient(TunnelManagementUserAgent, "2023-09-27-preview", () => {
            const res = `Bearer ${token}`;
            return Promise.resolve(res);
        });
        const options = {
            includeAccessControl: true,
        };
        const tunnels = await tunnelManagementClientImpl.listTunnels(undefined, undefined, options);
        return teamsfx_api_1.ok(tunnels);
    }
    catch (error) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError("DevTunnels", "ListDevTunnelsFailed", error.message));
    }
}
exports.listDevTunnels = listDevTunnels;
//# sourceMappingURL=tools.js.map