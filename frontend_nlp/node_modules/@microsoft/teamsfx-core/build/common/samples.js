"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.sampleProvider = exports.SampleConfigBranchForPrerelease = exports.SampleConfigTag = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const hooks_1 = require("@feathersjs/hooks");
const utils_1 = require("../component/generator/utils");
const globalVars_1 = require("../core/globalVars");
const common_1 = require("../error/common");
const constants_1 = require("./constants");
const packageJson = require("../../package.json");
const SampleConfigOwner = "OfficeDev";
const SampleConfigRepo = "TeamsFx-Samples";
const SampleConfigFile = ".config/samples-config-v3.json";
exports.SampleConfigTag = "v2.4.0";
// prerelease tag is always using a branch.
exports.SampleConfigBranchForPrerelease = "v3";
class SampleProvider {
    constructor() {
        this.branchOrTag = exports.SampleConfigTag;
    }
    async fetchSampleConfig() {
        const version = packageJson.version;
        if (version.includes("alpha")) {
            // daily build version always use 'dev' branch
            this.branchOrTag = "dev";
        }
        else if (version.includes("beta")) {
            // prerelease build version always use branch head for prerelease.
            this.branchOrTag = exports.SampleConfigBranchForPrerelease;
        }
        else if (version.includes("rc")) {
            // if there is a breaking change, the tag is not used by any stable version.
            this.branchOrTag = exports.SampleConfigTag;
        }
        else {
            // stable version uses the head of branch defined by feature flag when available
            this.branchOrTag = exports.SampleConfigTag;
            const branch = process.env[constants_1.FeatureFlagName.SampleConfigBranch];
            if (branch) {
                try {
                    const data = await this.fetchRawFileContent(branch);
                    this.branchOrTag = branch;
                    this.samplesConfig = data;
                }
                catch (e) { }
            }
        }
        if (this.samplesConfig === undefined) {
            this.samplesConfig = (await this.fetchRawFileContent(this.branchOrTag));
        }
    }
    get SampleCollection() {
        var _a, _b, _c, _d;
        const samples = ((_a = this.samplesConfig) === null || _a === void 0 ? void 0 : _a.samples.map((sample) => {
            const isExternal = sample["downloadUrlInfo"] ? true : false;
            let gifUrl = sample["gifPath"] !== undefined
                ? `https://raw.githubusercontent.com/${SampleConfigOwner}/${SampleConfigRepo}/${this.branchOrTag}/${sample["id"]}/${sample["gifPath"]}`
                : undefined;
            let thumbnailUrl = `https://raw.githubusercontent.com/${SampleConfigOwner}/${SampleConfigRepo}/${this.branchOrTag}/${sample["id"]}/${sample["thumbnailPath"]}`;
            if (isExternal) {
                const info = sample["downloadUrlInfo"];
                gifUrl =
                    sample["gifPath"] !== undefined
                        ? `https://raw.githubusercontent.com/${info.owner}/${info.repository}/${info.ref}/${info.dir}/${sample["gifPath"]}`
                        : undefined;
                thumbnailUrl = `https://raw.githubusercontent.com/${info.owner}/${info.repository}/${info.ref}/${info.dir}/${sample["thumbnailPath"]}`;
            }
            return Object.assign(Object.assign({}, sample), { onboardDate: new Date(sample["onboardDate"]), downloadUrlInfo: isExternal
                    ? sample["downloadUrlInfo"]
                    : {
                        owner: SampleConfigOwner,
                        repository: SampleConfigRepo,
                        ref: this.branchOrTag,
                        dir: sample["id"],
                    }, gifUrl: gifUrl, thumbnailUrl: thumbnailUrl });
        })) || [];
        return {
            samples,
            filterOptions: {
                capabilities: ((_b = this.samplesConfig) === null || _b === void 0 ? void 0 : _b.filterOptions["capabilities"]) || [],
                languages: ((_c = this.samplesConfig) === null || _c === void 0 ? void 0 : _c.filterOptions["languages"]) || [],
                technologies: ((_d = this.samplesConfig) === null || _d === void 0 ? void 0 : _d.filterOptions["technologies"]) || [],
            },
        };
    }
    async fetchRawFileContent(branchOrTag) {
        const url = `https://raw.githubusercontent.com/${SampleConfigOwner}/${SampleConfigRepo}/${branchOrTag}/${SampleConfigFile}`;
        try {
            const fileResponse = await utils_1.sendRequestWithTimeout(async () => {
                return await axios_1.default.get(url, { responseType: "json" });
            }, 1000, 3);
            if (fileResponse && fileResponse.data) {
                return fileResponse.data;
            }
        }
        catch (e) {
            throw new common_1.AccessGithubError(url, "SampleProvider", e);
        }
    }
}
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ component: "SampleProvider" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", Promise)
], SampleProvider.prototype, "fetchSampleConfig", null);
exports.sampleProvider = new SampleProvider();
//# sourceMappingURL=samples.js.map