"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.developerPortalScaffoldUtils = exports.isFromDevPortal = exports.getProjectTypeAndCapability = exports.DeveloperPortalScaffoldUtils = exports.answerToReplaceMessageExtensionBotId = exports.answerToRepaceBotId = void 0;
const tslib_1 = require("tslib");
/**
 * @author Yuqi Zhou <yuqzho@microsoft.com>
 */
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const localizeUtils_1 = require("../common/localizeUtils");
const error_1 = require("../core/error");
const create_1 = require("../question/create");
const constants_1 = require("./constants");
const appStudio = tslib_1.__importStar(require("./driver/teamsApp/appStudio"));
const constants_2 = require("./driver/teamsApp/constants");
const ManifestUtils_1 = require("./driver/teamsApp/utils/ManifestUtils");
const telemetry_1 = require("./driver/teamsApp/utils/telemetry");
const utils_1 = require("./driver/teamsApp/utils/utils");
const envUtil_1 = require("./utils/envUtil");
const questionNames_1 = require("../question/questionNames");
const appPackageFolderName = "appPackage";
const colorFileName = "color.png";
const outlineFileName = "outline.png";
const manifestFileName = "manifest.json";
exports.answerToRepaceBotId = "bot";
exports.answerToReplaceMessageExtensionBotId = "messageExtension";
class DeveloperPortalScaffoldUtils {
    async updateFilesForTdp(ctx, appDefinition, inputs) {
        if (!ctx.projectPath) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
        }
        if (!ctx.tokenProvider) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("tokenProvider"));
        }
        const manifestRes = await updateManifest(ctx, appDefinition, inputs);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        const envRes = await updateEnv(appDefinition.teamsAppId, ctx.projectPath);
        if (envRes.isErr()) {
            return teamsfx_api_1.err(envRes.error);
        }
        return teamsfx_api_1.ok(undefined);
    }
}
exports.DeveloperPortalScaffoldUtils = DeveloperPortalScaffoldUtils;
var TabUrlType;
(function (TabUrlType) {
    TabUrlType["WebsiteUrl"] = "WebsiteUrl";
    TabUrlType["ContentUrl"] = "ContentUrl";
})(TabUrlType || (TabUrlType = {}));
async function updateManifest(ctx, appDefinition, inputs) {
    var _a;
    telemetry_1.TelemetryUtils.init(ctx);
    const res = await appStudio.getAppPackage(appDefinition.teamsAppId, ctx.tokenProvider.m365TokenProvider, ctx.logProvider);
    if (res.isErr()) {
        return teamsfx_api_1.err(res.error);
    }
    const appPackage = res.value;
    if (!appPackage.manifest) {
        const msg = localizeUtils_1.getLocalizedString("core.developerPortal.scaffold.CannotFindManifest", appDefinition.teamsAppId);
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_1.CoordinatorSource, "CouldNotFoundManifest", msg, msg));
    }
    const colorFilePath = path.join(ctx.projectPath, appPackageFolderName, colorFileName);
    const outlineFilePath = path.join(ctx.projectPath, appPackageFolderName, outlineFileName);
    const manifestTemplatePath = path.join(ctx.projectPath, appPackageFolderName, manifestFileName);
    const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(manifestTemplatePath);
    if (manifestRes.isErr()) {
        return teamsfx_api_1.err(manifestRes.error);
    }
    const existingManifestTemplate = manifestRes.value;
    if (!existingManifestTemplate) {
        return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("manifest.json downloaded from template"));
    }
    // icons
    const icons = appPackage.icons;
    if (icons) {
        if (icons.color) {
            await fs_extra_1.default.writeFile(colorFilePath, icons.color);
        }
        if (icons.outline) {
            await fs_extra_1.default.writeFile(outlineFilePath, icons.outline);
        }
    }
    // manifest
    const manifest = JSON.parse(appPackage.manifest.toString("utf8"));
    manifest.id = "${{TEAMS_APP_ID}}";
    // Adding a feature with groupChat scope in TDP won't pass validation for extendToM365 action.
    if (!!manifest.configurableTabs && manifest.configurableTabs.length > 0) {
        if (manifest.configurableTabs[0].scopes) {
            {
                manifest.configurableTabs[0].scopes = decapitalizeScope(manifest.configurableTabs[0].scopes);
            }
        }
    }
    if (!!manifest.bots && manifest.bots.length > 0) {
        if (manifest.bots[0].scopes) {
            {
                manifest.bots[0].scopes = decapitalizeScope(manifest.bots[0].scopes);
            }
        }
        if (manifest.bots[0].commandLists) {
            manifest.bots[0].commandLists.forEach((commandList) => {
                if (commandList.scopes) {
                    commandList.scopes = decapitalizeScope(commandList.scopes);
                }
            });
        }
    }
    if (!!manifest.composeExtensions && manifest.composeExtensions.length > 0) {
        if (manifest.composeExtensions[0].scopes) {
            {
                manifest.composeExtensions[0].scopes = decapitalizeScope(manifest.composeExtensions[0].scopes);
            }
        }
    }
    // manifest: tab
    const tabs = manifest.staticTabs;
    let needUpdateStaticTabUrls = false;
    if (inputs[questionNames_1.QuestionNames.ReplaceContentUrl] &&
        inputs[questionNames_1.QuestionNames.ReplaceContentUrl].length != 0) {
        needUpdateStaticTabUrls = true;
        updateTabUrl(inputs[questionNames_1.QuestionNames.ReplaceContentUrl], TabUrlType.ContentUrl, tabs, existingManifestTemplate.staticTabs);
    }
    if (inputs[questionNames_1.QuestionNames.ReplaceWebsiteUrl] &&
        inputs[questionNames_1.QuestionNames.ReplaceWebsiteUrl].length != 0) {
        needUpdateStaticTabUrls = true;
        updateTabUrl(inputs[questionNames_1.QuestionNames.ReplaceWebsiteUrl], TabUrlType.WebsiteUrl, tabs, existingManifestTemplate.staticTabs);
    }
    if (needUpdateStaticTabUrls) {
        const validDomains = (_a = manifest.validDomains) !== null && _a !== void 0 ? _a : [];
        validDomains.push("${{TAB_DOMAIN}}");
        manifest.validDomains = validDomains;
    }
    // manifest: bot
    if (inputs[questionNames_1.QuestionNames.ReplaceBotIds]) {
        if (inputs[questionNames_1.QuestionNames.ReplaceBotIds].includes(exports.answerToRepaceBotId)) {
            if (existingManifestTemplate.bots && existingManifestTemplate.bots.length > 0) {
                manifest.bots = existingManifestTemplate.bots;
            }
            else {
                manifest.bots = constants_2.BOTS_TPL_V3;
                manifest.bots[0].botId = "${{BOT_ID}}";
            }
        }
        if (inputs[questionNames_1.QuestionNames.ReplaceBotIds].includes(exports.answerToReplaceMessageExtensionBotId)) {
            if (existingManifestTemplate.composeExtensions &&
                existingManifestTemplate.composeExtensions.length > 0) {
                manifest.composeExtensions = existingManifestTemplate.composeExtensions;
            }
            else {
                manifest.composeExtensions = constants_2.COMPOSE_EXTENSIONS_TPL_V3;
                manifest.composeExtensions[0].botId = "${{BOT_ID}}";
            }
        }
    }
    // manifest: no tab, bot or me selected on TDP before
    if (!getProjectTypeAndCapability(appDefinition)) {
        // which means user selects a capability through TTK UI.
        manifest.bots = existingManifestTemplate.bots;
        manifest.composeExtensions = existingManifestTemplate.composeExtensions;
        manifest.staticTabs = existingManifestTemplate.staticTabs;
        manifest.configurableTabs = existingManifestTemplate.configurableTabs;
        manifest.permissions = existingManifestTemplate.permissions;
        manifest.validDomains = existingManifestTemplate.validDomains;
        manifest.webApplicationInfo = existingManifestTemplate.webApplicationInfo;
    }
    // manifest: developer
    if (manifest.developer) {
        if (!manifest.developer.websiteUrl) {
            manifest.developer.websiteUrl = constants_2.DEFAULT_DEVELOPER.websiteUrl;
        }
        if (!manifest.developer.privacyUrl) {
            manifest.developer.privacyUrl = constants_2.DEFAULT_DEVELOPER.privacyUrl;
        }
        if (!manifest.developer.termsOfUseUrl) {
            manifest.developer.termsOfUseUrl = constants_2.DEFAULT_DEVELOPER.termsOfUseUrl;
        }
        if (!manifest.developer.name) {
            manifest.developer.name = constants_2.DEFAULT_DEVELOPER.name;
        }
        if (!manifest.description.short) {
            manifest.description.short = constants_2.DEFAULT_DESCRIPTION.short;
        }
        if (!manifest.description.full) {
            manifest.description.full = constants_2.DEFAULT_DESCRIPTION.full;
        }
    }
    await fs_extra_1.default.writeFile(manifestTemplatePath, JSON.stringify(manifest, null, "\t"), "utf-8");
    // languages
    const languages = appPackage.languages;
    if (languages) {
        for (const code in languages) {
            const content = JSON.parse(languages[code].toString("utf8"));
            const languageFilePath = path.join(ctx.projectPath, appPackageFolderName, `${code}.json`);
            await fs_extra_1.default.writeFile(languageFilePath, JSON.stringify(content, null, "\t"), "utf-8");
        }
    }
    return teamsfx_api_1.ok(undefined);
}
async function updateEnv(appId, projectPath) {
    return await envUtil_1.envUtil.writeEnv(projectPath, "local", {
        TEAMS_APP_ID: appId,
    });
}
function updateTabUrl(answers, tabUrlType, tabs, existingManifestStaticTabs) {
    if (!tabs || tabs.length === 0) {
        return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("static tabs"));
    }
    if (!existingManifestStaticTabs || existingManifestStaticTabs.length === 0) {
        return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("static tabs in manifest.json"));
    }
    answers.forEach((answer) => {
        const tabToUpdate = findTabBasedOnName(answer, tabs);
        if (tabToUpdate) {
            switch (tabUrlType) {
                case TabUrlType.ContentUrl:
                    tabToUpdate.contentUrl = existingManifestStaticTabs[0].contentUrl;
                    break;
                case TabUrlType.WebsiteUrl:
                    tabToUpdate.websiteUrl = existingManifestStaticTabs[0].websiteUrl;
                    break;
                default:
                    break;
            }
        }
    });
}
function findTabBasedOnName(name, tabs) {
    return tabs.find((o) => o.name === name);
}
function getProjectTypeAndCapability(teamsApp) {
    // tab with bot, tab with message extension, tab with bot and message extension
    if (utils_1.needTabAndBotCode(teamsApp)) {
        return { projectType: "tab-bot-type", templateId: create_1.CapabilityOptions.nonSsoTabAndBot().id };
    }
    // tab only
    if (utils_1.needTabCode(teamsApp)) {
        return { projectType: "tab-type", templateId: create_1.CapabilityOptions.nonSsoTab().id };
    }
    // bot and message extension
    if (utils_1.isBotAndBotBasedMessageExtension(teamsApp)) {
        return { projectType: "bot-me-type", templateId: create_1.CapabilityOptions.botAndMe().id };
    }
    // bot based message extension
    if (utils_1.isBotBasedMessageExtension(teamsApp)) {
        return { projectType: "me-type", templateId: create_1.CapabilityOptions.me().id };
    }
    // bot
    if (utils_1.isBot(teamsApp)) {
        return { projectType: "bot-type", templateId: create_1.CapabilityOptions.basicBot().id };
    }
    return undefined;
}
exports.getProjectTypeAndCapability = getProjectTypeAndCapability;
function decapitalizeScope(scopes) {
    return scopes.map((o) => o.toLowerCase());
}
function isFromDevPortal(inputs) {
    return !!(inputs === null || inputs === void 0 ? void 0 : inputs.teamsAppFromTdp);
}
exports.isFromDevPortal = isFromDevPortal;
exports.developerPortalScaffoldUtils = new DeveloperPortalScaffoldUtils();
//# sourceMappingURL=developerPortalScaffoldUtils.js.map