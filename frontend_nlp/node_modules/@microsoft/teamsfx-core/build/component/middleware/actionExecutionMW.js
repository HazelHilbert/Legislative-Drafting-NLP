"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionExecutionMW = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const globalVars_1 = require("../../core/globalVars");
const common_1 = require("../../error/common");
const visitor_1 = require("../../ui/visitor");
const constants_1 = require("../constants");
const telemetry_1 = require("../telemetry");
const settingsUtil_1 = require("../utils/settingsUtil");
function ActionExecutionMW(action) {
    return async (ctx, next) => {
        var _a, _b;
        const componentName = action.componentName || ((_a = ctx.self) === null || _a === void 0 ? void 0 : _a.constructor.name);
        const telemetryComponentName = action.telemetryComponentName || componentName;
        const methodName = ctx.method;
        const eventName = action.telemetryEventName || methodName;
        const telemetryProps = {
            [constants_1.TelemetryConstants.properties.component]: telemetryComponentName,
            env: process.env.TEAMSFX_ENV || "",
        };
        const telemetryMeasures = {};
        let progressBar;
        try {
            // send start telemetry
            if (action.enableTelemetry) {
                if (!globalVars_1.globalVars.trackingId) {
                    // try to get trackingId
                    const projectPath = ctx.arguments[0].projectPath;
                    if (projectPath) {
                        await settingsUtil_1.settingsUtil.readSettings(projectPath, false);
                    }
                }
                if (action.telemetryProps)
                    lodash_1.assign(telemetryProps, action.telemetryProps);
                if (globalVars_1.globalVars.trackingId)
                    telemetryProps["project-id"] = globalVars_1.globalVars.trackingId; // add trackingId prop in telemetry
                telemetry_1.sendStartEvent(eventName, telemetryProps);
            }
            // run question model
            if (action.question) {
                const context = ctx.arguments[0];
                const inputs = ctx.arguments[1];
                const getQuestionRes = await action.question(context, inputs);
                if (getQuestionRes.isErr())
                    throw getQuestionRes.error;
                const node = getQuestionRes.value;
                if (node) {
                    const askQuestionRes = await visitor_1.traverse(node, inputs, context.userInteraction, context.telemetryReporter);
                    if (askQuestionRes.isErr())
                        throw askQuestionRes.error;
                }
            }
            // progress bar
            if (action.enableProgressBar) {
                progressBar = globalVars_1.TOOLS.ui.createProgressBar(action.progressTitle || methodName, action.progressSteps || 1);
                await progressBar.start();
            }
            if (action.enableTelemetry || action.enableProgressBar) {
                const actionContext = {
                    progressBar: progressBar,
                    telemetryProps: telemetryProps,
                    telemetryMeasures: telemetryMeasures,
                };
                ctx.arguments.push(actionContext);
            }
            const startTime = new Date().getTime();
            await next();
            const timeCost = new Date().getTime() - startTime;
            if (((_b = ctx.result) === null || _b === void 0 ? void 0 : _b.isErr) && ctx.result.isErr())
                throw ctx.result.error;
            // send end telemetry
            lodash_1.merge(telemetryMeasures, { [constants_1.TelemetryConstants.properties.timeCost]: timeCost });
            if (action.enableTelemetry) {
                telemetry_1.sendSuccessEvent(eventName, telemetryProps, telemetryMeasures);
            }
            await (progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(true));
        }
        catch (e) {
            await (progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(false));
            const fxError = common_1.assembleError(e);
            if (fxError.source === "unknown") {
                fxError.source = action.errorSource || fxError.source;
                if (fxError instanceof teamsfx_api_1.UserError) {
                    fxError.helpLink = fxError.helpLink || action.errorHelpLink;
                }
                if (fxError instanceof teamsfx_api_1.SystemError) {
                    fxError.issueLink = fxError.issueLink || action.errorIssueLink;
                }
            }
            // send error telemetry
            if (action.enableTelemetry) {
                telemetry_1.sendErrorEvent(eventName, fxError, telemetryProps);
            }
            ctx.result = teamsfx_api_1.err(fxError);
        }
    };
}
exports.ActionExecutionMW = ActionExecutionMW;
//# sourceMappingURL=actionExecutionMW.js.map