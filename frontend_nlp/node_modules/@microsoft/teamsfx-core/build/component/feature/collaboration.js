"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsCollaboration = exports.AadCollaboration = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const typedi_1 = require("typedi");
const lib_1 = require("@feathersjs/hooks/lib");
const aadAppClient_1 = require("../driver/aad/utility/aadAppClient");
const constants_1 = require("../driver/aad/utility/constants");
const addStartAndEndTelemetry_1 = require("../driver/middleware/addStartAndEndTelemetry");
const axios_1 = tslib_1.__importDefault(require("axios"));
const common_1 = require("../../error/common");
const telemetry_1 = require("../driver/teamsApp/utils/telemetry");
const constants_2 = require("../driver/teamsApp/constants");
const appStudioClient_1 = require("../driver/teamsApp/clients/appStudioClient");
const error_1 = require("../../core/error");
const globalVars_1 = require("../../core/globalVars");
const EventName = {
    grantPermission: "grant-permission",
    listCollaborator: "list-collaborator",
    checkPermission: "check-permission",
};
const componentNameAad = "fx-resource-aad-app-for-teams";
const componentNameTeams = "AppStudioPlugin";
let AadCollaboration = class AadCollaboration {
    constructor(m365TokenProvider, logProvider) {
        this.aadAppClient = new aadAppClient_1.AadAppClient(m365TokenProvider, logProvider);
    }
    async grantPermission(ctx, objectId, userObjectId) {
        try {
            await this.aadAppClient.addOwner(objectId, userObjectId);
            const result = [
                {
                    name: constants_1.permissionsKeys.name,
                    type: constants_1.permissionsKeys.type,
                    roles: [constants_1.permissionsKeys.owner],
                    resourceId: objectId,
                },
            ];
            return teamsfx_api_1.ok(result);
        }
        catch (error) {
            return teamsfx_api_1.err(this.handleError(error, ctx, objectId));
        }
    }
    async listCollaborator(ctx, objectId) {
        try {
            const owners = await this.aadAppClient.getOwners(objectId);
            return teamsfx_api_1.ok(owners !== null && owners !== void 0 ? owners : []);
        }
        catch (error) {
            return teamsfx_api_1.err(this.handleError(error, ctx, objectId));
        }
    }
    async checkPermission(ctx, objectId, userObjectId) {
        try {
            const owners = await this.aadAppClient.getOwners(objectId);
            const isAadOwner = owners === null || owners === void 0 ? void 0 : owners.find((owner) => owner.userObjectId === userObjectId);
            const result = [
                {
                    name: constants_1.permissionsKeys.name,
                    type: constants_1.permissionsKeys.type,
                    roles: isAadOwner ? [constants_1.permissionsKeys.owner] : [constants_1.permissionsKeys.noPermission],
                    resourceId: objectId,
                },
            ];
            return teamsfx_api_1.ok(result);
        }
        catch (error) {
            return teamsfx_api_1.err(this.handleError(error, ctx, objectId));
        }
    }
    handleError(error, ctx, appId) {
        var _a, _b;
        if (axios_1.default.isAxiosError(error)) {
            const message = JSON.stringify(error.response.data);
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(message);
            if (error.response.status === 404) {
                return new error_1.AppIdNotExist(appId);
            }
            else if (error.response.status >= 400 && error.response.status < 500) {
                return new common_1.HttpClientError(error, componentNameAad, message);
            }
            else {
                return new common_1.HttpServerError(error, componentNameAad, message);
            }
        }
        const message = JSON.stringify(error);
        (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.error(message);
        return new common_1.UnhandledError(error, componentNameAad);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        globalVars_1.ErrorContextMW({ source: "Graph", component: "AadCollaboration" }),
        addStartAndEndTelemetry_1.addStartAndEndTelemetry(EventName.grantPermission, componentNameAad),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], AadCollaboration.prototype, "grantPermission", null);
tslib_1.__decorate([
    lib_1.hooks([
        globalVars_1.ErrorContextMW({ source: "Graph", component: "AadCollaboration" }),
        addStartAndEndTelemetry_1.addStartAndEndTelemetry(EventName.listCollaborator, componentNameAad),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], AadCollaboration.prototype, "listCollaborator", null);
tslib_1.__decorate([
    lib_1.hooks([
        globalVars_1.ErrorContextMW({ source: "Graph", component: "AadCollaboration" }),
        addStartAndEndTelemetry_1.addStartAndEndTelemetry(EventName.checkPermission, componentNameAad),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], AadCollaboration.prototype, "checkPermission", null);
AadCollaboration = tslib_1.__decorate([
    typedi_1.Service("aad-collaboration"),
    tslib_1.__metadata("design:paramtypes", [Object, Object])
], AadCollaboration);
exports.AadCollaboration = AadCollaboration;
let TeamsCollaboration = class TeamsCollaboration {
    constructor(ctx, m365TokenProvider) {
        this.tokenProvider = m365TokenProvider;
        telemetry_1.TelemetryUtils.init(ctx);
    }
    async grantPermission(ctx, teamsAppId, userInfo) {
        try {
            const appStudioTokenRes = await this.tokenProvider.getAccessToken({
                scopes: constants_2.AppStudioScopes,
            });
            const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
            await appStudioClient_1.AppStudioClient.grantPermission(teamsAppId, appStudioToken, userInfo, ctx.logProvider);
            const result = [
                {
                    name: constants_2.Constants.PERMISSIONS.name,
                    roles: [constants_2.Constants.PERMISSIONS.admin],
                    type: constants_2.Constants.PERMISSIONS.type,
                    resourceId: teamsAppId,
                },
            ];
            return teamsfx_api_1.ok(result);
        }
        catch (error) {
            return teamsfx_api_1.err(this.handleError(error, ctx, teamsAppId));
        }
    }
    async listCollaborator(ctx, teamsAppId) {
        try {
            const appStudioTokenRes = await this.tokenProvider.getAccessToken({
                scopes: constants_2.AppStudioScopes,
            });
            const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
            const userLists = await appStudioClient_1.AppStudioClient.getUserList(teamsAppId, appStudioToken, ctx.logProvider);
            if (!userLists) {
                return teamsfx_api_1.ok([]);
            }
            const teamsAppAdmin = userLists
                .filter((userList) => {
                return userList.isAdministrator;
            })
                .map((userList) => {
                return {
                    userObjectId: userList.aadId,
                    displayName: userList.displayName,
                    userPrincipalName: userList.userPrincipalName,
                    resourceId: teamsAppId,
                };
            });
            return teamsfx_api_1.ok(teamsAppAdmin);
        }
        catch (error) {
            return teamsfx_api_1.err(this.handleError(error, ctx, teamsAppId));
        }
    }
    async checkPermission(ctx, teamsAppId, userInfo) {
        try {
            const appStudioTokenRes = await this.tokenProvider.getAccessToken({
                scopes: constants_2.AppStudioScopes,
            });
            const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
            const teamsAppRoles = await appStudioClient_1.AppStudioClient.checkPermission(teamsAppId, appStudioToken, userInfo.aadId, ctx.logProvider);
            const result = [
                {
                    name: constants_2.Constants.PERMISSIONS.name,
                    roles: [teamsAppRoles],
                    type: constants_2.Constants.PERMISSIONS.type,
                    resourceId: teamsAppId,
                },
            ];
            return teamsfx_api_1.ok(result);
        }
        catch (error) {
            return teamsfx_api_1.err(this.handleError(error, ctx, teamsAppId));
        }
    }
    handleError(error, ctx, appId) {
        var _a, _b;
        if (error.innerError) {
            const message = JSON.stringify(error.innerError.response.data);
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(message);
            if (error.innerError.response.status) {
                const statusCode = error.innerError.response.status;
                if (statusCode === 404) {
                    return new error_1.AppIdNotExist(appId);
                }
                else if (statusCode >= 400 && statusCode < 500) {
                    return new common_1.HttpClientError(error, componentNameTeams, message);
                }
                else {
                    return new common_1.HttpServerError(error, componentNameTeams, message);
                }
            }
        }
        const message = JSON.stringify(error);
        (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.error(message);
        return new common_1.UnhandledError(error, componentNameTeams);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        globalVars_1.ErrorContextMW({ source: "Teams", component: "TeamsCollaboration" }),
        addStartAndEndTelemetry_1.addStartAndEndTelemetry(EventName.grantPermission, componentNameTeams),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsCollaboration.prototype, "grantPermission", null);
tslib_1.__decorate([
    lib_1.hooks([
        globalVars_1.ErrorContextMW({ source: "Teams", component: "TeamsCollaboration" }),
        addStartAndEndTelemetry_1.addStartAndEndTelemetry(EventName.listCollaborator, componentNameTeams),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsCollaboration.prototype, "listCollaborator", null);
tslib_1.__decorate([
    lib_1.hooks([
        globalVars_1.ErrorContextMW({ source: "Teams", component: "TeamsCollaboration" }),
        addStartAndEndTelemetry_1.addStartAndEndTelemetry(EventName.checkPermission, componentNameTeams),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsCollaboration.prototype, "checkPermission", null);
TeamsCollaboration = tslib_1.__decorate([
    typedi_1.Service("teams-collaboration"),
    tslib_1.__metadata("design:paramtypes", [Object, Object])
], TeamsCollaboration);
exports.TeamsCollaboration = TeamsCollaboration;
//# sourceMappingURL=collaboration.js.map