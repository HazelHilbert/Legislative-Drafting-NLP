"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.cpUtils = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-namespace */
// NOTE:
// DO NOT EDIT this file in function plugin.
// The source of truth of this file is in packages/vscode-extension/src/debug/depsChecker.
// If you need to edit this file, please edit it in the above folder
// and run the scripts (tools/depsChecker/copyfiles.sh or tools/depsChecker/copyfiles.ps1 according to your OS)
// to copy you changes to function plugin.
const cp = tslib_1.__importStar(require("child_process"));
const os = tslib_1.__importStar(require("os"));
var cpUtils;
(function (cpUtils) {
    async function executeCommand(workingDirectory, logger, options, command, ...args) {
        const result = await tryExecuteCommand(workingDirectory, logger, options, command, ...args);
        if (result.code !== 0) {
            const errorMessage = `Failed to run command: "${command} ${result.formattedArgs}", code: "${result.code}",
                            output: "${result.cmdOutput}", error: "${result.cmdOutputIncludingStderr}"`;
            logger === null || logger === void 0 ? void 0 : logger.debug(errorMessage);
            throw new Error(errorMessage);
        }
        else {
            logger === null || logger === void 0 ? void 0 : logger.debug(`Finished running command: "${command} ${result.formattedArgs}".`);
        }
        return result.cmdOutput;
    }
    cpUtils.executeCommand = executeCommand;
    async function tryExecuteCommand(workingDirectory, logger, additionalOptions, command, ...args) {
        return await new Promise((resolve, reject) => {
            var _a, _b;
            let cmdOutput = "";
            let cmdOutputIncludingStderr = "";
            const formattedArgs = args.join(" ");
            workingDirectory = workingDirectory || os.tmpdir();
            const options = {
                cwd: workingDirectory,
                shell: true,
            };
            Object.assign(options, additionalOptions);
            const childProc = cp.spawn(command, args, options);
            let timer;
            if (options.timeout && options.timeout > 0) {
                // timeout only exists for exec not spawn
                timer = setTimeout(() => {
                    childProc.kill();
                    logger === null || logger === void 0 ? void 0 : logger.debug(`Stop exec due to timeout, command: "${command} ${formattedArgs}", options = '${JSON.stringify(options)}'`);
                    reject(new Error(
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    `Exec command: "${command} ${formattedArgs}" timeout, ${options.timeout} ms`));
                }, options.timeout);
            }
            logger === null || logger === void 0 ? void 0 : logger.debug(`Running command: "${command} ${formattedArgs}", options = '${JSON.stringify(options)}'`);
            (_a = childProc.stdout) === null || _a === void 0 ? void 0 : _a.on("data", (data) => {
                data = data.toString();
                cmdOutput = cmdOutput.concat(data);
                cmdOutputIncludingStderr = cmdOutputIncludingStderr.concat(data);
            });
            (_b = childProc.stderr) === null || _b === void 0 ? void 0 : _b.on("data", (data) => {
                data = data.toString();
                cmdOutputIncludingStderr = cmdOutputIncludingStderr.concat(data);
            });
            childProc.on("error", (error) => {
                logger === null || logger === void 0 ? void 0 : logger.debug(
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                `Failed to run command '${command} ${formattedArgs}': cmdOutputIncludingStderr: '${cmdOutputIncludingStderr}', error: ${error}`);
                if (timer) {
                    clearTimeout(timer);
                }
                reject(error);
            });
            childProc.on("close", (code) => {
                logger === null || logger === void 0 ? void 0 : logger.debug(`Command finished with outputs, cmdOutputIncludingStderr: '${cmdOutputIncludingStderr}'`);
                if (timer) {
                    clearTimeout(timer);
                }
                resolve({
                    code,
                    cmdOutput,
                    cmdOutputIncludingStderr,
                    formattedArgs,
                });
            });
        });
    }
    cpUtils.tryExecuteCommand = tryExecuteCommand;
})(cpUtils = exports.cpUtils || (exports.cpUtils = {}));
//# sourceMappingURL=cpUtils.js.map