"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.dotenvUtil = exports.envUtil = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const settingsUtil_1 = require("./settingsUtil");
const crypto_1 = require("../../core/crypto");
const pathUtils_1 = require("./pathUtils");
const globalVars_1 = require("../../core/globalVars");
const path = tslib_1.__importStar(require("path"));
const os_1 = require("os");
const telemetry_1 = require("../../common/telemetry");
const crypto_2 = require("crypto");
const common_1 = require("../../error/common");
const configure_1 = require("../driver/teamsApp/configure");
const environmentName_1 = require("../../core/environmentName");
const EligibleKeys = {
    TEAMSFX_ENV: true,
    AZURE_SUBSCRIPTION_ID: false,
    BOT_ID: false,
    TEAMS_APP_ID: false,
    TAB_ENDPOINT: true,
    TEAMS_APP_TENANT_ID: false,
};
class EnvUtil {
    /**
     * read .env file and set to process.env (if loadToProcessEnv = true)
     * if silent = true, no error will return if .env file is not available, this function returns ok({ TEAMSFX_ENV: env })
     * if silent = false, this function will return error if .env file is not available.
     * @param projectPath
     * @param env
     * @param loadToProcessEnv
     * @param silent
     * @returns
     */
    async readEnv(projectPath, env, loadToProcessEnv = true, silent = true) {
        var _a;
        // read
        const dotEnvFilePathRes = await pathUtils_1.pathUtils.getEnvFilePath(projectPath, env);
        if (dotEnvFilePathRes.isErr())
            return teamsfx_api_1.err(dotEnvFilePathRes.error);
        const dotEnvFilePath = dotEnvFilePathRes.value;
        //global var
        globalVars_1.globalVars.envFilePath = dotEnvFilePath;
        if (!dotEnvFilePath || !(await fs_extra_1.default.pathExists(dotEnvFilePath))) {
            if (silent) {
                // .env file does not exist, just ignore
                if (loadToProcessEnv) {
                    process.env.TEAMSFX_ENV = env;
                }
                return teamsfx_api_1.ok({ TEAMSFX_ENV: env });
            }
            else {
                return teamsfx_api_1.err(new common_1.FileNotFoundError("core", dotEnvFilePath || `.env.${env}`));
            }
        }
        // deserialize
        const parseResult = exports.dotenvUtil.deserialize(await fs_extra_1.default.readFile(dotEnvFilePath, { encoding: "utf8" }));
        // get .env.xxx.user path
        const dotEnvSecretFilePath = dotEnvFilePath + ".user";
        let parseResultSecret;
        if (await fs_extra_1.default.pathExists(dotEnvSecretFilePath)) {
            // only need to decrypt the .env.xxx.user file
            parseResultSecret = exports.dotenvUtil.deserialize(await fs_extra_1.default.readFile(dotEnvSecretFilePath, { encoding: "utf8" }));
            // decrypt
            const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath);
            if (settingsRes.isErr()) {
                return teamsfx_api_1.err(settingsRes.error);
            }
            const projectId = settingsRes.value.trackingId;
            const cryptoProvider = new crypto_1.LocalCrypto(projectId);
            for (const key of Object.keys(parseResultSecret.obj)) {
                if (key.startsWith("SECRET_")) {
                    const raw = parseResultSecret.obj[key];
                    if (raw.startsWith("crypto_")) {
                        const decryptRes = cryptoProvider.decrypt(raw);
                        if (decryptRes.isErr())
                            return teamsfx_api_1.err(decryptRes.error);
                        parseResultSecret.obj[key] = decryptRes.value;
                    }
                }
            }
        }
        // set process.env
        parseResult.obj.TEAMSFX_ENV = env;
        if (loadToProcessEnv) {
            // '.env.xxx' has higher priority than '.env.xxx.user'
            if (parseResultSecret)
                this.mergeEnv(parseResult.obj, parseResultSecret.obj);
            // 'process.env' has higher priority than '.env.xxx'
            this.mergeEnv(process.env, parseResult.obj);
        }
        const props = {};
        const prefix = "env.";
        for (const key of Object.keys(parseResult.obj)) {
            if (Object.keys(EligibleKeys).includes(key)) {
                const value = parseResult.obj[key];
                if (key === "TEAMSFX_ENV" && (value === "dev" || value === "local")) {
                    props[prefix + key] = value;
                }
                else {
                    props[prefix + key] = EligibleKeys[key]
                        ? crypto_2.createHash("sha256").update(value).digest("hex")
                        : value;
                }
            }
        }
        (_a = globalVars_1.TOOLS.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(telemetry_1.TelemetryEvent.MetaData, props);
        return teamsfx_api_1.ok(parseResult.obj);
    }
    async loadEnvFile(dotEnvFilePath) {
        const parseResult = exports.dotenvUtil.deserialize(await fs_extra_1.default.readFile(dotEnvFilePath, { encoding: "utf8" }));
        this.mergeEnv(process.env, parseResult.obj);
        return teamsfx_api_1.ok(parseResult.obj);
    }
    mergeEnv(envWithHigherPriority, envWithLowerPriority) {
        for (const key of Object.keys(envWithLowerPriority)) {
            if (!envWithHigherPriority[key]) {
                envWithHigherPriority[key] = envWithLowerPriority[key];
            }
        }
    }
    /**
     * write env variables into .env file,
     * if .env file does not exist, this function will create a default one
     * if .env fila path is not available, the default path is `./env/.env.{env}`
     * @param projectPath
     * @param env
     * @param envs
     * @returns
     */
    async writeEnv(projectPath, env, envs) {
        envs.TEAMSFX_ENV = env;
        //encrypt
        const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath);
        if (settingsRes.isErr()) {
            return teamsfx_api_1.err(settingsRes.error);
        }
        const projectId = settingsRes.value.trackingId;
        const cryptoProvider = new crypto_1.LocalCrypto(projectId);
        const noneSecretEnv = {};
        const secretEnv = {};
        for (const key of Object.keys(envs)) {
            let value = envs[key];
            if (value && key.startsWith("SECRET_")) {
                const res = cryptoProvider.encrypt(value);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
                value = res.value;
                // envs[key] = value;
                secretEnv[key] = value;
            }
            else if (key === configure_1.internalOutputNames.teamsAppUpdateTime) {
                // Corner case: Avoid TEAMS_APP_UPDATE_TIME to be committed and cause merge conflict
                // Bug: 21970450
                secretEnv[key] = value;
            }
            else {
                noneSecretEnv[key] = value;
            }
        }
        //replace existing, if env file not exist, create a default one
        const dotEnvFilePathRes = await pathUtils_1.pathUtils.getEnvFilePath(projectPath, env);
        if (dotEnvFilePathRes.isErr())
            return teamsfx_api_1.err(dotEnvFilePathRes.error);
        const dotEnvFilePath = dotEnvFilePathRes.value || path.resolve(projectPath, "env", `.env.${env ? env : "dev"}`);
        const envFileExists = await fs_extra_1.default.pathExists(dotEnvFilePath);
        const dotEnvSecretFilePath = dotEnvFilePath + ".user";
        const envSecretFileExists = await fs_extra_1.default.pathExists(dotEnvSecretFilePath);
        const parsedDotenv = envFileExists
            ? exports.dotenvUtil.deserialize(await fs_extra_1.default.readFile(dotEnvFilePath))
            : { obj: {} };
        const parsedDotenvSecret = envSecretFileExists
            ? exports.dotenvUtil.deserialize(await fs_extra_1.default.readFile(dotEnvSecretFilePath))
            : { obj: {} };
        lodash_1.merge(parsedDotenv.obj, noneSecretEnv);
        lodash_1.merge(parsedDotenvSecret.obj, secretEnv);
        //serialize
        const content = exports.dotenvUtil.serialize(parsedDotenv);
        const contentSecret = exports.dotenvUtil.serialize(parsedDotenvSecret);
        //persist
        await fs_extra_1.default.ensureFile(dotEnvFilePath);
        await fs_extra_1.default.writeFile(dotEnvFilePath, content, { encoding: "utf8" });
        if (Object.keys(parsedDotenvSecret.obj).length > 0) {
            await fs_extra_1.default.ensureFile(dotEnvSecretFilePath);
            await fs_extra_1.default.writeFile(dotEnvSecretFilePath, contentSecret, { encoding: "utf8" });
        }
        if (!envFileExists) {
            globalVars_1.TOOLS.logProvider.info("  Created environment file at " + dotEnvFilePath + os_1.EOL + os_1.EOL);
        }
        if (!envSecretFileExists && Object.keys(parsedDotenvSecret.obj).length > 0) {
            globalVars_1.TOOLS.logProvider.info("  Created environment file (secret) at " + dotEnvSecretFilePath + os_1.EOL + os_1.EOL);
        }
        return teamsfx_api_1.ok(undefined);
    }
    async listEnv(projectPath, remoteOnly = false) {
        const folderRes = await pathUtils_1.pathUtils.getEnvFolderPath(projectPath);
        if (folderRes.isErr())
            return teamsfx_api_1.err(folderRes.error);
        const envFolderPath = folderRes.value;
        if (!envFolderPath)
            return teamsfx_api_1.ok([]);
        const list = await fs_extra_1.default.readdir(envFolderPath);
        let envs = list
            .map((fileName) => this.extractEnvNameFromFileName(fileName))
            .filter((env) => env !== undefined);
        if (remoteOnly) {
            envs = envs.filter((env) => environmentName_1.environmentNameManager.isRemoteEnvironment(env));
        }
        return teamsfx_api_1.ok(envs);
    }
    object2map(obj) {
        const map = new Map();
        for (const key of Object.keys(obj)) {
            map.set(key, obj[key]);
        }
        return map;
    }
    map2object(map) {
        const obj = {};
        for (const key of map.keys()) {
            obj[key] = map.get(key) || "";
        }
        return obj;
    }
    extractEnvNameFromFileName(inputFileName) {
        const regex = /^\.env\.(\w+)$/;
        const matches = inputFileName.match(regex);
        const envName = matches && matches[1];
        return envName || undefined;
    }
}
exports.envUtil = new EnvUtil();
const NEW_LINE_SPLITTER = /\r?\n/;
class DotenvUtil {
    deserialize(src) {
        const lines = [];
        const obj = {};
        const stringLines = src.toString().replace(/\r\n?/gm, "\n").split(NEW_LINE_SPLITTER);
        for (const line of stringLines) {
            const match = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm.exec(line);
            if (match) {
                let inlineComment;
                //key
                const key = match[1];
                //value
                let value = match[2] || "";
                //comment
                const valueIndex = match[0].indexOf(value);
                if (valueIndex >= 0) {
                    const remaining = match[0].substring(valueIndex + value.length).trim();
                    if (remaining.startsWith("#")) {
                        inlineComment = remaining;
                    }
                }
                //trim
                value = value.trim();
                //quote
                const firstChar = value[0];
                value = value.replace(/^(['"`])([\s\S]*)\1$/gm, "$2");
                //de-escape
                if (firstChar === '"') {
                    value = value.replace(/\\n/g, "\n");
                    value = value.replace(/\\r/g, "\r");
                }
                //output
                obj[key] = value;
                const parsedLine = { key: key, value: value };
                if (inlineComment)
                    parsedLine.comment = inlineComment;
                if (firstChar === '"' || firstChar === "'")
                    parsedLine.quote = firstChar;
                lines.push(parsedLine);
            }
            else {
                lines.push(line);
            }
        }
        return { lines: lines, obj: obj };
    }
    serialize(parsed) {
        const array = [];
        const obj = lodash_1.cloneDeep(parsed.obj);
        //append lines
        if (parsed.lines) {
            parsed.lines.forEach((line) => {
                if (typeof line === "string") {
                    // keep comment line or empty line
                    array.push(line);
                }
                else {
                    if (obj[line.key] !== undefined) {
                        // use kv in obj
                        line.value = obj[line.key];
                        delete obj[line.key];
                    }
                    if (line.value.includes("#") && !line.quote) {
                        // if value contains '#', need add quote
                        line.quote = '"';
                    }
                    let value = line.value;
                    if (line.quote) {
                        value = `${line.quote}${value}${line.quote}`;
                    }
                    array.push(`${line.key}=${value}${line.comment ? line.comment : ""}`);
                }
            });
        }
        //append additional kvs in object
        for (const key of Object.keys(obj)) {
            let value = parsed.obj[key];
            if (value.includes("#"))
                value = `"${value}"`; // if value contains '#', need add quote
            array.push(`${key}=${value}`);
        }
        return array.join("\n").trim();
    }
}
exports.dotenvUtil = new DotenvUtil();
//# sourceMappingURL=envUtil.js.map