"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.metadataGraphPermissionUtil = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const versionMetadata_1 = require("../../common/versionMetadata");
const permissions_1 = require("../driver/aad/permissions");
const telemetry_1 = require("../../common/telemetry");
const update_1 = require("../driver/aad/update");
class MetadataGraphPermissionUtil {
    async parseAadManifest(ymlPath, model, props) {
        var _a;
        let aadManifestName = versionMetadata_1.MetadataV3.aadManifestFileName;
        const updateAction = (_a = model.provision) === null || _a === void 0 ? void 0 : _a.driverDefs.find((def) => def.uses === update_1.actionName);
        // if aadApp/update action is defined, use the manifest file in the action
        if (updateAction) {
            const parameters = updateAction.with;
            if (parameters && parameters["manifestPath"]) {
                aadManifestName = parameters["manifestPath"];
            }
        }
        const aadManifestPath = path_1.default.join(path_1.default.dirname(ymlPath), aadManifestName);
        if (!(await fs_extra_1.default.pathExists(aadManifestPath))) {
            props[telemetry_1.TelemetryProperty.AadManifest] = "false";
            return;
        }
        props[telemetry_1.TelemetryProperty.AadManifest] = "true";
        try {
            const manifestString = await fs_extra_1.default.readFile(aadManifestPath, "utf8");
            const manifest = JSON.parse(manifestString);
            const graphPermissionSummary = this.getPermissionSummary(manifest);
            if (graphPermissionSummary) {
                props[telemetry_1.TelemetryProperty.GraphPermission] = graphPermissionSummary.hasGraphPermission
                    ? "true"
                    : "false";
                props[telemetry_1.TelemetryProperty.GraphPermissionHasRole] = graphPermissionSummary.hasRole
                    ? "true"
                    : "false";
                props[telemetry_1.TelemetryProperty.GraphPermissionHasAdminScope] = graphPermissionSummary.hasAdminScope
                    ? "true"
                    : "false";
                props[telemetry_1.TelemetryProperty.GraphPermissionScopes] = graphPermissionSummary.scopes.join(",");
            }
        }
        catch (error) {
            return;
        }
    }
    getPermissionSummary(manifest) {
        var _a, _b;
        let hasGraphPermission = false;
        let hasRole = false;
        let hasAdminScope = false;
        const scopes = [];
        const graphPermissionMap = permissions_1.getDetailedGraphPermissionMap();
        if (!graphPermissionMap) {
            return undefined;
        }
        const graphPermission = (_a = manifest.requiredResourceAccess) === null || _a === void 0 ? void 0 : _a.find((item) => item.resourceAppId === permissions_1.graphAppId || item.resourceAppId === permissions_1.graphAppName);
        if (!graphPermission) {
            return {
                hasGraphPermission,
                hasRole,
                hasAdminScope,
                scopes,
            };
        }
        hasGraphPermission = true;
        (_b = graphPermission.resourceAccess) === null || _b === void 0 ? void 0 : _b.forEach((access) => {
            if (access.type === "Role") {
                hasRole = true;
            }
            else {
                const id = isUUID_1.default(access.id) ? access.id : graphPermissionMap.scopes[access.id];
                if (graphPermissionMap.scopeIds[id]) {
                    scopes.push(graphPermissionMap.scopeIds[id].value);
                    if (graphPermissionMap.scopeIds[id].type === "Admin") {
                        hasAdminScope = true;
                    }
                }
            }
        });
        return {
            hasGraphPermission,
            hasRole,
            hasAdminScope,
            scopes,
        };
    }
}
exports.metadataGraphPermissionUtil = new MetadataGraphPermissionUtil();
//# sourceMappingURL=metadataGraphPermssion.js.map