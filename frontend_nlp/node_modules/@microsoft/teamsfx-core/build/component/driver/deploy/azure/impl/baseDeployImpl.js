"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseDeployImpl = void 0;
const tslib_1 = require("tslib");
const componentError_1 = require("../../../../error/componentError");
const ignore_1 = tslib_1.__importDefault(require("ignore"));
const deployConstant_1 = require("../../../../constant/deployConstant");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const common_1 = require("../../../../utils/common");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
class BaseDeployImpl {
    constructor(args, context) {
        this.dryRun = false;
        this.helpLink = undefined;
        this.progressPrepare = [];
        this.args = args;
        this.workingDirectory = context.projectPath;
        this.distDirectory = "";
        this.ui = context.ui;
        this.logger = context.logProvider;
        this.context = {
            azureAccountProvider: context.azureAccountProvider,
            progressBar: context.progressBar,
            logProvider: context.logProvider,
            telemetryReporter: context.telemetryReporter,
        };
        this.progressBar = context.progressBar;
    }
    async run() {
        this.context.logProvider.debug("start deploy process");
        this.updateProgressbar();
        return await this.wrapErrorHandler(async () => {
            var _a, _b;
            const deployArgs = BaseDeployImpl.asDeployArgs(this.args, this.helpLink);
            // if working directory not set, use current working directory
            deployArgs.workingDirectory = (_a = deployArgs.workingDirectory) !== null && _a !== void 0 ? _a : "./";
            // if working dir is not absolute path, then join the path with project path
            this.workingDirectory = this.handlePath(deployArgs.workingDirectory, this.workingDirectory);
            // if distribution path is not absolute path, then join the path with project path
            this.distDirectory = this.handlePath(deployArgs.artifactFolder, this.workingDirectory);
            this.dryRun = (_b = deployArgs.dryRun) !== null && _b !== void 0 ? _b : false;
            this.zipFilePath = deployArgs.outputZipFile;
            // call real deploy
            return await this.deploy(deployArgs);
        });
    }
    handlePath(inputPath, baseFolder) {
        return path.isAbsolute(inputPath) ? inputPath : path.join(baseFolder, inputPath);
    }
    async handleIgnore(args, context) {
        // always add deploy temp folder into ignore list
        const ig = ignore_1.default().add(deployConstant_1.DeployConstant.DEPLOYMENT_TMP_FOLDER);
        if (args.ignoreFile) {
            const ignoreFilePath = path.join(this.workingDirectory, args.ignoreFile);
            if (await fs.pathExists(ignoreFilePath)) {
                const ignoreFileContent = await fs.readFile(ignoreFilePath);
                ignoreFileContent
                    .toString()
                    .split("\n")
                    .map((line) => line.trim())
                    .forEach((it) => {
                    ig.add(it);
                });
            }
            else {
                context.logProvider.warning(`already set deploy ignore file ${args.ignoreFile} but file not exists in ${this.workingDirectory}, skip ignore!`);
            }
        }
        return ig;
    }
    async wrapErrorHandler(fn) {
        try {
            return (await fn())
                ? { result: teamsfx_api_1.ok(BaseDeployImpl.emptyMap), summaries: this.summaries() }
                : { result: teamsfx_api_1.ok(BaseDeployImpl.emptyMap), summaries: this.summaryPrepare() };
        }
        catch (e) {
            if (e instanceof componentError_1.BaseComponentInnerError) {
                const errorDetail = e.detail ? `Detail: ${e.detail}` : "";
                this.context.logProvider.error(`${e.message} ${errorDetail}`);
                return { result: teamsfx_api_1.err(e.toFxError()), summaries: [] };
            }
            else if (e instanceof teamsfx_api_1.SystemError || e instanceof teamsfx_api_1.UserError) {
                return {
                    result: teamsfx_api_1.err(e),
                    summaries: [],
                };
            }
            else {
                this.context.logProvider.error(`Unknown error: ${JSON.stringify(e, Object.getOwnPropertyNames(e))}`);
                return {
                    result: teamsfx_api_1.err(componentError_1.BaseComponentInnerError.unknownError("Deploy", e).toFxError()),
                    summaries: [],
                };
            }
        }
    }
}
exports.BaseDeployImpl = BaseDeployImpl;
BaseDeployImpl.emptyMap = new Map();
BaseDeployImpl.asDeployArgs = common_1.asFactory({
    workingDirectory: common_1.asOptional(common_1.asString),
    artifactFolder: common_1.asString,
    ignoreFile: common_1.asOptional(common_1.asString),
    resourceId: common_1.asString,
    dryRun: common_1.asOptional(common_1.asBoolean),
    outputZipFile: common_1.asOptional(common_1.asString),
});
//# sourceMappingURL=baseDeployImpl.js.map