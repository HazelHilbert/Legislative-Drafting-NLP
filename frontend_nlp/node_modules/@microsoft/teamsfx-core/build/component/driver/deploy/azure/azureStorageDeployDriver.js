"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureStorageDeployDriverImpl = exports.AzureStorageDeployDriver = void 0;
const tslib_1 = require("tslib");
/**
 * @author FanH <Siglud@gmail.com>
 */
const azureDeployImpl_1 = require("./impl/azureDeployImpl");
const deployConstant_1 = require("../../../constant/deployConstant");
const fileOperation_1 = require("../../../utils/fileOperation");
const path_1 = tslib_1.__importDefault(require("path"));
const mime = tslib_1.__importStar(require("mime"));
const typedi_1 = require("typedi");
const azureResourceOperation_1 = require("../../../utils/azureResourceOperation");
const hooks_1 = require("@feathersjs/hooks");
const addStartAndEndTelemetry_1 = require("../../middleware/addStartAndEndTelemetry");
const commonConstant_1 = require("../../../constant/commonConstant");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const azureSdkErrorHandler_1 = require("../../../utils/azureSdkErrorHandler");
const error_1 = require("../../../../error");
const messages_1 = require("../../../messages");
const globalVars_1 = require("../../../../core/globalVars");
const ACTION_NAME = "azureStorage/deploy";
let AzureStorageDeployDriver = class AzureStorageDeployDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.deploy.deployToAzureStorageDescription");
    }
    execute(args, ctx) {
        const impl = new AzureStorageDeployDriverImpl(args, ctx);
        return impl.run();
    }
};
tslib_1.__decorate([
    hooks_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(ACTION_NAME, commonConstant_1.TelemetryConstant.DEPLOY_COMPONENT_NAME)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AzureStorageDeployDriver.prototype, "execute", null);
AzureStorageDeployDriver = tslib_1.__decorate([
    typedi_1.Service(ACTION_NAME)
], AzureStorageDeployDriver);
exports.AzureStorageDeployDriver = AzureStorageDeployDriver;
/**
 * deploy to Azure Storage
 */
class AzureStorageDeployDriverImpl extends azureDeployImpl_1.AzureDeployImpl {
    constructor() {
        super(...arguments);
        this.summaries = () => [
            localizeUtils_1.getLocalizedString("driver.deploy.azureStorageDeployDetailSummary", this.distDirectory),
        ];
        this.summaryPrepare = () => [];
        this.pattern = /\/subscriptions\/([^\/]*)\/resourceGroups\/([^\/]*)\/providers\/Microsoft.Storage\/storageAccounts\/([^\/]*)/i;
        this.helpLink = "https://aka.ms/teamsfx-actions/azure-storage-deploy";
    }
    async azureDeploy(args, azureResource, azureCredential) {
        this.context.logProvider.debug("Start deploying to Azure Storage Service");
        this.context.logProvider.debug("Get Azure Storage Service deploy credential");
        const containerClient = await AzureStorageDeployDriverImpl.createContainerClient(azureResource, azureCredential);
        // delete all existing blobs
        await this.deleteAllBlobs(containerClient, azureResource.instanceId, this.context.logProvider);
        this.context.logProvider.debug("Uploading files to Azure Storage Service");
        // upload all to storage
        const ig = await this.handleIgnore(args, this.context);
        const sourceFolder = this.distDirectory;
        const tasks = [];
        await fileOperation_1.forEachFileAndDir(sourceFolder, (filePath, stats) => {
            const destFilePath = path_1.default.relative(sourceFolder, filePath);
            if (!destFilePath || stats.isDirectory()) {
                return;
            }
            const options = {
                blobHTTPHeaders: {
                    blobContentType: mime.getType(filePath) || undefined,
                },
            };
            const client = containerClient.getBlockBlobClient(destFilePath);
            tasks.push(client.uploadFile(filePath, options));
        }, (itemPath) => {
            return !ig.test(path_1.default.relative(sourceFolder, itemPath)).ignored;
        });
        const responses = await Promise.all(tasks);
        const errorResponse = responses.find((res) => res.errorCode);
        if (errorResponse) {
            throw new error_1.AzureStorageUploadFilesError(azureResource.instanceId, sourceFolder, errorResponse, this.helpLink);
        }
        this.context.logProvider.debug("Upload files to Azure Storage Service successfully");
        return;
    }
    static async createContainerClient(azureResource, azureCredential) {
        const blobServiceClient = await azureResourceOperation_1.createBlobServiceClient(azureResource, azureCredential);
        return await azureSdkErrorHandler_1.wrapAzureOperation(async () => {
            const container = blobServiceClient.getContainerClient(deployConstant_1.DeployConstant.AZURE_STORAGE_CONTAINER_NAME);
            if (!(await container.exists())) {
                await container.create();
            }
            return container;
        }, (e) => new error_1.AzureStorageGetContainerError(azureResource.instanceId, deployConstant_1.DeployConstant.AZURE_STORAGE_CONTAINER_NAME, e), (e) => new error_1.AzureStorageGetContainerError(azureResource.instanceId, deployConstant_1.DeployConstant.AZURE_STORAGE_CONTAINER_NAME, e));
    }
    async deleteAllBlobs(client, storageName, logProvider) {
        var e_1, _a;
        logProvider.debug(`Deleting all existing blobs in container '${deployConstant_1.DeployConstant.AZURE_STORAGE_CONTAINER_NAME}' for Azure Storage account '${storageName}'.`);
        const deleteJobs = [];
        try {
            for (var _b = tslib_1.__asyncValues(client.listBlobsFlat()), _c; _c = await _b.next(), !_c.done;) {
                const blob = _c.value;
                if (AzureStorageDeployDriverImpl.isBlobFile(blob)) {
                    deleteJobs.push(client.deleteBlob(blob.name));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const responses = await Promise.all(deleteJobs);
        logProvider.verbose(`Delete all blobs responses: ${JSON.stringify(responses)}`);
        const errorResponse = responses.find((res) => res.errorCode);
        if (errorResponse) {
            throw new error_1.AzureStorageClearBlobsError(storageName, errorResponse);
        }
    }
    static isBlobFile(blob) {
        var _a;
        return ((_a = blob.properties.contentLength) !== null && _a !== void 0 ? _a : -1) > 0;
    }
    updateProgressbar() {
        var _a;
        (_a = this.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_1.ProgressMessages.deployToAzure(this.workingDirectory, "Azure Storage Service"));
    }
}
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ source: "Azure", component: "AzureStorageDeployDriverImpl" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AzureStorageDeployDriverImpl.prototype, "azureDeploy", null);
exports.AzureStorageDeployDriverImpl = AzureStorageDeployDriverImpl;
//# sourceMappingURL=azureStorageDeployDriver.js.map