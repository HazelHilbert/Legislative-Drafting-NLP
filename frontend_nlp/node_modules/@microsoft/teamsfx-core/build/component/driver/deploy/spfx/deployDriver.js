"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPFxDeployDriver = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const axios_1 = tslib_1.__importDefault(require("axios"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const typedi_1 = require("typedi");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const tools_1 = require("../../../../common/tools");
const common_1 = require("../../../../error/common");
const common_2 = require("../../../utils/common");
const addStartAndEndTelemetry_1 = require("../../middleware/addStartAndEndTelemetry");
const wrapUtil_1 = require("../../util/wrapUtil");
const createAppCatalogFailedError_1 = require("./error/createAppCatalogFailedError");
const getGraphTokenFailedError_1 = require("./error/getGraphTokenFailedError");
const getSPOTokenFailedError_1 = require("./error/getSPOTokenFailedError");
const getTenantFailedError_1 = require("./error/getTenantFailedError");
const insufficientPermissionError_1 = require("./error/insufficientPermissionError");
const noSPPackageError_1 = require("./error/noSPPackageError");
const noValidAppCatelogError_1 = require("./error/noValidAppCatelogError");
const uploadAppPackageFailedError_1 = require("./error/uploadAppPackageFailedError");
const constants_1 = require("./utility/constants");
const sleep_1 = require("./utility/sleep");
const spoClient_1 = require("./utility/spoClient");
const globalVars_1 = require("../../../../core/globalVars");
let SPFxDeployDriver = class SPFxDeployDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.spfx.deploy.description");
        this.progressTitle = localizeUtils_1.getLocalizedString("driver.spfx.deploy.progressbar.stepMessage");
        this.EmptyMap = new Map();
        this.asDeployArgs = common_2.asFactory({
            createAppCatalogIfNotExist: common_2.asBoolean,
            packageSolutionPath: common_2.asString,
        });
    }
    async run(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, constants_1.Constants.TelemetryDeployEventName, constants_1.Constants.TelemetryComponentName);
        return common_2.wrapRun(() => this.deploy(args, wrapContext), constants_1.Constants.DeployDriverName);
    }
    async execute(args, ctx) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(ctx, constants_1.Constants.TelemetryDeployEventName, constants_1.Constants.TelemetryComponentName);
        const result = await this.run(args, wrapContext);
        return {
            result,
            summaries: wrapContext.summaries,
        };
    }
    async deploy(args, context) {
        var _a, _b, _c;
        const deployArgs = this.asDeployArgs(args);
        context.logProvider.debug(`Getting user tenant...`);
        const tenant = await this.getTenant(context.m365TokenProvider);
        spoClient_1.SPOClient.setBaseUrl(tenant);
        context.logProvider.debug(`Succeeded to get user tenant: ${tenant}.`);
        const spoToken = await tools_1.getSPFxToken(context.m365TokenProvider);
        if (!spoToken) {
            throw new getSPOTokenFailedError_1.GetSPOTokenFailedError();
        }
        context.logProvider.verbose(`Getting SharePoint app catalog site...`);
        let appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
        if (appCatalogSite) {
            context.logProvider.verbose(`Succeeded to get SharePoint app catalog site: ${appCatalogSite}.`);
            spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
            context.addSummary(constants_1.DeployProgressMessage.SkipCreateSPAppCatalog());
        }
        else {
            context.logProvider.verbose(`Failed to get valid SharePoint app catalog site under current tenant.`);
            if (deployArgs.createAppCatalogIfNotExist) {
                context.logProvider.verbose(`Creating app catalog for user since there's no existing one...`);
                try {
                    await spoClient_1.SPOClient.createAppCatalog(spoToken);
                    context.addSummary(constants_1.DeployProgressMessage.CreateSPAppCatalog());
                    context.logProvider.verbose(`Succeeded to create app catalog.`);
                }
                catch (e) {
                    throw new createAppCatalogFailedError_1.CreateAppCatalogFailedError(e);
                }
            }
            else {
                throw new noValidAppCatelogError_1.NoValidAppCatelog();
            }
            let retry = 0;
            context.logProvider.verbose(`Getting newly created app catalog site...`);
            appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
            while (appCatalogSite == null && retry < constants_1.Constants.APP_CATALOG_MAX_TIMES) {
                void context.logProvider.warning(localizeUtils_1.getLocalizedString("driver.spfx.warn.noTenantAppCatalogFound", retry));
                await sleep_1.sleep(constants_1.Constants.APP_CATALOG_REFRESH_TIME);
                appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                retry += 1;
            }
            if (appCatalogSite) {
                context.logProvider.verbose(`Succeeded to get newly created app catalog site: ${appCatalogSite}.`);
                spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
                void context.logProvider.info(localizeUtils_1.getLocalizedString("driver.spfx.info.tenantAppCatalogCreated", appCatalogSite));
                await sleep_1.sleep(constants_1.Constants.APP_CATALOG_ACTIVE_TIME);
            }
            else {
                throw new createAppCatalogFailedError_1.CreateAppCatalogFailedError(new Error(localizeUtils_1.getLocalizedString("driver.spfx.error.failedToGetAppCatalog")));
            }
        }
        const packageSolutionPath = path_1.default.isAbsolute(deployArgs.packageSolutionPath)
            ? deployArgs.packageSolutionPath
            : path_1.default.join(context.projectPath, deployArgs.packageSolutionPath);
        context.logProvider.debug(`Getting zipped package path from package-solution.json file under ${packageSolutionPath}...`);
        const appPackage = await this.getPackagePath(packageSolutionPath);
        if (!(await fs_extra_1.default.pathExists(appPackage))) {
            throw new noSPPackageError_1.NoSPPackageError(appPackage);
        }
        context.logProvider.debug(`Succeeded to get zipped package path: ${appPackage}.`);
        const fileName = path_1.default.parse(appPackage).base;
        const bytes = await fs_extra_1.default.readFile(appPackage);
        try {
            context.logProvider.verbose(`Uploading SharePoint app package ${fileName}...`);
            await spoClient_1.SPOClient.uploadAppPackage(spoToken, fileName, bytes);
            context.addSummary(constants_1.DeployProgressMessage.Upload());
            context.logProvider.verbose(`Succeeded to upload SharePoint app package.`);
        }
        catch (e) {
            if (((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) === 403) {
                throw new insufficientPermissionError_1.InsufficientPermissionError(appCatalogSite);
            }
            else {
                throw new uploadAppPackageFailedError_1.UploadAppPackageFailedError(e);
            }
        }
        context.logProvider.debug(`Getting app id from package-solution.json file under ${packageSolutionPath}...`);
        const appID = await this.getAppID(packageSolutionPath);
        context.logProvider.verbose(`Deploying SharePoint app package with app id: ${appID}...`);
        await spoClient_1.SPOClient.deployAppPackage(spoToken, appID);
        context.addSummary(constants_1.DeployProgressMessage.Deploy());
        context.logProvider.verbose(`Succeeded to deploy SharePoint app package.`);
        const guidance = localizeUtils_1.getLocalizedString("plugins.spfx.deployNotice", appPackage, appCatalogSite, appCatalogSite);
        if (context.platform === teamsfx_api_1.Platform.CLI) {
            (_b = context.ui) === null || _b === void 0 ? void 0 : _b.showMessage("info", guidance, false);
        }
        else {
            (_c = context.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", guidance, false, "OK");
        }
        return this.EmptyMap;
    }
    async getTenant(tokenProvider) {
        const graphTokenRes = await tokenProvider.getAccessToken({
            scopes: tools_1.GraphScopes,
        });
        const graphToken = graphTokenRes.isOk() ? graphTokenRes.value : undefined;
        if (!graphToken) {
            throw new getGraphTokenFailedError_1.GetGraphTokenFailedError();
        }
        const tokenJsonRes = await tokenProvider.getJsonObject({
            scopes: tools_1.GraphScopes,
        });
        const username = tokenJsonRes.value.unique_name;
        const instance = axios_1.default.create({
            baseURL: "https://graph.microsoft.com/v1.0",
        });
        instance.defaults.headers.common["Authorization"] = `Bearer ${graphToken}`;
        let tenant = "";
        try {
            const res = await instance.get("/sites/root?$select=webUrl");
            if (res && res.data && res.data.webUrl) {
                tenant = res.data.webUrl;
            }
            else {
                throw new getTenantFailedError_1.GetTenantFailedError(username);
            }
        }
        catch (e) {
            throw new getTenantFailedError_1.GetTenantFailedError(username, e);
        }
        return tenant;
    }
    async getPackagePath(solutionConfigPath) {
        if (!(await fs_extra_1.default.pathExists(solutionConfigPath))) {
            throw new common_1.FileNotFoundError(constants_1.Constants.DeployDriverName, solutionConfigPath);
        }
        const solutionConfig = await fs_extra_1.default.readJson(solutionConfigPath);
        const sharepointFolder = path_1.default.dirname(solutionConfigPath).replace("config", "sharepoint");
        return path_1.default.resolve(sharepointFolder, solutionConfig.paths.zippedPackage);
    }
    async getAppID(solutionConfigPath) {
        if (!(await fs_extra_1.default.pathExists(solutionConfigPath))) {
            throw new common_1.FileNotFoundError(constants_1.Constants.DeployDriverName, solutionConfigPath);
        }
        const solutionConfig = await fs_extra_1.default.readJson(solutionConfigPath);
        const appID = solutionConfig["solution"]["id"];
        return appID;
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        addStartAndEndTelemetry_1.addStartAndEndTelemetry(constants_1.Constants.TelemetryDeployEventName, constants_1.Constants.TelemetryComponentName),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], SPFxDeployDriver.prototype, "run", null);
tslib_1.__decorate([
    lib_1.hooks([globalVars_1.ErrorContextMW({ source: "SPFx", component: "SPFxDeployDriver" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext]),
    tslib_1.__metadata("design:returntype", Promise)
], SPFxDeployDriver.prototype, "deploy", null);
SPFxDeployDriver = tslib_1.__decorate([
    typedi_1.Service(constants_1.Constants.DeployDriverName)
], SPFxDeployDriver);
exports.SPFxDeployDriver = SPFxDeployDriver;
//# sourceMappingURL=deployDriver.js.map