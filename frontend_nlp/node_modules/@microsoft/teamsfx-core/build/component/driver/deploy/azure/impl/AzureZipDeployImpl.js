"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureZipDeployImpl = void 0;
const tslib_1 = require("tslib");
/**
 * @author FanH <Siglud@gmail.com>
 */
const azureDeployImpl_1 = require("./azureDeployImpl");
const messages_1 = require("../../../../messages");
const deployConstant_1 = require("../../../../constant/deployConstant");
const crypto_1 = require("crypto");
const axios_1 = tslib_1.__importDefault(require("axios"));
const commonConstant_1 = require("../../../../constant/commonConstant");
const localizeUtils_1 = require("../../../../../common/localizeUtils");
const path_1 = tslib_1.__importDefault(require("path"));
const fileOperation_1 = require("../../../../utils/fileOperation");
const deploy_1 = require("../../../../../error/deploy");
const globalVars_1 = require("../../../../../core/globalVars");
const hooks_1 = require("@feathersjs/hooks");
class AzureZipDeployImpl extends azureDeployImpl_1.AzureDeployImpl {
    constructor(args, context, serviceName, helpLink, summaries, summaryPrepare) {
        super(args, context);
        this.pattern = /\/subscriptions\/([^\/]*)\/resourceGroups\/([^\/]*)\/providers\/Microsoft.Web\/sites\/([^\/]*)/i;
        this.prepare = async (args) => {
            await this.packageToZip(args, this.context);
        };
        this.helpLink = helpLink;
        this.serviceName = serviceName;
        this.summaries = () => summaries.map((summary) => localizeUtils_1.getLocalizedString(summary, this.distDirectory));
        this.summaryPrepare = () => summaryPrepare.map((summary) => localizeUtils_1.getLocalizedString(summary, this.zipFilePath));
    }
    async azureDeploy(args, azureResource, azureCredential) {
        var _a;
        const cost = await this.zipDeploy(args, azureResource, azureCredential);
        await this.restartFunctionApp(azureResource);
        if (cost > deployConstant_1.DeployConstant.DEPLOY_OVER_TIME) {
            (_a = this.context.logProvider) === null || _a === void 0 ? void 0 : _a.info(localizeUtils_1.getLocalizedString("driver.deploy.notice.deployAcceleration", "https://aka.ms/teamsfx-config-run-from-package"));
        }
    }
    /**
     * deploy to azure app service or azure function use zip deploy method
     * @param args local file needed to be deployed
     * @param azureResource azure resource info
     * @param azureCredential azure user login credential
     * @return the zip deploy time cost
     * @protected
     */
    async zipDeploy(args, azureResource, azureCredential) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        const zipBuffer = await this.packageToZip(args, this.context);
        this.context.logProvider.debug("Start to get Azure account info for deploy");
        const config = await this.createAzureDeployConfig(azureResource, azureCredential);
        this.context.logProvider.debug("Get Azure account info for deploy complete");
        const endpoint = this.getZipDeployEndpoint(azureResource.instanceId);
        this.context.logProvider.debug(`Start to upload code to ${endpoint}`);
        const startTime = Date.now();
        const location = await this.zipDeployPackage(endpoint, zipBuffer, config, this.context.logProvider);
        this.context.logProvider.debug("Upload code to Azure complete");
        this.context.logProvider.debug("Start to check Azure deploy status");
        const deployRes = await this.checkDeployStatus(location, config, this.context.logProvider);
        this.context.logProvider.debug("Check Azure deploy status complete");
        const cost = Date.now() - startTime;
        const telemetryData = {
            time_cost: cost.toString(),
            status: (_b = (_a = deployRes === null || deployRes === void 0 ? void 0 : deployRes.status) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "",
            message: (_c = deployRes === null || deployRes === void 0 ? void 0 : deployRes.message) !== null && _c !== void 0 ? _c : "",
            received_time: (_d = deployRes === null || deployRes === void 0 ? void 0 : deployRes.received_time) !== null && _d !== void 0 ? _d : "",
            started_time: (_f = (_e = deployRes === null || deployRes === void 0 ? void 0 : deployRes.start_time) === null || _e === void 0 ? void 0 : _e.toString()) !== null && _f !== void 0 ? _f : "",
            end_time: (_h = (_g = deployRes === null || deployRes === void 0 ? void 0 : deployRes.end_time) === null || _g === void 0 ? void 0 : _g.toString()) !== null && _h !== void 0 ? _h : "",
            last_success_end_time: (_k = (_j = deployRes === null || deployRes === void 0 ? void 0 : deployRes.last_success_end_time) === null || _j === void 0 ? void 0 : _j.toString()) !== null && _k !== void 0 ? _k : "",
            complete: (_m = (_l = deployRes === null || deployRes === void 0 ? void 0 : deployRes.complete) === null || _l === void 0 ? void 0 : _l.toString()) !== null && _m !== void 0 ? _m : "",
            active: (_p = (_o = deployRes === null || deployRes === void 0 ? void 0 : deployRes.active) === null || _o === void 0 ? void 0 : _o.toString()) !== null && _p !== void 0 ? _p : "",
            is_readonly: (_r = (_q = deployRes === null || deployRes === void 0 ? void 0 : deployRes.is_readonly) === null || _q === void 0 ? void 0 : _q.toString()) !== null && _r !== void 0 ? _r : "",
            site_name_hash: (deployRes === null || deployRes === void 0 ? void 0 : deployRes.site_name)
                ? crypto_1.createHash("sha256").update(deployRes.site_name).digest("hex")
                : "",
        };
        this.context.logProvider.verbose(`Start send telemetry data ${JSON.stringify(telemetryData)}`);
        this.context.telemetryReporter.sendTelemetryEvent("deployResponse", telemetryData);
        return cost;
    }
    /**
     * pack dist folder into zip
     * @param args dist folder and ignore files
     * @param context log provider etc..
     * @protected
     */
    async packageToZip(args, context) {
        var _a, _b;
        const ig = await this.handleIgnore(args, context);
        this.zipFilePath = this.zipFilePath
            ? path_1.default.isAbsolute(this.zipFilePath)
                ? this.zipFilePath
                : path_1.default.join(this.workingDirectory, this.zipFilePath)
            : path_1.default.join(this.workingDirectory, deployConstant_1.DeployConstant.DEPLOYMENT_TMP_FOLDER, deployConstant_1.DeployConstant.DEPLOYMENT_ZIP_CACHE_FILE);
        (_a = this.context.logProvider) === null || _a === void 0 ? void 0 : _a.debug(`start zip dist folder ${this.distDirectory}`);
        const res = await fileOperation_1.zipFolderAsync(this.distDirectory, this.zipFilePath, ig);
        (_b = this.context.logProvider) === null || _b === void 0 ? void 0 : _b.debug(`zip dist folder ${this.distDirectory} to ${this.zipFilePath} complete`);
        return res;
    }
    /**
     * call azure app service or azure function zip deploy method
     * @param zipDeployEndpoint azure zip deploy endpoint
     * @param zipBuffer zip file buffer
     * @param config azure upload config, including azure account credential
     * @param logger log provider
     * @protected
     */
    async zipDeployPackage(zipDeployEndpoint, zipBuffer, config, logger) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        let res;
        let retryCount = 0;
        while (true) {
            this.context.logProvider.verbose(`Start to upload zip file to ${zipDeployEndpoint}`);
            try {
                res = await azureDeployImpl_1.AzureDeployImpl.AXIOS_INSTANCE.post(zipDeployEndpoint, zipBuffer, config);
                this.context.logProvider.verbose(`Upload zip file to ${zipDeployEndpoint} complete, response: ${JSON.stringify(res, Object.getOwnPropertyNames(res))}.`);
                break;
            }
            catch (e) {
                this.context.logProvider.verbose(`Upload zip file failed with error: ${JSON.stringify(e, Object.getOwnPropertyNames(e), 2)}`);
                if (axios_1.default.isAxiosError(e)) {
                    // if the error is remote server error, retry
                    if (((_b = (_a = e.response) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : commonConstant_1.HttpStatusCode.OK) >= commonConstant_1.HttpStatusCode.INTERNAL_SERVER_ERROR) {
                        retryCount += 1;
                        if (retryCount < deployConstant_1.DeployConstant.DEPLOY_UPLOAD_RETRY_TIMES) {
                            logger.warning(`Upload zip file failed with response status code: ${(_d = (_c = e.response) === null || _c === void 0 ? void 0 : _c.status) !== null && _d !== void 0 ? _d : "NA"}. Retrying...`);
                        }
                        else {
                            // if retry times exceed, throw error
                            logger.warning(`Retry times exceeded. Upload zip file failed with remote server error. Message: ${JSON.stringify((_e = e.response) === null || _e === void 0 ? void 0 : _e.data)}`);
                            throw new deploy_1.DeployZipPackageError(zipDeployEndpoint, new Error(`remote server error with status code: ${(_g = (_f = e.response) === null || _f === void 0 ? void 0 : _f.status) !== null && _g !== void 0 ? _g : "NA"}, message: ${JSON.stringify((_h = e.response) === null || _h === void 0 ? void 0 : _h.data)}`), this.helpLink);
                        }
                    }
                    else {
                        // None server error, throw
                        logger.error(`Upload zip file failed with response status code: ${(_k = (_j = e.response) === null || _j === void 0 ? void 0 : _j.status) !== null && _k !== void 0 ? _k : "NA"}, message: ${JSON.stringify((_l = e.response) === null || _l === void 0 ? void 0 : _l.data)}`);
                        throw new deploy_1.DeployZipPackageError(zipDeployEndpoint, new Error(`status code: ${(_o = (_m = e.response) === null || _m === void 0 ? void 0 : _m.status) !== null && _o !== void 0 ? _o : "NA"}, message: ${JSON.stringify((_p = e.response) === null || _p === void 0 ? void 0 : _p.data)}`), this.helpLink);
                    }
                }
                else {
                    // if the error is not axios error, throw
                    logger.error(`Upload zip file failed with error: ${JSON.stringify(e)}`);
                    throw new deploy_1.DeployZipPackageError(zipDeployEndpoint, e, this.helpLink);
                }
            }
        }
        if ((res === null || res === void 0 ? void 0 : res.status) !== commonConstant_1.HttpStatusCode.OK && (res === null || res === void 0 ? void 0 : res.status) !== commonConstant_1.HttpStatusCode.ACCEPTED) {
            if (res === null || res === void 0 ? void 0 : res.status) {
                logger.error(`Deployment is failed with error code: ${res.status}.`);
            }
            throw new deploy_1.DeployZipPackageError(zipDeployEndpoint, new Error(`status code: ${(_q = res === null || res === void 0 ? void 0 : res.status) !== null && _q !== void 0 ? _q : "NA"}`), this.helpLink);
        }
        return res.headers.location;
    }
    /**
     * create azure zip deploy endpoint
     * @param siteName azure app service or azure function name
     * @protected
     */
    getZipDeployEndpoint(siteName) {
        return `https://${siteName}.scm.azurewebsites.net/api/zipdeploy?isAsync=true`;
    }
    updateProgressbar() {
        var _a;
        (_a = this.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_1.ProgressMessages.deployToAzure(this.workingDirectory, this.serviceName));
    }
}
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ source: "Azure", component: "AzureZipDeployImpl" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Buffer, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AzureZipDeployImpl.prototype, "zipDeployPackage", null);
exports.AzureZipDeployImpl = AzureZipDeployImpl;
//# sourceMappingURL=AzureZipDeployImpl.js.map