"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureDeployImpl = void 0;
const tslib_1 = require("tslib");
const common_1 = require("../../../../utils/common");
const baseDeployImpl_1 = require("./baseDeployImpl");
const js_base64_1 = require("js-base64");
const appService = tslib_1.__importStar(require("@azure/arm-appservice"));
const deployConstant_1 = require("../../../../constant/deployConstant");
const axios_1 = tslib_1.__importDefault(require("axios"));
const tools_1 = require("../../../../../common/tools");
const commonConstant_1 = require("../../../../constant/commonConstant");
const azureResourceOperation_1 = require("../../../../utils/azureResourceOperation");
const fs = tslib_1.__importStar(require("fs-extra"));
const componentError_1 = require("../../../../error/componentError");
const azureSdkErrorHandler_1 = require("../../../../utils/azureSdkErrorHandler");
const localizeUtils_1 = require("../../../../../common/localizeUtils");
const error_1 = require("../../../../../error");
const hooks_1 = require("@feathersjs/hooks");
const globalVars_1 = require("../../../../../core/globalVars");
class AzureDeployImpl extends baseDeployImpl_1.BaseDeployImpl {
    constructor() {
        super(...arguments);
        this.prepare = undefined;
    }
    async deploy(args) {
        // check root path exists
        if (!(await fs.pathExists(this.workingDirectory))) {
            throw componentError_1.PrerequisiteError.folderNotExists(deployConstant_1.DeployConstant.DEPLOY_ERROR_TYPE, this.workingDirectory, this.helpLink);
        }
        // check distribution folder exists
        if (!(await fs.pathExists(this.distDirectory))) {
            throw componentError_1.PrerequisiteError.folderNotExists(deployConstant_1.DeployConstant.DEPLOY_ERROR_TYPE, this.distDirectory, this.helpLink);
        }
        const resourceId = common_1.checkMissingArgs("resourceId", args.resourceId);
        const azureResource = this.parseResourceId(resourceId);
        const azureCredential = await azureResourceOperation_1.getAzureAccountCredential(this.context.azureAccountProvider);
        const inputs = { ignoreFile: args.ignoreFile };
        if (args.dryRun && this.prepare) {
            await this.prepare(inputs);
            return false;
        }
        await this.azureDeploy(inputs, azureResource, azureCredential);
        return true;
    }
    /**
     * check if resource id is legal and parse it
     * @param resourceId deploy target
     * @protected
     */
    parseResourceId(resourceId) {
        return azureResourceOperation_1.parseAzureResourceId(resourceId, this.pattern);
    }
    /**
     * loop and check azure deployment status
     * by default, it will wait for 120 minutes
     * @param location azure deployment location
     * @param config azure upload config, including azure account credential
     * @param logger log provider
     * @protected
     */
    async checkDeployStatus(location, config, logger) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        let res;
        for (let i = 0; i < deployConstant_1.DeployConstant.DEPLOY_CHECK_RETRY_TIMES; ++i) {
            try {
                this.logger.verbose(`Check deploy status with location: ${location}`);
                res = await AzureDeployImpl.AXIOS_INSTANCE.get(location, config);
                this.logger.verbose(`Check deploy status response: ${JSON.stringify(res, Object.getOwnPropertyNames(res))}`);
            }
            catch (e) {
                this.logger.verbose(`Check deploy status failed with error: ${JSON.stringify(e, Object.getOwnPropertyNames(e), 2)}`);
                if (axios_1.default.isAxiosError(e)) {
                    logger.error(`Check deploy status failed with response status code: ${(_b = (_a = e.response) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : "NA"}, message: ${JSON.stringify((_c = e.response) === null || _c === void 0 ? void 0 : _c.data)}`);
                    throw new error_1.CheckDeploymentStatusError(location, e, this.helpLink, `status code: ${(_e = (_d = e.response) === null || _d === void 0 ? void 0 : _d.status) !== null && _e !== void 0 ? _e : "NA"}, message: ${JSON.stringify((_f = e.response) === null || _f === void 0 ? void 0 : _f.data)}`);
                }
                throw new error_1.CheckDeploymentStatusError(location, e, this.helpLink);
            }
            if (res) {
                if ((res === null || res === void 0 ? void 0 : res.status) === commonConstant_1.HttpStatusCode.ACCEPTED) {
                    await tools_1.waitSeconds(deployConstant_1.DeployConstant.BACKOFF_TIME_S);
                }
                else if ((res === null || res === void 0 ? void 0 : res.status) === commonConstant_1.HttpStatusCode.OK || (res === null || res === void 0 ? void 0 : res.status) === commonConstant_1.HttpStatusCode.CREATED) {
                    if (((_g = res.data) === null || _g === void 0 ? void 0 : _g.status) === deployConstant_1.DeployStatus.Failed) {
                        this.logger.warning(localizeUtils_1.getDefaultString("error.deploy.DeployRemoteStartError", location, JSON.stringify(res.data)));
                    }
                    return res.data;
                }
                else {
                    if (res.status) {
                        logger.error(`Deployment is failed with error code: ${res.status}.`);
                    }
                    throw new error_1.CheckDeploymentStatusError(location, new Error(`status code: ${(_h = res.status) !== null && _h !== void 0 ? _h : "NA"}`), this.helpLink);
                }
            }
        }
        throw new error_1.CheckDeploymentStatusTimeoutError(this.helpLink);
    }
    /**
     * create azure deploy config for Azure Function and Azure App service
     * @param azureResource azure resource info
     * @param azureCredential user azure credential
     */
    async createAzureDeployConfig(azureResource, azureCredential) {
        var _a, _b;
        this.managementClient = new appService.WebSiteManagementClient(azureCredential, azureResource.subscriptionId);
        try {
            const defaultScope = "https://management.azure.com/.default";
            const token = await azureCredential.getToken(defaultScope);
            if (token) {
                this.logger.info("Get Microsoft Entra token successfully. Upload zip package through AAD Auth mode.");
                return {
                    headers: {
                        "Content-Type": "application/octet-stream",
                        "Cache-Control": "no-cache",
                        Authorization: `Bearer ${token.token}`,
                    },
                    maxContentLength: Infinity,
                    maxBodyLength: Infinity,
                    timeout: deployConstant_1.DeployConstant.DEPLOY_TIMEOUT_IN_MS,
                };
            }
            else {
                this.context.telemetryReporter.sendTelemetryErrorEvent("Get-Deploy-Microsoft Entra-token-failed", {
                    error: "Microsoft Entra token is empty.",
                });
                this.logger.info("Get Microsoft Entra token failed. AAD Token is empty. Upload zip package through basic auth mode. Please check your Azure credential.");
            }
        }
        catch (e) {
            this.context.telemetryReporter.sendTelemetryErrorEvent("Get-Deploy-AAD-token-failed", {
                error: e.toString(),
            });
            this.logger.info(`Get AAD token failed with error: ${JSON.stringify(e, Object.getOwnPropertyNames(e))}. Upload zip package through basic auth mode.`);
        }
        // IF only enable Microsoft Entra deploy, throw error
        if (process.env["TEAMSFX_AAD_DEPLOY_ONLY"] === "true") {
            throw new error_1.GetPublishingCredentialsError(azureResource.instanceId, azureResource.resourceGroupName, new Error("Get Microsoft Entra token failed."), this.helpLink);
        }
        const managementClient = this.managementClient;
        const listResponse = await azureSdkErrorHandler_1.wrapAzureOperation(() => managementClient.webApps.beginListPublishingCredentialsAndWait(azureResource.resourceGroupName, azureResource.instanceId), (e) => new error_1.GetPublishingCredentialsError(azureResource.instanceId, azureResource.resourceGroupName, e, this.helpLink), (e) => new error_1.GetPublishingCredentialsError(azureResource.instanceId, azureResource.resourceGroupName, e, this.helpLink));
        const publishingUserName = (_a = listResponse.publishingUserName) !== null && _a !== void 0 ? _a : "";
        const publishingPassword = (_b = listResponse.publishingPassword) !== null && _b !== void 0 ? _b : "";
        const encryptedCredentials = js_base64_1.Base64.encode(`${publishingUserName}:${publishingPassword}`);
        return {
            headers: {
                "Content-Type": "application/octet-stream",
                "Cache-Control": "no-cache",
                Authorization: `Basic ${encryptedCredentials}`,
            },
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            timeout: deployConstant_1.DeployConstant.DEPLOY_TIMEOUT_IN_MS,
        };
    }
    async restartFunctionApp(azureResource) {
        var _a, _b;
        this.context.logProvider.debug("Restarting function app...");
        try {
            await ((_b = (_a = this.managementClient) === null || _a === void 0 ? void 0 : _a.webApps) === null || _b === void 0 ? void 0 : _b.restart(azureResource.resourceGroupName, azureResource.instanceId));
        }
        catch (e) {
            this.logger.warning(localizeUtils_1.getLocalizedString("driver.deploy.error.restartWebAppError"));
        }
    }
}
AzureDeployImpl.AXIOS_INSTANCE = axios_1.default.create();
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ source: "Azure", component: "AzureZipDeployImpl" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AzureDeployImpl.prototype, "checkDeployStatus", null);
exports.AzureDeployImpl = AzureDeployImpl;
//# sourceMappingURL=azureDeployImpl.js.map