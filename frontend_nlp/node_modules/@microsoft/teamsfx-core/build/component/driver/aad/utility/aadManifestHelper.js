"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AadManifestHelper = void 0;
const tslib_1 = require("tslib");
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const permissions_1 = require("../permissions");
const aadManifestError_1 = require("../error/aadManifestError");
const componentName = "AadManifestHelper";
class AadManifestHelper {
    static manifestToApplication(manifest) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const result = {
            id: manifest.id,
            appId: manifest.appId,
            disabledByMicrosoftStatus: manifest.disabledByMicrosoftStatus,
            displayName: manifest.name,
            description: manifest.description,
            groupMembershipClaims: manifest.groupMembershipClaims,
            identifierUris: manifest.identifierUris,
            isFallbackPublicClient: manifest.allowPublicClient,
            notes: manifest.notes,
            signInAudience: manifest.signInAudience,
            tags: manifest.tags,
            tokenEncryptionKeyId: manifest.tokenEncryptionKeyId,
            addIns: manifest.addIns,
            api: {
                acceptMappedClaims: manifest.acceptMappedClaims,
                knownClientApplications: manifest.knownClientApplications,
                requestedAccessTokenVersion: manifest.accessTokenAcceptedVersion,
                oauth2PermissionScopes: manifest.oauth2Permissions,
                preAuthorizedApplications: (_a = manifest.preAuthorizedApplications) === null || _a === void 0 ? void 0 : _a.map((item) => {
                    return { appId: item.appId, delegatedPermissionIds: item.permissionIds };
                }),
            },
            appRoles: manifest.appRoles,
            info: {
                marketingUrl: (_b = manifest.informationalUrls) === null || _b === void 0 ? void 0 : _b.marketing,
                privacyStatementUrl: (_c = manifest.informationalUrls) === null || _c === void 0 ? void 0 : _c.privacy,
                supportUrl: (_d = manifest.informationalUrls) === null || _d === void 0 ? void 0 : _d.support,
                termsOfServiceUrl: (_e = manifest.informationalUrls) === null || _e === void 0 ? void 0 : _e.termsOfService,
            },
            keyCredentials: (_f = manifest.keyCredentials) === null || _f === void 0 ? void 0 : _f.map((item) => {
                return {
                    customKeyIdentifier: item.customKeyIdentifier,
                    displayName: item.displayName,
                    endDateTime: item.endDate,
                    key: item.value,
                    keyId: item.keyId,
                    startDateTime: item.startDate,
                    type: item.type,
                    usage: item.usage,
                };
            }),
            optionalClaims: manifest.optionalClaims,
            parentalControlSettings: manifest.parentalControlSettings,
            publicClient: {
                redirectUris: (_g = manifest.replyUrlsWithType) === null || _g === void 0 ? void 0 : _g.filter((item) => item.type === "InstalledClient").map((item) => item.url),
            },
            requiredResourceAccess: manifest.requiredResourceAccess,
            web: {
                homePageUrl: manifest.signInUrl,
                logoutUrl: manifest.logoutUrl,
                redirectUris: (_h = manifest.replyUrlsWithType) === null || _h === void 0 ? void 0 : _h.filter((item) => item.type === "Web").map((item) => item.url),
                implicitGrantSettings: {
                    enableIdTokenIssuance: manifest.oauth2AllowIdTokenImplicitFlow,
                    enableAccessTokenIssuance: manifest.oauth2AllowImplicitFlow,
                },
            },
            spa: {
                redirectUris: (_j = manifest.replyUrlsWithType) === null || _j === void 0 ? void 0 : _j.filter((item) => item.type === "Spa").map((item) => item.url),
            },
        };
        return result;
    }
    static applicationToManifest(app) {
        const result = {
            id: app.id,
            appId: app.appId,
            acceptMappedClaims: app.api.acceptMappedClaims,
            accessTokenAcceptedVersion: app.api.requestedAccessTokenVersion,
            addIns: app.addIns,
            allowPublicClient: app.isFallbackPublicClient,
            appRoles: app.appRoles,
            description: app.description,
            disabledByMicrosoftStatus: app.disabledByMicrosoftStatus,
            groupMembershipClaims: app.groupMembershipClaims,
            identifierUris: app.identifierUris,
            informationalUrls: {
                termsOfService: app.info.termsOfServiceUrl,
                support: app.info.supportUrl,
                privacy: app.info.privacyStatementUrl,
                marketing: app.info.marketingUrl,
            },
            keyCredentials: app.keyCredentials.map((item) => {
                return {
                    customKeyIdentifier: item.customKeyIdentifier,
                    endDate: item.endDateTime,
                    keyId: item.keyId,
                    startDate: item.startDateTime,
                    type: item.type,
                    usage: item.usage,
                    value: item.key,
                    displayName: item.displayName,
                };
            }),
            knownClientApplications: app.api.knownClientApplications,
            logoutUrl: app.web.logoutUrl,
            name: app.displayName,
            notes: app.notes,
            oauth2AllowIdTokenImplicitFlow: app.web.implicitGrantSettings.enableIdTokenIssuance,
            oauth2AllowImplicitFlow: app.web.implicitGrantSettings.enableIdTokenIssuance,
            oauth2Permissions: app.api.oauth2PermissionScopes,
            optionalClaims: app.optionalClaims,
            parentalControlSettings: app.parentalControlSettings,
            preAuthorizedApplications: app.api.preAuthorizedApplications.map((item) => {
                return {
                    appId: item.appId,
                    permissionIds: item.delegatedPermissionIds,
                };
            }),
            replyUrlsWithType: app.spa.redirectUris
                .map((item) => {
                return {
                    type: "Spa",
                    url: item,
                };
            })
                .concat(app.web.redirectUris.map((item) => {
                return {
                    type: "Web",
                    url: item,
                };
            }))
                .concat(app.publicClient.redirectUris.map((item) => {
                return {
                    type: "InstalledClient",
                    url: item,
                };
            })),
            requiredResourceAccess: app.requiredResourceAccess,
            signInUrl: app.web.homePageUrl,
            signInAudience: app.signInAudience,
            tags: app.tags,
            tokenEncryptionKeyId: app.tokenEncryptionKeyId,
        };
        return result;
    }
    static validateManifest(manifest) {
        let warningMsg = "";
        // if manifest doesn't contain name property or name is empty
        if (!manifest.name || manifest.name === "") {
            warningMsg += aadManifestError_1.AadManifestErrorMessage.NameIsMissing;
        }
        // if manifest doesn't contain signInAudience property
        if (!manifest.signInAudience) {
            warningMsg += aadManifestError_1.AadManifestErrorMessage.SignInAudienceIsMissing;
        }
        // if manifest doesn't contain requiredResourceAccess property
        if (!manifest.requiredResourceAccess) {
            warningMsg += aadManifestError_1.AadManifestErrorMessage.RequiredResourceAccessIsMissing;
        }
        // if manifest doesn't contain oauth2Permissions or oauth2Permissions length is 0
        if (!manifest.oauth2Permissions || manifest.oauth2Permissions.length === 0) {
            warningMsg += aadManifestError_1.AadManifestErrorMessage.Oauth2PermissionsIsMissing;
        }
        // if manifest doesn't contain preAuthorizedApplications
        if (!manifest.preAuthorizedApplications || manifest.preAuthorizedApplications.length === 0) {
            warningMsg += aadManifestError_1.AadManifestErrorMessage.PreAuthorizedApplicationsIsMissing;
        }
        // if accessTokenAcceptedVersion in manifest is not 2
        if (manifest.accessTokenAcceptedVersion !== 2) {
            warningMsg += aadManifestError_1.AadManifestErrorMessage.AccessTokenAcceptedVersionIs1;
        }
        // if manifest doesn't contain optionalClaims or access token doesn't contain idtyp clams
        if (!manifest.optionalClaims) {
            warningMsg += aadManifestError_1.AadManifestErrorMessage.OptionalClaimsIsMissing;
        }
        else if (!manifest.optionalClaims.accessToken.find((item) => item.name === "idtyp")) {
            warningMsg += aadManifestError_1.AadManifestErrorMessage.OptionalClaimsMissingIdtypClaim;
        }
        if (warningMsg) {
            warningMsg = aadManifestError_1.AadManifestErrorMessage.AADManifestIssues + warningMsg;
        }
        return warningMsg.trimEnd();
    }
    static processRequiredResourceAccessInManifest(manifest) {
        var _a;
        const map = permissions_1.getPermissionMap();
        (_a = manifest.requiredResourceAccess) === null || _a === void 0 ? void 0 : _a.forEach((requiredResourceAccessItem) => {
            var _a, _b;
            const resourceIdOrName = requiredResourceAccessItem.resourceAppId;
            let resourceId = resourceIdOrName;
            if (!isUUID_1.default(resourceIdOrName)) {
                resourceId = (_a = map[resourceIdOrName]) === null || _a === void 0 ? void 0 : _a.id;
                if (!resourceId) {
                    throw new aadManifestError_1.UnknownResourceAppIdUserError(componentName, resourceIdOrName);
                }
                requiredResourceAccessItem.resourceAppId = resourceId;
            }
            (_b = requiredResourceAccessItem.resourceAccess) === null || _b === void 0 ? void 0 : _b.forEach((resourceAccessItem) => {
                var _a, _b;
                const resourceAccessIdOrName = resourceAccessItem.id;
                if (!isUUID_1.default(resourceAccessIdOrName)) {
                    let resourceAccessId;
                    if (resourceAccessItem.type === "Scope") {
                        resourceAccessId = (_a = map[resourceId]) === null || _a === void 0 ? void 0 : _a.scopes[resourceAccessItem.id];
                    }
                    else if (resourceAccessItem.type === "Role") {
                        resourceAccessId = (_b = map[resourceId]) === null || _b === void 0 ? void 0 : _b.roles[resourceAccessItem.id];
                    }
                    else {
                        throw new aadManifestError_1.UnknownResourceAccessTypeUserError(componentName, resourceAccessItem.type);
                    }
                    if (!resourceAccessId) {
                        throw new aadManifestError_1.UnknownResourceAccessIdUserError(componentName, resourceAccessItem.id);
                    }
                    resourceAccessItem.id = resourceAccessId;
                }
            });
        });
    }
}
exports.AadManifestHelper = AadManifestHelper;
//# sourceMappingURL=aadManifestHelper.js.map