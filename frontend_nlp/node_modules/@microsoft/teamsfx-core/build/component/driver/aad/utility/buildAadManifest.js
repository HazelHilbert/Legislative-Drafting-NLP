"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAadManifest = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const aadManifestHelper_1 = require("./aadManifestHelper");
const invalidFieldInManifestError_1 = require("../error/invalidFieldInManifestError");
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const localizeUtils_1 = require("../../../../common/localizeUtils");
const constants_1 = require("../utility/constants");
const common_1 = require("../../../utils/common");
const tools_1 = require("../../../../common/tools");
const common_2 = require("../../../../error/common");
const actionName = "aadApp/update"; // DO NOT MODIFY the name
const helpLink = "https://aka.ms/teamsfx-actions/aadapp-update";
async function buildAadManifest(context, manifestPath, outputFilePath, state) {
    var _a;
    const manifestAbsolutePath = getAbsolutePath(manifestPath, context.projectPath);
    if (!(await fs.pathExists(manifestAbsolutePath))) {
        throw new common_2.FileNotFoundError(actionName, manifestAbsolutePath, helpLink);
    }
    const manifest = await loadManifest(manifestAbsolutePath, state);
    const warningMessage = aadManifestHelper_1.AadManifestHelper.validateManifest(manifest);
    if (warningMessage) {
        warningMessage.split("\n").forEach((warning) => {
            var _a;
            (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.warning(warning);
        });
    }
    if (!manifest.id || !isUUID_1.default(manifest.id)) {
        throw new invalidFieldInManifestError_1.MissingFieldInManifestUserError(actionName, "id", helpLink);
    }
    // Output actual manifest to project folder first for better troubleshooting experience
    const outputFileAbsolutePath = getAbsolutePath(outputFilePath, context.projectPath);
    await fs.ensureDir(path.dirname(outputFileAbsolutePath));
    await fs.writeFile(outputFileAbsolutePath, JSON.stringify(manifest, null, 4), "utf8");
    (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.info(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.outputAadAppManifest, outputFileAbsolutePath));
    return manifest;
}
exports.buildAadManifest = buildAadManifest;
function getAbsolutePath(relativeOrAbsolutePath, projectPath) {
    return path.isAbsolute(relativeOrAbsolutePath)
        ? relativeOrAbsolutePath
        : path.join(projectPath, relativeOrAbsolutePath);
}
async function loadManifest(manifestPath, state) {
    let generatedNewPermissionId = false;
    try {
        const manifestTemplate = await fs.readFile(manifestPath, "utf8");
        const permissionIdPlaceholderRegex = /\${{ *AAD_APP_ACCESS_AS_USER_PERMISSION_ID *}}/;
        // generate a new permission id if there's no one in env and manifest needs it
        if (!process.env.AAD_APP_ACCESS_AS_USER_PERMISSION_ID) {
            const matches = permissionIdPlaceholderRegex.exec(manifestTemplate);
            if (matches) {
                const permissionId = tools_1.getUuid();
                process.env.AAD_APP_ACCESS_AS_USER_PERMISSION_ID = permissionId;
                if (state) {
                    state.AAD_APP_ACCESS_AS_USER_PERMISSION_ID = permissionId;
                }
                generatedNewPermissionId = true;
            }
        }
        const manifestString = common_1.expandEnvironmentVariable(manifestTemplate);
        const unresolvedEnvironmentVariable = common_1.getEnvironmentVariables(manifestString);
        if (unresolvedEnvironmentVariable && unresolvedEnvironmentVariable.length > 0) {
            const error = new common_2.MissingEnvironmentVariablesError("aadAppUpdate", unresolvedEnvironmentVariable.join(", "), manifestPath, helpLink);
            throw error;
        }
        let manifest;
        try {
            manifest = JSON.parse(manifestString);
        }
        catch (error) {
            // JSON.parse only throws SyntaxError per doc, which is a subsclass of Error
            throw new common_2.JSONSyntaxError(manifestPath, error, actionName);
        }
        aadManifestHelper_1.AadManifestHelper.processRequiredResourceAccessInManifest(manifest);
        return manifest;
    }
    finally {
        if (generatedNewPermissionId) {
            // restore environment variable to avoid impact to other code
            delete process.env.AAD_APP_ACCESS_AS_USER_PERMISSION_ID;
        }
    }
}
//# sourceMappingURL=buildAadManifest.js.map