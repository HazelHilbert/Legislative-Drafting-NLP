"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureBicepForDriver = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const path = tslib_1.__importStar(require("path"));
const os = tslib_1.__importStar(require("os"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const cpUtils_1 = require("../../../utils/depsChecker/cpUtils");
const stream_1 = require("stream");
const common_1 = require("../../../utils/depsChecker/common");
const constants_1 = require("../../../constants");
const perf_hooks_1 = require("perf_hooks");
const utils_1 = require("../../../utils");
const common_2 = require("../../../../error/common");
const arm_1 = require("../../../../error/arm");
const system_1 = require("../../../../common/deps-checker/util/system");
const BicepName = "Bicep";
const timeout = 5 * 60 * 1000;
const source = "bicep-envchecker";
const bicepReleaseApiUrl = "https://api.github.com/repos/Azure/bicep/releases";
async function ensureBicepForDriver(ctx, version) {
    const bicepChecker = new BicepChecker(version, ctx.logProvider, ctx.telemetryReporter);
    try {
        const isPrivateBicepInstalled = await bicepChecker.isPrivateBicepInstalled();
        if (!isPrivateBicepInstalled) {
            await bicepChecker.install();
        }
    }
    catch (err) {
        throw err;
    }
    return bicepChecker.getBicepExecPath();
}
exports.ensureBicepForDriver = ensureBicepForDriver;
class BicepChecker {
    constructor(version, logger, telemetry) {
        this._logger = logger;
        this._telemetry = telemetry;
        this.version = version;
        this._axios = axios_1.default.create({
            headers: { "content-type": "application/json" },
            timeout: timeout,
            timeoutErrorMessage: "Failed to download bicep by http request timeout",
        });
    }
    async install() {
        await this.cleanup();
        await this.installBicep();
        if (!(await this.validate())) {
            await this.handleInstallFailed();
        }
        await this.handleInstallCompleted();
    }
    async getVersions() {
        const response = await this._axios.get(bicepReleaseApiUrl, {
            headers: { Accept: "application/vnd.github.v3+json" },
        });
        const versions = response.data.map((item) => item.tag_name);
        return versions;
    }
    async cleanup() {
        var _a;
        try {
            await fs.emptyDir(this.getBicepInstallDir());
        }
        catch (err) {
            (_a = this._logger) === null || _a === void 0 ? void 0 : _a.debug(`Failed to clean up path: ${this.getBicepInstallDir()}, error: ${err.toString()}`);
        }
    }
    async installBicep() {
        var _a;
        try {
            const start = perf_hooks_1.performance.now();
            await this.doInstallBicep();
            (_a = this._telemetry) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(common_1.DepsCheckerEvent.bicepInstallScriptCompleted, getCommonProps(), {
                [common_1.TelemetryMeasurement.completionTime]: Number(((perf_hooks_1.performance.now() - start) / 1000).toFixed(2)),
            });
        }
        catch (err) {
            sendSystemErrorEvent(common_1.DepsCheckerEvent.bicepInstallScriptError, common_1.TelemtryMessages.failedToInstallBicep, err, this._telemetry);
            throw new arm_1.DownloadBicepCliError(bicepReleaseApiUrl, err);
        }
    }
    getBicepDisplayBicepName() {
        return `${BicepName} (${this.version})`;
    }
    async doInstallBicep() {
        var _a;
        const installDir = this.getBicepExecPath();
        (_a = this._logger) === null || _a === void 0 ? void 0 : _a.info(common_1.Messages.downloadBicep()
            .replace("@NameVersion", `Bicep ${this.version}`)
            .replace("@InstallDir", installDir));
        const axiosResponse = await this._axios.get(`https://github.com/Azure/bicep/releases/download/${this.version}/${this.getBicepBitSuffixName()}`, {
            responseType: "stream",
        });
        const bicepReader = axiosResponse.data;
        const bicepWriter = fs.createWriteStream(installDir);
        // https://nodejs.org/api/fs.html#fscreatewritestreampath-options
        // on 'error' or 'finish' the file descriptor will be closed automatically
        // calling writer.end() again will hang
        await this.writeBicepBits(bicepWriter, bicepReader);
        fs.chmodSync(installDir, 0o755);
    }
    async writeBicepBits(writer, reader) {
        return new Promise((resolve, reject) => {
            reader.on("error", (err) => {
                // Handles reader error.
                writer.end();
                reject(err);
            });
            // https://nodejs.org/api/stream.html#readablepipedestination-options
            // If the Readable stream emits an error during processing, the Writable destination is **NOT** closed.
            reader.pipe(writer);
            stream_1.finished(writer, (err) => {
                // Handles writer end and writer error.
                // By handling writer end, it implicitly handles reader end because of reader.pipe(writer).
                // But reader error is not handled here.
                if (err)
                    reject(err);
                else
                    resolve();
            });
        });
    }
    async validate() {
        var _a, _b;
        let isVersionSupported = false;
        let privateVersion = "";
        try {
            privateVersion = await this.queryVersion(this.getBicepExecPath());
            isVersionSupported = this.isVersionSupported(privateVersion);
        }
        catch (err) {
            sendSystemErrorEvent(common_1.DepsCheckerEvent.bicepValidationError, common_1.TelemtryMessages.failedToValidateBicep, err, this._telemetry);
            (_a = this._logger) === null || _a === void 0 ? void 0 : _a.error(`${common_1.TelemtryMessages.failedToValidateBicep}, error = ${err.toString()}`);
        }
        if (!isVersionSupported) {
            (_b = this._telemetry) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(common_1.DepsCheckerEvent.bicepValidationError, Object.assign({ "bicep-private-version": privateVersion }, getCommonProps()));
        }
        return isVersionSupported;
    }
    async handleInstallCompleted() {
        var _a, _b;
        (_a = this._telemetry) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(common_1.DepsCheckerEvent.bicepInstallCompleted);
        (_b = this._logger) === null || _b === void 0 ? void 0 : _b.info(common_1.Messages.finishInstallBicep().replace("@NameVersion", this.getBicepDisplayBicepName()));
        return Promise.resolve();
    }
    async handleInstallFailed() {
        var _a;
        await this.cleanup();
        (_a = this._telemetry) === null || _a === void 0 ? void 0 : _a.sendTelemetryErrorEvent(common_1.DepsCheckerEvent.bicepInstallError);
        throw new common_2.InstallSoftwareError(source, this.getBicepDisplayBicepName());
    }
    isVersionSupported(version) {
        return this.version === version;
    }
    async isPrivateBicepInstalled() {
        try {
            const version = await this.queryVersion(this.getBicepExecPath());
            return this.isVersionSupported(version);
        }
        catch (e) {
            // do nothing
            return false;
        }
    }
    getBicepExecPath() {
        return path.join(this.getBicepInstallDir(), this.getBicepFileName());
    }
    getBicepFileName() {
        if (system_1.isWindows()) {
            return "bicep.exe";
        }
        return "bicep";
    }
    getBicepBitSuffixName() {
        if (system_1.isWindows()) {
            return "bicep-win-x64.exe";
        }
        if (system_1.isMacOS()) {
            return "bicep-osx-x64";
        }
        if (fs.pathExistsSync("/lib/ld-musl-x86_64.so.1")) {
            return "bicep-linux-musl-x64";
        }
        return "bicep-linux-x64";
    }
    getBicepInstallDir() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", "bicep", this.version);
    }
    async queryVersion(path) {
        var _a, _b, _c;
        const output = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { shell: false }, path, "--version");
        const regex = /(?<major_version>\d+)\.(?<minor_version>\d+)\.(?<patch_version>\d+)/gm;
        const match = regex.exec(output);
        if (!match) {
            return "";
        }
        return `v${((_a = match.groups) === null || _a === void 0 ? void 0 : _a.major_version) || ""}.${((_b = match.groups) === null || _b === void 0 ? void 0 : _b.minor_version) || ""}.${((_c = match.groups) === null || _c === void 0 ? void 0 : _c.patch_version) || ""}`;
    }
}
function sendSystemErrorEvent(eventName, errorMessage, errorStack, telemetry) {
    const error = new teamsfx_api_1.SystemError(source, eventName, `errorMsg=${errorMessage},errorStack=${errorStack}`);
    error.stack = errorStack;
    utils_1.sendErrorTelemetryThenReturnError(eventName, error, telemetry, getCommonProps());
}
function getCommonProps() {
    const properties = {};
    properties[common_1.TelemetryMeasurement.OSArch] = os.arch();
    properties[common_1.TelemetryMeasurement.OSRelease] = os.release();
    properties[constants_1.SolutionTelemetryProperty.Component] = constants_1.SolutionTelemetryComponentName;
    properties[constants_1.SolutionTelemetryProperty.Success] = constants_1.SolutionTelemetrySuccess.Yes;
    return properties;
}
//# sourceMappingURL=bicepChecker.js.map