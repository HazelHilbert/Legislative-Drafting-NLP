"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArmDeployImpl = void 0;
const tslib_1 = require("tslib");
/**
 * @author xzf0587 <zhaofengxu@microsoft.com>
 */
const arm_resources_1 = require("@azure/arm-resources");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const constants_1 = require("../../../common/constants");
const localizeUtils_1 = require("../../../common/localizeUtils");
const arm_1 = require("../../../error/arm");
const azure_1 = require("../../../error/azure");
const common_1 = require("../../../error/common");
const common_2 = require("../../utils/common");
const cpUtils_1 = require("../../utils/depsChecker/cpUtils");
const constant_1 = require("./constant");
const bicepChecker_1 = require("./util/bicepChecker");
const handleError_1 = require("./util/handleError");
const util_1 = require("./util/util");
const validator_1 = require("./validator");
const globalVars_1 = require("../../../core/globalVars");
const hooks_1 = require("@feathersjs/hooks");
const helpLink = "https://aka.ms/teamsfx-actions/arm-deploy";
class ArmDeployImpl {
    constructor(args, context) {
        this.args = args;
        this.context = context;
    }
    async run() {
        await this.validateArgs();
        await this.createClient();
        const needBicepCli = util_1.hasBicepTemplate(this.args.templates);
        if (needBicepCli && this.args.bicepCliVersion) {
            this.context.logProvider.debug(`Ensure bicep cli version ${this.args.bicepCliVersion} for ${constant_1.Constants.actionName}`);
            this.bicepCommand = await this.ensureBicepCli();
        }
        else {
            this.bicepCommand = "bicep";
        }
        const deployRes = await this.deployTemplates();
        if (deployRes.isOk()) {
            const outputs = deployRes.value;
            return util_1.convertOutputs(outputs);
        }
        else {
            throw deployRes.error;
        }
    }
    async validateArgs() {
        const invalidParameters = await validator_1.validateArgs(this.args);
        if (invalidParameters.length > 0) {
            throw new common_1.InvalidActionInputError(constant_1.Constants.actionName, invalidParameters, helpLink);
        }
    }
    async ensureBicepCli() {
        return await bicepChecker_1.ensureBicepForDriver(this.context, this.args.bicepCliVersion);
    }
    async createClient() {
        this.context.logProvider.debug(`Get token from AzureAccountProvider to create ResourceManagementClient of @azure/arm-resources`);
        const azureToken = await this.context.azureAccountProvider.getIdentityCredentialAsync();
        if (!azureToken) {
            throw new azure_1.InvalidAzureCredentialError();
        }
        this.client = new arm_resources_1.ResourceManagementClient(azureToken, this.args.subscriptionId);
    }
    async deployTemplates() {
        const outputs = [];
        this.setTelemetries();
        await Promise.all(this.args.templates.map(async (template) => {
            this.context.logProvider.debug(`Deploy template ${template.deploymentName} from ${template.path} to resource group ${this.args.resourceGroupName}`);
            const res = await this.deployTemplate(template);
            if (res.isOk() && res.value) {
                this.context.addSummary(localizeUtils_1.getLocalizedString("core.deployArmTemplates.ActionSuccess", this.args.resourceGroupName, template.deploymentName));
                outputs.push(res.value);
            }
            else if (res.isErr()) {
                throw res.error;
            }
        }));
        return teamsfx_api_1.ok(outputs);
    }
    async deployTemplate(templateArg) {
        const deployCtx = {
            ctx: this.context,
            finished: false,
            deploymentStartTime: Date.now(),
            client: this.client,
            resourceGroupName: this.args.resourceGroupName,
            deploymentName: templateArg.deploymentName,
        };
        try {
            const parameters = await this.getDeployParameters(templateArg.parameters);
            const template = await this.getDeployTemplate(templateArg.path);
            const deploymentParameters = {
                properties: {
                    parameters: parameters ? parameters.parameters : null,
                    template: template,
                    mode: "Incremental",
                },
            };
            const res = await this.executeDeployment(templateArg, deploymentParameters, deployCtx);
            return res;
        }
        catch (error) {
            if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError)
                return teamsfx_api_1.err(error);
            return teamsfx_api_1.err(new arm_1.DeployArmError(deployCtx.deploymentName, deployCtx.resourceGroupName, error));
        }
    }
    async executeDeployment(templateArg, deploymentParameters, deployCtx) {
        try {
            return await this.innerExecuteDeployment(templateArg, deploymentParameters);
        }
        catch (error) {
            const errRes = handleError_1.ArmErrorHandle.handleArmDeploymentError(error, deployCtx);
            return errRes;
        }
    }
    async innerExecuteDeployment(templateArg, deploymentParameters) {
        var _a, _b;
        const result = await ((_a = this.client) === null || _a === void 0 ? void 0 : _a.deployments.beginCreateOrUpdateAndWait(this.args.resourceGroupName, templateArg.deploymentName, deploymentParameters));
        return teamsfx_api_1.ok((_b = result === null || result === void 0 ? void 0 : result.properties) === null || _b === void 0 ? void 0 : _b.outputs);
    }
    async getDeployParameters(parameters) {
        if (!parameters) {
            return null;
        }
        const filePath = common_2.getAbsolutePath(parameters, this.context.projectPath);
        const template = await fs.readFile(filePath, constants_1.ConstantString.UTF8Encoding);
        const parameterJsonString = common_2.expandEnvironmentVariable(template);
        this.checkPlaceholderInTemplate(parameterJsonString, filePath);
        return JSON.parse(parameterJsonString);
    }
    checkPlaceholderInTemplate(parameterJsonString, filePath) {
        const tokens = common_2.getEnvironmentVariables(parameterJsonString);
        if (tokens.length > 0) {
            throw new common_1.MissingEnvironmentVariablesError("arm", tokens.join(","), filePath);
        }
    }
    async getDeployTemplate(templatePath) {
        const templateType = util_1.getFileExtension(templatePath);
        const filePath = common_2.getAbsolutePath(templatePath, this.context.projectPath);
        let templateJsonString;
        if (templateType === constant_1.TemplateType.Bicep) {
            templateJsonString = await this.compileBicepToJson(filePath);
        }
        else {
            const template = await fs.readFile(filePath, constants_1.ConstantString.UTF8Encoding);
            templateJsonString = JSON.parse(template);
        }
        return templateJsonString;
    }
    async compileBicepToJson(filePath) {
        try {
            this.context.logProvider.debug(`Compile bicep template ${filePath} to json`);
            const result = await cpUtils_1.cpUtils.executeCommand(undefined, this.context.logProvider, { shell: false }, this.bicepCommand, ...["build", filePath, "--stdout"]);
            return JSON.parse(result);
        }
        catch (err) {
            throw new arm_1.CompileBicepError(filePath, err);
        }
    }
    setTelemetries() {
        let bicepCount = 0;
        let jsonCount = 0;
        for (const template of this.args.templates) {
            const templateType = util_1.getFileExtension(template.path);
            if (templateType === constant_1.TemplateType.Bicep) {
                bicepCount++;
            }
            else {
                jsonCount++;
            }
        }
        this.context.addTelemetryProperties({
            [constant_1.TelemetryProperties.bicepTemplateCount]: bicepCount.toString(),
            [constant_1.TelemetryProperties.jsonTemplateCount]: jsonCount.toString(),
        });
    }
}
tslib_1.__decorate([
    hooks_1.hooks([globalVars_1.ErrorContextMW({ source: "Azure", component: "ArmDeployImpl" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], ArmDeployImpl.prototype, "innerExecuteDeployment", null);
exports.ArmDeployImpl = ArmDeployImpl;
//# sourceMappingURL=deployImpl.js.map