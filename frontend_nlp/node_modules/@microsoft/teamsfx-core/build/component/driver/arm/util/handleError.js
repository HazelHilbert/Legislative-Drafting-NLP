"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArmErrorHandle = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("../../../../common/constants");
const tools_1 = require("../../../../common/tools");
const azure_1 = require("../../../../error/azure");
const arm_1 = require("../../../../error/arm");
const innerHandleError_1 = require("./innerHandleError");
// constant string
const ErrorCodes = {
    InvalidTemplate: "InvalidTemplate",
    InvalidTemplateDeployment: "InvalidTemplateDeployment",
    ResourceGroupNotFound: "ResourceGroupNotFound",
    DeploymentOperationFailed: "DeploymentOperationFailed",
};
const filteredErrorMessage = "Template output evaluation skipped";
/* eslint-disable @typescript-eslint/no-namespace */
var ArmErrorHandle;
(function (ArmErrorHandle) {
    function fetchInnerError(error) {
        if (!error.details) {
            return error;
        }
        if (error.details.error) {
            return fetchInnerError(error.details.error);
        }
        else if (error.details instanceof Array && error.details[0]) {
            return fetchInnerError(error.details[0]);
        }
        return error;
    }
    ArmErrorHandle.fetchInnerError = fetchInnerError;
    async function handleArmDeploymentError(error, deployCtx) {
        var _a;
        // return the error if the template is invalid
        if (Object.keys(ErrorCodes).includes(error.code)) {
            if (error.code === ErrorCodes.InvalidTemplateDeployment) {
                error = fetchInnerError(error);
            }
            if (error.code === ErrorCodes.ResourceGroupNotFound) {
                return teamsfx_api_1.err(new azure_1.ResourceGroupNotExistError(deployCtx.resourceGroupName, deployCtx.client.subscriptionId));
            }
            else if (error.code === ErrorCodes.InvalidTemplate ||
                error.code === ErrorCodes.InvalidTemplateDeployment) {
                return teamsfx_api_1.err(new arm_1.DeployArmError(deployCtx.deploymentName, deployCtx.resourceGroupName, error));
            }
        }
        // try to get deployment error
        const result = await ArmErrorHandle.wrapGetDeploymentError(deployCtx, deployCtx.resourceGroupName, deployCtx.deploymentName, error);
        if (result.isOk()) {
            const deploymentError = result.value;
            // return thrown error if deploymentError is empty
            if (!deploymentError) {
                return teamsfx_api_1.err(new arm_1.DeployArmError(deployCtx.deploymentName, deployCtx.resourceGroupName, error));
            }
            const deploymentErrorObj = formattedDeploymentError(deploymentError);
            const deploymentErrorMessage = JSON.stringify(deploymentErrorObj, undefined, 2);
            let failedDeployments = [];
            if (deploymentError.subErrors) {
                failedDeployments = Object.keys(deploymentError.subErrors);
            }
            else {
                failedDeployments.push(deployCtx.deploymentName);
            }
            const format = failedDeployments.map((deployment) => deployment + " module");
            error.message = error.message + "\n" + deploymentErrorMessage;
            return teamsfx_api_1.err(new arm_1.DeployArmError(format.join(", "), deployCtx.resourceGroupName, error));
        }
        else {
            (_a = deployCtx.ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(`origin error message is : \n${JSON.stringify(error, undefined, 2)}`);
            return result;
        }
    }
    ArmErrorHandle.handleArmDeploymentError = handleArmDeploymentError;
    async function wrapGetDeploymentError(deployCtx, resourceGroupName, deploymentName, rawError) {
        try {
            const deploymentError = await ArmErrorHandle.getDeploymentError(deployCtx, resourceGroupName, deploymentName);
            return teamsfx_api_1.ok(deploymentError);
        }
        catch (error) {
            return teamsfx_api_1.err(new arm_1.GetArmDeploymentError(deployCtx.deploymentName, deployCtx.resourceGroupName, rawError, error));
        }
    }
    ArmErrorHandle.wrapGetDeploymentError = wrapGetDeploymentError;
    async function getDeploymentError(deployCtx, resourceGroupName, deploymentName) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        let deployment;
        try {
            deployment = await innerHandleError_1.innerGetDeploymentError(deployCtx.client, resourceGroupName, deploymentName);
        }
        catch (error) {
            if (deploymentName !== deployCtx.deploymentName &&
                error.code === constants_1.ConstantString.DeploymentNotFound) {
                return undefined;
            }
            throw error;
        }
        // The root deployment error name is deployCtx.deploymentName.
        // If we find the root error has a timestamp less than startTime, it is an old error to be ignored.
        // Other erros will be ignored as well.
        if (deploymentName === deployCtx.deploymentName &&
            ((_a = deployment.properties) === null || _a === void 0 ? void 0 : _a.timestamp) &&
            deployment.properties.timestamp.getTime() < deployCtx.deploymentStartTime) {
            return undefined;
        }
        if (!((_b = deployment.properties) === null || _b === void 0 ? void 0 : _b.error)) {
            return undefined;
        }
        const deploymentError = {
            error: (_c = deployment.properties) === null || _c === void 0 ? void 0 : _c.error,
        };
        const operations = [];
        const deploymentOperations = await innerHandleError_1.innerGetDeploymentOperations(deployCtx.client, resourceGroupName, deploymentName);
        for (const deploymentOperation of deploymentOperations) {
            operations.push(deploymentOperation);
        }
        for (const operation of operations) {
            if ((_e = (_d = operation.properties) === null || _d === void 0 ? void 0 : _d.statusMessage) === null || _e === void 0 ? void 0 : _e.error) {
                if (!deploymentError.subErrors) {
                    deploymentError.subErrors = {};
                }
                const name = (_g = (_f = operation.properties.targetResource) === null || _f === void 0 ? void 0 : _f.resourceName) !== null && _g !== void 0 ? _g : operation.id;
                deploymentError.subErrors[name] = {
                    error: operation.properties.statusMessage.error,
                };
                if (((_h = operation.properties.targetResource) === null || _h === void 0 ? void 0 : _h.resourceType) ===
                    constants_1.ConstantString.DeploymentResourceType &&
                    ((_j = operation.properties.targetResource) === null || _j === void 0 ? void 0 : _j.resourceName) &&
                    ((_k = operation.properties.targetResource) === null || _k === void 0 ? void 0 : _k.id)) {
                    const resourceGroupName = tools_1.getResourceGroupNameFromResourceId(operation.properties.targetResource.id);
                    const subError = await getDeploymentError(deployCtx, resourceGroupName, (_l = operation.properties.targetResource) === null || _l === void 0 ? void 0 : _l.resourceName);
                    if (subError) {
                        deploymentError.subErrors[name].inner = subError;
                    }
                }
            }
        }
        return deploymentError;
    }
    ArmErrorHandle.getDeploymentError = getDeploymentError;
    function formattedDeploymentError(deploymentError) {
        var _a, _b, _c;
        if (deploymentError.subErrors) {
            const result = {};
            for (const key in deploymentError.subErrors) {
                const subError = deploymentError.subErrors[key];
                if (subError.inner) {
                    result[key] = formattedDeploymentError(subError.inner);
                }
                else {
                    const needFilter = ((_b = (_a = subError.error) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.includes(filteredErrorMessage)) &&
                        ((_c = subError.error) === null || _c === void 0 ? void 0 : _c.code) === ErrorCodes.DeploymentOperationFailed;
                    if (!needFilter) {
                        result[key] = subError.error;
                    }
                }
            }
            return result;
        }
        else {
            return deploymentError.error;
        }
    }
    ArmErrorHandle.formattedDeploymentError = formattedDeploymentError;
})(ArmErrorHandle = exports.ArmErrorHandle || (exports.ArmErrorHandle = {}));
//# sourceMappingURL=handleError.js.map