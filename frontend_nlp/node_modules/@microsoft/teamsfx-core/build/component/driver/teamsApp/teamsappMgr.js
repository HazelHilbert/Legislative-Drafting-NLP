"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.teamsappMgr = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const util = tslib_1.__importStar(require("util"));
const localizeUtils_1 = require("../../../common/localizeUtils");
const tools_1 = require("../../../common/tools");
const common_1 = require("../../../error/common");
const lifecycle_1 = require("../../configManager/lifecycle");
const utils_1 = require("../../utils");
const envUtil_1 = require("../../utils/envUtil");
const pathUtils_1 = require("../../utils/pathUtils");
const configure_1 = require("./configure");
const constants_1 = require("./constants");
const createAppPackage_1 = require("./createAppPackage");
const publishAppPackage_1 = require("./publishAppPackage");
const ManifestUtils_1 = require("./utils/ManifestUtils");
class TeamsAppMgr {
    async ensureAppPackageFile(inputs) {
        // if no package file input, then do package first
        if (!inputs["package-file"]) {
            const packageRes = await this.packageTeamsApp(inputs);
            if (packageRes.isErr()) {
                return teamsfx_api_1.err(packageRes.error);
            }
            inputs["package-file"] = packageRes.value.outputZipPath;
        }
        if (!(await fs_extra_1.default.pathExists(inputs["package-file"]))) {
            return teamsfx_api_1.err(new common_1.FileNotFoundError("TeamsAppMgr", inputs["package-file"]));
        }
        return teamsfx_api_1.ok(undefined);
    }
    async readManifestFromZip(appPackagePath) {
        const archivedFile = await fs_extra_1.default.readFile(appPackagePath);
        const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
        const manifestFile = zipEntries.find((x) => x.entryName === constants_1.Constants.MANIFEST_FILE);
        if (manifestFile) {
            const manifestContent = manifestFile.getData().toString();
            const manifest = JSON.parse(manifestContent);
            return teamsfx_api_1.ok(manifest);
        }
        return teamsfx_api_1.err(new common_1.FileNotFoundError("TeamsAppMgr", appPackagePath + ":" + constants_1.Constants.MANIFEST_FILE));
    }
    async checkAndTryToLoadEnv(inputs) {
        //check placeholders in manifest file, if there are unresolved placeholders in manifest file, try to load env file
        const manifestFile = inputs["manifest-file"];
        const manifestString = await fs_extra_1.default.readFile(manifestFile, { encoding: "utf-8" });
        const unresolved = [];
        const resovled = [];
        lifecycle_1.resolveString(manifestString, resovled, unresolved);
        let env = undefined;
        if (unresolved.length > 0) {
            if (!inputs["env-file"]) {
                const envRes = await envUtil_1.envUtil.listEnv(inputs.projectPath);
                if (envRes.isErr()) {
                    return teamsfx_api_1.err(envRes.error);
                }
                const envs = envRes.value;
                const envFolderPathRes = await pathUtils_1.pathUtils.getEnvFolderPath(inputs.projectPath);
                if (envFolderPathRes.isErr()) {
                    return teamsfx_api_1.err(envFolderPathRes.error);
                }
                const envFolder = envFolderPathRes.value;
                if (!envFolder)
                    return teamsfx_api_1.ok(env);
                if (inputs.env) {
                    // env provided
                    if (envs.includes(inputs.env)) {
                        //env provided and found
                        inputs["env-file"] = path.join(envFolder, `.env.${inputs.env}`);
                        env = inputs.env;
                    }
                    else {
                        // env provided but not found
                        return teamsfx_api_1.err(new common_1.FileNotFoundError("TeamsAppMgr", path.join(envFolder, `.env.${inputs.env}`)));
                    }
                }
                else {
                    //env not provided
                    if (envs.length > 1) {
                        //need provide
                        return teamsfx_api_1.err(new common_1.MissingRequiredInputError("env", "TeamsAppMgr"));
                    }
                    else if (envs.length === 1) {
                        // no need provide
                        env = envs[0];
                        inputs["env-file"] = path.join(envFolder, `.env.${env}`);
                    }
                    else {
                        // no env file found
                    }
                }
            }
            if (inputs["env-file"]) {
                const res = await envUtil_1.envUtil.loadEnvFile(inputs["env-file"]);
                if (res.isErr()) {
                    return teamsfx_api_1.err(res.error);
                }
            }
        }
        return teamsfx_api_1.ok(env);
    }
    async packageTeamsApp(inputs) {
        if (!inputs["manifest-file"]) {
            const defaultManifestPath = ManifestUtils_1.manifestUtils.getTeamsAppManifestPath(inputs.projectPath);
            if (!(await fs_extra_1.default.pathExists(defaultManifestPath))) {
                return teamsfx_api_1.err(new common_1.MissingRequiredInputError("package-file/manifest-file", "TeamsAppMgr"));
            }
            inputs["manifest-file"] = defaultManifestPath;
        }
        else {
            if (!(await fs_extra_1.default.pathExists(inputs["manifest-file"]))) {
                return teamsfx_api_1.err(new common_1.FileNotFoundError("TeamsAppMgr", inputs["manifest-file"]));
            }
        }
        const loadEnvRes = await this.checkAndTryToLoadEnv(inputs);
        if (loadEnvRes.isErr())
            return teamsfx_api_1.err(loadEnvRes.error);
        const env = loadEnvRes.value;
        // reach here means manifes-file is provided and exists
        inputs["output-package-file"] =
            inputs["output-package-file"] ||
                path.join(inputs.projectPath, "appPackage", "build", env ? `appPackage.${env}.zip` : "appPackage.zip");
        inputs["output-manifest-file"] =
            inputs["output-manifest-file"] ||
                path.join(inputs.projectPath, "appPackage", "build", env ? `manifest.${env}.json` : "manifest.json");
        const packageArgs = {
            manifestPath: inputs["manifest-file"],
            outputZipPath: inputs["output-package-file"],
            outputJsonPath: inputs["output-manifest-file"],
        };
        const buildDriver = typedi_1.Container.get(createAppPackage_1.actionName);
        const driverContext = utils_1.createDriverContext(inputs);
        const res = (await buildDriver.execute(packageArgs, driverContext)).result;
        if (res.isErr()) {
            return teamsfx_api_1.err(res.error);
        }
        return teamsfx_api_1.ok(packageArgs);
    }
    /**
     * entry of validate teams app
     */
    async validateTeamsApp(inputs) {
        const context = utils_1.createDriverContext(inputs);
        if (!inputs["manifest-file"] && !inputs["package-file"]) {
            // neither manifest-file nor package-file provided, use default manifest file
            const defaultManifestPath = ManifestUtils_1.manifestUtils.getTeamsAppManifestPath(inputs.projectPath);
            if (!(await fs_extra_1.default.pathExists(defaultManifestPath))) {
                return teamsfx_api_1.err(new common_1.MissingRequiredInputError("package-file/manifest-file", "TeamsAppMgr"));
            }
            inputs["manifest-file"] = defaultManifestPath;
        }
        if (inputs["manifest-file"]) {
            const loadEnvRes = await this.checkAndTryToLoadEnv(inputs);
            if (loadEnvRes.isErr())
                return teamsfx_api_1.err(loadEnvRes.error);
            const teamsAppManifestFilePath = inputs["manifest-file"];
            const args = {
                manifestPath: teamsAppManifestFilePath,
                showMessage: (inputs === null || inputs === void 0 ? void 0 : inputs.showMessage) != undefined ? inputs.showMessage : true,
            };
            const driver = typedi_1.Container.get("teamsApp/validateManifest");
            const result = (await driver.execute(args, context)).result;
            if (result.isErr()) {
                return teamsfx_api_1.err(result.error);
            }
        }
        else if (inputs["package-file"]) {
            const teamsAppPackageFilePath = inputs["package-file"];
            const args = {
                appPackagePath: teamsAppPackageFilePath,
                showMessage: true,
            };
            const driver = typedi_1.Container.get("teamsApp/validateAppPackage");
            const result = (await driver.execute(args, context)).result;
            if (result.isErr()) {
                return teamsfx_api_1.err(result.error);
            }
        }
        return teamsfx_api_1.ok(undefined);
    }
    /**
     * entry of update teams app
     */
    async updateTeamsApp(inputs) {
        var _a;
        // 1. zip package if necessary
        const packageRes = await this.ensureAppPackageFile(inputs);
        if (packageRes.isErr()) {
            return teamsfx_api_1.err(packageRes.error);
        }
        const appPackageFile = inputs["package-file"];
        const driverContext = utils_1.createDriverContext(inputs);
        // 2. validate against app package
        const args = {
            appPackagePath: appPackageFile,
            showMessage: true,
        };
        const driver = typedi_1.Container.get("teamsApp/validateAppPackage");
        const validateRes = (await driver.execute(args, driverContext)).result;
        if (validateRes.isErr()) {
            return teamsfx_api_1.err(validateRes.error);
        }
        // 3. update app package
        const updateTeamsAppArgs = {
            appPackagePath: appPackageFile,
        };
        const configureDriver = typedi_1.Container.get(configure_1.actionName);
        const updateRes = (await configureDriver.execute(updateTeamsAppArgs, driverContext)).result;
        if (updateRes.isErr()) {
            return teamsfx_api_1.err(updateRes.error);
        }
        // 4. show result
        let loginHint = "";
        const accountRes = await driverContext.m365TokenProvider.getJsonObject({
            scopes: tools_1.AppStudioScopes,
        });
        if (accountRes.isOk()) {
            loginHint = accountRes.value.unique_name;
        }
        const manifestRes = await this.readManifestFromZip(appPackageFile);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        const manifest = manifestRes.value;
        const teamsAppId = manifest.id;
        const url = util.format(constants_1.Constants.DEVELOPER_PORTAL_APP_PACKAGE_URL, teamsAppId, loginHint);
        const message = [
            {
                content: localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedCLINotice"),
                color: teamsfx_api_1.Colors.BRIGHT_GREEN,
            },
            { content: url, color: teamsfx_api_1.Colors.BRIGHT_CYAN },
        ];
        void ((_a = driverContext.ui) === null || _a === void 0 ? void 0 : _a.showMessage("info", message, false));
        return teamsfx_api_1.ok(undefined);
    }
    async publishTeamsApp(inputs) {
        var _a;
        // 1. zip package if necessary
        const packageRes = await this.ensureAppPackageFile(inputs);
        if (packageRes.isErr()) {
            return teamsfx_api_1.err(packageRes.error);
        }
        const appPackageFile = inputs["package-file"];
        const driverContext = utils_1.createDriverContext(inputs);
        // 2. validate against app package
        const args = {
            appPackagePath: appPackageFile,
            showMessage: true,
        };
        const driver = typedi_1.Container.get("teamsApp/validateAppPackage");
        const validateRes = (await driver.execute(args, driverContext)).result;
        if (validateRes.isErr()) {
            return teamsfx_api_1.err(validateRes.error);
        }
        // 3. publish app package
        const publishArgs = {
            appPackagePath: appPackageFile,
        };
        const publishDriver = typedi_1.Container.get(publishAppPackage_1.actionName);
        const updateRes = (await publishDriver.execute(publishArgs, driverContext)).result;
        if (updateRes.isErr()) {
            return teamsfx_api_1.err(updateRes.error);
        }
        void ((_a = driverContext.ui) === null || _a === void 0 ? void 0 : _a.showMessage("info", `publish successfully, Go to admin portal: ${constants_1.Constants.TEAMS_ADMIN_PORTAL}`, false));
        return teamsfx_api_1.ok(undefined);
    }
}
exports.teamsappMgr = new TeamsAppMgr();
//# sourceMappingURL=teamsappMgr.js.map