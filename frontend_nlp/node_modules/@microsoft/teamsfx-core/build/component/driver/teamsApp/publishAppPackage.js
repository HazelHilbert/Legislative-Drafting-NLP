"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublishAppPackageDriver = exports.actionName = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const lodash_1 = require("lodash");
const lib_1 = require("@feathersjs/hooks/lib");
const wrapUtil_1 = require("../util/wrapUtil");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const appStudioClient_1 = require("./clients/appStudioClient");
const constants_1 = require("./constants");
const telemetry_1 = require("./utils/telemetry");
const telemetry_2 = require("./utils/telemetry");
const tools_1 = require("../../../common/tools");
const localizeUtils_1 = require("../../../common/localizeUtils");
const typedi_1 = require("typedi");
const common_1 = require("../../utils/common");
const common_2 = require("../../../error/common");
exports.actionName = "teamsApp/publishAppPackage";
const defaultOutputNames = {
    publishedAppId: "TEAMS_APP_PUBLISHED_APP_ID",
};
let PublishAppPackageDriver = class PublishAppPackageDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.teamsApp.description.publishDriver");
        this.progressTitle = localizeUtils_1.getLocalizedString("driver.teamsApp.progressBar.publishTeamsAppStep2.2");
    }
    async execute(args, context, outputEnvVarNames) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, exports.actionName, exports.actionName);
        const res = await this.publish(args, wrapContext, outputEnvVarNames);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async publish(args, context, outputEnvVarNames) {
        var _a, _b, _c;
        telemetry_1.TelemetryUtils.init(context);
        const argsValidationResult = this.validateArgs(args);
        if (argsValidationResult.isErr()) {
            return teamsfx_api_1.err(argsValidationResult.error);
        }
        if (!outputEnvVarNames) {
            outputEnvVarNames = new Map(Object.entries(defaultOutputNames));
        }
        const appPackagePath = common_1.getAbsolutePath(args.appPackagePath, context.projectPath);
        if (!(await fs_extra_1.default.pathExists(appPackagePath))) {
            return teamsfx_api_1.err(new common_2.FileNotFoundError(exports.actionName, appPackagePath, "https://aka.ms/teamsfx-actions/teamsapp-publish"));
        }
        const archivedFile = await fs_extra_1.default.readFile(appPackagePath);
        const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
        const manifestFile = zipEntries.find((x) => x.entryName === constants_1.Constants.MANIFEST_FILE);
        if (!manifestFile) {
            return teamsfx_api_1.err(new common_2.FileNotFoundError(exports.actionName, constants_1.Constants.MANIFEST_FILE, "https://aka.ms/teamsfx-actions/teamsapp-publish"));
        }
        const manifestString = manifestFile.getData().toString();
        const manifest = JSON.parse(manifestString);
        // manifest.id === externalID
        const appStudioTokenRes = await context.m365TokenProvider.getAccessToken({
            scopes: tools_1.AppStudioScopes,
        });
        if (appStudioTokenRes.isErr()) {
            return teamsfx_api_1.err(appStudioTokenRes.error);
        }
        let result;
        const message = localizeUtils_1.getLocalizedString("driver.teamsApp.progressBar.publishTeamsAppStep1");
        context.addSummary(message);
        try {
            const existApp = await appStudioClient_1.AppStudioClient.getAppByTeamsAppId(manifest.id, appStudioTokenRes.value);
            if (existApp) {
                context.addSummary(localizeUtils_1.getLocalizedString("driver.teamsApp.summary.publishTeamsAppExists", manifest.id));
                let executePublishUpdate = false;
                let description = localizeUtils_1.getLocalizedString("plugins.appstudio.pubWarn", existApp.displayName, existApp.publishingState);
                if (existApp.lastModifiedDateTime) {
                    description =
                        description +
                            localizeUtils_1.getLocalizedString("plugins.appstudio.lastModified", (_a = existApp.lastModifiedDateTime) === null || _a === void 0 ? void 0 : _a.toLocaleString());
                }
                description =
                    description + localizeUtils_1.getLocalizedString("plugins.appstudio.updatePublihsedAppConfirm");
                const confirm = localizeUtils_1.getLocalizedString("core.option.confirm");
                const res = await ((_b = context.ui) === null || _b === void 0 ? void 0 : _b.showMessage("warn", description, true, confirm));
                if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === confirm)
                    executePublishUpdate = true;
                if (executePublishUpdate) {
                    const message = localizeUtils_1.getLocalizedString("driver.teamsApp.progressBar.publishTeamsAppStep2.1");
                    context.addSummary(message);
                    context.logProvider.debug(message);
                    const appId = await appStudioClient_1.AppStudioClient.publishTeamsAppUpdate(manifest.id, archivedFile, appStudioTokenRes.value);
                    result = new Map([[outputEnvVarNames.get("publishedAppId"), appId]]);
                    lodash_1.merge(context.telemetryProperties, {
                        [telemetry_2.TelemetryPropertyKey.updateExistingApp]: "true",
                        [telemetry_2.TelemetryPropertyKey.publishedAppId]: appId,
                    });
                }
                else {
                    return teamsfx_api_1.err(new common_2.UserCancelError(exports.actionName));
                }
            }
            else {
                context.addSummary(localizeUtils_1.getLocalizedString("driver.teamsApp.summary.publishTeamsAppNotExists", manifest.id));
                const message = localizeUtils_1.getLocalizedString("driver.teamsApp.progressBar.publishTeamsAppStep2.2");
                context.addSummary(message);
                context.logProvider.debug(message);
                const appId = await appStudioClient_1.AppStudioClient.publishTeamsApp(manifest.id, archivedFile, appStudioTokenRes.value);
                result = new Map([[outputEnvVarNames.get("publishedAppId"), appId]]);
                lodash_1.merge(context.telemetryProperties, {
                    [telemetry_2.TelemetryPropertyKey.updateExistingApp]: "false",
                });
            }
        }
        catch (e) {
            return teamsfx_api_1.err(e);
        }
        context.logProvider.info(`Publish success!`);
        context.addSummary(localizeUtils_1.getLocalizedString("driver.teamsApp.summary.publishTeamsAppSuccess", manifest.id));
        if (context.platform === teamsfx_api_1.Platform.CLI) {
            const msg = localizeUtils_1.getLocalizedString("plugins.appstudio.publishSucceedNotice.cli", manifest.name.short, constants_1.Constants.TEAMS_ADMIN_PORTAL, constants_1.Constants.TEAMS_MANAGE_APP_DOC);
            (_c = context.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", msg, false);
        }
        return teamsfx_api_1.ok(result);
    }
    validateArgs(args) {
        const invalidParams = [];
        if (!args || !args.appPackagePath) {
            invalidParams.push("appPackagePath");
        }
        if (invalidParams.length > 0) {
            return teamsfx_api_1.err(new common_2.InvalidActionInputError(exports.actionName, invalidParams, "https://aka.ms/teamsfx-actions/teamsapp-publish"));
        }
        else {
            return teamsfx_api_1.ok(undefined);
        }
    }
};
tslib_1.__decorate([
    lib_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(exports.actionName, exports.actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext,
        Map]),
    tslib_1.__metadata("design:returntype", Promise)
], PublishAppPackageDriver.prototype, "publish", null);
PublishAppPackageDriver = tslib_1.__decorate([
    typedi_1.Service(exports.actionName)
], PublishAppPackageDriver);
exports.PublishAppPackageDriver = PublishAppPackageDriver;
//# sourceMappingURL=publishAppPackage.js.map