"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.M365TitleAcquireDriver = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const typedi_1 = require("typedi");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const localizeUtils_1 = require("../../../common/localizeUtils");
const packageService_1 = require("../../../common/m365/packageService");
const serviceConstant_1 = require("../../../common/m365/serviceConstant");
const common_1 = require("../../utils/common");
const constants_1 = require("../aad/utility/constants");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const common_2 = require("../../../error/common");
const common_3 = require("../../../error/common");
const actionName = "teamsApp/extendToM365";
const helpLink = "https://aka.ms/teamsfx-actions/teamsapp-extendToM365";
const outputKeys = {
    titleId: "titleId",
    appId: "appId",
};
let M365TitleAcquireDriver = class M365TitleAcquireDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.m365.acquire.description");
        this.progressTitle = localizeUtils_1.getLocalizedString("driver.m365.acquire.progress.message");
    }
    async run(args, context) {
        return common_1.wrapRun(async () => {
            const result = await this.handler(args, context);
            return result.output;
        }, actionName);
    }
    async execute(args, ctx, outputEnvVarNames) {
        let summaries = [];
        const outputResult = await common_1.wrapRun(async () => {
            const result = await this.handler(args, ctx, outputEnvVarNames);
            summaries = result.summaries;
            return result.output;
        }, actionName);
        return {
            result: outputResult,
            summaries,
        };
    }
    async handler(args, context, outputEnvVarNames) {
        var _a, _b, _c, _d;
        try {
            this.validateArgs(args);
            this.validateOutputEnvVarNames(outputEnvVarNames);
            const appPackagePath = common_1.getAbsolutePath(args.appPackagePath, context.projectPath);
            if (!(await fs.pathExists(appPackagePath))) {
                throw new common_2.FileNotFoundError(actionName, appPackagePath, helpLink);
            }
            // get sideloading service settings
            const sideloadingServiceEndpoint = (_a = process.env.SIDELOADING_SERVICE_ENDPOINT) !== null && _a !== void 0 ? _a : serviceConstant_1.serviceEndpoint;
            const sideloadingServiceScope = (_b = process.env.SIDELOADING_SERVICE_SCOPE) !== null && _b !== void 0 ? _b : serviceConstant_1.serviceScope;
            const packageService = new packageService_1.PackageService(sideloadingServiceEndpoint, context.logProvider);
            const sideloadingTokenRes = await context.m365TokenProvider.getAccessToken({
                scopes: [sideloadingServiceScope],
            });
            if (sideloadingTokenRes.isErr()) {
                throw sideloadingTokenRes.error;
            }
            const sideloadingToken = sideloadingTokenRes.value;
            const sideloadingRes = await packageService.sideLoading(sideloadingToken, appPackagePath);
            return {
                output: new Map([
                    [outputEnvVarNames.get(outputKeys.titleId), sideloadingRes[0]],
                    [outputEnvVarNames.get(outputKeys.appId), sideloadingRes[1]],
                ]),
                summaries: [localizeUtils_1.getLocalizedString("driver.m365.acquire.summary", sideloadingRes[0])],
            };
        }
        catch (error) {
            if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
                (_c = context.logProvider) === null || _c === void 0 ? void 0 : _c.error(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.failExecuteDriver, actionName, error.displayMessage));
                throw error;
            }
            const message = JSON.stringify(error);
            (_d = context.logProvider) === null || _d === void 0 ? void 0 : _d.error(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.failExecuteDriver, actionName, message));
            throw new common_3.UnhandledError(error, actionName);
        }
    }
    validateArgs(args) {
        const invalidParameters = [];
        if (!args.appPackagePath || typeof args.appPackagePath !== "string") {
            invalidParameters.push("appPackagePath");
        }
        if (invalidParameters.length > 0) {
            throw new common_2.InvalidActionInputError(actionName, invalidParameters, helpLink);
        }
    }
    validateOutputEnvVarNames(outputEnvVarNames) {
        if (!(outputEnvVarNames === null || outputEnvVarNames === void 0 ? void 0 : outputEnvVarNames.get(outputKeys.titleId)) || !outputEnvVarNames.get(outputKeys.appId)) {
            throw new common_2.InvalidActionInputError(actionName, ["writeToEnvironmentFile"], helpLink);
        }
    }
};
tslib_1.__decorate([
    lib_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], M365TitleAcquireDriver.prototype, "run", null);
tslib_1.__decorate([
    lib_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Map]),
    tslib_1.__metadata("design:returntype", Promise)
], M365TitleAcquireDriver.prototype, "execute", null);
M365TitleAcquireDriver = tslib_1.__decorate([
    typedi_1.Service(actionName) // DO NOT MODIFY the service name
], M365TitleAcquireDriver);
exports.M365TitleAcquireDriver = M365TitleAcquireDriver;
//# sourceMappingURL=acquire.js.map