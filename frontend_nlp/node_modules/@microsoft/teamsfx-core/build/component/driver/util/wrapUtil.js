"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapRun = exports.WrapDriverContext = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const localizeUtils_1 = require("../../../common/localizeUtils");
const constants_1 = require("../../constants");
const componentError_1 = require("../../error/componentError");
const teamsFxTelemetryReporter_1 = require("../../utils/teamsFxTelemetryReporter");
const constants_2 = require("../aad/utility/constants");
class WrapDriverContext {
    constructor(driverContext, eventName, componentName) {
        this.progressBars = [];
        this.summaries = [];
        Object.assign(this, driverContext, {});
        this.eventName = eventName;
        this.telemetryProperties = {
            component: componentName.replace(/\//g, ""), // Remove `/` in the componentName to avoid the value being redacted.
        };
        if (driverContext.telemetryReporter) {
            this.wrapTelemetryReporter = new teamsFxTelemetryReporter_1.TeamsFxTelemetryReporter(driverContext.telemetryReporter, {
                componentName,
            });
        }
    }
    async createProgressBar(title, steps) {
        var _a;
        const progressBar = (_a = this.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(title, steps);
        if (progressBar) {
            this.progressBars.push(progressBar);
            await progressBar.start();
            await progressBar.next();
        }
        return progressBar;
    }
    async endProgressBars(success) {
        await Promise.all(this.progressBars.map(async (progressbar) => {
            await progressbar.end(success);
        }));
    }
    addTelemetryProperties(properties) {
        this.telemetryProperties = Object.assign(Object.assign({}, properties), this.telemetryProperties);
    }
    addSummary(...summaries) {
        this.summaries.push(...summaries);
    }
}
exports.WrapDriverContext = WrapDriverContext;
async function wrapRun(context, exec, isExecute) {
    var _a, _b, _c, _d, _e;
    const eventName = context.eventName;
    try {
        let actionRes;
        (_a = context.wrapTelemetryReporter) === null || _a === void 0 ? void 0 : _a.sendStartEvent({ eventName });
        (_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.info(localizeUtils_1.getLocalizedString(constants_2.logMessageKeys.startExecuteDriver, eventName));
        const res = await exec();
        (_c = context.wrapTelemetryReporter) === null || _c === void 0 ? void 0 : _c.sendEndEvent({
            eventName,
            properties: context.telemetryProperties,
        });
        (_d = context.logProvider) === null || _d === void 0 ? void 0 : _d.info(localizeUtils_1.getLocalizedString(constants_2.logMessageKeys.successExecuteDriver, eventName));
        await context.endProgressBars(true);
        if (isExecute) {
            actionRes = { result: teamsfx_api_1.ok(res), summaries: context.summaries };
        }
        else {
            actionRes = teamsfx_api_1.ok(res);
        }
        return actionRes;
    }
    catch (error) {
        let actionRes;
        const fxError = getError(context, error);
        (_e = context.wrapTelemetryReporter) === null || _e === void 0 ? void 0 : _e.sendEndEvent({
            eventName,
            properties: context.telemetryProperties,
        }, fxError);
        await context.endProgressBars(false);
        if (isExecute) {
            actionRes = { result: teamsfx_api_1.err(fxError), summaries: context.summaries };
        }
        else {
            actionRes = teamsfx_api_1.err(fxError);
        }
        return actionRes;
    }
}
exports.wrapRun = wrapRun;
function getError(context, error) {
    let fxError;
    if (error instanceof componentError_1.BaseComponentInnerError) {
        fxError = error.toFxError();
    }
    else if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
        fxError = error;
    }
    else {
        if (!(error instanceof Error)) {
            error = new Error(error.toString());
        }
        fxError = new teamsfx_api_1.SystemError({
            error,
            source: context.eventName,
            name: constants_1.ErrorConstants.unhandledError,
            message: error.message,
            displayMessage: error.message,
        });
    }
    return fxError;
}
//# sourceMappingURL=wrapUtil.js.map