"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolsInstallDriverImpl = exports.ToolsInstallDriver = void 0;
const tslib_1 = require("tslib");
/**
 * @author Xiaofu Huang <xiaofhua@microsoft.com>
 */
const path = tslib_1.__importStar(require("path"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const typedi_1 = require("typedi");
const deps_checker_1 = require("../../../common/deps-checker");
const localCertificateManager_1 = require("../../../common/local/localCertificateManager");
const common_1 = require("../../utils/common");
const wrapUtil_1 = require("../util/wrapUtil");
const constant_1 = require("./constant");
const dotnetInstallationUserError_1 = require("./error/dotnetInstallationUserError");
const funcInstallationUserError_1 = require("./error/funcInstallationUserError");
const common_2 = require("../../../error/common");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const lib_1 = require("@feathersjs/hooks/lib");
const localizeUtils_1 = require("../../../common/localizeUtils");
const funcToolChecker_1 = require("../../../common/deps-checker/internal/funcToolChecker");
const dotnetChecker_1 = require("../../../common/deps-checker/internal/dotnetChecker");
const globalVars_1 = require("../../../core/globalVars");
const testToolChecker_1 = require("../../../common/deps-checker/internal/testToolChecker");
const testToolInstallationUserError_1 = require("./error/testToolInstallationUserError");
const ACTION_NAME = "devTool/install";
const helpLink = "https://aka.ms/teamsfx-actions/devtool-install";
const outputKeys = {
    sslCertFile: "sslCertFile",
    sslKeyFile: "sslKeyFile",
    funcPath: "funcPath",
    dotnetPath: "dotnetPath",
    testToolPath: "testToolPath",
};
let ToolsInstallDriver = class ToolsInstallDriver {
    constructor() {
        this.description = constant_1.toolsInstallDescription();
        this.progressTitle = localizeUtils_1.getLocalizedString("driver.prerequisite.progressBar");
    }
    async run(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, ACTION_NAME, ACTION_NAME);
        return await this._run(args, wrapContext);
    }
    async execute(args, context, outputEnvVarNames) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, ACTION_NAME, ACTION_NAME);
        const result = await this._run(args, wrapContext, outputEnvVarNames);
        return {
            result: result,
            summaries: wrapContext.summaries,
        };
    }
    async _run(args, wrapContext, outputEnvVarNames) {
        return common_1.wrapRun(async () => {
            const impl = new ToolsInstallDriverImpl(wrapContext);
            return await impl.run(args, outputEnvVarNames);
        }, ACTION_NAME);
    }
};
tslib_1.__decorate([
    lib_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(ACTION_NAME, ACTION_NAME)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext,
        Map]),
    tslib_1.__metadata("design:returntype", Promise)
], ToolsInstallDriver.prototype, "_run", null);
ToolsInstallDriver = tslib_1.__decorate([
    typedi_1.Service(ACTION_NAME)
], ToolsInstallDriver);
exports.ToolsInstallDriver = ToolsInstallDriver;
class ToolsInstallDriverImpl {
    constructor(context) {
        this.context = context;
    }
    async run(args, outputEnvVarNames) {
        const res = new Map();
        this.validateArgs(args);
        this.setArgTelemetry(args);
        if (args.devCert) {
            const localCertRes = await this.resolveLocalCertificate(args.devCert.trust, outputEnvVarNames);
            localCertRes.forEach((v, k) => res.set(k, v));
        }
        if (args.func) {
            const funcRes = await this.resolveFuncCoreTools(`${args.func.version}`, args.func.symlinkDir, outputEnvVarNames);
            funcRes.forEach((v, k) => res.set(k, v));
        }
        if (args.dotnet) {
            const dotnetRes = await this.resolveDotnet(outputEnvVarNames);
            dotnetRes.forEach((v, k) => res.set(k, v));
        }
        if (args.testTool) {
            await this.resolveTestTool(`${args.testTool.version}`, args.testTool.symlinkDir);
        }
        return res;
    }
    async resolveLocalCertificate(trustDevCert, outputEnvVarNames) {
        const res = new Map();
        // Do not print any log in LocalCertificateManager, use the error message returned instead.
        const certManager = new localCertificateManager_1.LocalCertificateManager(this.context.ui);
        const localCertResult = await certManager.setupCertificate(trustDevCert);
        this.context.logProvider.debug(`Dev cert result: ${JSON.stringify({
            cert: localCertResult.certPath,
            key: localCertResult.keyPath,
            alreadyTrusted: localCertResult.alreadyTrusted,
            isTrusted: localCertResult.isTrusted,
        })}`);
        if (trustDevCert) {
            let name = outputEnvVarNames === null || outputEnvVarNames === void 0 ? void 0 : outputEnvVarNames.get(outputKeys.sslCertFile);
            if (name) {
                res.set(name, localCertResult.certPath);
            }
            name = outputEnvVarNames === null || outputEnvVarNames === void 0 ? void 0 : outputEnvVarNames.get(outputKeys.sslKeyFile);
            if (name) {
                res.set(name, localCertResult.keyPath);
            }
        }
        this.setDevCertTelemetry(trustDevCert, localCertResult);
        if (typeof localCertResult.isTrusted === "undefined") {
            this.context.logProvider.warning(constant_1.Summaries.devCertSkipped());
            this.context.addSummary(constant_1.Summaries.devCertSkipped());
        }
        else if (localCertResult.isTrusted === false) {
            throw localCertResult.error;
        }
        else {
            this.context.addSummary(constant_1.Summaries.devCertSuccess(trustDevCert));
        }
        return res;
    }
    async resolveFuncCoreTools(version, symlinkDir, outputEnvVarNames) {
        var _a;
        const res = new Map();
        const funcToolChecker = new funcToolChecker_1.FuncToolChecker();
        const funcStatus = await funcToolChecker.resolve({
            version: version,
            symlinkDir: symlinkDir,
            projectPath: this.context.projectPath,
        });
        this.context.logProvider.debug(`Func tool result: ${JSON.stringify({
            isInstalled: funcStatus.isInstalled,
            version: funcStatus.details.installVersion,
            bin: funcStatus.details.binFolders,
            supportedVersions: funcStatus.details.supportedVersions,
        })}`);
        this.setDepsCheckTelemetry(constant_1.TelemetryProperties.funcStatus, funcStatus);
        if (!funcStatus.isInstalled && funcStatus.error) {
            throw new funcInstallationUserError_1.FuncInstallationUserError(ACTION_NAME, funcStatus.error, funcStatus.error.helpLink);
        }
        else if (funcStatus.error) {
            this.context.logProvider.warning(funcStatus.error.message);
            this.context.addSummary(constant_1.Summaries.funcSuccess(funcStatus.details.binFolders) + funcStatus.error.message);
        }
        else {
            this.context.addSummary(constant_1.Summaries.funcSuccess(funcStatus.details.binFolders));
        }
        if (((_a = funcStatus === null || funcStatus === void 0 ? void 0 : funcStatus.details) === null || _a === void 0 ? void 0 : _a.binFolders) !== undefined) {
            const funcBinFolder = funcStatus.details.binFolders.join(path.delimiter);
            const name = outputEnvVarNames === null || outputEnvVarNames === void 0 ? void 0 : outputEnvVarNames.get(outputKeys.funcPath);
            if (name) {
                res.set(name, funcBinFolder);
            }
        }
        return res;
    }
    async resolveDotnet(outputEnvVarNames) {
        var _a, _b, _c, _d, _e, _f, _g;
        const res = new Map();
        const dotnetChecker = new dotnetChecker_1.DotnetChecker(new deps_checker_1.EmptyLogger(), new deps_checker_1.EmptyTelemetry());
        const dotnetStatus = await dotnetChecker.resolve();
        this.context.logProvider.debug(`.NET result: ${JSON.stringify({
            isInstalled: dotnetStatus.isInstalled,
            version: (_a = dotnetStatus.details) === null || _a === void 0 ? void 0 : _a.installVersion,
            bin: (_b = dotnetStatus.details) === null || _b === void 0 ? void 0 : _b.binFolders,
            supportedVersions: (_c = dotnetStatus.details) === null || _c === void 0 ? void 0 : _c.supportedVersions,
        })}`);
        this.setDepsCheckTelemetry(constant_1.TelemetryProperties.dotnetStatus, dotnetStatus);
        if (!dotnetStatus.isInstalled && dotnetStatus.error) {
            throw new dotnetInstallationUserError_1.DotnetInstallationUserError(ACTION_NAME, dotnetStatus.error, dotnetStatus.error.helpLink);
        }
        else if (dotnetStatus.error) {
            this.context.logProvider.warning((_d = dotnetStatus.error) === null || _d === void 0 ? void 0 : _d.message);
            this.context.addSummary((_e = dotnetStatus.error) === null || _e === void 0 ? void 0 : _e.message);
        }
        else {
            this.context.addSummary(constant_1.Summaries.dotnetSuccess((_f = dotnetStatus === null || dotnetStatus === void 0 ? void 0 : dotnetStatus.details) === null || _f === void 0 ? void 0 : _f.binFolders));
        }
        if (((_g = dotnetStatus === null || dotnetStatus === void 0 ? void 0 : dotnetStatus.details) === null || _g === void 0 ? void 0 : _g.binFolders) !== undefined) {
            const dotnetBinFolder = `${dotnetStatus.details.binFolders
                .map((f) => path.dirname(f))
                .join(path.delimiter)}`;
            const name = outputEnvVarNames === null || outputEnvVarNames === void 0 ? void 0 : outputEnvVarNames.get(outputKeys.dotnetPath);
            if (name) {
                res.set(name, dotnetBinFolder);
            }
        }
        return res;
    }
    async resolveTestTool(versionRange, symlinkDir) {
        var _a;
        const checker = new testToolChecker_1.TestToolChecker();
        const projectPath = this.context.projectPath;
        const status = await checker.resolve({
            versionRange,
            symlinkDir,
            projectPath,
        });
        this.context.logProvider.debug(`Teams App Test Tool result: ${JSON.stringify({
            isInstalled: status.isInstalled,
            version: status.details.installVersion,
            bin: status.details.binFolders,
            supportedVersions: status.details.supportedVersions,
        })}`);
        this.setDepsCheckTelemetry(constant_1.TelemetryProperties.testToolStatus, status);
        if (!status.isInstalled) {
            throw new testToolInstallationUserError_1.TestToolInstallationUserError(ACTION_NAME, status.error, ((_a = status.error) === null || _a === void 0 ? void 0 : _a.helpLink) || deps_checker_1.v3DefaultHelpLink);
        }
        else {
            this.context.addSummary(constant_1.Summaries.testToolSuccess(status.details.binFolders));
        }
    }
    validateArgs(args) {
        var _a, _b, _c;
        if (!!args.devCert && typeof ((_a = args.devCert) === null || _a === void 0 ? void 0 : _a.trust) !== "boolean") {
            throw new common_2.InvalidActionInputError(ACTION_NAME, ["devCert.trust"], helpLink);
        }
        if (typeof args.func !== "undefined") {
            if (typeof args.func !== "object") {
                throw new common_2.InvalidActionInputError(ACTION_NAME, ["func"], helpLink);
            }
            if ((typeof args.func.version !== "string" && typeof args.func.version !== "number") ||
                !semver_1.default.validRange(`${(_b = args.func) === null || _b === void 0 ? void 0 : _b.version}`)) {
                throw new common_2.InvalidActionInputError(ACTION_NAME, ["func.version"], helpLink);
            }
            if (typeof args.func.symlinkDir !== "string" && typeof args.func.symlinkDir !== "undefined") {
                throw new common_2.InvalidActionInputError(ACTION_NAME, ["func.symlinkDir"], helpLink);
            }
        }
        if (!!args.dotnet && typeof args.dotnet !== "boolean") {
            throw new common_2.InvalidActionInputError(ACTION_NAME, ["dotnet"], helpLink);
        }
        if (typeof args.testTool !== "undefined") {
            if (typeof args.testTool !== "object") {
                throw new common_2.InvalidActionInputError(ACTION_NAME, ["testTool"], helpLink);
            }
            if (typeof args.testTool.version !== "string" ||
                !semver_1.default.validRange(`${(_c = args.testTool) === null || _c === void 0 ? void 0 : _c.version}`)) {
                throw new common_2.InvalidActionInputError(ACTION_NAME, ["testTool.version"], helpLink);
            }
            if (typeof args.testTool.symlinkDir !== "string") {
                throw new common_2.InvalidActionInputError(ACTION_NAME, ["testTool.symlinkDir"], helpLink);
            }
        }
    }
    setArgTelemetry(args) {
        var _a, _b, _c, _d;
        this.context.addTelemetryProperties({
            [constant_1.TelemetryProperties.driverArgs]: JSON.stringify({
                devCert: args.devCert,
                func: {
                    version: (_a = args.func) === null || _a === void 0 ? void 0 : _a.version,
                    symlinkDir: ((_b = args.func) === null || _b === void 0 ? void 0 : _b.symlinkDir)
                        ? path.resolve(args.func.symlinkDir) === path.resolve("./devTools/func")
                            ? "<default>"
                            : "<unknown>"
                        : "<undefined>",
                },
                dotnet: args.dotnet,
                testTool: {
                    version: (_c = args.testTool) === null || _c === void 0 ? void 0 : _c.version,
                    symlinkDir: ((_d = args.testTool) === null || _d === void 0 ? void 0 : _d.symlinkDir)
                        ? path.resolve(args.testTool.symlinkDir) === path.resolve("./devTools/testTool")
                            ? "<default>"
                            : "<unknown>"
                        : "<undefined>",
                },
            }),
        });
    }
    setDevCertTelemetry(trustDevCert, localCertResult) {
        this.context.addTelemetryProperties({
            [constant_1.TelemetryProperties.devCertStatus]: !trustDevCert
                ? constant_1.TelemetryDevCertStatus.Disabled
                : localCertResult.alreadyTrusted
                    ? constant_1.TelemetryDevCertStatus.AlreadyTrusted
                    : localCertResult.isTrusted
                        ? constant_1.TelemetryDevCertStatus.Trusted
                        : constant_1.TelemetryDevCertStatus.NotTrusted,
        });
    }
    setDepsCheckTelemetry(propertyName, depStatus) {
        this.context.addTelemetryProperties({
            [propertyName]: depStatus.isInstalled
                ? depStatus.error
                    ? constant_1.TelemetryDepsCheckStatus.warn
                    : constant_1.TelemetryDepsCheckStatus.success
                : constant_1.TelemetryDepsCheckStatus.failed,
        });
        if (depStatus.telemetryProperties) {
            this.context.addTelemetryProperties(depStatus.telemetryProperties);
        }
    }
}
tslib_1.__decorate([
    lib_1.hooks([globalVars_1.ErrorContextMW({ source: "DevTools", component: "ToolsInstallDriverImpl" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Map]),
    tslib_1.__metadata("design:returntype", Promise)
], ToolsInstallDriverImpl.prototype, "run", null);
exports.ToolsInstallDriverImpl = ToolsInstallDriverImpl;
//# sourceMappingURL=installDriver.js.map