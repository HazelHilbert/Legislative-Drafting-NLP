"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddWebPartDriver = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lib_1 = require("@feathersjs/hooks/lib");
const typedi_1 = require("typedi");
const wrapUtil_1 = require("../util/wrapUtil");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const ManifestUtils_1 = require("../teamsApp/utils/ManifestUtils");
const localizeUtils_1 = require("../../../common/localizeUtils");
const common_1 = require("../../utils/common");
const path_1 = tslib_1.__importDefault(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const util = tslib_1.__importStar(require("util"));
const constants_1 = require("../../generator/spfx/utils/constants");
const spfxGenerator_1 = require("../../generator/spfx/spfxGenerator");
const utils_1 = require("../../utils");
const constants_2 = require("./utility/constants");
const noConfigurationError_1 = require("./error/noConfigurationError");
const questionNames_1 = require("../../../question/questionNames");
let AddWebPartDriver = class AddWebPartDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.spfx.add.description");
    }
    async run(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, constants_2.Constants.ActionName, constants_2.Constants.ActionName);
        return common_1.wrapRun(() => this.add(args, wrapContext), constants_2.Constants.ActionName);
    }
    async execute(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, constants_2.Constants.ActionName, constants_2.Constants.ActionName);
        const res = await this.run(args, wrapContext);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async add(args, context) {
        var _a;
        const webpartName = args.webpartName;
        const framework = args.framework;
        const spfxFolder = args.spfxFolder;
        const manifestPath = args.manifestPath;
        const localManifestPath = args.localManifestPath;
        const spfxPackage = args.spfxPackage;
        const yorcPath = path_1.default.join(spfxFolder, constants_2.Constants.YO_RC_FILE);
        context.logProvider.verbose(`Checking configuration file under ${yorcPath}...`);
        if (!(await fs.pathExists(yorcPath))) {
            throw new noConfigurationError_1.NoConfigurationError();
        }
        context.logProvider.verbose(`Configuration file exists.`);
        const inputs = { platform: context.platform, stage: teamsfx_api_1.Stage.addWebpart };
        inputs[questionNames_1.QuestionNames.SPFxWebpartName] = webpartName;
        inputs[questionNames_1.QuestionNames.SPFxFramework] = framework;
        inputs[questionNames_1.QuestionNames.SPFxFolder] = spfxFolder;
        inputs[questionNames_1.QuestionNames.ManifestPath] = manifestPath;
        inputs[questionNames_1.QuestionNames.LocalTeamsAppManifestFilePath] = localManifestPath;
        inputs[questionNames_1.QuestionNames.SPFxInstallPackage] = spfxPackage;
        context.logProvider.verbose(`Adding web part with Yeoman generator...`);
        context.logProvider.debug(`SPFx web part name: ${webpartName}, SPFx folder: ${spfxFolder}, manifest path: ${manifestPath}, local manifest path: ${localManifestPath}`);
        const yeomanRes = await spfxGenerator_1.SPFxGenerator.doYeomanScaffold(utils_1.createContextV3(), inputs, context.projectPath);
        if (yeomanRes.isErr())
            throw yeomanRes.error;
        context.logProvider.verbose(`Succeeded to add web part '${webpartName}'.`);
        const componentId = yeomanRes.value;
        const remoteStaticSnippet = {
            entityId: componentId,
            name: webpartName,
            contentUrl: util.format(constants_2.Constants.REMOTE_CONTENT_URL, componentId),
            websiteUrl: constants_1.ManifestTemplate.WEBSITE_URL,
            scopes: ["personal"],
        };
        const localStaticSnippet = {
            entityId: componentId,
            name: webpartName,
            contentUrl: util.format(constants_2.Constants.LOCAL_CONTENT_URL, componentId),
            websiteUrl: constants_1.ManifestTemplate.WEBSITE_URL,
            scopes: ["personal"],
        };
        inputs["addManifestPath"] = localManifestPath;
        context.logProvider.verbose(`Exposing web part with component id ${componentId} to local manifest file under ${localManifestPath}...`);
        const localRes = await ManifestUtils_1.manifestUtils.addCapabilities(Object.assign(Object.assign({}, inputs), { projectPath: context.projectPath }), [{ name: "staticTab", snippet: localStaticSnippet }]);
        if (localRes.isErr())
            throw localRes.error;
        context.logProvider.verbose(`Succeeded to update local manifest file.`);
        inputs["addManifestPath"] = manifestPath;
        context.logProvider.verbose(`Exposing web part with component id ${componentId} to remote manifest file under ${manifestPath}...`);
        const remoteRes = await ManifestUtils_1.manifestUtils.addCapabilities(Object.assign(Object.assign({}, inputs), { projectPath: context.projectPath }), [{ name: "staticTab", snippet: remoteStaticSnippet }]);
        if (remoteRes.isErr())
            throw remoteRes.error;
        context.logProvider.verbose(`Succeeded to update remote manifest file.`);
        (_a = context.ui) === null || _a === void 0 ? void 0 : _a.showMessage("info", localizeUtils_1.getLocalizedString("driver.spfx.add.successNotice", webpartName), false);
        return new Map();
    }
};
tslib_1.__decorate([
    lib_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(constants_2.Constants.ActionName, constants_2.Constants.ActionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AddWebPartDriver.prototype, "run", null);
AddWebPartDriver = tslib_1.__decorate([
    typedi_1.Service(constants_2.Constants.ActionName)
], AddWebPartDriver);
exports.AddWebPartDriver = AddWebPartDriver;
//# sourceMappingURL=addWebPart.js.map