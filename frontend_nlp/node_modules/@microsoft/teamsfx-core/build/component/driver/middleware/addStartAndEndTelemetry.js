"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.addStartAndEndTelemetry = void 0;
const teamsFxTelemetryReporter_1 = require("../../utils/teamsFxTelemetryReporter");
const constants_1 = require("../../constants");
const perf_hooks_1 = require("perf_hooks");
// Based on fx-core's design that a component should always return FxError instead of throw exception, no error handling is added
// Will remove `/` in the componentName to avoid the value being redacted.
function addStartAndEndTelemetry(eventName, componentName) {
    return async (ctx, next) => {
        const driverContext = ctx.arguments[1];
        let telemetryReporter = undefined;
        if (driverContext.telemetryReporter) {
            const normalizedComponentName = componentName.replace(/\//g, ""); // Remove `/` in the componentName to avoid the value being redacted.
            telemetryReporter = new teamsFxTelemetryReporter_1.TeamsFxTelemetryReporter(driverContext.telemetryReporter, {
                componentName: normalizedComponentName,
            });
        }
        telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendStartEvent({ eventName });
        const startTime = perf_hooks_1.performance.now();
        await next();
        const timeCost = perf_hooks_1.performance.now() - startTime;
        let result;
        // support run and execution interface at the same time, can remove after we retire the run interface
        if (isExecutionResult(ctx.result)) {
            result = ctx.result.result;
        }
        else {
            result = ctx.result;
        }
        const telemetryConfig = {
            eventName: eventName,
            properties: driverContext.telemetryProperties,
            measurements: { [constants_1.TelemetryConstants.properties.timeCost]: timeCost },
        };
        if (result.isOk()) {
            telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendEndEvent(telemetryConfig);
        }
        else {
            telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendEndEvent(telemetryConfig, result.error);
        }
    };
}
exports.addStartAndEndTelemetry = addStartAndEndTelemetry;
function isExecutionResult(result) {
    return result.result !== undefined;
}
//# sourceMappingURL=addStartAndEndTelemetry.js.map