"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.coordinator = exports.TemplateNames = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const glob_1 = require("glob");
const jsonschema = tslib_1.__importStar(require("jsonschema"));
const lodash_1 = require("lodash");
const os_1 = require("os");
const path = tslib_1.__importStar(require("path"));
const uuid = tslib_1.__importStar(require("uuid"));
const xml2js = tslib_1.__importStar(require("xml2js"));
const localizeUtils_1 = require("../../common/localizeUtils");
const telemetry_1 = require("../../common/telemetry");
const tools_1 = require("../../common/tools");
const versionMetadata_1 = require("../../common/versionMetadata");
const error_1 = require("../../core/error");
const globalVars_1 = require("../../core/globalVars");
const azure_1 = require("../../error/azure");
const common_1 = require("../../error/common");
const yml_1 = require("../../error/yml");
const create_1 = require("../../question/create");
const questionNames_1 = require("../../question/questionNames");
const constants_1 = require("../constants");
const deployUtils_1 = require("../deployUtils");
const developerPortalScaffoldUtils_1 = require("../developerPortalScaffoldUtils");
const appStudio_1 = require("../driver/teamsApp/appStudio");
const constants_2 = require("../driver/teamsApp/constants");
const generator_1 = require("../generator/copilotPlugin/generator");
const generator_2 = require("../generator/generator");
const generator_3 = require("../generator/officeAddin/generator");
const spfxGenerator_1 = require("../generator/spfx/spfxGenerator");
const utils_1 = require("../generator/utils");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const provisionUtils_1 = require("../provisionUtils");
const ResourceGroupHelper_1 = require("../utils/ResourceGroupHelper");
const envUtil_1 = require("../utils/envUtil");
const metadataUtil_1 = require("../utils/metadataUtil");
const pathUtils_1 = require("../utils/pathUtils");
const settingsUtil_1 = require("../utils/settingsUtil");
const summary_1 = require("./summary");
const utils_2 = require("../../common/utils");
var TemplateNames;
(function (TemplateNames) {
    TemplateNames["Tab"] = "non-sso-tab";
    TemplateNames["SsoTab"] = "sso-tab";
    TemplateNames["M365Tab"] = "m365-tab";
    TemplateNames["DashboardTab"] = "dashboard-tab";
    TemplateNames["NotificationRestify"] = "notification-restify";
    TemplateNames["NotificationWebApi"] = "notification-webapi";
    TemplateNames["NotificationHttpTrigger"] = "notification-http-trigger";
    TemplateNames["NotificationTimerTrigger"] = "notification-timer-trigger";
    TemplateNames["NotificationHttpTimerTrigger"] = "notification-http-timer-trigger";
    TemplateNames["CommandAndResponse"] = "command-and-response";
    TemplateNames["Workflow"] = "workflow";
    TemplateNames["DefaultBot"] = "default-bot";
    TemplateNames["MessageExtension"] = "message-extension";
    TemplateNames["MessageExtensionAction"] = "message-extension-action";
    TemplateNames["MessageExtensionSearch"] = "message-extension-search";
    TemplateNames["MessageExtensionCopilot"] = "message-extension-copilot";
    TemplateNames["M365MessageExtension"] = "m365-message-extension";
    TemplateNames["TabAndDefaultBot"] = "non-sso-tab-default-bot";
    TemplateNames["BotAndMessageExtension"] = "default-bot-message-extension";
    TemplateNames["SsoTabObo"] = "sso-tab-with-obo-flow";
    TemplateNames["LinkUnfurling"] = "link-unfurling";
    TemplateNames["CopilotPluginFromScratch"] = "copilot-plugin-from-scratch";
    TemplateNames["AIBot"] = "ai-bot";
    TemplateNames["AIAssistantBot"] = "ai-assistant-bot";
})(TemplateNames = exports.TemplateNames || (exports.TemplateNames = {}));
const Feature2TemplateName = {
    [`${create_1.CapabilityOptions.notificationBot().id}:${create_1.NotificationTriggerOptions.appService().id}`]: TemplateNames.NotificationRestify,
    [`${create_1.CapabilityOptions.notificationBot().id}:${create_1.NotificationTriggerOptions.appServiceForVS().id}`]: TemplateNames.NotificationWebApi,
    [`${create_1.CapabilityOptions.notificationBot().id}:${create_1.NotificationTriggerOptions.functionsHttpTrigger().id}`]: TemplateNames.NotificationHttpTrigger,
    [`${create_1.CapabilityOptions.notificationBot().id}:${create_1.NotificationTriggerOptions.functionsTimerTrigger().id}`]: TemplateNames.NotificationTimerTrigger,
    [`${create_1.CapabilityOptions.notificationBot().id}:${create_1.NotificationTriggerOptions.functionsHttpAndTimerTrigger().id}`]: TemplateNames.NotificationHttpTimerTrigger,
    [`${create_1.CapabilityOptions.commandBot().id}:undefined`]: TemplateNames.CommandAndResponse,
    [`${create_1.CapabilityOptions.workflowBot().id}:undefined`]: TemplateNames.Workflow,
    [`${create_1.CapabilityOptions.basicBot().id}:undefined`]: TemplateNames.DefaultBot,
    [`${create_1.CapabilityOptions.collectFormMe().id}:undefined`]: TemplateNames.MessageExtensionAction,
    [`${create_1.CapabilityOptions.me().id}:undefined`]: TemplateNames.MessageExtension,
    [`${create_1.CapabilityOptions.m365SearchMe().id}:undefined:${create_1.MeArchitectureOptions.botMe().id}`]: TemplateNames.M365MessageExtension,
    [`${create_1.CapabilityOptions.m365SearchMe().id}:undefined:${create_1.MeArchitectureOptions.botPlugin().id}`]: TemplateNames.MessageExtensionCopilot,
    [`${create_1.CapabilityOptions.SearchMe().id}:undefined`]: TemplateNames.MessageExtensionSearch,
    [`${create_1.CapabilityOptions.tab().id}:undefined`]: TemplateNames.SsoTab,
    [`${create_1.CapabilityOptions.nonSsoTab().id}:undefined`]: TemplateNames.Tab,
    [`${create_1.CapabilityOptions.m365SsoLaunchPage().id}:undefined`]: TemplateNames.SsoTabObo,
    [`${create_1.CapabilityOptions.dashboardTab().id}:undefined`]: TemplateNames.DashboardTab,
    [`${create_1.CapabilityOptions.nonSsoTabAndBot().id}:undefined`]: TemplateNames.TabAndDefaultBot,
    [`${create_1.CapabilityOptions.botAndMe().id}:undefined`]: TemplateNames.BotAndMessageExtension,
    [`${create_1.CapabilityOptions.linkUnfurling().id}:undefined`]: TemplateNames.LinkUnfurling,
    [`${create_1.CapabilityOptions.copilotPluginNewApi().id}:undefined`]: TemplateNames.CopilotPluginFromScratch,
    [`${create_1.CapabilityOptions.m365SearchMe().id}:undefined:${create_1.MeArchitectureOptions.newApi().id}`]: TemplateNames.CopilotPluginFromScratch,
    [`${create_1.CapabilityOptions.aiBot().id}:undefined`]: TemplateNames.AIBot,
    [`${create_1.CapabilityOptions.aiAssistantBot().id}:undefined`]: TemplateNames.AIAssistantBot,
};
const M365Actions = [
    "botAadApp/create",
    "teamsApp/create",
    "teamsApp/update",
    "aadApp/create",
    "aadApp/update",
    "botFramework/create",
    "teamsApp/extendToM365",
];
const AzureActions = ["arm/deploy"];
const AzureDeployActions = [
    "azureAppService/zipDeploy",
    "azureFunctions/zipDeploy",
    "azureStorage/deploy",
];
const needTenantCheckActions = ["botAadApp/create", "aadApp/create", "botFramework/create"];
class Coordinator {
    async create(context, inputs, actionContext) {
        let folder = inputs["folder"];
        if (!folder) {
            return teamsfx_api_1.err(new common_1.MissingRequiredInputError("folder"));
        }
        folder = path.resolve(folder);
        const scratch = inputs[questionNames_1.QuestionNames.Scratch];
        let projectPath = "";
        let warnings = undefined;
        if (scratch === create_1.ScratchOptions.no().id) {
            // create from sample
            const sampleId = inputs[questionNames_1.QuestionNames.Samples];
            if (!sampleId) {
                throw new common_1.MissingRequiredInputError(questionNames_1.QuestionNames.Samples);
            }
            projectPath = path.join(folder, sampleId);
            let suffix = 1;
            while ((await fs_extra_1.default.pathExists(projectPath)) && (await fs_extra_1.default.readdir(projectPath)).length > 0) {
                projectPath = path.join(folder, `${sampleId}_${suffix++}`);
            }
            inputs.projectPath = projectPath;
            await fs_extra_1.default.ensureDir(projectPath);
            const res = await generator_2.Generator.generateSample(context, projectPath, sampleId);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            downloadSampleHook(sampleId, projectPath);
        }
        else if (!scratch || scratch === create_1.ScratchOptions.yes().id) {
            // create from new
            const appName = inputs[questionNames_1.QuestionNames.AppName];
            if (undefined === appName)
                return teamsfx_api_1.err(new common_1.MissingRequiredInputError(questionNames_1.QuestionNames.AppName));
            const validateResult = jsonschema.validate(appName, {
                pattern: create_1.AppNamePattern,
            });
            if (validateResult.errors && validateResult.errors.length > 0) {
                return teamsfx_api_1.err(new common_1.InputValidationError(questionNames_1.QuestionNames.AppName, validateResult.errors[0].message));
            }
            projectPath = path.join(folder, appName);
            inputs.projectPath = projectPath;
            await fs_extra_1.default.ensureDir(projectPath);
            // set isVS global var when creating project
            const language = inputs[questionNames_1.QuestionNames.ProgrammingLanguage];
            globalVars_1.globalVars.isVS = language === "csharp";
            const capability = inputs.capabilities;
            const meArchitecture = inputs[questionNames_1.QuestionNames.MeArchitectureType];
            delete inputs.folder;
            lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
                [telemetry_1.TelemetryProperty.Capabilities]: capability,
                [telemetry_1.TelemetryProperty.IsFromTdp]: (!!inputs.teamsAppFromTdp).toString(),
            });
            if (capability === create_1.CapabilityOptions.SPFxTab().id) {
                const res = await spfxGenerator_1.SPFxGenerator.generate(context, inputs, projectPath);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
            }
            else if (inputs[questionNames_1.QuestionNames.ProjectType] === create_1.ProjectTypeOptions.outlookAddin().id) {
                const res = await generator_3.OfficeAddinGenerator.generate(context, inputs, projectPath);
                if (res.isErr()) {
                    return teamsfx_api_1.err(res.error);
                }
            }
            else if (capability === create_1.CapabilityOptions.copilotPluginApiSpec().id ||
                meArchitecture === create_1.MeArchitectureOptions.apiSpec().id) {
                const res = await generator_1.CopilotPluginGenerator.generateFromApiSpec(context, inputs, projectPath);
                if (res.isErr()) {
                    return teamsfx_api_1.err(res.error);
                }
                else {
                    warnings = res.value.warnings;
                }
            }
            else if (capability === create_1.CapabilityOptions.copilotPluginOpenAIPlugin().id) {
                const res = await generator_1.CopilotPluginGenerator.generateFromOpenAIPlugin(context, inputs, projectPath);
                if (res.isErr()) {
                    return teamsfx_api_1.err(res.error);
                }
                else {
                    warnings = res.value.warnings;
                }
            }
            else {
                if (capability === create_1.CapabilityOptions.m365SsoLaunchPage().id ||
                    capability === create_1.CapabilityOptions.m365SearchMe().id) {
                    inputs.isM365 = true;
                }
                const trigger = inputs[questionNames_1.QuestionNames.BotTrigger];
                let feature = `${capability}:${trigger}`;
                if (meArchitecture) {
                    feature = `${feature}:${meArchitecture}`;
                }
                const templateName = Feature2TemplateName[feature];
                if (templateName) {
                    const langKey = utils_1.convertToLangKey(language);
                    const safeProjectNameFromVS = language === "csharp" ? inputs[questionNames_1.QuestionNames.SafeProjectName] : undefined;
                    context.templateVariables = generator_2.Generator.getDefaultVariables(appName, safeProjectNameFromVS);
                    const res = await generator_2.Generator.generateTemplate(context, projectPath, templateName, langKey);
                    if (res.isErr())
                        return teamsfx_api_1.err(res.error);
                }
                else {
                    return teamsfx_api_1.err(new common_1.MissingRequiredInputError(questionNames_1.QuestionNames.Capabilities, "coordinator"));
                }
            }
        }
        // generate unique projectId in teamsapp.yaml (optional)
        const ymlPath = path.join(projectPath, versionMetadata_1.MetadataV3.configFile);
        if (fs_extra_1.default.pathExistsSync(ymlPath)) {
            const ensureRes = await this.ensureTrackingId(projectPath, inputs.projectId);
            if (ensureRes.isErr())
                return teamsfx_api_1.err(ensureRes.error);
            inputs.projectId = ensureRes.value;
        }
        context.projectPath = projectPath;
        if (inputs.teamsAppFromTdp) {
            const res = await developerPortalScaffoldUtils_1.developerPortalScaffoldUtils.updateFilesForTdp(context, inputs.teamsAppFromTdp, inputs);
            if (res.isErr()) {
                return teamsfx_api_1.err(res.error);
            }
        }
        return teamsfx_api_1.ok({ projectPath: projectPath, warnings });
    }
    async ensureTeamsFxInCsproj(projectPath) {
        const list = await fs_extra_1.default.readdir(projectPath);
        const csprojFiles = list.filter((fileName) => fileName.endsWith(".csproj"));
        if (csprojFiles.length === 0)
            return teamsfx_api_1.ok(undefined);
        const filePath = csprojFiles[0];
        const xmlStringOld = (await fs_extra_1.default.readFile(filePath, { encoding: "utf8" })).toString();
        const jsonObj = await xml2js.parseStringPromise(xmlStringOld);
        let ItemGroup = jsonObj.Project.ItemGroup;
        if (!ItemGroup) {
            ItemGroup = [];
            jsonObj.Project.ItemGroup = ItemGroup;
        }
        const existItems = ItemGroup.filter((item) => {
            var _a;
            if (item.ProjectCapability && item.ProjectCapability[0])
                if (((_a = item.ProjectCapability[0]["$"]) === null || _a === void 0 ? void 0 : _a.Include) === "TeamsFx")
                    return true;
            return false;
        });
        if (existItems.length === 0) {
            const toAdd = {
                ProjectCapability: [
                    {
                        $: {
                            Include: "TeamsFx",
                        },
                    },
                ],
            };
            ItemGroup.push(toAdd);
            const builder = new xml2js.Builder();
            const xmlStringNew = builder.buildObject(jsonObj);
            await fs_extra_1.default.writeFile(filePath, xmlStringNew, { encoding: "utf8" });
        }
        return teamsfx_api_1.ok(undefined);
    }
    async ensureTrackingId(projectPath, trackingId = undefined) {
        // generate unique trackingId in settings.json
        const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath, false);
        if (settingsRes.isErr())
            return teamsfx_api_1.err(settingsRes.error);
        const settings = settingsRes.value;
        if (settings.trackingId && !trackingId)
            return teamsfx_api_1.ok(settings.trackingId); // do nothing
        settings.trackingId = trackingId || uuid.v4();
        await settingsUtil_1.settingsUtil.writeSettings(projectPath, settings);
        return teamsfx_api_1.ok(settings.trackingId);
    }
    async preProvisionForVS(ctx, inputs) {
        const res = {
            needAzureLogin: false,
            needM365Login: false,
        };
        // 1. parse yml to cycles
        const templatePath = inputs["workflowFilePath"] || pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath, inputs.env);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const cycles = [
            projectModel.registerApp,
            projectModel.provision,
            projectModel.configureApp,
        ].filter((c) => c !== undefined);
        // 2. check each cycle
        for (const cycle of cycles) {
            const unresolvedPlaceholders = cycle.resolvePlaceholders();
            let firstArmDriver;
            for (const driver of cycle.driverDefs) {
                if (AzureActions.includes(driver.uses)) {
                    res.needAzureLogin = true;
                    if (!firstArmDriver) {
                        firstArmDriver = driver;
                    }
                }
                if (M365Actions.includes(driver.uses)) {
                    res.needM365Login = true;
                }
            }
            if (firstArmDriver) {
                const withObj = firstArmDriver.with;
                res.resolvedAzureSubscriptionId = unresolvedPlaceholders.includes("AZURE_SUBSCRIPTION_ID")
                    ? undefined
                    : withObj["subscriptionId"];
                res.resolvedAzureResourceGroupName = unresolvedPlaceholders.includes("AZURE_RESOURCE_GROUP_NAME")
                    ? undefined
                    : withObj["resourceGroupName"];
            }
        }
        return teamsfx_api_1.ok(res);
    }
    async preCheckYmlAndEnvForVS(ctx, inputs) {
        const templatePath = inputs["workflowFilePath"] || pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath, inputs.env);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const cycles = [projectModel.provision].filter((c) => c !== undefined);
        let unresolvedPlaceholders = [];
        // 2. check each cycle
        for (const cycle of cycles) {
            unresolvedPlaceholders = unresolvedPlaceholders.concat(cycle.resolvePlaceholders());
        }
        if (unresolvedPlaceholders.length > 0) {
            return teamsfx_api_1.err(new yml_1.LifeCycleUndefinedError(unresolvedPlaceholders.join(",")));
        }
        return teamsfx_api_1.ok(undefined);
    }
    async provision(ctx, inputs) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const output = {};
        if (process.env.APP_NAME_SUFFIX === undefined && process.env.TEAMSFX_ENV) {
            process.env.APP_NAME_SUFFIX = process.env.TEAMSFX_ENV;
            output.APP_NAME_SUFFIX = process.env.TEAMSFX_ENV;
        }
        const folderName = path.parse(ctx.projectPath).name;
        // 1. parse yml
        const templatePath = inputs["workflowFilePath"] || pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath, inputs.env);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const cycles = [
            // projectModel.registerApp,
            projectModel.provision,
            // projectModel.configureApp,
        ].filter((c) => c !== undefined);
        if (cycles.length === 0) {
            return teamsfx_api_1.err(new yml_1.LifeCycleUndefinedError("provision"));
        }
        // 2. M365 sign in and tenant check if needed.
        let containsM365 = false;
        let containsAzure = false;
        const tenantSwitchCheckActions = [];
        cycles.forEach((cycle) => {
            var _a;
            (_a = cycle.driverDefs) === null || _a === void 0 ? void 0 : _a.forEach((def) => {
                if (M365Actions.includes(def.uses)) {
                    containsM365 = true;
                }
                else if (AzureActions.includes(def.uses)) {
                    containsAzure = true;
                }
                if (needTenantCheckActions.includes(def.uses)) {
                    tenantSwitchCheckActions.push(def.uses);
                }
            });
        });
        let m365tenantInfo = undefined;
        if (containsM365) {
            const tenantInfoInTokenRes = await provisionUtils_1.provisionUtils.getM365TenantId(ctx.m365TokenProvider);
            if (tenantInfoInTokenRes.isErr()) {
                return teamsfx_api_1.err(tenantInfoInTokenRes.error);
            }
            m365tenantInfo = tenantInfoInTokenRes.value;
            const checkM365TenatRes = provisionUtils_1.provisionUtils.ensureM365TenantMatchesV3(tenantSwitchCheckActions, m365tenantInfo === null || m365tenantInfo === void 0 ? void 0 : m365tenantInfo.tenantIdInToken);
            if (checkM365TenatRes.isErr()) {
                return teamsfx_api_1.err(checkM365TenatRes.error);
            }
        }
        // We will update targetResourceGroupInfo if creating resource group is needed and create the resource group later after confirming with the user
        let targetResourceGroupInfo = {
            createNewResourceGroup: false,
            name: "",
            location: "",
        };
        let resolvedSubscriptionId;
        let resolvedResourceGroupName;
        let azureSubInfo = undefined;
        if (containsAzure) {
            //ensure RESOURCE_SUFFIX
            if (!process.env.RESOURCE_SUFFIX) {
                const suffix = process.env.RESOURCE_SUFFIX || uuid.v4().slice(0, 6);
                process.env.RESOURCE_SUFFIX = suffix;
                output.RESOURCE_SUFFIX = suffix;
            }
            // check whether placeholders are resolved
            let subscriptionUnresolved = false;
            let resourceGroupUnresolved = false;
            for (const cycle of cycles) {
                const unresolvedPlaceHolders = cycle.resolvePlaceholders();
                if (unresolvedPlaceHolders.includes("AZURE_SUBSCRIPTION_ID"))
                    subscriptionUnresolved = true;
                else {
                    (_a = cycle.driverDefs) === null || _a === void 0 ? void 0 : _a.forEach((driver) => {
                        const withObj = driver.with;
                        if (withObj && withObj.subscriptionId && resolvedSubscriptionId === undefined)
                            resolvedSubscriptionId = withObj.subscriptionId;
                    });
                }
                if (unresolvedPlaceHolders.includes("AZURE_RESOURCE_GROUP_NAME"))
                    resourceGroupUnresolved = true;
                else {
                    (_b = cycle.driverDefs) === null || _b === void 0 ? void 0 : _b.forEach((driver) => {
                        const withObj = driver.with;
                        if (withObj && withObj.resourceGroupName && resolvedResourceGroupName === undefined)
                            resolvedResourceGroupName = withObj.resourceGroupName;
                    });
                }
            }
            // ensure subscription, pop up UI to select if necessary
            if (subscriptionUnresolved) {
                if (inputs["targetSubscriptionId"]) {
                    process.env.AZURE_SUBSCRIPTION_ID = inputs["targetSubscriptionId"];
                    output.AZURE_SUBSCRIPTION_ID = inputs["targetSubscriptionId"];
                }
                else {
                    const ensureRes = await provisionUtils_1.provisionUtils.ensureSubscription(ctx.azureAccountProvider, undefined);
                    if (ensureRes.isErr())
                        return teamsfx_api_1.err(ensureRes.error);
                    const subInfo = ensureRes.value;
                    if (subInfo && subInfo.subscriptionId) {
                        process.env.AZURE_SUBSCRIPTION_ID = subInfo.subscriptionId;
                        output.AZURE_SUBSCRIPTION_ID = subInfo.subscriptionId;
                    }
                }
                resolvedSubscriptionId = process.env.AZURE_SUBSCRIPTION_ID;
            }
            // ensure resource group
            if (resourceGroupUnresolved) {
                const inputRG = inputs["targetResourceGroupName"];
                const inputLocation = inputs["targetResourceLocationName"];
                if (inputRG && inputLocation) {
                    // targetResourceGroupName is from VS inputs, which means create resource group if not exists
                    targetResourceGroupInfo.name = inputRG;
                    targetResourceGroupInfo.location = inputLocation;
                    targetResourceGroupInfo.createNewResourceGroup = true; // create resource group if not exists
                }
                else {
                    const defaultRg = `rg-${utils_2.convertToAlphanumericOnly(folderName)}${process.env.RESOURCE_SUFFIX}-${inputs.env}`;
                    const ensureRes = await provisionUtils_1.provisionUtils.ensureResourceGroup(inputs, ctx.azureAccountProvider, resolvedSubscriptionId, undefined, defaultRg);
                    if (ensureRes.isErr())
                        return teamsfx_api_1.err(ensureRes.error);
                    targetResourceGroupInfo = ensureRes.value;
                    if (!targetResourceGroupInfo.createNewResourceGroup) {
                        process.env.AZURE_RESOURCE_GROUP_NAME = targetResourceGroupInfo.name;
                        output.AZURE_RESOURCE_GROUP_NAME = targetResourceGroupInfo.name;
                    }
                }
                resolvedResourceGroupName = targetResourceGroupInfo.name;
            }
            // consent user
            await ctx.azureAccountProvider.getIdentityCredentialAsync(true); // make sure login if ensureSubScription() is not called.
            try {
                await ctx.azureAccountProvider.setSubscription(resolvedSubscriptionId); //make sure sub is correctly set if ensureSubscription() is not called.
            }
            catch (e) {
                return teamsfx_api_1.err(common_1.assembleError(e));
            }
            azureSubInfo = await ctx.azureAccountProvider.getSelectedSubscription(false);
            if (!azureSubInfo) {
                return teamsfx_api_1.err(new azure_1.SelectSubscriptionError());
            }
            const consentRes = await provisionUtils_1.provisionUtils.askForProvisionConsentV3(ctx, m365tenantInfo, azureSubInfo, inputs.env);
            if (consentRes.isErr())
                return teamsfx_api_1.err(consentRes.error);
            // create resource group if necessary
            if (targetResourceGroupInfo.createNewResourceGroup) {
                const createRgRes = await ResourceGroupHelper_1.resourceGroupHelper.createNewResourceGroup(targetResourceGroupInfo.name, ctx.azureAccountProvider, resolvedSubscriptionId, targetResourceGroupInfo.location);
                if (createRgRes.isErr()) {
                    const error = createRgRes.error;
                    if (!(error instanceof azure_1.ResourceGroupConflictError)) {
                        return teamsfx_api_1.err(error);
                    }
                }
                process.env.AZURE_RESOURCE_GROUP_NAME = targetResourceGroupInfo.name;
                output.AZURE_RESOURCE_GROUP_NAME = targetResourceGroupInfo.name;
            }
        }
        // execute
        const summaryReporter = new summary_1.SummaryReporter(cycles, ctx.logProvider);
        const steps = cycles.reduce((acc, cur) => acc + cur.driverDefs.length, 0);
        let hasError = false;
        try {
            ctx.progressBar = (_c = ctx.ui) === null || _c === void 0 ? void 0 : _c.createProgressBar(localizeUtils_1.getLocalizedString("core.progress.provision"), steps);
            await ((_d = ctx.progressBar) === null || _d === void 0 ? void 0 : _d.start());
            const maybeDescription = summaryReporter.getLifecycleDescriptions();
            if (maybeDescription.isErr()) {
                hasError = true;
                return teamsfx_api_1.err(maybeDescription.error);
            }
            ctx.logProvider.info(`Executing provision ${os_1.EOL}${os_1.EOL}${maybeDescription.value}${os_1.EOL}`);
            for (const [index, cycle] of cycles.entries()) {
                const execRes = await cycle.execute(ctx);
                summaryReporter.updateLifecycleState(index, execRes);
                const result = this.convertExecuteResult(execRes.result, templatePath);
                lodash_1.merge(output, result[0]);
                if (result[1]) {
                    hasError = true;
                    inputs.envVars = output;
                    return teamsfx_api_1.err(result[1]);
                }
            }
        }
        finally {
            const summary = summaryReporter.getLifecycleSummary(inputs.createdEnvFile);
            ctx.logProvider.info(`Execution summary:${os_1.EOL}${os_1.EOL}${summary}${os_1.EOL}`);
            await ((_e = ctx.progressBar) === null || _e === void 0 ? void 0 : _e.end(!hasError));
        }
        // show provisioned resources
        const msg = localizeUtils_1.getLocalizedString("core.common.LifecycleComplete.provision", steps, steps);
        if (azureSubInfo) {
            const url = tools_1.getResourceGroupInPortal(azureSubInfo.subscriptionId, azureSubInfo.tenantId, resolvedResourceGroupName);
            if (url && ctx.platform !== teamsfx_api_1.Platform.CLI) {
                const title = localizeUtils_1.getLocalizedString("core.provision.viewResources");
                (_f = ctx.ui) === null || _f === void 0 ? void 0 : _f.showMessage("info", msg, false, title).then((result) => {
                    var _a;
                    const userSelected = result.isOk() ? result.value : undefined;
                    if (userSelected === title) {
                        (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.openUrl(url);
                    }
                });
            }
            else {
                if (url && ctx.platform === teamsfx_api_1.Platform.CLI) {
                    (_g = ctx.ui) === null || _g === void 0 ? void 0 : _g.showMessage("info", [
                        {
                            content: `${msg} View the provisioned resources from `,
                            color: teamsfx_api_1.Colors.BRIGHT_GREEN,
                        },
                        {
                            content: url,
                            color: teamsfx_api_1.Colors.BRIGHT_CYAN,
                        },
                    ], false);
                }
                else {
                    (_h = ctx.ui) === null || _h === void 0 ? void 0 : _h.showMessage("info", msg, false);
                }
            }
        }
        else {
            if (ctx.platform === teamsfx_api_1.Platform.VS) {
                void ctx.ui.showMessage("info", localizeUtils_1.getLocalizedString("core.common.LifecycleComplete.prepareTeamsApp"), false);
            }
            else {
                void ctx.ui.showMessage("info", msg, false);
            }
        }
        ctx.logProvider.info(msg);
        return teamsfx_api_1.ok(output);
    }
    convertExecuteResult(execRes, templatePath) {
        var _a;
        const output = {};
        let error = undefined;
        if (execRes.isErr()) {
            const execError = execRes.error;
            if (execError.kind === "Failure") {
                error = execError.error;
            }
            else {
                const partialOutput = execError.env;
                const newOutput = envUtil_1.envUtil.map2object(partialOutput);
                lodash_1.merge(output, newOutput);
                const reason = execError.reason;
                if (reason.kind === "DriverError") {
                    error = reason.error;
                }
                else if (reason.kind === "UnresolvedPlaceholders") {
                    const placeholders = ((_a = reason.unresolvedPlaceHolders) === null || _a === void 0 ? void 0 : _a.join(",")) || "";
                    error = new common_1.MissingEnvironmentVariablesError(lodash_1.camelCase(reason.failedDriver.uses), placeholders, templatePath);
                }
            }
        }
        else {
            const newOutput = envUtil_1.envUtil.map2object(execRes.value);
            lodash_1.merge(output, newOutput);
        }
        return [output, error];
    }
    async deploy(ctx, inputs) {
        var _a, _b, _c, _d, _e;
        const output = {};
        const templatePath = inputs["workflowFilePath"] || pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath, inputs.env);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        if (projectModel.deploy) {
            //check whether deploy to azure
            let containsAzure = false;
            (_a = projectModel.deploy.driverDefs) === null || _a === void 0 ? void 0 : _a.forEach((def) => {
                if (AzureDeployActions.includes(def.uses)) {
                    containsAzure = true;
                }
            });
            //consent
            if (containsAzure) {
                const consent = await deployUtils_1.deployUtils.askForDeployConsentV3(ctx);
                if (consent.isErr()) {
                    return teamsfx_api_1.err(consent.error);
                }
            }
            const summaryReporter = new summary_1.SummaryReporter([projectModel.deploy], ctx.logProvider);
            let hasError = false;
            try {
                const steps = projectModel.deploy.driverDefs.length;
                ctx.progressBar = (_b = ctx.ui) === null || _b === void 0 ? void 0 : _b.createProgressBar(localizeUtils_1.getLocalizedString("core.progress.deploy"), steps);
                await ((_c = ctx.progressBar) === null || _c === void 0 ? void 0 : _c.start());
                const maybeDescription = summaryReporter.getLifecycleDescriptions();
                if (maybeDescription.isErr()) {
                    return teamsfx_api_1.err(maybeDescription.error);
                }
                ctx.logProvider.info(`Executing deploy ${os_1.EOL}${os_1.EOL}${maybeDescription.value}${os_1.EOL}`);
                const execRes = await projectModel.deploy.execute(ctx);
                summaryReporter.updateLifecycleState(0, execRes);
                const result = this.convertExecuteResult(execRes.result, templatePath);
                lodash_1.merge(output, result[0]);
                if (result[1]) {
                    hasError = true;
                    inputs.envVars = output;
                    return teamsfx_api_1.err(result[1]);
                }
                // show message box after deploy
                const botTroubleShootMsg = getBotTroubleShootMessage(false);
                const msg = localizeUtils_1.getLocalizedString("core.common.LifecycleComplete.deploy", steps, steps) +
                    botTroubleShootMsg.textForLogging;
                if (ctx.platform !== teamsfx_api_1.Platform.VS) {
                    (_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.showMessage("info", msg, false);
                }
            }
            finally {
                const summary = summaryReporter.getLifecycleSummary();
                ctx.logProvider.info(`Execution summary:${os_1.EOL}${os_1.EOL}${summary}${os_1.EOL}`);
                await ((_e = ctx.progressBar) === null || _e === void 0 ? void 0 : _e.end(!hasError));
            }
        }
        else {
            return teamsfx_api_1.err(new yml_1.LifeCycleUndefinedError("deploy"));
        }
        return teamsfx_api_1.ok(output);
    }
    async publish(ctx, inputs) {
        var _a, _b, _c, _d, _e;
        const output = {};
        const templatePath = pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath, inputs.env);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        let hasError = false;
        if (projectModel.publish) {
            const summaryReporter = new summary_1.SummaryReporter([projectModel.publish], ctx.logProvider);
            try {
                const steps = projectModel.publish.driverDefs.length;
                ctx.progressBar = (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(localizeUtils_1.getLocalizedString("core.progress.publish"), steps);
                await ((_b = ctx.progressBar) === null || _b === void 0 ? void 0 : _b.start());
                const maybeDescription = summaryReporter.getLifecycleDescriptions();
                if (maybeDescription.isErr()) {
                    hasError = true;
                    return teamsfx_api_1.err(maybeDescription.error);
                }
                ctx.logProvider.info(`Executing publish ${os_1.EOL}${os_1.EOL}${maybeDescription.value}${os_1.EOL}`);
                const execRes = await projectModel.publish.execute(ctx);
                const result = this.convertExecuteResult(execRes.result, templatePath);
                lodash_1.merge(output, result[0]);
                summaryReporter.updateLifecycleState(0, execRes);
                if (result[1]) {
                    hasError = true;
                    inputs.envVars = output;
                    return teamsfx_api_1.err(result[1]);
                }
                else {
                    const msg = localizeUtils_1.getLocalizedString("core.common.LifecycleComplete.publish", steps, steps);
                    const adminPortal = localizeUtils_1.getLocalizedString("plugins.appstudio.adminPortal");
                    if (ctx.platform !== teamsfx_api_1.Platform.CLI) {
                        (_c = ctx.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", msg, false, adminPortal).then((value) => {
                            if (value.isOk() && value.value === adminPortal) {
                                void ctx.ui.openUrl(constants_2.Constants.TEAMS_ADMIN_PORTAL);
                            }
                        });
                    }
                    else {
                        (_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.showMessage("info", msg, false);
                    }
                }
            }
            finally {
                const summary = summaryReporter.getLifecycleSummary();
                ctx.logProvider.info(`Execution summary:${os_1.EOL}${os_1.EOL}${summary}${os_1.EOL}`);
                await ((_e = ctx.progressBar) === null || _e === void 0 ? void 0 : _e.end(!hasError));
            }
        }
        else {
            return teamsfx_api_1.err(new yml_1.LifeCycleUndefinedError("publish"));
        }
        return teamsfx_api_1.ok(output);
    }
    async publishInDeveloperPortal(ctx, inputs) {
        // update teams app
        if (!ctx.tokenProvider) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("tokenProvider"));
        }
        if (!inputs[questionNames_1.QuestionNames.AppPackagePath]) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("appPackagePath"));
        }
        const updateRes = await appStudio_1.updateTeamsAppV3ForPublish(ctx, inputs);
        if (updateRes.isErr()) {
            return teamsfx_api_1.err(updateRes.error);
        }
        let loginHint = "";
        const accountRes = await ctx.tokenProvider.m365TokenProvider.getJsonObject({
            scopes: constants_2.AppStudioScopes,
        });
        if (accountRes.isOk()) {
            loginHint = accountRes.value.unique_name;
        }
        await ctx.userInteraction.openUrl(`https://dev.teams.microsoft.com/apps/${updateRes.value}/distributions/app-catalog?login_hint=${loginHint}&referrer=teamstoolkit_${inputs.platform}`);
        return teamsfx_api_1.ok(undefined);
    }
}
tslib_1.__decorate([
    lib_1.hooks([
        globalVars_1.ErrorContextMW({ component: "Coordinator" }),
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.CreateProject,
            telemetryComponentName: "coordinator",
            errorSource: constants_1.CoordinatorSource,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "create", null);
tslib_1.__decorate([
    lib_1.hooks([globalVars_1.ErrorContextMW({ component: "Coordinator" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "preProvisionForVS", null);
tslib_1.__decorate([
    lib_1.hooks([globalVars_1.ErrorContextMW({ component: "Coordinator" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "preCheckYmlAndEnvForVS", null);
tslib_1.__decorate([
    lib_1.hooks([globalVars_1.ErrorContextMW({ component: "Coordinator" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "provision", null);
tslib_1.__decorate([
    lib_1.hooks([globalVars_1.ErrorContextMW({ component: "Coordinator" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "deploy", null);
tslib_1.__decorate([
    lib_1.hooks([globalVars_1.ErrorContextMW({ component: "Coordinator" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "publish", null);
tslib_1.__decorate([
    lib_1.hooks([globalVars_1.ErrorContextMW({ component: "Coordinator" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "publishInDeveloperPortal", null);
exports.coordinator = new Coordinator();
function getBotTroubleShootMessage(isBot) {
    const botTroubleShootLink = "https://aka.ms/teamsfx-bot-help#how-can-i-troubleshoot-issues-when-teams-bot-isnt-responding-on-azure";
    const botTroubleShootDesc = localizeUtils_1.getLocalizedString("core.deploy.botTroubleShoot");
    const botTroubleShootLearnMore = localizeUtils_1.getLocalizedString("core.deploy.botTroubleShoot.learnMore");
    const botTroubleShootMsg = `${botTroubleShootDesc} ${botTroubleShootLearnMore}: ${botTroubleShootLink}.`;
    return {
        troubleShootLink: botTroubleShootLink,
        textForLogging: isBot ? botTroubleShootMsg : "",
        textForMsgBox: botTroubleShootDesc,
        textForActionButton: botTroubleShootLearnMore,
    };
}
function downloadSampleHook(sampleId, sampleAppPath) {
    // A temporary solution to aundefined duplicate componentId
    if (sampleId === "todo-list-SPFx") {
        const originalId = "c314487b-f51c-474d-823e-a2c3ec82b1ff";
        const componentId = uuid.v4();
        glob_1.glob.glob(`${sampleAppPath}/**/*.json`, { nodir: true, dot: true }, (err, files) => {
            void Promise.all(files.map(async (file) => {
                let content = (await fs_extra_1.default.readFile(file)).toString();
                const reg = new RegExp(originalId, "g");
                content = content.replace(reg, componentId);
                await fs_extra_1.default.writeFile(file, content);
            }));
        });
    }
}
//# sourceMappingURL=index.js.map