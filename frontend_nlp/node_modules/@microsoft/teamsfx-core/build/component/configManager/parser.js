"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.yamlParser = exports.YamlParser = void 0;
const tslib_1 = require("tslib");
/**
 * @author yefuwang@microsoft.com
 */
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const js_yaml_1 = require("js-yaml");
const globalVars_1 = require("../../core/globalVars");
const yml_1 = require("../../error/yml");
const interface_1 = require("./interface");
const lifecycle_1 = require("./lifecycle");
const validator_1 = require("./validator");
const localizeUtils_1 = require("../../common/localizeUtils");
const validator = new validator_1.Validator();
const environmentFolderPath = "environmentFolderPath";
const writeToEnvironmentFile = "writeToEnvironmentFile";
const versionNotSupportedKey = "error.yaml.VersionNotSupported";
function parseRawProjectModel(obj) {
    const result = { version: "" };
    if (environmentFolderPath in obj) {
        if (typeof obj[environmentFolderPath] !== "string") {
            return teamsfx_api_1.err(new yml_1.YamlFieldTypeError("environmentFolderPath", "string"));
        }
        result.environmentFolderPath = obj[environmentFolderPath];
    }
    if ("version" in obj) {
        if (typeof obj["version"] !== "string") {
            return teamsfx_api_1.err(new yml_1.YamlFieldTypeError("version", "string"));
        }
        result.version = obj["version"];
    }
    else {
        return teamsfx_api_1.err(new yml_1.YamlFieldMissingError("version"));
    }
    if ("additionalMetadata" in obj) {
        // No validation for additionalMetadata by design. This property is for telemetry related purpose only
        // and should not affect user-observable behavior of TTK.
        result.additionalMetadata = obj["additionalMetadata"];
    }
    for (const name of interface_1.LifecycleNames) {
        if (name in obj) {
            const value = obj[name];
            if (!Array.isArray(value)) {
                return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(name, "array"));
            }
            for (const elem of value) {
                if (!("uses" in elem)) {
                    return teamsfx_api_1.err(new yml_1.YamlFieldMissingError(`${name}.uses`));
                }
                if (!(typeof elem["uses"] === "string")) {
                    return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(`${name}.uses`, "string"));
                }
                if (!("with" in elem)) {
                    return teamsfx_api_1.err(new yml_1.YamlFieldMissingError(`${name}.with`));
                }
                if (!(typeof elem["with"] === "object")) {
                    return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(`${name}.with`, "object"));
                }
                if (elem["env"]) {
                    if (typeof elem["env"] !== "object" || Array.isArray(elem["env"])) {
                        return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(`${name}.env`, "object"));
                    }
                    for (const envVar in elem["env"]) {
                        if (typeof elem["env"][envVar] !== "string") {
                            return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(`${name}.env.${envVar}`, "string"));
                        }
                    }
                }
                if (elem[writeToEnvironmentFile]) {
                    if (typeof elem[writeToEnvironmentFile] !== "object" ||
                        Array.isArray(elem[writeToEnvironmentFile])) {
                        return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(`${name}.writeToEnvironmentFile`, "object"));
                    }
                    for (const envVar in elem[writeToEnvironmentFile]) {
                        if (typeof elem[writeToEnvironmentFile][envVar] !== "string") {
                            return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(`${name}.writeToEnvironmentFile.${envVar}`, "string"));
                        }
                    }
                }
            }
            result[name] = value;
        }
    }
    return teamsfx_api_1.ok(result);
}
class YamlParser {
    async parse(path, validateSchema) {
        const raw = await this.parseRaw(path, validateSchema);
        if (raw.isErr()) {
            return teamsfx_api_1.err(raw.error);
        }
        const result = { version: raw.value.version };
        for (const name of interface_1.LifecycleNames) {
            if (name in raw.value) {
                const definitions = raw.value[name];
                if (definitions) {
                    result[name] = new lifecycle_1.Lifecycle(name, definitions, result.version);
                }
            }
        }
        if (raw.value.environmentFolderPath) {
            result.environmentFolderPath = raw.value.environmentFolderPath;
        }
        if (raw.value.additionalMetadata) {
            result.additionalMetadata = raw.value.additionalMetadata;
        }
        return teamsfx_api_1.ok(result);
    }
    async parseRaw(path, validateSchema) {
        try {
            globalVars_1.globalVars.ymlFilePath = path;
            const str = await fs_extra_1.default.readFile(path, "utf8");
            const content = js_yaml_1.load(str);
            const value = content;
            const version = typeof value["version"] === "string" ? value["version"] : undefined;
            // note: typeof null === "object" typeof undefined === "undefined" in js
            if (typeof content !== "object" || Array.isArray(content) || content === null) {
                return teamsfx_api_1.err(new yml_1.InvalidYamlSchemaError(path));
            }
            if (validateSchema) {
                if (!validator.isVersionSupported(version !== null && version !== void 0 ? version : "undefined")) {
                    return teamsfx_api_1.err(new yml_1.InvalidYamlSchemaError(path, localizeUtils_1.getLocalizedString(versionNotSupportedKey, version, validator.supportedVersions().join(", "))));
                }
                const valid = validator.validate(value, version);
                if (!valid) {
                    return teamsfx_api_1.err(new yml_1.InvalidYamlSchemaError(path));
                }
            }
            return parseRawProjectModel(value);
        }
        catch (error) {
            return teamsfx_api_1.err(new yml_1.InvalidYamlSchemaError(path));
        }
    }
}
exports.YamlParser = YamlParser;
exports.yamlParser = new YamlParser();
//# sourceMappingURL=parser.js.map