"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lifecycle = exports.resolveString = void 0;
const tslib_1 = require("tslib");
/**
 * @author yefuwang@microsoft.com
 */
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = tslib_1.__importStar(require("lodash"));
const typedi_1 = require("typedi");
const yml_1 = require("../../error/yml");
const teamsFxTelemetryReporter_1 = require("../utils/teamsFxTelemetryReporter");
const constant_1 = require("./constant");
const error_1 = require("../../error");
const globalVars_1 = require("../../core/globalVars");
function resolveDriverDef(def, resolved, unresolved) {
    const args = def.with;
    for (const k in args) {
        const val = args[k];
        args[k] = resolve(val, resolved, unresolved);
    }
    if (def.env) {
        for (const k in def.env) {
            const val = def.env[k];
            def.env[k] = resolveString(val, resolved, unresolved);
        }
    }
}
// Replace placeholders in the driver definitions' `with` field inplace
// and returns resolved and unresolved placeholders
function resolvePlaceHolders(defs) {
    const resolvedVars = [];
    const unresolvedVars = [];
    for (const def of defs) {
        resolveDriverDef(def, resolvedVars, unresolvedVars);
    }
    return [resolvedVars, unresolvedVars];
}
function resolve(input, resolved, unresolved) {
    if (input === undefined || input === null) {
        return input;
    }
    else if (typeof input === "string") {
        return resolveString(input, resolved, unresolved);
    }
    else if (Array.isArray(input)) {
        const newArray = [];
        for (const e of input) {
            newArray.push(resolve(e, resolved, unresolved));
        }
        return newArray;
    }
    else if (input !== null && typeof input === "object") {
        const newObj = lodash_1.default.cloneDeep(input);
        Object.keys(newObj).forEach((key) => {
            newObj[key] = resolve(newObj[key], resolved, unresolved);
        });
        return newObj;
    }
    else {
        return input;
    }
}
function resolveString(val, resolved, unresolved) {
    const placeHolderReg = /\${{\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*}}/g;
    let matches = placeHolderReg.exec(val);
    let newVal = val;
    while (matches != null) {
        const envVar = matches[1];
        const envVal = process.env[envVar];
        if (envVar === "APP_NAME_SUFFIX") {
            if (envVal === undefined || envVal === null) {
                unresolved.push(envVar);
            }
            else {
                resolved.push(envVar);
                newVal = newVal.replace(matches[0], envVal);
            }
        }
        else {
            if (!envVal) {
                unresolved.push(envVar);
            }
            else {
                resolved.push(envVar);
                newVal = newVal.replace(matches[0], envVal);
            }
        }
        matches = placeHolderReg.exec(val);
    }
    return newVal;
}
exports.resolveString = resolveString;
class Lifecycle {
    constructor(name, driverDefs, version) {
        this.driverDefs = driverDefs;
        this.name = name;
        this.version = version;
    }
    resolvePlaceholders() {
        const result = resolvePlaceHolders(this.driverDefs);
        return result[1];
    }
    static stringifyOutput(output) {
        const obj = {};
        for (const [k, v] of output) {
            if (k.startsWith("SECRET_")) {
                obj[k] = "******";
            }
            else {
                obj[k] = v;
            }
        }
        return JSON.stringify(obj);
    }
    async execute(ctx) {
        var _a;
        const actions = JSON.stringify(this.driverDefs.map((def) => lodash_1.camelCase(this.stringifyDriverDef(def))));
        const telemetryReporter = new teamsFxTelemetryReporter_1.TeamsFxTelemetryReporter(ctx.telemetryReporter, {
            componentName: constant_1.component,
        });
        telemetryReporter.sendStartEvent({
            eventName: constant_1.lifecycleExecutionEvent,
            properties: {
                [constant_1.TelemetryProperty.Lifecycle]: this.name,
                [constant_1.TelemetryProperty.Actions]: actions,
            },
        });
        ctx.logProvider.info(`Executing lifecycle ${this.name}`);
        const resolved = [];
        const unresolved = [];
        const { result, summaries } = await this.executeImpl(ctx, resolved, unresolved);
        let e;
        let failedAction;
        if (result.isOk()) {
            ctx.logProvider.info(`Finished Executing lifecycle ${this.name}. Result: ${Lifecycle.stringifyOutput(result.value)}`);
        }
        else {
            if (result.error.kind === "Failure") {
                e = result.error.error;
                ctx.logProvider.error(`Failed to Execute lifecycle ${this.name}. ${e.name}:${e.message}`);
            }
            else if (result.error.kind === "PartialSuccess") {
                failedAction = this.stringifyDriverDef(result.error.reason.failedDriver);
                const output = Lifecycle.stringifyOutput(result.error.env);
                if (result.error.reason.kind === "DriverError") {
                    e = result.error.reason.error;
                    ctx.logProvider.error(`Failed to Execute lifecycle ${this.name} due to failed action: ${failedAction}. ${e.name}:${e.message}. Env output: ${output}`);
                }
                else if (result.error.reason.kind === "UnresolvedPlaceholders") {
                    // This error is just for telemetry because sendEndEvent() needs an error as parameter.
                    e = new error_1.MissingEnvironmentVariablesError(constant_1.component, result.error.reason.unresolvedPlaceHolders.join(","));
                    ctx.logProvider.error(`Failed to Execute lifecycle ${this.name} because there are unresolved placeholders ${JSON.stringify(unresolved)} for action: ${failedAction}. Env output: ${output}`);
                }
            }
        }
        telemetryReporter.sendEndEvent({
            eventName: constant_1.lifecycleExecutionEvent,
            properties: {
                [constant_1.TelemetryProperty.Lifecycle]: this.name,
                [constant_1.TelemetryProperty.Actions]: actions,
                [constant_1.TelemetryProperty.ResolvedPlaceholders]: JSON.stringify(resolved),
                [constant_1.TelemetryProperty.UnresolvedPlaceholders]: JSON.stringify(unresolved),
                [constant_1.TelemetryProperty.FailedAction]: (_a = lodash_1.camelCase(failedAction)) !== null && _a !== void 0 ? _a : "",
            },
        }, e);
        return { result, summaries };
    }
    async executeImpl(ctx, resolved, unresolved) {
        var _a;
        const maybeDrivers = this.resolveDriverInstances(ctx.logProvider);
        if (maybeDrivers.isErr()) {
            return { result: teamsfx_api_1.err({ kind: "Failure", error: maybeDrivers.error }), summaries: [] };
        }
        const drivers = maybeDrivers.value;
        const envOutput = new Map();
        const summaries = [];
        for (const driver of drivers) {
            ctx.logProvider.verbose(`Executing action ${this.stringifyDriverDef(driver)} in lifecycle ${this.name}`);
            if (driver.instance.progressTitle) {
                await ((_a = ctx.progressBar) === null || _a === void 0 ? void 0 : _a.next(driver.instance.progressTitle));
            }
            resolveDriverDef(driver, resolved, unresolved);
            if (unresolved.length > 0) {
                ctx.logProvider.warning(`Unresolved placeholders(${unresolved.join(",")}) found for Action ${this.stringifyDriverDef(driver)} in lifecycle ${this.name}`);
                summaries.push([
                    `${constant_1.SummaryConstant.Failed} Unresolved placeholders: ${unresolved.join(",")}`,
                ]);
                return {
                    result: teamsfx_api_1.err({
                        kind: "PartialSuccess",
                        env: envOutput,
                        reason: {
                            kind: "UnresolvedPlaceholders",
                            failedDriver: driver,
                            unresolvedPlaceHolders: unresolved,
                        },
                    }),
                    summaries,
                };
            }
            if (driver.env) {
                for (const [envVar, value] of Object.entries(driver.env)) {
                    process.env[envVar] = value;
                }
            }
            globalVars_1.setErrorContext({ component: lodash_1.camelCase(driver.uses), method: "execute" }); // set driver name as component name for telemetry
            const r = await driver.instance.execute(driver.with, ctx, driver.writeToEnvironmentFile
                ? new Map(Object.entries(driver.writeToEnvironmentFile))
                : undefined, this.version);
            const result = r.result;
            const summary = r.summaries.map((s) => `${constant_1.SummaryConstant.Succeeded} ${s}`);
            summaries.push(summary);
            if (result.isErr()) {
                summary.push(`${constant_1.SummaryConstant.Failed} ${result.error.message}`);
                return {
                    result: teamsfx_api_1.err({
                        kind: "PartialSuccess",
                        env: envOutput,
                        reason: {
                            kind: "DriverError",
                            failedDriver: driver,
                            error: result.error,
                        },
                    }),
                    summaries,
                };
            }
            for (const [envVar, value] of result.value) {
                envOutput.set(envVar, value);
                process.env[envVar] = value;
            }
            ctx.logProvider.verbose(`Action ${this.stringifyDriverDef(driver)} in lifecycle ${this.name} succeeded with output ${Lifecycle.stringifyOutput(result.value)}`);
        }
        return { result: teamsfx_api_1.ok(envOutput), summaries };
    }
    stringifyDriverDef(def) {
        if (def.name) {
            return JSON.stringify({ name: def.name, uses: def.uses });
        }
        return def.uses;
    }
    resolveDriverInstances(log) {
        void log.debug(`Trying to resolve actions for lifecycle ${this.name}`);
        const drivers = [];
        for (const def of this.driverDefs) {
            if (!typedi_1.Container.has(def.uses)) {
                return teamsfx_api_1.err(new yml_1.InvalidYmlActionNameError(def.uses));
            }
            const driver = typedi_1.Container.get(def.uses);
            drivers.push(Object.assign({ instance: driver }, def));
            void log.debug(`Action ${this.stringifyDriverDef(def)} found for lifecycle ${this.name}`);
        }
        return teamsfx_api_1.ok(drivers);
    }
}
exports.Lifecycle = Lifecycle;
//# sourceMappingURL=lifecycle.js.map