"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.provisionUtils = void 0;
const arm_resources_1 = require("@azure/arm-resources");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("../common/constants");
const localizeUtils_1 = require("../common/localizeUtils");
const telemetry_1 = require("../common/telemetry");
const tools_1 = require("../common/tools");
const globalVars_1 = require("../core/globalVars");
const azure_1 = require("../error/azure");
const common_1 = require("../error/common");
const m365_1 = require("../error/m365");
const constants_2 = require("./constants");
const constants_3 = require("./driver/teamsApp/constants");
const ResourceGroupHelper_1 = require("./utils/ResourceGroupHelper");
class ProvisionUtils {
    /**
     * make sure subscription is correct before provision for V3
     * subscriptionId is provided from .env.xxx file
     */
    async ensureSubscription(azureAccountProvider, givenSubscriptionId) {
        globalVars_1.TOOLS.logProvider.info("check whether azure account is signed in.");
        // make sure the user is logged in
        await azureAccountProvider.getIdentityCredentialAsync(true);
        if (!givenSubscriptionId) {
            globalVars_1.TOOLS.logProvider.info("subscription is not selected, try to select.");
            try {
                const subscriptionInAccount = await azureAccountProvider.getSelectedSubscription(true);
                if (!subscriptionInAccount) {
                    // this case will not happen actually
                    return teamsfx_api_1.err(new azure_1.SelectSubscriptionError());
                }
                else {
                    globalVars_1.TOOLS.logProvider.info(`successful to select subscription: ${subscriptionInAccount.subscriptionId}`);
                    return teamsfx_api_1.ok(subscriptionInAccount);
                }
            }
            catch (e) {
                return teamsfx_api_1.err(common_1.assembleError(e));
            }
        }
        // verify valid subscription (permission)
        globalVars_1.TOOLS.logProvider.info("subscription is given, try to validate");
        const subscriptions = await azureAccountProvider.listSubscriptions();
        const foundSubscriptionInfo = findSubscriptionFromList(givenSubscriptionId, subscriptions);
        if (!foundSubscriptionInfo) {
            globalVars_1.TOOLS.logProvider.info("subscription validate fail");
            return teamsfx_api_1.err(new azure_1.InvalidAzureSubscriptionError(givenSubscriptionId));
        }
        globalVars_1.TOOLS.logProvider.info("subscription validate success");
        return teamsfx_api_1.ok(foundSubscriptionInfo);
    }
    async ensureResourceGroup(inputs, azureAccountProvider, subscriptionId, givenResourceGroupName, defaultResourceGroupName) {
        const azureToken = await azureAccountProvider.getIdentityCredentialAsync();
        if (azureToken === undefined) {
            return teamsfx_api_1.err(new azure_1.InvalidAzureCredentialError());
        }
        await azureAccountProvider.setSubscription(subscriptionId);
        const rmClient = new arm_resources_1.ResourceManagementClient(azureToken, subscriptionId);
        let resourceGroupInfo;
        if (givenResourceGroupName) {
            const getResourceGroupRes = await ResourceGroupHelper_1.resourceGroupHelper.getResourceGroupInfo(givenResourceGroupName, rmClient);
            if (getResourceGroupRes.isErr()) {
                return teamsfx_api_1.err(getResourceGroupRes.error);
            }
            else {
                if (!getResourceGroupRes.value) {
                    return teamsfx_api_1.err(new azure_1.ResourceGroupNotExistError(givenResourceGroupName, subscriptionId));
                }
                else {
                    resourceGroupInfo = getResourceGroupRes.value;
                }
            }
        }
        else {
            const defaultRG = defaultResourceGroupName || "teams-app-rg";
            const rgRes = await ResourceGroupHelper_1.resourceGroupHelper.askResourceGroupInfoV3(inputs, azureAccountProvider, rmClient, defaultRG);
            if (rgRes.isErr())
                return teamsfx_api_1.err(rgRes.error);
            resourceGroupInfo = rgRes.value;
        }
        return teamsfx_api_1.ok(resourceGroupInfo);
    }
    async getM365TenantId(m365TokenProvider) {
        // Just to trigger M365 login before the concurrent execution of localDebug.
        // Because concurrent execution of localDebug may getAccessToken() concurrently, which
        // causes 2 M365 logins before the token caching in common lib takes effect.
        const appStudioTokenRes = await m365TokenProvider.getAccessToken({ scopes: constants_3.AppStudioScopes });
        if (appStudioTokenRes.isErr()) {
            return teamsfx_api_1.err(appStudioTokenRes.error);
        }
        const appStudioTokenJsonRes = await m365TokenProvider.getJsonObject({
            scopes: constants_3.AppStudioScopes,
        });
        const appStudioTokenJson = appStudioTokenJsonRes.isOk()
            ? appStudioTokenJsonRes.value
            : undefined;
        if (appStudioTokenJson === undefined) {
            return teamsfx_api_1.err(new m365_1.M365TokenJSONNotFoundError());
        }
        const tenantIdInToken = appStudioTokenJson.tid;
        const tenantUserName = appStudioTokenJson.upn;
        if (!tenantIdInToken || !(typeof tenantIdInToken === "string")) {
            return teamsfx_api_1.err(new m365_1.M365TenantIdNotFoundInTokenError());
        }
        return teamsfx_api_1.ok({ tenantIdInToken, tenantUserName });
    }
    async askForProvisionConsentV3(ctx, m365tenant, azureSubInfo, envName) {
        var _a, _b, _c;
        const azureTokenJson = await ctx.azureAccountProvider.getJsonObject();
        const username = azureTokenJson.unique_name || "";
        const azureAccountInfo = localizeUtils_1.getLocalizedString("core.provision.azureAccount", username);
        const azureSubscriptionInfo = localizeUtils_1.getLocalizedString("core.provision.azureSubscription", azureSubInfo.subscriptionName);
        const accountsInfo = [azureAccountInfo, azureSubscriptionInfo];
        if (m365tenant) {
            const m365AccountInfo = localizeUtils_1.getLocalizedString("core.provision.m365Account", m365tenant === null || m365tenant === void 0 ? void 0 : m365tenant.tenantUserName);
            accountsInfo.push(m365AccountInfo);
        }
        const confirmMsg = localizeUtils_1.getLocalizedString("core.provision.confirmEnvAndCostNotice", envName);
        const provisionText = localizeUtils_1.getLocalizedString("core.provision.provision");
        const confirmRes = await ((_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.showMessage("warn", accountsInfo.join("\n") + "\n\n" + confirmMsg, true, provisionText));
        const confirm = (confirmRes === null || confirmRes === void 0 ? void 0 : confirmRes.isOk()) ? confirmRes.value : undefined;
        (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(telemetry_1.TelemetryEvent.ConfirmProvision, envName
            ? {
                [telemetry_1.TelemetryProperty.Env]: tools_1.getHashedEnv(envName),
                [constants_2.SolutionTelemetryProperty.SubscriptionId]: azureSubInfo.subscriptionId,
                [constants_2.SolutionTelemetryProperty.M365TenantId]: (_c = m365tenant === null || m365tenant === void 0 ? void 0 : m365tenant.tenantIdInToken) !== null && _c !== void 0 ? _c : "",
                [constants_2.SolutionTelemetryProperty.ConfirmRes]: !confirm ? "Cancel" : "Provision",
            }
            : {});
        if (confirm !== provisionText) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError("coordinator", "CancelProvision", "CancelProvision"));
        }
        return teamsfx_api_1.ok(undefined);
    }
    ensureM365TenantMatchesV3(actions, tenantId) {
        if (actions.length === 0 || !tenantId) {
            return teamsfx_api_1.ok(undefined);
        }
        const hasSwitched = !!process.env.TEAMS_APP_TENANT_ID && process.env.TEAMS_APP_TENANT_ID !== tenantId;
        const keysNeedToUpdate = ["TEAMS_APP_TENANT_ID"];
        if (actions.includes("aadApp/create")) {
            if (process.env.AAD_APP_CLIENT_ID) {
                keysNeedToUpdate.push("AAD_APP_CLIENT_ID");
            }
        }
        if (actions.includes("botAadApp/create") || actions.includes("botFramework/create")) {
            if (process.env.BOT_ID) {
                keysNeedToUpdate.push("BOT_ID");
            }
        }
        const error = new m365_1.M365TenantIdNotMatchError(tenantId, process.env.TEAMS_APP_TENANT_ID, keysNeedToUpdate.join(", "));
        error.helpLink = constants_1.HelpLinks.SwitchTenant;
        return !hasSwitched ? teamsfx_api_1.ok(undefined) : teamsfx_api_1.err(error);
    }
}
function findSubscriptionFromList(subscriptionId, subscriptions) {
    return subscriptions.find((item) => item.subscriptionId === subscriptionId);
}
exports.provisionUtils = new ProvisionUtils();
//# sourceMappingURL=provisionUtils.js.map