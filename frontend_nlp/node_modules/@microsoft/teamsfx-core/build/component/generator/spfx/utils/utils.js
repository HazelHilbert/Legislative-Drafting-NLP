"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExecCommand = exports.Utils = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const fs = tslib_1.__importStar(require("fs-extra"));
const glob_1 = require("glob");
const child_process_1 = require("child_process");
const axios_1 = tslib_1.__importDefault(require("axios"));
const cpUtils_1 = require("../../../../common/deps-checker/util/cpUtils");
const os = tslib_1.__importStar(require("os"));
const constants_1 = require("./constants");
class Utils {
    static async configure(configurePath, map) {
        let files = [];
        const extensions = ["*.json", "*.ts", "*.js", "*.scss", "*.tsx"];
        if (fs.lstatSync(configurePath).isFile()) {
            files = [configurePath];
        }
        else {
            for (const ext of extensions) {
                files = files.concat(glob_1.glob.sync(`${configurePath}/**/${ext}`, { nodir: true }));
            }
        }
        for (const file of files) {
            let content = (await fs.readFile(file)).toString();
            map.forEach((value, key) => {
                const reg = new RegExp(key, "g");
                content = content.replace(reg, value);
            });
            await fs.writeFile(file, content);
        }
    }
    static normalizeComponentName(name) {
        name = lodash_1.default.camelCase(name);
        name = lodash_1.default.upperFirst(name);
        return name;
    }
    static async execute(command, title, workingDir, logProvider, showInOutputWindow = false) {
        return new Promise((resolve, reject) => {
            if (showInOutputWindow) {
                logProvider === null || logProvider === void 0 ? void 0 : logProvider.info(`[${title || ""}] Start to run command: "${command}".`);
            }
            child_process_1.exec(command, { cwd: workingDir }, (error, standardOutput) => {
                if (showInOutputWindow) {
                    logProvider === null || logProvider === void 0 ? void 0 : logProvider.debug(`[${title || ""}]${standardOutput}`);
                }
                if (error) {
                    if (showInOutputWindow) {
                        logProvider === null || logProvider === void 0 ? void 0 : logProvider.error(`[${title || ""}] Failed to run command: "${command}".`);
                        logProvider === null || logProvider === void 0 ? void 0 : logProvider.error(error.message);
                    }
                    reject(error);
                    return;
                }
                resolve(standardOutput);
            });
        });
    }
    static createAxiosInstanceWithToken(accessToken) {
        const axiosInstance = axios_1.default.create({
            headers: {
                authorization: `Bearer ${accessToken}`,
            },
        });
        return axiosInstance;
    }
    static getPackageVersion(pkgName) {
        try {
            const output = child_process_1.execSync(`npm list ${pkgName} -g --depth=0`);
            const regex = /(?<installPath>[^\n]+)\n`-- ([^@]+)@(?<version>\d+\.\d+\.\d+)/;
            const match = regex.exec(output.toString());
            if (match && match.groups) {
                return match.groups.version;
            }
            else {
                return undefined;
            }
        }
        catch (e) {
            return undefined;
        }
    }
    static async hasNPM(logger) {
        const version = await this.getNPMMajorVersion(logger);
        return version !== undefined;
    }
    static async getNPMMajorVersion(logger) {
        try {
            const output = await cpUtils_1.cpUtils.executeCommand(undefined, logger, { shell: true }, "npm", "--version");
            const regex = /(?<majorVersion>\d+)(\.\d+\.\d+)/;
            const match = regex.exec(output.toString());
            if (match && match.groups) {
                return match.groups.majorVersion;
            }
            else {
                return undefined;
            }
        }
        catch (error) {
            return undefined;
        }
    }
    static async getNodeVersion() {
        try {
            const output = await cpUtils_1.cpUtils.executeCommand(undefined, undefined, undefined, "node", "--version");
            const regex = /v(?<major_version>\d+)\.(?<minor_version>\d+)\.(?<patch_version>\d+)/gm;
            const match = regex.exec(output);
            if (match && match.groups) {
                return match.groups.major_version;
            }
            else {
                return undefined;
            }
        }
        catch (error) {
            return undefined;
        }
    }
    static async findGloballyInstalledVersion(logger, packageName, timeoutInSeconds, shouldThrowIfNotFound = true) {
        const timeout = timeoutInSeconds * 1000;
        try {
            const output = await cpUtils_1.cpUtils.executeCommand(undefined, logger, { timeout: timeout, shell: false }, getExecCommand("npm"), "ls", `${packageName}`, "-g", "--depth=0");
            const regex = new RegExp(packageName + "@" + "(?<version>\\d+\\.\\d+\\.\\d+[\\w-.]*)"); // in case user has installed any -alpha, -beta version
            const match = regex.exec(output.toString());
            if (match && match.groups) {
                return match.groups.version;
            }
            else {
                return undefined;
            }
        }
        catch (error) {
            logger === null || logger === void 0 ? void 0 : logger.error(`Failed to execute "npm ls ${packageName}"`);
            if (shouldThrowIfNotFound) {
                throw error;
            }
        }
    }
    static async findLatestVersion(logger, packageName, timeoutInSeconds) {
        const timeout = timeoutInSeconds * 1000;
        try {
            const output = await cpUtils_1.cpUtils.executeCommand(undefined, logger, { timeout: timeout, shell: false }, getExecCommand("npm"), "view", `${packageName}`, "version");
            const regex = new RegExp("(?<version>\\d+\\.\\d+\\.\\d)");
            const match = regex.exec(output.toString());
            if (match && match.groups) {
                return match.groups.version;
            }
            else {
                return undefined;
            }
        }
        catch (error) {
            return undefined;
        }
    }
    static truncateAppShortName(appName) {
        const appNameSuffixPlaceholder = "${{APP_NAME_SUFFIX}}";
        const localSuffix = "local";
        if (appName.endsWith(appNameSuffixPlaceholder)) {
            const appNameWithouSuffix = appName.substring(0, appName.length - appNameSuffixPlaceholder.length);
            if (appNameWithouSuffix.length + localSuffix.length > constants_1.Constants.TEAMS_APP_NAME_MAX_LENGTH) {
                return (appNameWithouSuffix.substring(0, constants_1.Constants.TEAMS_APP_NAME_MAX_LENGTH - localSuffix.length) + appNameSuffixPlaceholder);
            }
        }
        else if (appName.length > constants_1.Constants.TEAMS_APP_NAME_MAX_LENGTH) {
            return appName.substring(0, constants_1.Constants.TEAMS_APP_NAME_MAX_LENGTH);
        }
        return appName;
    }
}
exports.Utils = Utils;
function getExecCommand(command) {
    return isWindows() ? `${command}.cmd` : command;
}
exports.getExecCommand = getExecCommand;
function isWindows() {
    return os.type() === "Windows_NT";
}
//# sourceMappingURL=utils.js.map