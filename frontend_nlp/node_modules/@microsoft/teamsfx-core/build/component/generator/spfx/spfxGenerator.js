"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPFxGenerator = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const os_1 = require("os");
const path = tslib_1.__importStar(require("path"));
const util = tslib_1.__importStar(require("util"));
const lodash_2 = require("lodash");
const deps_checker_1 = require("../../../common/deps-checker");
const localizeUtils_1 = require("../../../common/localizeUtils");
const error_1 = require("../../../error");
const questionNames_1 = require("../../../question/questionNames");
const constants_1 = require("../../constants");
const ManifestUtils_1 = require("../../driver/teamsApp/utils/ManifestUtils");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const envUtil_1 = require("../../utils/envUtil");
const generator_1 = require("../generator");
const generatorChecker_1 = require("./depsChecker/generatorChecker");
const yoChecker_1 = require("./depsChecker/yoChecker");
const error_2 = require("./error");
const constants_2 = require("./utils/constants");
const progress_helper_1 = require("./utils/progress-helper");
const create_1 = require("../../../question/create");
const telemetryEvents_1 = require("./utils/telemetryEvents");
const utils_1 = require("./utils/utils");
const semver_1 = tslib_1.__importDefault(require("semver"));
class SPFxGenerator {
    static async generate(context, inputs, destinationPath, actionContext) {
        const spfxSolution = inputs[questionNames_1.QuestionNames.SPFxSolution];
        lodash_2.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetryEvents_1.TelemetryProperty.SPFxSolution]: spfxSolution,
        });
        if (spfxSolution === "new") {
            return await this.newSPFxProject(context, inputs, destinationPath);
        }
        else {
            return await this.importSPFxProject(context, inputs, destinationPath, actionContext);
        }
    }
    static async newSPFxProject(context, inputs, destinationPath) {
        const yeomanRes = await this.doYeomanScaffold(context, inputs, destinationPath);
        if (yeomanRes.isErr())
            return teamsfx_api_1.err(yeomanRes.error);
        const templateRes = await generator_1.Generator.generateTemplate(context, destinationPath, constants_2.Constants.TEMPLATE_NAME, "ts");
        if (templateRes.isErr())
            return teamsfx_api_1.err(templateRes.error);
        return teamsfx_api_1.ok(undefined);
    }
    static async importSPFxProject(context, inputs, destinationPath, actionContext) {
        var _a, _b, _c, _d;
        const importProgress = context.userInteraction.createProgressBar(localizeUtils_1.getLocalizedString("plugins.spfx.import.title"), 3);
        await importProgress.start();
        const importDetails = [];
        try {
            // Copy & paste existing SPFx solution
            await importProgress.next(localizeUtils_1.getLocalizedString("plugins.spfx.import.copyExistingSPFxSolution"));
            const spfxFolder = inputs[questionNames_1.QuestionNames.SPFxFolder];
            const destSpfxFolder = path.join(destinationPath, "src");
            importDetails.push(os_1.EOL +
                `(.) Processing: Copying existing SPFx solution from ${spfxFolder} to ${destSpfxFolder}...`);
            await this.copySPFxSolution(spfxFolder, destSpfxFolder);
            importDetails.push(`(√) Done: Succeeded to copy existing SPFx solution.`);
            // Retrieve solution info to generate template
            await importProgress.next(localizeUtils_1.getLocalizedString("plugins.spfx.import.generateSPFxTemplates"));
            importDetails.push(`(.) Processing: Reading web part manifest in SPFx solution...`);
            const webpartManifest = await this.getWebpartManifest(spfxFolder);
            if (!webpartManifest ||
                !webpartManifest["id"] ||
                !webpartManifest["preconfiguredEntries"][0].title.default) {
                importDetails.push(`(×) Error: Failed to Read web part manifest due to invalid ${!webpartManifest
                    ? "web part manifest"
                    : !webpartManifest["id"]
                        ? "web part manifest id"
                        : "preconfiguredEntries title in web part manifest file"}!`);
                throw error_2.RetrieveSPFxInfoError();
            }
            importDetails.push(`(√) Done: Succeeded to retrieve web part manifest in SPFx solution.`);
            if (!context.templateVariables) {
                context.templateVariables = generator_1.Generator.getDefaultVariables(inputs[questionNames_1.QuestionNames.AppName]);
            }
            context.templateVariables["componentId"] = webpartManifest["id"];
            context.templateVariables["webpartName"] =
                webpartManifest["preconfiguredEntries"][0].title.default;
            importDetails.push(`(.) Processing: Generating SPFx project templates with app name: ${inputs[questionNames_1.QuestionNames.AppName]}, component id: ${webpartManifest["id"]}, web part name: ${webpartManifest["preconfiguredEntries"][0].title.default}`);
            const templateRes = await generator_1.Generator.generateTemplate(context, destinationPath, constants_2.Constants.TEMPLATE_NAME, "ts");
            if (templateRes.isErr()) {
                importDetails.push(`(×) Error: Failed to generate SPFx project templates!`);
                throw templateRes.error;
            }
            importDetails.push(`(√) Done: Succeeded to generate SPFx project templates.`);
            // Update manifest and related files
            await importProgress.next(localizeUtils_1.getLocalizedString("plugins.spfx.import.updateTemplates"));
            await this.updateSPFxTemplate(spfxFolder, destinationPath, importDetails);
        }
        catch (error) {
            await importProgress.end(false);
            importDetails.push(localizeUtils_1.getLocalizedString("plugins.spfx.import.log.fail", (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.getLogFilePath()));
            await context.logProvider.logInFile(teamsfx_api_1.LogLevel.Info, importDetails.join(os_1.EOL));
            void context.logProvider.error(localizeUtils_1.getLocalizedString("plugins.spfx.import.log.fail", (_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.getLogFilePath()));
            if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
                return teamsfx_api_1.err(error);
            }
            return teamsfx_api_1.err(error_2.ImportSPFxSolutionError(error));
        }
        await importProgress.end(true);
        importDetails.push(localizeUtils_1.getLocalizedString("plugins.spfx.import.log.success", (_c = context.logProvider) === null || _c === void 0 ? void 0 : _c.getLogFilePath()));
        await context.logProvider.logInFile(teamsfx_api_1.LogLevel.Info, importDetails.join(os_1.EOL));
        void context.logProvider.info(localizeUtils_1.getLocalizedString("plugins.spfx.import.log.success", (_d = context.logProvider) === null || _d === void 0 ? void 0 : _d.getLogFilePath()));
        void context.userInteraction.showMessage("info", localizeUtils_1.getLocalizedString("plugins.spfx.import.success", destinationPath), false);
        return teamsfx_api_1.ok(undefined);
    }
    static async doYeomanScaffold(context, inputs, destinationPath) {
        var _a, _b;
        const ui = context.userInteraction;
        const progressHandler = await progress_helper_1.ProgressHelper.startScaffoldProgressHandler(ui, inputs.stage == teamsfx_api_1.Stage.addWebpart);
        const shouldInstallLocally = inputs[questionNames_1.QuestionNames.SPFxInstallPackage] === create_1.SPFxVersionOptionIds.installLocally;
        try {
            const webpartName = inputs[questionNames_1.QuestionNames.SPFxWebpartName];
            const framework = inputs[questionNames_1.QuestionNames.SPFxFramework];
            const solutionName = inputs[questionNames_1.QuestionNames.AppName];
            const isAddSPFx = inputs.stage == teamsfx_api_1.Stage.addWebpart;
            const componentName = utils_1.Utils.normalizeComponentName(webpartName);
            const componentNameCamelCase = lodash_1.camelCase(componentName);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(localizeUtils_1.getLocalizedString("plugins.spfx.scaffold.dependencyCheck")));
            const yoChecker = new yoChecker_1.YoChecker(context.logProvider);
            const spGeneratorChecker = new generatorChecker_1.GeneratorChecker(context.logProvider);
            if (shouldInstallLocally) {
                const latestYoInstalled = await yoChecker.isLatestInstalled();
                const latestGeneratorInstalled = await spGeneratorChecker.isLatestInstalled(inputs.latestSpfxPackageVersion);
                if (!latestYoInstalled || !latestGeneratorInstalled) {
                    await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(localizeUtils_1.getLocalizedString("plugins.spfx.scaffold.dependencyInstall")));
                    if (!latestYoInstalled) {
                        const yoRes = await yoChecker.ensureLatestDependency(context);
                        if (yoRes.isErr()) {
                            throw error_2.LatestPackageInstallError();
                        }
                    }
                    if (!latestGeneratorInstalled) {
                        const spGeneratorRes = await spGeneratorChecker.ensureLatestDependency(context);
                        if (spGeneratorRes.isErr()) {
                            throw error_2.LatestPackageInstallError();
                        }
                    }
                }
            }
            else {
                const isLowerVersion = !!inputs.globalSpfxPackageVersion &&
                    semver_1.default.lte(inputs.globalSpfxPackageVersion, constants_2.Constants.RecommendedLowestSpfxVersion.substring(1));
                if (isLowerVersion) {
                    context.telemetryReporter.sendTelemetryEvent(telemetryEvents_1.TelemetryEvents.UseNotRecommendedVersion);
                }
            }
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(localizeUtils_1.getLocalizedString(isAddSPFx
                ? "driver.spfx.add.progress.scaffoldWebpart"
                : "plugins.spfx.scaffold.scaffoldProject")));
            if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
                context.logProvider.outputChannel.show();
            }
            const yoEnv = process.env;
            if (yoEnv.PATH) {
                yoEnv.PATH = shouldInstallLocally
                    ? `${yoChecker.getBinFolders().join(path.delimiter)}${path.delimiter}${(_a = process.env.PATH) !== null && _a !== void 0 ? _a : ""}`
                    : process.env.PATH;
            }
            else {
                yoEnv.Path = shouldInstallLocally
                    ? `${yoChecker.getBinFolders().join(path.delimiter)}${path.delimiter}${(_b = process.env.Path) !== null && _b !== void 0 ? _b : ""}`
                    : process.env.Path;
            }
            const args = [
                shouldInstallLocally ? spGeneratorChecker.getSpGeneratorPath() : "@microsoft/sharepoint",
                "--skip-install",
                "true",
                "--component-type",
                "webpart",
                "--component-name",
                webpartName,
                "--environment",
                "spo",
                "--skip-feature-deployment",
                "true",
                "--is-domain-isolated",
                "false",
            ];
            if (framework) {
                args.push("--framework", framework);
            }
            if (solutionName) {
                args.push("--solution-name", `"${solutionName}"`);
            }
            try {
                await deps_checker_1.cpUtils.executeCommand(isAddSPFx ? inputs[constants_1.SPFxQuestionNames.SPFxFolder] : destinationPath, context.logProvider, {
                    timeout: 2 * 60 * 1000,
                    env: yoEnv,
                }, "yo", ...args);
            }
            catch (yoError) {
                if (yoError.message) {
                    void context.logProvider.error(yoError.message);
                }
                throw error_2.YoGeneratorScaffoldError();
            }
            const newPath = path.join(destinationPath, "src");
            if (!isAddSPFx) {
                const currentPath = path.join(destinationPath, solutionName);
                await fs_extra_1.default.rename(currentPath, newPath);
            }
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(localizeUtils_1.getLocalizedString("plugins.spfx.scaffold.updateManifest")));
            const manifestPath = `${newPath}/src/webparts/${componentNameCamelCase}/${componentName}WebPart.manifest.json`;
            const manifest = await fs_extra_1.default.readFile(manifestPath, "utf8");
            let manifestString = manifest.toString();
            manifestString = manifestString.replace(`"supportedHosts": ["SharePointWebPart"]`, `"supportedHosts": ["SharePointWebPart", "TeamsPersonalApp", "TeamsTab"]`);
            await fs_extra_1.default.writeFile(manifestPath, manifestString);
            const matchHashComment = new RegExp(/(\/\/ .*)/, "gi");
            const manifestJson = JSON.parse(manifestString.replace(matchHashComment, "").trim());
            const componentId = manifestJson.id;
            if (!isAddSPFx) {
                if (!context.templateVariables) {
                    context.templateVariables = generator_1.Generator.getDefaultVariables(solutionName);
                }
                context.templateVariables["componentId"] = componentId;
                context.templateVariables["webpartName"] = webpartName;
            }
            // remove dataVersion() function, related issue: https://github.com/SharePoint/sp-dev-docs/issues/6469
            const webpartFile = `${newPath}/src/webparts/${componentNameCamelCase}/${componentName}WebPart.ts`;
            const codeFile = await fs_extra_1.default.readFile(webpartFile, "utf8");
            let codeString = codeFile.toString();
            codeString = codeString.replace(`  protected get dataVersion(): Version {\r\n    return Version.parse('1.0');\r\n  }\r\n\r\n`, ``);
            codeString = codeString.replace(`import { Version } from '@microsoft/sp-core-library';\r\n`, ``);
            await fs_extra_1.default.writeFile(webpartFile, codeString);
            // remove .vscode
            const debugPath = `${newPath}/.vscode`;
            if (await fs_extra_1.default.pathExists(debugPath)) {
                await fs_extra_1.default.remove(debugPath);
            }
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(true));
            return teamsfx_api_1.ok(componentId);
        }
        catch (error) {
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(false));
            return teamsfx_api_1.err(error_2.ScaffoldError(error));
        }
    }
    static async getSolutionName(spfxFolder) {
        const yoInfoPath = path.join(spfxFolder, ".yo-rc.json");
        if (await fs_extra_1.default.pathExists(yoInfoPath)) {
            const yoInfo = await fs_extra_1.default.readJson(yoInfoPath);
            if (yoInfo["@microsoft/generator-sharepoint"]) {
                return yoInfo["@microsoft/generator-sharepoint"][constants_2.Constants.YO_RC_SOLUTION_NAME];
            }
        }
        else {
            throw new error_1.FileNotFoundError(constants_2.Constants.PLUGIN_NAME, yoInfoPath, constants_2.Constants.IMPORT_HELP_LINK);
        }
        return undefined;
    }
    static async copySPFxSolution(src, dest) {
        try {
            await fs_extra_1.default.ensureDir(dest);
            await fs_extra_1.default.copy(src, dest, {
                overwrite: true,
                recursive: true,
                filter: (file) => {
                    return file.indexOf("node_modules") < 0;
                },
            });
        }
        catch (e) {
            throw error_2.CopyExistingSPFxSolutionError(e);
        }
    }
    static async getWebpartManifest(spfxFolder) {
        const webpartsDir = path.join(spfxFolder, "src", "webparts");
        if (await fs_extra_1.default.pathExists(webpartsDir)) {
            const webparts = (await fs_extra_1.default.readdir(webpartsDir)).filter((file) => fs_extra_1.default.statSync(path.join(webpartsDir, file)).isDirectory());
            if (webparts.length < 1) {
                return undefined;
            }
            const webpartName = webparts[0].split(path.sep).pop();
            const webpartManifestPath = path.join(webpartsDir, webparts[0], `${webpartName}WebPart.manifest.json`);
            if (!(await fs_extra_1.default.pathExists(webpartManifestPath))) {
                throw new error_1.FileNotFoundError(constants_2.Constants.PLUGIN_NAME, webpartManifestPath, constants_2.Constants.IMPORT_HELP_LINK);
            }
            const matchHashComment = new RegExp(/(\/\/ .*)/, "gi");
            const manifest = JSON.parse((await fs_extra_1.default.readFile(webpartManifestPath, "utf8"))
                .toString()
                .replace(matchHashComment, "")
                .trim());
            return manifest;
        }
        return undefined;
    }
    static async updateSPFxTemplate(spfxFolder, destinationPath, importDetails) {
        var _a, _b;
        try {
            importDetails.push(`(.) Processing: Loading manifest.local.json...`);
            const localManifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(path.join(destinationPath, teamsfx_api_1.AppPackageFolderName, "manifest.local.json"));
            if (localManifestRes.isErr())
                throw localManifestRes.error;
            const localManifest = localManifestRes.value;
            importDetails.push(`(√) Done: Succeeded to load manifest.local.json.`);
            importDetails.push(`(.) Processing: Loading manifest.json...`);
            const remoteManifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(path.join(destinationPath, teamsfx_api_1.AppPackageFolderName, "manifest.json"));
            if (remoteManifestRes.isErr())
                throw remoteManifestRes.error;
            let remoteManifest = remoteManifestRes.value;
            importDetails.push(`(√) Done: Succeeded to load manifest.json.`);
            const webpartsDir = path.join(spfxFolder, "src", "webparts");
            const webparts = (await fs_extra_1.default.readdir(webpartsDir)).filter((file) => fs_extra_1.default.statSync(path.join(webpartsDir, file)).isDirectory());
            if (webparts.length > 1) {
                importDetails.push(`(.) Processing: There're multiple web parts in the SPFx solution, exposing each of them in Teams manifest...`);
                for (let i = 1; i < webparts.length; i++) {
                    const webpart = webparts[i];
                    const webpartManifestPath = path.join(webpartsDir, webpart, `${webpart.split(path.sep).pop()}WebPart.manifest.json`);
                    if (!(await fs_extra_1.default.pathExists(webpartManifestPath))) {
                        importDetails.push(` [${i}] Web part manifest doesn't exist at ${webpartManifestPath}, skip...`);
                        continue;
                    }
                    const matchHashComment = new RegExp(/(\/\/ .*)/, "gi");
                    const webpartManifest = JSON.parse((await fs_extra_1.default.readFile(webpartManifestPath, "utf8"))
                        .toString()
                        .replace(matchHashComment, "")
                        .trim());
                    importDetails.push(` [${i}] Adding web part to Teams manifest with component id: ${webpartManifest["id"]}, web part name: ${webpartManifest["preconfiguredEntries"][0].title.default}...`);
                    const componentId = webpartManifest["id"];
                    const webpartName = webpartManifest["preconfiguredEntries"][0].title.default;
                    const remoteStaticSnippet = {
                        entityId: componentId,
                        name: webpartName,
                        contentUrl: util.format(constants_2.ManifestTemplate.REMOTE_CONTENT_URL, componentId),
                        websiteUrl: constants_2.ManifestTemplate.WEBSITE_URL,
                        scopes: ["personal"],
                    };
                    const localStaticSnippet = {
                        entityId: componentId,
                        name: webpartName,
                        contentUrl: util.format(constants_2.ManifestTemplate.LOCAL_CONTENT_URL, componentId),
                        websiteUrl: constants_2.ManifestTemplate.WEBSITE_URL,
                        scopes: ["personal"],
                    };
                    (_a = localManifest.staticTabs) === null || _a === void 0 ? void 0 : _a.push(localStaticSnippet);
                    (_b = remoteManifest.staticTabs) === null || _b === void 0 ? void 0 : _b.push(remoteStaticSnippet);
                }
                importDetails.push(`(√) Done: Succeeded to expose additional web parts in Teams manifest.`);
            }
            if (await fs_extra_1.default.pathExists(path.join(spfxFolder, "teams", "manifest.json"))) {
                importDetails.push(`(.) Processing: There's existing Teams manifest under ${path.join(spfxFolder, "teams", "manifest.json")}, updating default template...`);
                const existingManifest = await fs_extra_1.default.readJson(path.join(spfxFolder, "teams", "manifest.json"));
                importDetails.push(`(.) Processing: Writing existing app id in manifest.json to TEAMS_APP_ID in env.dev...`);
                await envUtil_1.envUtil.writeEnv(destinationPath, "dev", { TEAMS_APP_ID: existingManifest.id });
                importDetails.push(`(√) Done: Succeeded to write existing app id to env.dev.`);
                importDetails.push(`(.) Processing: Updating default manifest with existing one...`);
                existingManifest.$schema = remoteManifest.$schema;
                existingManifest.manifestVersion = remoteManifest.manifestVersion;
                existingManifest.id = remoteManifest.id;
                existingManifest.icons = remoteManifest.icons;
                existingManifest.staticTabs = remoteManifest.staticTabs;
                existingManifest.configurableTabs = remoteManifest.configurableTabs;
                remoteManifest = existingManifest;
            }
            // Truncate manifest app name if exceed limitation
            localManifest.name.short = utils_1.Utils.truncateAppShortName(localManifest.name.short);
            remoteManifest.name.short = utils_1.Utils.truncateAppShortName(remoteManifest.name.short);
            importDetails.push(`(.) Processing: Writing to save changes to manifest.local.json...`);
            await ManifestUtils_1.manifestUtils._writeAppManifest(localManifest, path.join(destinationPath, teamsfx_api_1.AppPackageFolderName, "manifest.local.json"));
            importDetails.push(`(√) Done: Succeeded to write manifest.local.json.`);
            importDetails.push(`(.) Processing: Writing to save changes to manifest.json...`);
            await ManifestUtils_1.manifestUtils._writeAppManifest(remoteManifest, path.join(destinationPath, teamsfx_api_1.AppPackageFolderName, "manifest.json"));
            importDetails.push(`(√) Done: Succeeded to write manifest.json.`);
            let colorUpdated = false, outlineUpdated = false;
            if (await fs_extra_1.default.pathExists(path.join(spfxFolder, "teams"))) {
                for (const file of await fs_extra_1.default.readdir(path.join(spfxFolder, "teams"))) {
                    if (file.endsWith("color.png") && !colorUpdated) {
                        importDetails.push(`(.) Processing: Updating color.png with existing ${path.join(spfxFolder, "teams", file)}`);
                        await fs_extra_1.default.copyFile(path.join(spfxFolder, "teams", file), path.join(destinationPath, teamsfx_api_1.AppPackageFolderName, "color.png"));
                        colorUpdated = true;
                        importDetails.push(`(√) Done: Succeeded to update color.png.`);
                    }
                    if (file.endsWith("outline.png") && !outlineUpdated) {
                        importDetails.push(`(.) Processing: Updating outline.png with existing ${path.join(spfxFolder, "teams", file)}`);
                        await fs_extra_1.default.copyFile(path.join(spfxFolder, "teams", file), path.join(destinationPath, teamsfx_api_1.AppPackageFolderName, "outline.png"));
                        outlineUpdated = true;
                        importDetails.push(`(√) Done: Succeeded to update outline.png.`);
                    }
                }
            }
        }
        catch (e) {
            throw error_2.UpdateSPFxTemplateError(e);
        }
    }
}
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: constants_2.Constants.PLUGIN_DEV_NAME,
            telemetryEventName: telemetryEvents_1.TelemetryEvents.Generate,
            errorSource: constants_2.Constants.PLUGIN_DEV_NAME,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], SPFxGenerator, "generate", null);
exports.SPFxGenerator = SPFxGenerator;
//# sourceMappingURL=spfxGenerator.js.map