"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToLangKey = exports.runWithLimitedConcurrency = exports.parseSampleUrl = exports.downloadDirectory = exports.zipFolder = exports.getSampleInfoFromName = exports.renderTemplateFileName = exports.renderTemplateFileData = exports.unzip = exports.fetchZipFromUrl = exports.fetchTemplateZipUrl = exports.sendRequestWithTimeout = exports.sendRequestWithRetry = void 0;
const tslib_1 = require("tslib");
const mustache_1 = tslib_1.__importStar(require("mustache"));
const path_1 = tslib_1.__importDefault(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const constant_1 = require("./constant");
const samples_1 = require("../../common/samples");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const axios_1 = tslib_1.__importDefault(require("axios"));
const templates_config_json_1 = tslib_1.__importDefault(require("../../common/templates-config.json"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const error_1 = require("./error");
const tools_1 = require("../../common/tools");
const error_2 = require("../../core/error");
const question_1 = require("../../question");
async function selectTemplateTag(getTags) {
    const preRelease = process.env.TEAMSFX_TEMPLATE_PRERELEASE
        ? `0.0.0-${process.env.TEAMSFX_TEMPLATE_PRERELEASE}`
        : "";
    const templateVersion = templates_config_json_1.default.version;
    const templateTagPrefix = templates_config_json_1.default.tagPrefix;
    const useLocal = templates_config_json_1.default.useLocalTemplate;
    const versionPattern = preRelease || templateVersion;
    if (useLocal.toString() === "true") {
        throw new error_1.CancelDownloading();
    }
    const versionList = (await getTags()).map((tag) => tag.replace(templateTagPrefix, ""));
    const selectedVersion = semver_1.default.maxSatisfying(versionList, versionPattern);
    return selectedVersion ? templateTagPrefix + selectedVersion : undefined;
}
async function sendRequestWithRetry(requestFn, tryLimits) {
    var _a;
    // !status means network error, see https://github.com/axios/axios/issues/383
    const canTry = (status) => !status || (status >= 500 && status < 600);
    let status;
    let error;
    for (let i = 0; i < tryLimits && canTry(status); i++) {
        try {
            const res = await requestFn();
            if (res.status === 200 || res.status === 201) {
                return res;
            }
            else {
                error = new Error(`HTTP Request failed: ${JSON.stringify(res)}`);
            }
            status = res.status;
        }
        catch (e) {
            error = e;
            status = (_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.status;
        }
    }
    error !== null && error !== void 0 ? error : (error = new Error(`RequestWithRetry got bad tryLimits: ${tryLimits}`));
    throw error;
}
exports.sendRequestWithRetry = sendRequestWithRetry;
async function sendRequestWithTimeout(requestFn, timeoutInMs, tryLimits = 1) {
    const source = axios_1.default.CancelToken.source();
    const timeout = setTimeout(() => {
        source.cancel();
    }, timeoutInMs);
    try {
        const res = await sendRequestWithRetry(() => requestFn(source.token), tryLimits);
        clearTimeout(timeout);
        return res;
    }
    catch (err) {
        if (axios_1.default.isCancel(err)) {
            throw new Error("Request timeout");
        }
        throw err;
    }
}
exports.sendRequestWithTimeout = sendRequestWithTimeout;
async function fetchTagList(url, tryLimits, timeoutInMs) {
    const res = await sendRequestWithTimeout(async (cancelToken) => {
        return await axios_1.default.get(url, {
            cancelToken: cancelToken,
        });
    }, timeoutInMs, tryLimits);
    return res.data;
}
async function fetchTemplateZipUrl(name, tryLimits = constant_1.defaultTryLimits, timeoutInMs = constant_1.defaultTimeoutInMs) {
    const templateTagListURL = templates_config_json_1.default.tagListURL;
    const selectedTag = await selectTemplateTag(async () => (await fetchTagList(templateTagListURL, tryLimits, timeoutInMs)).replace(/\r/g, "").split("\n"));
    if (!selectedTag) {
        throw new Error(`Failed to find valid template for ${name}`);
    }
    return `${templates_config_json_1.default.templateDownloadBaseURL}/${selectedTag}/${name}.zip`;
}
exports.fetchTemplateZipUrl = fetchTemplateZipUrl;
async function fetchZipFromUrl(url, tryLimits = constant_1.defaultTryLimits, timeoutInMs = constant_1.defaultTimeoutInMs) {
    const res = await sendRequestWithRetry(async () => {
        return await axios_1.default.get(url, {
            responseType: "arraybuffer",
            timeout: timeoutInMs,
        });
    }, tryLimits);
    const zip = new adm_zip_1.default(res.data);
    return zip;
}
exports.fetchZipFromUrl = fetchZipFromUrl;
/* The unzip used for scaffold which would drop the attr of the files and dirs. */
async function unzip(zip, dstPath, nameReplaceFn, dataReplaceFn, filterFn) {
    const output = [];
    let entries = zip.getEntries().filter((entry) => !entry.isDirectory);
    if (filterFn) {
        entries = entries.filter((entry) => filterFn(entry.entryName));
    }
    for (const entry of entries) {
        const rawEntryData = entry.getData();
        const entryName = nameReplaceFn
            ? nameReplaceFn(entry.entryName, rawEntryData)
            : entry.entryName;
        const entryData = dataReplaceFn
            ? dataReplaceFn(entry.name, rawEntryData)
            : rawEntryData;
        const filePath = path_1.default.join(dstPath, entryName);
        const dirPath = path_1.default.dirname(filePath);
        await fs.ensureDir(dirPath);
        await fs.writeFile(filePath, entryData);
        output.push(entryName);
    }
    return output;
}
exports.unzip = unzip;
function renderTemplateFileData(fileName, fileData, variables) {
    //only mustache files with name ending with .tpl
    if (path_1.default.extname(fileName) === constant_1.templateFileExt) {
        const token = escapeEmptyVariable(fileData.toString(), variables !== null && variables !== void 0 ? variables : {});
        const writer = new mustache_1.Writer();
        const result = writer.renderTokens(token, new mustache_1.Context(variables));
        // Be compatible with current stable templates, can be removed after new template released.
        return mustache_1.default.render(result, variables, {}, constant_1.oldPlaceholderDelimiters);
    }
    // Return Buffer instead of string if the file is not a template. Because `toString()` may break binary resources, like png files.
    return fileData;
}
exports.renderTemplateFileData = renderTemplateFileData;
function escapeEmptyVariable(template, view, tags = constant_1.placeholderDelimiters) {
    const parsed = mustache_1.default.parse(template, tags);
    const tokens = tools_1.deepCopy(parsed); // Mustache cache the parsed result. Modify the result in place may cause unexpected issue.
    let accShift = 0;
    const shift = tags[0].length + tags[1].length;
    // token: [Type, Value, Start, End]
    for (const token of tokens) {
        token[2] += accShift;
        const value = token[1];
        if (token[0] === "name" && (view[value] === undefined || view[value] === null)) {
            token[0] = "text";
            token[1] = tags[0] + value + tags[1];
            accShift += shift;
        }
        token[3] += accShift;
    }
    return tokens;
}
function renderTemplateFileName(fileName, fileData, variables) {
    return mustache_1.default.render(fileName, variables, {}, constant_1.placeholderDelimiters).replace(constant_1.templateFileExt, "");
}
exports.renderTemplateFileName = renderTemplateFileName;
function getSampleInfoFromName(sampleName) {
    const sample = samples_1.sampleProvider.SampleCollection.samples.find((sample) => sample.id.toLowerCase() === sampleName.toLowerCase());
    if (!sample) {
        throw error_2.InvalidInputError(`sample '${sampleName}' not found`);
    }
    return sample;
}
exports.getSampleInfoFromName = getSampleInfoFromName;
function zipFolder(folderPath) {
    const zip = new adm_zip_1.default();
    zip.addLocalFolder(folderPath);
    return zip;
}
exports.zipFolder = zipFolder;
async function downloadDirectory(sampleInfo, dstPath, concurrencyLimits = constant_1.sampleConcurrencyLimits, retryLimits = constant_1.sampleDefaultRetryLimits) {
    const { samplePaths, fileUrlPrefix } = await getSampleFileInfo(sampleInfo, retryLimits);
    await downloadSampleFiles(fileUrlPrefix, samplePaths, dstPath, sampleInfo.dir, retryLimits, concurrencyLimits);
    return samplePaths;
}
exports.downloadDirectory = downloadDirectory;
function parseSampleUrl(url) {
    const urlParserRegex = /https:\/\/github.com\/([^/]+)\/([^/]+)\/tree\/([^/]+)[/](.*)/;
    const parsed = urlParserRegex.exec(url);
    if (!parsed)
        throw new error_1.ParseUrlError(url);
    const [owner, repository, ref, dir] = parsed.slice(1);
    return { owner, repository, ref, dir };
}
exports.parseSampleUrl = parseSampleUrl;
async function getSampleFileInfo(urlInfo, retryLimits) {
    var _a;
    const fileInfoUrl = `https://api.github.com/repos/${urlInfo.owner}/${urlInfo.repository}/git/trees/${urlInfo.ref}?recursive=1`;
    const fileInfo = (await sendRequestWithRetry(async () => {
        return await axios_1.default.get(fileInfoUrl);
    }, retryLimits)).data;
    const samplePaths = (_a = fileInfo === null || fileInfo === void 0 ? void 0 : fileInfo.tree) === null || _a === void 0 ? void 0 : _a.filter((node) => node.path.startsWith(`${urlInfo.dir}/`) && node.type !== "tree").map((node) => node.path);
    const fileUrlPrefix = `https://raw.githubusercontent.com/${urlInfo.owner}/${urlInfo.repository}/${fileInfo === null || fileInfo === void 0 ? void 0 : fileInfo.sha}/`;
    return { samplePaths, fileUrlPrefix };
}
async function downloadSampleFiles(fileUrlPrefix, samplePaths, dstPath, relativePath, retryLimits, concurrencyLimits) {
    const downloadCallback = async (samplePath) => {
        const file = (await sendRequestWithRetry(async () => {
            return await axios_1.default.get(fileUrlPrefix + samplePath, { responseType: "arraybuffer" });
        }, retryLimits));
        const filePath = path_1.default.join(dstPath, path_1.default.relative(`${relativePath}/`, samplePath));
        await fs.ensureFile(filePath);
        await fs.writeFile(filePath, Buffer.from(file.data));
    };
    await runWithLimitedConcurrency(samplePaths, downloadCallback, concurrencyLimits);
}
async function runWithLimitedConcurrency(items, callback, concurrencyLimit) {
    const queue = [];
    for (const item of items) {
        // fire the async function, add its promise to the queue, and remove
        // it from queue when complete
        const p = callback(item)
            .then((res) => {
            queue.splice(queue.indexOf(p), 1);
            return res;
        })
            .catch((err) => {
            throw err;
        });
        queue.push(p);
        // if max concurrent, wait for one to finish
        if (queue.length >= concurrencyLimit) {
            await Promise.race(queue);
        }
    }
    // wait for the rest of the calls to finish
    await Promise.all(queue);
}
exports.runWithLimitedConcurrency = runWithLimitedConcurrency;
function convertToLangKey(programmingLanguage) {
    switch (programmingLanguage) {
        case question_1.ProgrammingLanguage.JS: {
            return "js";
        }
        case question_1.ProgrammingLanguage.TS: {
            return "ts";
        }
        case question_1.ProgrammingLanguage.CSharp: {
            return "csharp";
        }
    }
    return programmingLanguage;
}
exports.convertToLangKey = convertToLangKey;
//# sourceMappingURL=utils.js.map