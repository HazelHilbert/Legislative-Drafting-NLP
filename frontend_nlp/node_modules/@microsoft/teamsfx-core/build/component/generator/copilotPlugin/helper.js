"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatValidationErrors = exports.isYamlSpecFile = exports.convertSpecParserErrorToFxError = exports.generateScaffoldingSummary = exports.logValidationResults = exports.listOperations = exports.OpenAIPluginManifestHelper = exports.specParserGenerateResultWarningsTelemetryProperty = exports.specParserGenerateResultAllSuccessTelemetryProperty = exports.specParserGenerateResultTelemetryEvent = void 0;
const tslib_1 = require("tslib");
/**
 * @author yuqzho@microsoft.com
 */
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const axios_1 = tslib_1.__importDefault(require("axios"));
const utils_1 = require("../utils");
const spec_parser_1 = require("../../../common/spec-parser");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const localizeUtils_1 = require("../../../common/localizeUtils");
const error_1 = require("../../../error");
const os_1 = require("os");
const constant_1 = require("../../configManager/constant");
const ManifestUtils_1 = require("../../driver/teamsApp/utils/ManifestUtils");
const path_1 = tslib_1.__importDefault(require("path"));
const featureFlags_1 = require("../../../common/featureFlags");
const manifestFilePath = "/.well-known/ai-plugin.json";
const componentName = "OpenAIPluginManifestHelper";
var OpenAIPluginManifestErrorType;
(function (OpenAIPluginManifestErrorType) {
    OpenAIPluginManifestErrorType["AuthNotSupported"] = "openai-pliugin-auth-not-supported";
    OpenAIPluginManifestErrorType["ApiUrlMissing"] = "openai-plugin-api-url-missing";
})(OpenAIPluginManifestErrorType || (OpenAIPluginManifestErrorType = {}));
exports.specParserGenerateResultTelemetryEvent = "spec-parser-generate-result";
exports.specParserGenerateResultAllSuccessTelemetryProperty = "all-success";
exports.specParserGenerateResultWarningsTelemetryProperty = "warnings";
class OpenAIPluginManifestHelper {
    static async loadOpenAIPluginManifest(input) {
        input = input.trim();
        let path = input.endsWith("/") ? input.substring(0, input.length - 1) : input;
        if (!input.toLowerCase().endsWith(manifestFilePath)) {
            path = path + manifestFilePath;
        }
        if (!input.toLowerCase().startsWith("https://") && !input.toLowerCase().startsWith("http://")) {
            path = "https://" + path;
        }
        try {
            const res = await utils_1.sendRequestWithRetry(async () => {
                return await axios_1.default.get(path);
            }, 3);
            return res.data;
        }
        catch (e) {
            throw new teamsfx_api_1.UserError(componentName, "loadOpenAIPluginManifest", localizeUtils_1.getLocalizedString("error.copilotPlugin.openAiPluginManifest.CannotGetManifest", path), localizeUtils_1.getLocalizedString("error.copilotPlugin.openAiPluginManifest.CannotGetManifest", path));
        }
    }
    static async updateManifest(openAiPluginManifest, teamsAppManifest, manifestPath) {
        teamsAppManifest.description.full = openAiPluginManifest.description_for_human;
        teamsAppManifest.description.short = openAiPluginManifest.description_for_human;
        teamsAppManifest.developer.websiteUrl = openAiPluginManifest.legal_info_url;
        teamsAppManifest.developer.privacyUrl = openAiPluginManifest.legal_info_url;
        teamsAppManifest.developer.termsOfUseUrl = openAiPluginManifest.legal_info_url;
        await fs_extra_1.default.writeFile(manifestPath, JSON.stringify(teamsAppManifest, null, "\t"), "utf-8");
        return teamsfx_api_1.ok(undefined);
    }
}
exports.OpenAIPluginManifestHelper = OpenAIPluginManifestHelper;
async function listOperations(context, manifest, apiSpecUrl, teamsManifestPath, includeExistingAPIs = true, shouldLogWarning = true, existingCorrelationId) {
    if (manifest) {
        const errors = validateOpenAIPluginManifest(manifest);
        logValidationResults(errors, [], context, false, shouldLogWarning, false, existingCorrelationId);
        if (errors.length > 0) {
            return teamsfx_api_1.err(errors);
        }
        apiSpecUrl = manifest.api.url;
    }
    try {
        const allowAPIKeyAuth = featureFlags_1.isApiKeyEnabled();
        const specParser = new spec_parser_1.SpecParser(apiSpecUrl, { allowAPIKeyAuth });
        const validationRes = await specParser.validate();
        validationRes.errors = formatValidationErrors(validationRes.errors);
        logValidationResults(validationRes.errors, validationRes.warnings, context, true, shouldLogWarning, false, existingCorrelationId);
        if (validationRes.status === spec_parser_1.ValidationStatus.Error) {
            return teamsfx_api_1.err(validationRes.errors);
        }
        let operations = await specParser.list();
        // Filter out exsiting APIs
        if (!includeExistingAPIs) {
            if (!teamsManifestPath) {
                throw new error_1.MissingRequiredInputError("teamsManifestPath", "inputs");
            }
            const manifest = await ManifestUtils_1.manifestUtils._readAppManifest(teamsManifestPath);
            if (manifest.isOk()) {
                const existingOperationIds = ManifestUtils_1.manifestUtils.getOperationIds(manifest.value);
                const existingOperations = existingOperationIds.map((key) => { var _a; return (_a = operations.find((item) => item.operationId === key)) === null || _a === void 0 ? void 0 : _a.api; });
                operations = operations.filter((operation) => !existingOperations.includes(operation.api));
                // No extra API can be added
                if (operations.length == 0) {
                    const errors = [
                        {
                            type: spec_parser_1.ErrorType.NoExtraAPICanBeAdded,
                            content: localizeUtils_1.getLocalizedString("error.copilotPlugin.noExtraAPICanBeAdded"),
                        },
                    ];
                    logValidationResults(errors, [], context, true, false, false, existingCorrelationId);
                    return teamsfx_api_1.err(errors);
                }
            }
            else {
                throw manifest.error;
            }
        }
        const sortedOperations = sortOperations(operations);
        return teamsfx_api_1.ok(sortedOperations);
    }
    catch (e) {
        if (e instanceof spec_parser_1.SpecParserError) {
            throw convertSpecParserErrorToFxError(e);
        }
        else {
            throw e;
        }
    }
}
exports.listOperations = listOperations;
function sortOperations(operations) {
    const operationsWithSeparator = [];
    for (const operation of operations) {
        const arr = operation.api.toUpperCase().split(" ");
        const result = {
            id: operation.api,
            label: operation.api,
            groupName: arr[0],
            data: {
                serverUrl: operation.server,
            },
        };
        if (operation.auth) {
            result.data.authName = operation.auth.name;
        }
        operationsWithSeparator.push(result);
    }
    return operationsWithSeparator.sort((operation1, operation2) => {
        const arr1 = operation1.id.toLowerCase().split(" ");
        const arr2 = operation2.id.toLowerCase().split(" ");
        return arr1[0] < arr2[0] ? -1 : arr1[0] > arr2[0] ? 1 : arr1[1].localeCompare(arr2[1]);
    });
}
function formatTelemetryValidationProperty(result) {
    return result.type.toString() + ": " + result.content;
}
function logValidationResults(errors, warnings, context, isApiSpec, shouldLogWarning, shouldSkipTelemetry, existingCorrelationId) {
    if (!shouldSkipTelemetry) {
        const properties = {
            ["validation-status" /* validationStatus */]: errors.length !== 0 ? "error" : warnings.length !== 0 ? "warning" : "success",
            ["validation-errors" /* validationErrors */]: errors
                .map((error) => formatTelemetryValidationProperty(error))
                .join(";"),
            ["validation-warnings" /* validationWarnings */]: warnings
                .map((warn) => formatTelemetryValidationProperty(warn))
                .join(";"),
        };
        if (existingCorrelationId) {
            properties["correlation-id"] = existingCorrelationId;
        }
        context.telemetryReporter.sendTelemetryEvent(isApiSpec ? "validate-api-spec" /* validateApiSpec */ : "validate-openai-plugin-manifest" /* validateOpenAiPluginManifest */, properties);
    }
    if (errors.length === 0 && (warnings.length === 0 || !shouldLogWarning)) {
        return;
    }
    // errors > 0 || (warnings > 0 && shouldLogWarning)
    const errorMessage = errors
        .map((error) => {
        return `${constant_1.SummaryConstant.Failed} ${error.content}`;
    })
        .join(os_1.EOL);
    const warningMessage = shouldLogWarning
        ? warnings
            .map((warning) => {
            return `${constant_1.SummaryConstant.NotExecuted} ${warning.content}`;
        })
            .join(os_1.EOL)
        : "";
    const failed = errors.length;
    const warns = warnings.length;
    const summaryStr = [];
    if (failed > 0) {
        summaryStr.push(localizeUtils_1.getLocalizedString("core.copilotPlugin.validate.summary.validate.failed", failed));
    }
    if (warns > 0 && shouldLogWarning) {
        summaryStr.push(localizeUtils_1.getLocalizedString("core.copilotPlugin.validate.summary.validate.warning", warns));
    }
    const outputMessage = isApiSpec
        ? os_1.EOL +
            localizeUtils_1.getLocalizedString("core.copilotPlugin.validate.apiSpec.summary", summaryStr.join(", "), errorMessage, warningMessage)
        : os_1.EOL +
            localizeUtils_1.getLocalizedString("core.copilotPlugin.validate.openAIPluginManifest.summary", summaryStr.join(", "), errorMessage, warningMessage);
    void context.logProvider.info(outputMessage);
}
exports.logValidationResults = logValidationResults;
function validateOpenAIPluginManifest(manifest) {
    var _a, _b;
    const errors = [];
    if (!((_a = manifest.api) === null || _a === void 0 ? void 0 : _a.url)) {
        errors.push({
            type: OpenAIPluginManifestErrorType.ApiUrlMissing,
            content: localizeUtils_1.getLocalizedString("core.createProjectQuestion.openAiPluginManifest.validationError.missingApiUrl", "api.url"),
        });
    }
    if (((_b = manifest.auth) === null || _b === void 0 ? void 0 : _b.type) !== teamsfx_api_1.OpenAIManifestAuthType.None) {
        errors.push({
            type: OpenAIPluginManifestErrorType.AuthNotSupported,
            content: localizeUtils_1.getLocalizedString("core.createProjectQuestion.openAiPluginManifest.validationError.authNotSupported", "none"),
        });
    }
    return errors;
}
function generateScaffoldingSummary(warnings, teamsManifest, projectPath) {
    var _a;
    const apiSpecFileName = ((_a = teamsManifest.composeExtensions) === null || _a === void 0 ? void 0 : _a.length) &&
        teamsManifest.composeExtensions[0].apiSpecificationFile
        ? teamsManifest.composeExtensions[0].apiSpecificationFile
        : "";
    const apiSpecWarningMessage = formatApiSpecValidationWarningMessage(warnings, path_1.default.join(teamsfx_api_1.AppPackageFolderName, apiSpecFileName));
    const manifestWarningResult = validateTeamsManifestLength(teamsManifest, projectPath, warnings);
    const manifestWarningMessage = manifestWarningResult.map((warn) => {
        return `${constant_1.SummaryConstant.NotExecuted} ${warn}`;
    });
    if (apiSpecWarningMessage.length || manifestWarningMessage.length) {
        let details = "";
        if (apiSpecWarningMessage.length) {
            details += os_1.EOL + apiSpecWarningMessage.join(os_1.EOL);
        }
        if (manifestWarningMessage.length) {
            details += os_1.EOL + manifestWarningMessage.join(os_1.EOL);
        }
        return localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary", details);
    }
    else {
        return "";
    }
}
exports.generateScaffoldingSummary = generateScaffoldingSummary;
function formatApiSpecValidationWarningMessage(specWarnings, apiSpecFileName) {
    const resultWarnings = [];
    const operationIdWarning = specWarnings.find((w) => w.type === spec_parser_1.WarningType.OperationIdMissing);
    if (operationIdWarning) {
        resultWarnings.push(localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.operationId", `${constant_1.SummaryConstant.NotExecuted} ${operationIdWarning.content}`, teamsfx_api_1.ManifestTemplateFileName));
    }
    const swaggerWarning = specWarnings.find((w) => w.type === spec_parser_1.WarningType.ConvertSwaggerToOpenAPI);
    if (swaggerWarning) {
        resultWarnings.push(`${constant_1.SummaryConstant.NotExecuted} ` +
            localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.swaggerVersion", apiSpecFileName));
    }
    return resultWarnings;
}
function validateTeamsManifestLength(teamsManifest, projectPath, warnings) {
    var _a, _b, _c, _d, _e;
    const nameShortLimit = 30;
    const nameFullLimit = 100;
    const descriptionShortLimit = 80;
    const descriptionFullLimit = 4000;
    const appnameSuffixPlaceholder = "${{APP_NAME_SUFFIX}}";
    const devEnv = "dev";
    const resultWarnings = [];
    // validate name
    const shortNameLength = teamsManifest.name.short.includes(appnameSuffixPlaceholder)
        ? teamsManifest.name.short.length - appnameSuffixPlaceholder.length + devEnv.length
        : teamsManifest.name.short.length;
    if (shortNameLength > nameShortLimit) {
        resultWarnings.push(formatLengthExceedingErrorMessage("/name/short", nameShortLimit));
    }
    if (!!teamsManifest.name.full && ((_a = teamsManifest.name.full) === null || _a === void 0 ? void 0 : _a.length) > nameFullLimit) {
        resultWarnings.push(formatLengthExceedingErrorMessage("/name/full", nameFullLimit));
    }
    // validate description
    if (teamsManifest.description.short.length > descriptionShortLimit) {
        resultWarnings.push(formatLengthExceedingErrorMessage("/description/short", descriptionShortLimit));
    }
    if (!((_b = teamsManifest.description.full) === null || _b === void 0 ? void 0 : _b.length)) {
        resultWarnings.push(localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.teamsManifest.missingFullDescription") +
            localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.teamsManifest.mitigation", "full/description", path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName)));
    }
    if (teamsManifest.description.full.length > descriptionFullLimit) {
        resultWarnings.push(formatLengthExceedingErrorMessage("/description/full", descriptionFullLimit));
    }
    // validate command
    if (teamsfx_api_1.ManifestUtil.parseCommonProperties(teamsManifest).isApiME) {
        const optionalParamsOnlyWarnings = warnings.filter((o) => o.type === spec_parser_1.WarningType.OperationOnlyContainsOptionalParam);
        const commands = teamsManifest.composeExtensions[0].commands;
        if (optionalParamsOnlyWarnings) {
            for (const optionalParamsOnlyWarning of optionalParamsOnlyWarnings) {
                const command = commands.find((o) => o.id === optionalParamsOnlyWarning.data);
                if (command && command.parameters) {
                    const parameterName = (_c = command.parameters[0]) === null || _c === void 0 ? void 0 : _c.name;
                    resultWarnings.push(localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.api.optionalParametersOnly", optionalParamsOnlyWarning.data, optionalParamsOnlyWarning.data) +
                        localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.api.optionalParametersOnly.mitigation", parameterName, optionalParamsOnlyWarning.data, path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName), path_1.default.join(teamsfx_api_1.AppPackageFolderName, (_d = teamsManifest.composeExtensions[0].apiSpecificationFile) !== null && _d !== void 0 ? _d : "")));
                }
            }
        }
        for (const command of commands) {
            if (command.type === "query") {
                if (!command.apiResponseRenderingTemplateFile) {
                    const errorDetail = (_e = warnings.find((w) => w.type === spec_parser_1.WarningType.GenerateCardFailed && w.data === command.id)) === null || _e === void 0 ? void 0 : _e.content;
                    resultWarnings.push(localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.teamsManifest.missingCardTemlate", "apiResponseRenderingTemplateFile", command.id) +
                        localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.teamsManifest.missingCardTemlate.mitigation", teamsfx_api_1.AppPackageFolderName, `composeExtensions/commands/${command.id}/apiResponseRenderingTemplateFile`, path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName)) +
                        (errorDetail ? os_1.EOL + errorDetail : ""));
                }
            }
        }
    }
    return resultWarnings;
}
function formatLengthExceedingErrorMessage(field, limit) {
    return (localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.teamsManifest.lengthExceeding", field, limit.toString()) +
        localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.teamsManifest.mitigation", field, path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName)));
}
function convertSpecParserErrorToFxError(error) {
    return new teamsfx_api_1.SystemError("SpecParser", error.errorType.toString(), error.message, error.message);
}
exports.convertSpecParserErrorToFxError = convertSpecParserErrorToFxError;
async function isYamlSpecFile(specPath) {
    if (specPath.endsWith(".yaml") || specPath.endsWith(".yml")) {
        return true;
    }
    else if (specPath.endsWith(".json")) {
        return false;
    }
    const isRemoteFile = specPath.startsWith("http:") || specPath.startsWith("https:");
    const fileContent = isRemoteFile
        ? (await axios_1.default.get(specPath)).data
        : await fs_extra_1.default.readFile(specPath, "utf-8");
    try {
        JSON.parse(fileContent);
        return false;
    }
    catch (error) {
        return true;
    }
}
exports.isYamlSpecFile = isYamlSpecFile;
function formatValidationErrors(errors) {
    return errors.map((error) => {
        return {
            type: error.type,
            content: formatValidationErrorContent(error),
            data: error.data,
        };
    });
}
exports.formatValidationErrors = formatValidationErrors;
function formatValidationErrorContent(error) {
    try {
        switch (error.type) {
            case spec_parser_1.ErrorType.SpecNotValid: {
                let content = error.content;
                if (error.content.startsWith("ResolverError: Error downloading")) {
                    content = error.content
                        .split("\n")
                        .map((o) => o.trim())
                        .join(". ");
                    content = `${content}. ${localizeUtils_1.getLocalizedString("core.common.ErrorFetchApiSpec")}`;
                }
                return content;
            }
            case spec_parser_1.ErrorType.RemoteRefNotSupported:
                return localizeUtils_1.getLocalizedString("core.common.RemoteRefNotSupported", error.data.join(", "));
            case spec_parser_1.ErrorType.NoServerInformation:
                return localizeUtils_1.getLocalizedString("core.common.NoServerInformation");
            case spec_parser_1.ErrorType.UrlProtocolNotSupported:
                return localizeUtils_1.getLocalizedString("core.common.UrlProtocolNotSupported", error.data);
            case spec_parser_1.ErrorType.RelativeServerUrlNotSupported:
                return localizeUtils_1.getLocalizedString("core.common.RelativeServerUrlNotSupported");
            case spec_parser_1.ErrorType.NoSupportedApi:
                return localizeUtils_1.getLocalizedString("core.common.NoSupportedApi");
            case spec_parser_1.ErrorType.NoExtraAPICanBeAdded:
                return localizeUtils_1.getLocalizedString("error.copilotPlugin.noExtraAPICanBeAdded");
            case spec_parser_1.ErrorType.ResolveServerUrlFailed:
                return error.content;
            case spec_parser_1.ErrorType.Cancelled:
                return localizeUtils_1.getLocalizedString("core.common.CancelledMessage");
            case spec_parser_1.ErrorType.SwaggerNotSupported:
                return localizeUtils_1.getLocalizedString("core.common.SwaggerNotSupported");
            default:
                return error.content;
        }
    }
    catch (e) {
        return error.content;
    }
}
//# sourceMappingURL=helper.js.map