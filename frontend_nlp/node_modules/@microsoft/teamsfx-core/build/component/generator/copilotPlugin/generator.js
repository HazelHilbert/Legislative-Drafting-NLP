"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CopilotPluginGenerator = void 0;
const tslib_1 = require("tslib");
/**
 * @author yuqzho@microsoft.com
 */
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const generator_1 = require("../generator");
const path_1 = tslib_1.__importDefault(require("path"));
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const telemetryEvents_1 = require("../spfx/utils/telemetryEvents");
const questionNames_1 = require("../../../question/questionNames");
const helper_1 = require("./helper");
const localizeUtils_1 = require("../../../common/localizeUtils");
const ManifestUtils_1 = require("../../driver/teamsApp/utils/ManifestUtils");
const create_1 = require("../../../question/create");
const fs = tslib_1.__importStar(require("fs-extra"));
const error_1 = require("../../../error");
const spec_parser_1 = require("../../../common/spec-parser");
const util = tslib_1.__importStar(require("util"));
const util_1 = require("../../../question/util");
const featureFlags_1 = require("../../../common/featureFlags");
const fromApiSpecComponentName = "copilot-plugin-existing-api";
const fromApiSpecTemplateName = "copilot-plugin-existing-api";
const fromApiSpecWithApiKeyComponentName = "copilot-plugin-existing-api-api-key";
const fromApiSpecWithApiKeyTemplateName = "copilot-plugin-existing-api-api-key";
const fromOpenAIPlugincomponentName = "copilot-plugin-from-oai-plugin";
const fromOpenAIPluginTemplateName = "copilot-plugin-from-oai-plugin";
const apiSpecFolderName = "apiSpecificationFiles";
const apiSpecYamlFileName = "openapi.yaml";
const apiSpecJsonFileName = "openapi.json";
const invalidApiSpecErrorName = "invalid-api-spec";
const copilotPluginExistingApiSpecUrlTelemetryEvent = "copilot-plugin-existing-api-spec-url";
const isRemoteUrlTelemetryProperty = "remote-url";
function normalizePath(path) {
    return "./" + path.replace(/\\/g, "/");
}
class CopilotPluginGenerator {
    static async generateFromApiSpec(context, inputs, destinationPath) {
        const apiOperations = inputs[questionNames_1.QuestionNames.ApiOperation];
        const authApi = inputs.supportedApisFromApiSpec.find((api) => !!api.data.authName && apiOperations.includes(api.id));
        return await this.generateForME(context, inputs, destinationPath, authApi ? fromApiSpecWithApiKeyTemplateName : fromApiSpecTemplateName, authApi ? fromApiSpecWithApiKeyComponentName : fromApiSpecComponentName, authApi === null || authApi === void 0 ? void 0 : authApi.data);
    }
    static async generateFromOpenAIPlugin(context, inputs, destinationPath) {
        return await this.generateForME(context, inputs, destinationPath, fromOpenAIPluginTemplateName, fromOpenAIPlugincomponentName);
    }
    static async generateForME(context, inputs, destinationPath, templateName, componentName, apiKeyAuthData) {
        var _a, _b;
        try {
            const appName = inputs[questionNames_1.QuestionNames.AppName];
            const language = inputs[questionNames_1.QuestionNames.ProgrammingLanguage];
            const safeProjectNameFromVS = language === "csharp" ? inputs[questionNames_1.QuestionNames.SafeProjectName] : undefined;
            const manifestPath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName);
            const apiSpecFolderPath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, apiSpecFolderName);
            let url = (_a = inputs[questionNames_1.QuestionNames.ApiSpecLocation]) !== null && _a !== void 0 ? _a : (_b = inputs.openAIPluginManifest) === null || _b === void 0 ? void 0 : _b.api.url;
            url = url.trim();
            let isYaml;
            try {
                isYaml = await helper_1.isYamlSpecFile(url);
            }
            catch (e) {
                isYaml = false;
            }
            const openapiSpecFileName = isYaml ? apiSpecYamlFileName : apiSpecJsonFileName;
            const openapiSpecPath = path_1.default.join(apiSpecFolderPath, openapiSpecFileName);
            if (apiKeyAuthData === null || apiKeyAuthData === void 0 ? void 0 : apiKeyAuthData.authName) {
                context.templateVariables = generator_1.Generator.getDefaultVariables(appName, safeProjectNameFromVS, {
                    authName: apiKeyAuthData.authName,
                    openapiSpecPath: normalizePath(path_1.default.join(teamsfx_api_1.AppPackageFolderName, apiSpecFolderName, openapiSpecFileName)),
                    registrationIdEnvName: `${apiKeyAuthData.authName.toUpperCase()}_REGISTRATION_ID`,
                });
            }
            else {
                context.templateVariables = generator_1.Generator.getDefaultVariables(appName, safeProjectNameFromVS);
            }
            const filters = inputs[questionNames_1.QuestionNames.ApiOperation];
            // download template
            const templateRes = await generator_1.Generator.generateTemplate(context, destinationPath, templateName, language === create_1.ProgrammingLanguage.CSharp ? create_1.ProgrammingLanguage.CSharp : undefined);
            if (templateRes.isErr())
                return teamsfx_api_1.err(templateRes.error);
            context.telemetryReporter.sendTelemetryEvent(copilotPluginExistingApiSpecUrlTelemetryEvent, {
                [isRemoteUrlTelemetryProperty]: util_1.isValidHttpUrl(url).toString(),
            });
            // validate API spec
            const allowAPIKeyAuth = featureFlags_1.isApiKeyEnabled();
            const specParser = new spec_parser_1.SpecParser(url, { allowAPIKeyAuth });
            const validationRes = await specParser.validate();
            const warnings = validationRes.warnings;
            const operationIdWarning = warnings.find((w) => w.type === spec_parser_1.WarningType.OperationIdMissing);
            if (operationIdWarning && operationIdWarning.data) {
                const apisMissingOperationId = operationIdWarning.data.filter((api) => filters.includes(api));
                if (apisMissingOperationId.length > 0) {
                    operationIdWarning.content = util.format(localizeUtils_1.getLocalizedString("core.common.MissingOperationId"), apisMissingOperationId.join(", "));
                    delete operationIdWarning.data;
                }
                else {
                    warnings.splice(warnings.indexOf(operationIdWarning), 1);
                }
            }
            const specVersionWarning = warnings.find((w) => w.type === spec_parser_1.WarningType.ConvertSwaggerToOpenAPI);
            if (specVersionWarning) {
                specVersionWarning.content = ""; // We don't care content of this warning
            }
            if (validationRes.status === spec_parser_1.ValidationStatus.Error) {
                helper_1.logValidationResults(validationRes.errors, warnings, context, true, false, true);
                const errorMessage = inputs.platform === teamsfx_api_1.Platform.VSCode
                    ? localizeUtils_1.getLocalizedString("core.createProjectQuestion.apiSpec.multipleValidationErrors.vscode.message")
                    : localizeUtils_1.getLocalizedString("core.createProjectQuestion.apiSpec.multipleValidationErrors.message");
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(componentName, invalidApiSpecErrorName, errorMessage, errorMessage));
            }
            // generate files
            await fs.ensureDir(apiSpecFolderPath);
            const adaptiveCardFolder = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ResponseTemplatesFolderName);
            const generateResult = await specParser.generate(manifestPath, filters, openapiSpecPath, adaptiveCardFolder);
            context.telemetryReporter.sendTelemetryEvent(helper_1.specParserGenerateResultTelemetryEvent, {
                [helper_1.specParserGenerateResultAllSuccessTelemetryProperty]: generateResult.allSuccess.toString(),
                [helper_1.specParserGenerateResultWarningsTelemetryProperty]: generateResult.warnings
                    .map((w) => w.type.toString() + ": " + w.content)
                    .join(";"),
            });
            if (generateResult.warnings.length > 0) {
                generateResult.warnings.find((o) => {
                    if (o.type === spec_parser_1.WarningType.OperationOnlyContainsOptionalParam) {
                        o.content = ""; // We don't care content of this warning
                    }
                });
                warnings.push(...generateResult.warnings);
            }
            // update manifest based on openAI plugin manifest
            const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(manifestPath);
            if (manifestRes.isErr()) {
                return teamsfx_api_1.err(manifestRes.error);
            }
            const teamsManifest = manifestRes.value;
            if (inputs.openAIPluginManifest) {
                const updateManifestRes = await helper_1.OpenAIPluginManifestHelper.updateManifest(inputs.openAIPluginManifest, teamsManifest, manifestPath);
                if (updateManifestRes.isErr())
                    return teamsfx_api_1.err(updateManifestRes.error);
            }
            // log warnings
            if (inputs.platform === teamsfx_api_1.Platform.CLI || inputs.platform === teamsfx_api_1.Platform.VS) {
                const warnSummary = helper_1.generateScaffoldingSummary(warnings, teamsManifest, destinationPath);
                if (warnSummary) {
                    void context.logProvider.info(warnSummary);
                }
            }
            if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
                return teamsfx_api_1.ok({
                    warnings: warnings.map((warning) => {
                        return {
                            type: warning.type,
                            content: warning.content,
                            data: warning.data,
                        };
                    }),
                });
            }
            else {
                return teamsfx_api_1.ok({ warnings: undefined });
            }
        }
        catch (e) {
            let error;
            if (e instanceof spec_parser_1.SpecParserError) {
                error = helper_1.convertSpecParserErrorToFxError(e);
            }
            else {
                error = error_1.assembleError(e);
            }
            return teamsfx_api_1.err(error);
        }
    }
}
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: fromApiSpecComponentName,
            telemetryEventName: telemetryEvents_1.TelemetryEvents.Generate,
            errorSource: fromApiSpecComponentName,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], CopilotPluginGenerator, "generateFromApiSpec", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: fromOpenAIPlugincomponentName,
            telemetryEventName: telemetryEvents_1.TelemetryEvents.Generate,
            errorSource: fromOpenAIPlugincomponentName,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], CopilotPluginGenerator, "generateFromOpenAIPlugin", null);
exports.CopilotPluginGenerator = CopilotPluginGenerator;
//# sourceMappingURL=generator.js.map