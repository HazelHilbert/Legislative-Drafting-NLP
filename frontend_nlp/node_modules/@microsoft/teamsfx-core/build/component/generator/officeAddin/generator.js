"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.OfficeAddinGenerator = void 0;
const tslib_1 = require("tslib");
/**
 * @author yefuwang@microsoft.com
 */
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path_1 = require("path");
const helperMethods_1 = require("./helperMethods");
const office_addin_manifest_1 = require("office-addin-manifest");
const projectsJsonData_1 = tslib_1.__importDefault(require("./config/projectsJsonData"));
const childProcess = tslib_1.__importStar(require("child_process"));
const util_1 = require("util");
const error_1 = require("../../../core/error");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const lib_1 = require("@feathersjs/hooks/lib");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const generator_1 = require("../generator");
const office_addin_project_1 = require("office-addin-project");
const questionNames_1 = require("../../../question/questionNames");
const create_1 = require("../../../question/create");
const localizeUtils_1 = require("../../../common/localizeUtils");
const componentName = "office-addin";
const telemetryEvent = "generate";
const templateName = "office-addin";
class OfficeAddinGenerator {
    static async generate(context, inputs, destinationPath) {
        const result = await OfficeAddinGenerator.doScaffolding(context, inputs, destinationPath);
        if (result.isErr()) {
            return teamsfx_api_1.err(result.error);
        }
        // If lang is undefined, it means the project is created from a folder.
        const lang = inputs[questionNames_1.QuestionNames.ProgrammingLanguage];
        const templateRes = await generator_1.Generator.generateTemplate(context, destinationPath, templateName, lang != "No Options" ? (lang === "TypeScript" ? "ts" : "js") : undefined);
        if (templateRes.isErr())
            return teamsfx_api_1.err(templateRes.error);
        return teamsfx_api_1.ok(undefined);
    }
    static async childProcessExec(cmdLine) {
        return util_1.promisify(childProcess.exec)(cmdLine);
    }
    static async doScaffolding(context, inputs, destinationPath) {
        const template = create_1.getTemplate(inputs);
        const name = inputs[questionNames_1.QuestionNames.AppName];
        const addinRoot = destinationPath;
        const fromFolder = inputs[questionNames_1.QuestionNames.OfficeAddinFolder];
        const language = inputs[questionNames_1.QuestionNames.ProgrammingLanguage];
        const host = inputs[questionNames_1.QuestionNames.OfficeAddinHost];
        const workingDir = process.cwd();
        const importProgress = context.userInteraction.createProgressBar(localizeUtils_1.getLocalizedString("core.generator.officeAddin.importProject.title"), 3);
        process.chdir(addinRoot);
        try {
            if (!fromFolder) {
                // from template
                const jsonData = new projectsJsonData_1.default();
                const projectRepoBranchInfo = jsonData.getProjectRepoAndBranch(template, language, true);
                // Copy project template files from project repository
                if (projectRepoBranchInfo.repo) {
                    await helperMethods_1.HelperMethods.downloadProjectTemplateZipFile(addinRoot, projectRepoBranchInfo.repo, projectRepoBranchInfo.branch);
                    // Call 'convert-to-single-host' npm script in generated project, passing in host parameter
                    const cmdLine = `npm run convert-to-single-host --if-present -- ${lodash_1.default.toLower(host)}`;
                    await OfficeAddinGenerator.childProcessExec(cmdLine);
                    const manifestPath = jsonData.getManifestPath(template);
                    // modify manifest guid and DisplayName
                    await office_addin_manifest_1.OfficeAddinManifest.modifyManifestFile(`${path_1.join(addinRoot, manifestPath)}`, "random", `${name}`);
                    await helperMethods_1.HelperMethods.moveManifestLocation(addinRoot, manifestPath);
                }
            }
            else {
                await importProgress.start();
                // from existing project
                await importProgress.next(localizeUtils_1.getLocalizedString("core.generator.officeAddin.importProject.copyFiles"));
                helperMethods_1.HelperMethods.copyAddinFiles(fromFolder, addinRoot);
                const sourceManifestFile = inputs[questionNames_1.QuestionNames.OfficeAddinManifest];
                let manifestFile = sourceManifestFile.replace(fromFolder, addinRoot);
                await importProgress.next(localizeUtils_1.getLocalizedString("core.generator.officeAddin.importProject.convertProject"));
                if (manifestFile.endsWith(".xml")) {
                    // Need to convert to json project first
                    await office_addin_project_1.convertProject(manifestFile);
                    manifestFile = manifestFile.replace(/\.xml$/, ".json");
                }
                inputs[questionNames_1.QuestionNames.OfficeAddinHost] = await getHost(manifestFile);
                await importProgress.next(localizeUtils_1.getLocalizedString("core.generator.officeAddin.importProject.updateManifest"));
                await helperMethods_1.HelperMethods.updateManifest(destinationPath, manifestFile);
            }
            process.chdir(workingDir);
            await importProgress.end(true, true);
            return teamsfx_api_1.ok(undefined);
        }
        catch (e) {
            process.chdir(workingDir);
            await importProgress.end(false, true);
            return teamsfx_api_1.err(error_1.CopyFileError(e));
        }
    }
}
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: componentName,
            telemetryEventName: telemetryEvent,
            errorSource: componentName,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], OfficeAddinGenerator, "generate", null);
exports.OfficeAddinGenerator = OfficeAddinGenerator;
async function getHost(addinManifestPath) {
    var _a, _b, _c;
    // Read add-in manifest file
    const addinManifest = await teamsfx_api_1.ManifestUtil.loadFromPath(addinManifestPath);
    let host = "Outlook";
    switch ((_c = (_b = (_a = addinManifest.extensions) === null || _a === void 0 ? void 0 : _a[0].requirements) === null || _b === void 0 ? void 0 : _b.scopes) === null || _c === void 0 ? void 0 : _c[0]) {
        // case "document":
        //   host = "Word";
        case "mail":
            host = "Outlook";
        // case "notebook":
        //   host = "OneNote";
        // case "presentation":
        //   host = "PowerPoint";
        // case "project":
        //   host = "Project";
        // case "workbook":
        //   host = "Excel";
    }
    return host;
}
//# sourceMappingURL=generator.js.map