"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.usePagination = void 0;
const chalk_1 = require("chalk");
const cli_width_1 = require("cli-width");
const utils_mjs_1 = require('./utils.js');
const hook_engine_mjs_1 = require('./hook-engine.js');
const use_ref_mjs_1 = require('./use-ref.js');
function usePagination(output, { active, pageSize = 7, }) {
    const rl = (0, hook_engine_mjs_1.readline)();
    const state = (0, use_ref_mjs_1.useRef)({
        pointer: 0,
        lastIndex: 0,
    });
    const width = (0, cli_width_1.default)({ defaultWidth: 80, output: rl.output });
    const lines = (0, utils_mjs_1.breakLines)(output, width).split('\n');
    // Make sure there's enough lines to paginate
    if (lines.length <= pageSize) {
        return output;
    }
    const middleOfList = Math.floor(pageSize / 2);
    // Move the pointer only when the user go down and limit it to the middle of the list
    const { pointer: prevPointer, lastIndex } = state.current;
    if (prevPointer < middleOfList && lastIndex < active && active - lastIndex < pageSize) {
        state.current.pointer = Math.min(middleOfList, prevPointer + active - lastIndex);
    }
    state.current.lastIndex = active;
    // Duplicate the lines so it give an infinite list look
    const infinite = [lines, lines, lines].flat();
    const topIndex = Math.max(0, active + lines.length - state.current.pointer);
    const section = infinite.splice(topIndex, pageSize).join('\n');
    return section + '\n' + chalk_1.default.dim('(Use arrow keys to reveal more choices)');
}
exports.usePagination = usePagination;
