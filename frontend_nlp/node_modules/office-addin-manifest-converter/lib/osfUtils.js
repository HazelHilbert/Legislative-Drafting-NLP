"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XmlProcessor = exports.DomParserProvider = exports.Utils = void 0;
const osfmos_1 = require("../lib/osfmos");
const xmldom_1 = require("@xmldom/xmldom");
var Utils;
(function (Utils) {
    function validateParams(params, expectedParams, ParameterCount) {
        var e, expectedLength = expectedParams.length;
        ParameterCount = ParameterCount || (typeof (ParameterCount) === "undefined");
        e = validateParameterCount(params, expectedParams, ParameterCount);
        if (e) {
            return e;
        }
        for (var i = 0, l = params.length; i < l; i++) {
            var expectedParam = expectedParams[Math.min(i, expectedLength - 1)], paramName = expectedParam.name;
            if (expectedParam.parameterArray) {
                paramName += "[" + (i - expectedLength + 1) + "]";
            }
            else if (!ParameterCount && (i >= expectedLength)) {
                break;
            }
            e = validateParameter(params[i], expectedParam, paramName);
            if (e) {
                e.popStackFrame();
                return e;
            }
        }
        return null;
    }
    Utils.validateParams = validateParams;
    function validateParameter(param, expectedParam, paramName) {
        var e, expectedType = expectedParam.type, expectedInteger = !!expectedParam.integer, expectedDomElement = !!expectedParam.domElement, mayBeNull = !!expectedParam.mayBeNull;
        e = validateParameterType(param, expectedType, expectedInteger, expectedDomElement, mayBeNull, paramName);
        if (e) {
            e.popStackFrame();
            return e;
        }
        var expectedElementType = expectedParam.elementType, elementMayBeNull = !!expectedParam.elementMayBeNull;
        if (expectedType === Array && typeof (param) !== "undefined" && param !== null &&
            (expectedElementType || !elementMayBeNull)) {
            var expectedElementInteger = !!expectedParam.elementInteger, expectedElementDomElement = !!expectedParam.elementDomElement;
            for (var i = 0; i < param.length; i++) {
                var elem = param[i];
                e = validateParameterType(elem, expectedElementType, expectedElementInteger, expectedElementDomElement, elementMayBeNull, paramName + "[" + i + "]");
                if (e) {
                    e.popStackFrame();
                    return e;
                }
            }
        }
        return null;
    }
    Utils.validateParameter = validateParameter;
    ;
    function validateParameterCount(params, expectedParams, validateParameterCount) {
        var i, error, expectedLen = expectedParams.length, actualLen = params.length;
        if (actualLen < expectedLen) {
            var minParams = expectedLen;
            for (i = 0; i < expectedLen; i++) {
                var param = expectedParams[i];
                if (param.optional || param.parameterArray) {
                    minParams--;
                }
            }
            if (actualLen < minParams) {
                error = true;
            }
        }
        else if (validateParameterCount && (actualLen > expectedLen)) {
            error = true;
            for (i = 0; i < expectedLen; i++) {
                if (expectedParams[i].parameterArray) {
                    error = false;
                    break;
                }
            }
        }
        if (error) {
            var e = osfmos_1.OfficeExt.MsAjaxError.parameterCount();
            return e;
        }
        return null;
    }
    Utils.validateParameterCount = validateParameterCount;
    function validateParameterType(param, expectedType, expectedInteger, expectedDomElement, mayBeNull, paramName) {
        var e, i;
        if (typeof (param) === "undefined") {
            if (mayBeNull) {
                return null;
            }
            else {
                e = osfmos_1.OfficeExt.MsAjaxError.argumentUndefined(paramName);
                e.popStackFrame();
                return e;
            }
        }
        if (param === null) {
            if (mayBeNull) {
                return null;
            }
            else {
                e = osfmos_1.OfficeExt.MsAjaxError.argumentNull(paramName);
                e.popStackFrame();
                return e;
            }
        }
        if (expectedType && !osfmos_1.OfficeExt.MsAjaxTypeHelper.isInstanceOfType(expectedType, param)) {
            e = osfmos_1.OfficeExt.MsAjaxError.argumentType(paramName, typeof (param), expectedType);
            e.popStackFrame();
            return e;
        }
        return null;
    }
    Utils.validateParameterType = validateParameterType;
    function getDomainForUrl(url) {
        if (!url) {
            return null;
        }
        var urlObject = osfmos_1.OSF.OUtil.parseUrl(url, true);
        return urlObject.protocol + "//" + urlObject.host;
    }
    Utils.getDomainForUrl = getDomainForUrl;
    function OverrideMethods() {
        osfmos_1.OSF.XmlProcessor = XmlProcessor;
        osfmos_1.OfficeExt.WACUtils.getDomainForUrl = Utils.getDomainForUrl;
    }
    Utils.OverrideMethods = OverrideMethods;
})(Utils = exports.Utils || (exports.Utils = {}));
class DomParserProvider {
    constructor(xml, xmlNamespaces) {
        try {
            this._xmldoc = new xmldom_1.DOMParser({}).parseFromString(xml, "text/xml");
        }
        catch (ex) {
            console.trace("xml doc creating error:" + ex);
        }
        this._namespaceMapping = {};
        this._defaultNamespace = null;
        var namespaces = xmlNamespaces.split(' ');
        var matches;
        for (var i = 0; i < namespaces.length; ++i) {
            matches = /xmlns="([^"]*)"/g.exec(namespaces[i]);
            if (matches) {
                this._defaultNamespace = matches[1];
                continue;
            }
            matches = /xmlns:([^=]*)="([^"]*)"/g.exec(namespaces[i]);
            if (matches) {
                this._namespaceMapping[matches[1]] = matches[2];
                continue;
            }
        }
    }
    addNamespaceMapping(namespacePrefix, namespaceUri) {
        var ns = this._namespaceMapping[namespacePrefix];
        if (ns) {
            return false;
        }
        else {
            this._namespaceMapping[namespacePrefix] = namespaceUri;
            return true;
        }
    }
    getNamespaceMapping() {
        return this._namespaceMapping;
    }
    selectSingleNode(name, contextNode) {
        var selectedNode = contextNode || this._xmldoc;
        var nodes = this._selectNodes(name, selectedNode);
        if (nodes.length === 0)
            return null;
        return nodes[0];
    }
    selectNodes(name, contextNode) {
        var selectedNode = contextNode || this._xmldoc;
        return this._selectNodes(name, selectedNode);
    }
    selectNodesByXPath(xpath, contextNode) {
        return null;
    }
    _selectNodes(name, contextNode) {
        var nodes = [];
        if (!name)
            return nodes;
        var nameInfo = name.split(":");
        var ns, nodeName;
        if (nameInfo.length === 1) {
            ns = null;
            nodeName = nameInfo[0];
        }
        else if (nameInfo.length === 2) {
            ns = this._namespaceMapping[nameInfo[0]];
            nodeName = nameInfo[1];
        }
        else {
            throw osfmos_1.OfficeExt.MsAjaxError.argument("name");
        }
        if (!contextNode.hasChildNodes)
            return nodes;
        var childs = contextNode.childNodes;
        for (var i = 0; i < childs.length; i++) {
            if (nodeName === this._removeNodePrefix(childs[i].nodeName) && (ns === childs[i].namespaceURI)) {
                nodes.push(childs[i]);
            }
        }
        return nodes;
    }
    _removeNodePrefix(nodeName) {
        if (!nodeName)
            return null;
        var nodeInfo = nodeName.split(':');
        if (nodeInfo.length === 1) {
            return nodeName;
        }
        else {
            return nodeInfo[1];
        }
    }
    getDocumentElement() {
        return this._xmldoc.documentElement;
    }
}
exports.DomParserProvider = DomParserProvider;
class XmlProcessor {
    constructor(xml, xmlNamespaces) {
        var e = Utils.validateParams(arguments, [
            { name: "xml", type: String, mayBeNull: false },
            { name: "xmlNamespaces", type: String, mayBeNull: false }
        ]);
        if (e)
            throw e;
        this._provider = new DomParserProvider(xml, xmlNamespaces);
    }
    addNamespaceMapping(namespacePrefix, namespaceUri) {
        var e = Utils.validateParams(arguments, [
            { name: "namespacePrefix", type: String, mayBeNull: false },
            { name: "namespaceUri", type: String, mayBeNull: false }
        ]);
        if (e)
            throw e;
        return this._provider.addNamespaceMapping(namespacePrefix, namespaceUri);
    }
    getNamespaceMapping() {
        var _a;
        return (_a = this._provider) === null || _a === void 0 ? void 0 : _a.getNamespaceMapping();
    }
    selectSingleNode(name, contextNode) {
        var e = Utils.validateParams(arguments, [
            { name: "name", type: String, mayBeNull: false },
            { name: "contextNode", mayBeNull: true, optional: true }
        ]);
        if (e)
            throw e;
        return this._provider.selectSingleNode(name, contextNode);
    }
    selectNodes(name, contextNode) {
        var e = Utils.validateParams(arguments, [
            { name: "name", type: String, mayBeNull: false },
            { name: "contextNode", mayBeNull: true, optional: true }
        ]);
        if (e)
            throw e;
        return this._provider.selectNodes(name, contextNode);
    }
    selectNodesByXPath(xpath, contextNode) {
        var e = Utils.validateParams(arguments, [
            { name: "xpath", type: String, mayBeNull: false },
            { name: "contextNode", mayBeNull: true, optional: true }
        ]);
        if (e)
            throw e;
        contextNode = contextNode || this._provider.getDocumentElement();
        return this._provider.selectNodesByXPath(xpath, contextNode);
    }
    getDocumentElement() {
        return this._provider.getDocumentElement();
    }
    getNodeValue(node) {
        var e = Utils.validateParams(arguments, [
            { name: "node", type: Object, mayBeNull: false }
        ]);
        if (e)
            throw e;
        var nodeValue;
        if (node.text) {
            nodeValue = node.text;
        }
        else {
            nodeValue = node.textContent;
        }
        return nodeValue;
    }
    getNodeText(node) {
        var e = Utils.validateParams(arguments, [
            { name: "node", type: Object, mayBeNull: false }
        ]);
        if (e)
            throw e;
        if (this.getNodeType(node) == 9) {
            return this.getNodeText(this.getDocumentElement());
        }
        var nodeText;
        if (node.text) {
            nodeText = node.text;
        }
        else {
            nodeText = node.textContent;
        }
        return nodeText;
    }
    setNodeText(node, text) {
        var e = Utils.validateParams(arguments, [
            { name: "node", type: Object, mayBeNull: false },
            { name: "text", type: String, mayBeNull: false }
        ]);
        if (e)
            throw e;
        if (this.getNodeType(node) == 9) {
            return false;
        }
        try {
            if (node.text) {
                node.text = text;
            }
            else {
                node.textContent = text;
            }
        }
        catch (ex) {
            return false;
        }
        return true;
    }
    getNodeXml(node) {
        var e = Utils.validateParams(arguments, [
            { name: "node", type: Object, mayBeNull: false }
        ]);
        if (e)
            throw e;
        var nodeXml;
        if (node.xml) {
            nodeXml = node.xml;
        }
        else {
            nodeXml = new XMLSerializer().serializeToString(node);
            if (this.getNodeType(node) == 2) {
                nodeXml = this.getNodeBaseName(node) + "=\"" + nodeXml + "\"";
            }
        }
        return nodeXml;
    }
    setNodeXml(node, xml) {
        var e = Utils.validateParams(arguments, [
            { name: "node", type: Object, mayBeNull: false },
            { name: "xml", type: String, mayBeNull: false }
        ]);
        if (e)
            throw e;
        var processor = new osfmos_1.OSF.XmlProcessor(xml, "");
        if (!processor.isValidXml()) {
            return null;
        }
        var newNode = processor.getDocumentElement();
        try {
            node.parentNode.replaceChild(newNode, node);
        }
        catch (ex) {
            return null;
        }
        return newNode;
    }
    getNodeNamespaceURI(node) {
        var e = Utils.validateParams(arguments, [
            { name: "node", type: Object, mayBeNull: false }
        ]);
        if (e)
            throw e;
        return node.namespaceURI;
    }
    getNodePrefix(node) {
        var e = Utils.validateParams(arguments, [
            { name: "node", type: Object, mayBeNull: false }
        ]);
        if (e)
            throw e;
        return node.prefix;
    }
    getNodeBaseName(node) {
        var e = Utils.validateParams(arguments, [
            { name: "node", type: Object, mayBeNull: false }
        ]);
        if (e)
            throw e;
        var nodeBaseName;
        if (node.nodeType && (node.nodeType == 1 || node.nodeType == 2)) {
            if (node.baseName) {
                nodeBaseName = node.baseName;
            }
            else {
                nodeBaseName = node.localName;
            }
        }
        else {
            nodeBaseName = node.nodeName;
        }
        return nodeBaseName;
    }
    getNodeType(node) {
        var e = Utils.validateParams(arguments, [
            { name: "node", type: Object, mayBeNull: false }
        ]);
        if (e)
            throw e;
        return node.nodeType;
    }
    appendChild(node, childXml) {
        var e = Utils.validateParams(arguments, [
            { name: "node", type: Object, mayBeNull: false },
            { name: "childXml", type: String, mayBeNull: false }
        ]);
        if (e)
            throw e;
        var processor = new osfmos_1.OSF.XmlProcessor(childXml, "");
        if (!processor.isValidXml()) {
            return null;
        }
        var childNode = processor.getDocumentElement();
        node.appendChild(childNode);
        return childNode;
    }
    _getAttributeLocalName(attribute) {
        var localName;
        if (attribute.localName) {
            localName = attribute.localName;
        }
        else {
            localName = attribute.baseName;
        }
        return localName;
    }
    readAttributes(node, attributesToRead, objectToFill) {
        var e = Utils.validateParams(arguments, [
            { name: "node", type: Object, mayBeNull: false },
            { name: "attributesToRead", type: Object, mayBeNull: false },
            { name: "objectToFill", type: Object, mayBeNull: false }
        ]);
        if (e)
            throw e;
        var attribute;
        var localName;
        for (var i = 0; i < node.attributes.length; i++) {
            attribute = node.attributes[i];
            localName = this._getAttributeLocalName(attribute);
            for (var p in attributesToRead) {
                if (localName === p) {
                    objectToFill[attributesToRead[p]] = attribute.value;
                }
            }
        }
    }
    isValidXml() {
        var documentElement = this.getDocumentElement();
        if (documentElement == null) {
            return false;
        }
        else if (this._provider._xmldoc.getElementsByTagName("parsererror").length > 0) {
            var parser = new xmldom_1.DOMParser();
            var errorParse = parser.parseFromString('<', 'text/xml');
            var parseErrorNS = errorParse.getElementsByTagName("parsererror")[0].namespaceURI;
            return this._provider._xmldoc.getElementsByTagNameNS(parseErrorNS, 'parsererror').length <= 0;
        }
        return true;
    }
}
exports.XmlProcessor = XmlProcessor;
//# sourceMappingURL=osfUtils.js.map