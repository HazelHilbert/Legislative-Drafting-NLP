"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IconBuilder = void 0;
const fs = require('fs');
const http = require('http');
const https = require('https');
const util = require("util");
const constants_1 = require("./constants");
const utilities_1 = require("./utilities");
class IconBuilder {
    constructor() {
        this._icons = {};
    }
    addIconAndGetReference(url, getShortNameAndStore, forRootIcon = false) {
        utilities_1.Utilities.assert(getShortNameAndStore || !forRootIcon, "Root icon must have getShortNameAndStore to be true");
        if (!getShortNameAndStore) {
            return url;
        }
        else {
            let imageFile = decodeURIComponent(IconBuilder._getFolderPath(url));
            if (!forRootIcon || utilities_1.Utilities._downloadImages) {
                imageFile = decodeURIComponent(this._getLeafName(url).trim());
                imageFile = imageFile.replace(constants_1.Constants.InvalidCharacterInFileName, '-');
                imageFile = this._getUniqueIconName(imageFile);
            }
            this._storeIcon(imageFile, url);
            return imageFile;
        }
    }
    _storeIcon(iconName, url) {
        this._icons[iconName] = url;
    }
    static _getFolderPath(url) {
        try {
            let realUrl = new URL(url);
            let path = realUrl.pathname;
            if (!!path && path.charAt(0) == '/') {
                path = path.substring(1);
            }
            if (!path) {
                path = realUrl.hostname;
            }
            return path;
        }
        catch (err) {
            return url;
        }
    }
    _getLeafName(url) {
        let segments = url.split("/");
        utilities_1.Utilities.assert(segments.length > 2, "valid url with segments");
        return segments[segments.length - 1].split("?")[0];
    }
    _getUniqueIconName(iconName) {
        if (utilities_1.Utilities.isNullOrUndefined(this._icons[iconName])) {
            return iconName;
        }
        else {
            for (var idx = 2; idx < 100; idx++) {
                let suffix = "" + idx;
                if (idx < 10) {
                    suffix = "0" + idx;
                }
                suffix = "_" + suffix;
                if (utilities_1.Utilities.isNullOrUndefined(this._icons[iconName + suffix])) {
                    let fixedIconName = "";
                    let nameSegments = iconName.split(".");
                    if (nameSegments.length > 1) {
                        fixedIconName = iconName.substring(0, iconName.length - nameSegments[nameSegments.length - 1].length - 1) +
                            suffix + "." + nameSegments[nameSegments.length - 1];
                    }
                    if (utilities_1.Utilities.isNullOrUndefined(this._icons[fixedIconName])) {
                        return fixedIconName;
                    }
                }
            }
            utilities_1.Utilities.logError("unable to find a non-conflicting icon name: " + iconName);
            utilities_1.Utilities.assert(false, "unable to find a non-conflicting icon name: " + iconName);
            return null;
        }
    }
    downloadAndStoreIcons(folderPath) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            let promises = [];
            for (var iconName in this._icons) {
                if (utilities_1.Utilities._downloadImages) {
                    promises.push(this._downloadAndStoreIcon(iconName, folderPath));
                }
                else {
                    utilities_1.Utilities.log(util.format("File download skipped for file: %s    url: %s", iconName, this._icons[iconName]));
                }
            }
            yield utilities_1.Utilities.promiseAll(promises, resolve, reject, "downloadAndStoreIcons: Failed");
        }));
    }
    _downloadAndStoreIcon(iconName, folderPath) {
        return new Promise((resolve, reject) => {
            let iconUrl = this._icons[iconName];
            let filePath = folderPath + "/" + iconName;
            try {
                const url = new URL(iconUrl);
                let protocol = (url.protocol == "https:") ? https : http;
                protocol.get(iconUrl, (res) => {
                    if (!res.headers['content-type'] || res.headers['content-type'].match(/image/)) {
                        const file = fs.createWriteStream(filePath);
                        res.pipe(file);
                        file.on('finish', () => {
                            file.close();
                            utilities_1.Utilities.log("File downloaded: ", filePath + ", url: " + iconUrl);
                        });
                        resolve();
                    }
                    else {
                        this._createDefaultIconFile(filePath, "Failed to get icon file " + iconUrl + " as image", resolve, reject);
                    }
                }).on("error", (err) => {
                    this._createDefaultIconFile(filePath, "Failed to get icon file " + iconUrl + ". " + err, resolve, reject);
                });
            }
            catch (ex) {
                this._createDefaultIconFile(filePath, "Failed to get icon file " + iconUrl + ". Exception: " + ex, resolve, reject);
            }
        });
    }
    _createDefaultIconFile(filePath, message, resolve, reject) {
        utilities_1.Utilities.logError(message + ". Default icon will be used.");
        let defaultIconEncoded_32x32 = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAQ9SURBVFhHxVdfaFtVHP7uTdLaP2tdK7apBQNLU7SadtC1diyzuFXmgw8qY/qmDwrTPe5JQRF8EcSXISgTN6E+bEPFbaLYdesEpX90dEy7VZydoA2USWM7upE09/j7/e65aZrcJPcGYV/zu/fc73fO+b5z7jknjaEIuIsw9f2uoeoZuHxlGqtnnoKiv6anv0XvowM64w9VzcA6Rer0Xuza14vEvj6kvtpLNqpDVQYujL6Jx3d3Qd2m8a9ZVI7i3OhbOusPvg3cug00Jd8Hau8FLMsmqdyUfE9yfuHbwMRnL2JwdxwqTS/CMIRTGQuDu+KUe0me/cCXgeTiCmLpz2nk99CTLb6BOsTunMLS0qp+9gZfBqZGn0NsRx9UVk+9A9pIKrOO2EAffjz+jCa9wbOBa7/OYeiBWSATtAla9ryBZRPzhV8H5YY6ZjE/N2fX8QDPBq6e2Y+2WA+Uxar0IT0zHILZHrS3IHOUa+vqwdXT+6WNF3gyMHPxLJ58eA1Ib7x3sz0Eo+scjNg4zI5azRIywEj3LVz64awmysOTgdT3r6ChPUIzLWN1B3vjtUDroyEcwT/jL9t8BVQ0MPHFEezZ2UIj0+Ly4gsWIUN4ClkLCnuGtuLil0d0sjTKGqDZRGDhDZiN90vfOZHCLSg83Z1zgcpm430wr78ufZRDWQNjRw8jMdgtB01OXIuUh0UHlUKiP4rxY4c1546SBpZXgPDah0Bwi29xmQ2OUBPaUh9guczZVNLA1LED2P5YL9S6Hn2+OBeZK4IjThXow223D8Qx/ckBO+0CVwMLfy4huuUb6o+2F3/hFI7cTdwgLk88B1WDbfVf4wb16QZXA5dOPIvoI3Tk0vHqKl6kX0Kc1wLtiGhPHLOn3I/oIgNXJmcw/OB12gKUchUvUtfiFAXisLSh9QASHb/hl6kZO5WHIgPJ8RfQGonZR24+HHGvC9ERJ3Bf3Ofi2PM2kYdNBia/O4FEHxUyBSKu4iTiis3iNqgtHQiJeBaTYyc1ZyNnIEux+vMh1LV2khY1cOAmbliwFjNQ809IWMm0TpQQp+Au6lo6sTp9ULQc5AxMnHwXI4NhWTQ5uImzSF4VG1yntLiQ3Iz6HtnRJloOxMAdqtP8xztAfauQgnLitNrNcA2M7vMS/LVcSTyXq29B8+9viyZDDJw/+ir6Ew/ZRy6jgngRijipSFEgThxr9O+MkeZrwpg3V7KIZD+lSg1CVBTXNL93NT8MdW04bw0wSotLSKoRkfTHuLliwbhw/JAa7v6JnNVQkitQVBC3QYcMTztBrnKRivaDqzgROm0E05hYGIIZqE3RPBgwAiaRFKGAfQ/ynXm+U4R0XoJ4MwCTOI7NOapr6jL36fTL/ThlCpgKgdAyjOTfKXX5o23o3PovGdT/cArYsS5uQileQ49wA7pyXhuDftz9tdyM3oM3qv9x+v8A+A89FNxU0V8XUQAAAABJRU5ErkJggg==";
        let defaultIconDecoded = Buffer.from(defaultIconEncoded_32x32, 'base64');
        try {
            fs.writeFileSync(filePath, defaultIconDecoded, "binary");
            resolve();
        }
        catch (err) {
            utilities_1.Utilities.logError("Failed to create default icon file " + filePath + ". Error is: " + err);
            reject();
        }
    }
}
exports.IconBuilder = IconBuilder;
//# sourceMappingURL=iconBuilder.js.map