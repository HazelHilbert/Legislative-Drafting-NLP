"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  useDisposable: () => useDisposable,
  useIsStrictMode: () => useIsStrictMode
});
module.exports = __toCommonJS(src_exports);

// src/useIsStrictMode.ts
var React = __toESM(require("react"), 1);
var getCurrentOwner = () => React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner.current;
var REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode");
var useIsStrictMode = () => {
  if (process.env.NODE_ENV === "production") {
    return false;
  }
  const isStrictMode = React.useRef(void 0);
  const reactMajorVersion = React.useMemo(() => {
    return Number(React.version.split(".")[0]);
  }, [React.version]);
  if (isNaN(reactMajorVersion) || reactMajorVersion < 18) {
    return false;
  }
  if (isStrictMode.current === void 0) {
    let currentOwner = getCurrentOwner();
    while (currentOwner && currentOwner.return) {
      currentOwner = currentOwner.return;
      if (currentOwner.type === REACT_STRICT_MODE_TYPE || currentOwner.elementType === REACT_STRICT_MODE_TYPE) {
        isStrictMode.current = true;
      }
    }
  }
  return !!isStrictMode.current;
};

// src/useDisposable.ts
var React4 = __toESM(require("react"), 1);

// src/useStrictEffect.ts
var React2 = __toESM(require("react"), 1);
var effectSet = /* @__PURE__ */ new WeakSet();
function useStrictEffect(effect, deps) {
  const currentOwner = getCurrentOwner();
  React2.useEffect(() => {
    if (!effectSet.has(currentOwner)) {
      effectSet.add(currentOwner);
      effect();
      return;
    }
    const dispose = effect();
    return dispose;
  }, deps);
}

// src/useStrictMemo.ts
var React3 = __toESM(require("react"), 1);
var memoSet = /* @__PURE__ */ new WeakSet();
function useStrictMemo(factory, deps) {
  return React3.useMemo(() => {
    const currentOwner = getCurrentOwner();
    if (!memoSet.has(currentOwner)) {
      memoSet.add(currentOwner);
      return null;
    }
    return factory();
  }, deps);
}

// src/useDisposable.ts
function useDisposable(factory, deps) {
  var _a;
  const isStrictMode = useIsStrictMode() && process.env.NODE_ENV !== "production";
  const useMemo4 = isStrictMode ? useStrictMemo : React4.useMemo;
  const useEffect3 = isStrictMode ? useStrictEffect : React4.useEffect;
  const [disposable, dispose] = (_a = useMemo4(() => factory(), deps)) != null ? _a : [
    null,
    () => null
  ];
  useEffect3(() => {
    return dispose;
  }, deps);
  return disposable;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useDisposable,
  useIsStrictMode
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIiwgIi4uL3NyYy91c2VJc1N0cmljdE1vZGUudHMiLCAiLi4vc3JjL3VzZURpc3Bvc2FibGUudHMiLCAiLi4vc3JjL3VzZVN0cmljdEVmZmVjdC50cyIsICIuLi9zcmMvdXNlU3RyaWN0TWVtby50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiZXhwb3J0IHsgdXNlSXNTdHJpY3RNb2RlIH0gZnJvbSBcIi4vdXNlSXNTdHJpY3RNb2RlXCI7XG5leHBvcnQgeyB1c2VEaXNwb3NhYmxlIH0gZnJvbSBcIi4vdXNlRGlzcG9zYWJsZVwiO1xuZXhwb3J0IHR5cGUgeyBEaXNwb3NhYmxlRmFjdG9yeSB9IGZyb20gXCIuL3R5cGVzXCI7XG4iLCAiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbi8qKlxuICogQHJldHVybnMgQ3VycmVudCByZWFjdCBmaWJlciBiZWluZyByZW5kZXJlZFxuICovXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudE93bmVyID0gKCkgPT5cbiAgLy8gQHRzLWlnbm9yZSAtIHVzaW5nIHJlYWN0IGludGVybmFsc1xuICBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lclxuICAgIC5jdXJyZW50O1xuXG5jb25zdCBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gLyojX19QVVJFX18qLyBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik7XG5cbi8qKlxuICogVHJhdmVyc2VzIHVwIHRoZSBSZWFjdCBmaWJlciB0cmVlIHRvIGZpbmQgdGhlIFN0cmljdE1vZGUgY29tcG9uZW50LlxuICogTm90ZTogVGhpcyBvbmx5IGRldGVjdHMgc3RyaWN0IG1vZGUgZnJvbSBSZWFjdCA+PSAxOFxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvMTlcbiAqIEByZXR1cm5zIElmIHN0cmljdCBtb2RlIGlzIGJlaW5nIHVzZWQgaW4gdGhlIFJlYWN0IHRyZWVcbiAqL1xuZXhwb3J0IGNvbnN0IHVzZUlzU3RyaWN0TW9kZSA9ICgpOiBib29sZWFuID0+IHtcbiAgLy8gVGhpcyBjaGVjayB2aW9sYXRlcyBSdWxlcyBvZiBIb29rcywgYnV0IFwicHJvY2Vzcy5lbnYuTk9ERV9FTlZcIiBkb2VzIG5vdCBjaGFuZ2UgaW4gYnVuZGxlXG4gIC8vIG9yIGR1cmluZyBhcHBsaWNhdGlvbiBsaWZlY3ljbGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGlzU3RyaWN0TW9kZSA9IFJlYWN0LnVzZVJlZjxib29sZWFuIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICBjb25zdCByZWFjdE1ham9yVmVyc2lvbiA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBOdW1iZXIoUmVhY3QudmVyc2lvbi5zcGxpdChcIi5cIilbMF0pO1xuICB9LCBbUmVhY3QudmVyc2lvbl0pO1xuXG4gIGlmIChpc05hTihyZWFjdE1ham9yVmVyc2lvbikgfHwgcmVhY3RNYWpvclZlcnNpb24gPCAxOCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc1N0cmljdE1vZGUuY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGN1cnJlbnRPd25lciA9IGdldEN1cnJlbnRPd25lcigpO1xuICAgIHdoaWxlIChjdXJyZW50T3duZXIgJiYgY3VycmVudE93bmVyLnJldHVybikge1xuICAgICAgY3VycmVudE93bmVyID0gY3VycmVudE93bmVyLnJldHVybjtcbiAgICAgIGlmIChcbiAgICAgICAgY3VycmVudE93bmVyLnR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHxcbiAgICAgICAgY3VycmVudE93bmVyLmVsZW1lbnRUeXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFXG4gICAgICApIHtcbiAgICAgICAgaXNTdHJpY3RNb2RlLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAhIWlzU3RyaWN0TW9kZS5jdXJyZW50O1xufTtcbiIsICJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgRGlzcG9zYWJsZUZhY3RvcnkgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgdXNlSXNTdHJpY3RNb2RlIH0gZnJvbSBcIi4vdXNlSXNTdHJpY3RNb2RlXCI7XG5pbXBvcnQgeyB1c2VTdHJpY3RFZmZlY3QgfSBmcm9tIFwiLi91c2VTdHJpY3RFZmZlY3RcIjtcbmltcG9ydCB7IHVzZVN0cmljdE1lbW8gfSBmcm9tIFwiLi91c2VTdHJpY3RNZW1vXCI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRpc3Bvc2FibGUgaW5zdGFuY2UgZHVyaW5nICoqcmVuZGVyIHRpbWUqKiB0aGF0IHdpbGxcbiAqIGJlIGNyZWF0ZWQgb25jZSAoYmFzZWQgb24gZGVwZW5kZW5jeSBhcnJheSkgZXZlbiBkdXJpbmcgc3RyaWN0IG1vZGUuXG4gKiBUaGUgZGlzcG9zYWJsZSB3aWxsIGJlIGRpc3Bvc2VkIGJhc2VkIG9uIHRoZSBkZXBlbmRlbmN5IGFycmF5IHNpbWlsYXIgdG9cbiAqIHVzZUVmZmVjdC5cbiAqXG4gKiBcdTI2QTBcdUZFMEYgVGhpcyBjYW4gb25seSBiZSBjYWxsZWQgKipvbmNlKiogcGVyIGNvbXBvbmVudFxuICogQHBhcmFtIGZhY3RvcnkgLSBmYWN0b3J5IGZvciBkaXNwb3NhYmxlIGFuZCBpdHMgZGlzcG9zZSBmdW5jdGlvblxuICogQHBhcmFtIGRlcHMgLSBTaW1pbGFyIHRvIGEgUmVhY3QgZGVwZW5kZW5jeSBhcnJheVxuICogQHJldHVybnMgLSBUaGUgZGlzcG9zYWJsZSBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGlzcG9zYWJsZTxUSW5zdGFuY2U+KFxuICBmYWN0b3J5OiBEaXNwb3NhYmxlRmFjdG9yeTxUSW5zdGFuY2U+LFxuICBkZXBzOiBhbnlbXVxuKSB7XG4gIC8vIEluIHByb2R1Y3Rpb24sIHN0cmljdCBtb2RlIGRvZXMgbm90IHJlcXVpcmUgc3BlY2lhbCBoYW5kbGluZ1xuICBjb25zdCBpc1N0cmljdE1vZGUgPVxuICAgIHVzZUlzU3RyaWN0TW9kZSgpICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIjtcblxuICBjb25zdCB1c2VNZW1vID0gaXNTdHJpY3RNb2RlID8gdXNlU3RyaWN0TWVtbyA6IFJlYWN0LnVzZU1lbW87XG4gIGNvbnN0IHVzZUVmZmVjdCA9IGlzU3RyaWN0TW9kZSA/IHVzZVN0cmljdEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcblxuICBjb25zdCBbZGlzcG9zYWJsZSwgZGlzcG9zZV0gPSB1c2VNZW1vKCgpID0+IGZhY3RvcnkoKSwgZGVwcykgPz8gW1xuICAgIG51bGwsXG4gICAgKCkgPT4gbnVsbCxcbiAgXTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gZGlzcG9zZTtcbiAgfSwgZGVwcyk7XG5cbiAgcmV0dXJuIGRpc3Bvc2FibGU7XG59XG4iLCAiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBnZXRDdXJyZW50T3duZXIgfSBmcm9tIFwiLi91c2VJc1N0cmljdE1vZGVcIjtcblxuLy8gd2Uga25vdyBzdHJpY3QgbW9kZSB3aWxsIHJlbmRlciB1c2VNZW1vIGZhY29yeSB0d2ljZVxuLy8ga2VlcCBhIHdlYWsgc2V0IHRvIGRldGVjdCB3aGVuIHRoZSBzZWNvbmQgcmVuZGVyIGhhcHBlbnNcbmNvbnN0IGVmZmVjdFNldCA9IG5ldyBXZWFrU2V0KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdHJpY3RFZmZlY3QoXG4gIGVmZmVjdDogKCkgPT4gKCkgPT4gdm9pZCxcbiAgZGVwczogUmVhY3QuRGVwZW5kZW5jeUxpc3QgfCB1bmRlZmluZWRcbikge1xuICBjb25zdCBjdXJyZW50T3duZXIgPSBnZXRDdXJyZW50T3duZXIoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVmZmVjdFNldC5oYXMoY3VycmVudE93bmVyKSkge1xuICAgICAgZWZmZWN0U2V0LmFkZChjdXJyZW50T3duZXIpO1xuICAgICAgZWZmZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlzcG9zZSA9IGVmZmVjdCgpO1xuICAgIHJldHVybiBkaXNwb3NlO1xuICB9LCBkZXBzKTtcbn1cbiIsICJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGdldEN1cnJlbnRPd25lciB9IGZyb20gXCIuL3VzZUlzU3RyaWN0TW9kZVwiO1xuXG4vLyB3ZSBrbm93IHN0cmljdCBtb2RlIHdpbGwgcmVuZGVyIHVzZU1lbW8gZmFjb3J5IHR3aWNlXG4vLyBrZWVwIGEgd2VhayBzZXQgdG8gZGV0ZWN0IHdoZW4gdGhlIHNlY29uZCByZW5kZXIgaGFwcGVuc1xuY29uc3QgbWVtb1NldCA9IG5ldyBXZWFrU2V0KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdHJpY3RNZW1vPFRNZW1vaXplZD4oXG4gIGZhY3Rvcnk6ICgpID0+IGFueSxcbiAgZGVwczogUmVhY3QuRGVwZW5kZW5jeUxpc3QgfCB1bmRlZmluZWRcbik6IFRNZW1vaXplZCB8IG51bGwge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudE93bmVyID0gZ2V0Q3VycmVudE93bmVyKCk7XG4gICAgaWYgKCFtZW1vU2V0LmhhcyhjdXJyZW50T3duZXIpKSB7XG4gICAgICBtZW1vU2V0LmFkZChjdXJyZW50T3duZXIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhY3RvcnkoKTtcbiAgfSwgZGVwcyk7XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FDQUEsWUFBdUI7QUFLaEIsSUFBTSxrQkFBa0IsTUFFdkIseURBQW1ELGtCQUN0RDtBQUVMLElBQU0seUJBQXVDLHVCQUFPLElBQUksbUJBQW1CO0FBUXBFLElBQU0sa0JBQWtCLE1BQWU7QUFHNUMsTUFBSSxRQUFRLElBQUksYUFBYSxjQUFjO0FBQ3pDLFdBQU87QUFBQSxFQUNUO0FBRUEsUUFBTSxlQUFxQixhQUE0QixNQUFTO0FBQ2hFLFFBQU0sb0JBQTBCLGNBQVEsTUFBTTtBQUM1QyxXQUFPLE9BQWEsY0FBUSxNQUFNLEdBQUcsRUFBRSxFQUFFO0FBQUEsRUFDM0MsR0FBRyxDQUFPLGFBQU8sQ0FBQztBQUVsQixNQUFJLE1BQU0saUJBQWlCLEtBQUssb0JBQW9CLElBQUk7QUFDdEQsV0FBTztBQUFBLEVBQ1Q7QUFFQSxNQUFJLGFBQWEsWUFBWSxRQUFXO0FBQ3RDLFFBQUksZUFBZSxnQkFBZ0I7QUFDbkMsV0FBTyxnQkFBZ0IsYUFBYSxRQUFRO0FBQzFDLHFCQUFlLGFBQWE7QUFDNUIsVUFDRSxhQUFhLFNBQVMsMEJBQ3RCLGFBQWEsZ0JBQWdCLHdCQUM3QjtBQUNBLHFCQUFhLFVBQVU7QUFBQSxNQUN6QjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBRUEsU0FBTyxDQUFDLENBQUMsYUFBYTtBQUN4Qjs7O0FDaERBLElBQUFBLFNBQXVCOzs7QUNBdkIsSUFBQUMsU0FBdUI7QUFLdkIsSUFBTSxZQUFZLG9CQUFJLFFBQVE7QUFFdkIsU0FBUyxnQkFDZCxRQUNBLE1BQ0E7QUFDQSxRQUFNLGVBQWUsZ0JBQWdCO0FBQ3JDLEVBQU0saUJBQVUsTUFBTTtBQUNwQixRQUFJLENBQUMsVUFBVSxJQUFJLFlBQVksR0FBRztBQUNoQyxnQkFBVSxJQUFJLFlBQVk7QUFDMUIsYUFBTztBQUNQO0FBQUEsSUFDRjtBQUVBLFVBQU0sVUFBVSxPQUFPO0FBQ3ZCLFdBQU87QUFBQSxFQUNULEdBQUcsSUFBSTtBQUNUOzs7QUN0QkEsSUFBQUMsU0FBdUI7QUFLdkIsSUFBTSxVQUFVLG9CQUFJLFFBQVE7QUFFckIsU0FBUyxjQUNkLFNBQ0EsTUFDa0I7QUFDbEIsU0FBYSxlQUFRLE1BQU07QUFDekIsVUFBTSxlQUFlLGdCQUFnQjtBQUNyQyxRQUFJLENBQUMsUUFBUSxJQUFJLFlBQVksR0FBRztBQUM5QixjQUFRLElBQUksWUFBWTtBQUN4QixhQUFPO0FBQUEsSUFDVDtBQUVBLFdBQU8sUUFBUTtBQUFBLEVBQ2pCLEdBQUcsSUFBSTtBQUNUOzs7QUZITyxTQUFTLGNBQ2QsU0FDQSxNQUNBO0FBcEJGO0FBc0JFLFFBQU0sZUFDSixnQkFBZ0IsS0FBSyxRQUFRLElBQUksYUFBYTtBQUVoRCxRQUFNQyxXQUFVLGVBQWUsZ0JBQXNCO0FBQ3JELFFBQU1DLGFBQVksZUFBZSxrQkFBd0I7QUFFekQsUUFBTSxDQUFDLFlBQVksT0FBTyxLQUFJLEtBQUFELFNBQVEsTUFBTSxRQUFRLEdBQUcsSUFBSSxNQUE3QixZQUFrQztBQUFBLElBQzlEO0FBQUEsSUFDQSxNQUFNO0FBQUEsRUFDUjtBQUNBLEVBQUFDLFdBQVUsTUFBTTtBQUNkLFdBQU87QUFBQSxFQUNULEdBQUcsSUFBSTtBQUVQLFNBQU87QUFDVDsiLAogICJuYW1lcyI6IFsiUmVhY3QiLCAiUmVhY3QiLCAiUmVhY3QiLCAidXNlTWVtbyIsICJ1c2VFZmZlY3QiXQp9Cg==