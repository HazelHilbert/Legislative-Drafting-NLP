{"version":3,"sources":["../../src/WeakRefInstance.ts","../../src/FocusEvent.ts","../../src/Keyborg.ts","../../src/index.ts"],"sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n// IE11 compat, checks if WeakRef is supported\nexport const _canUseWeakRef = typeof WeakRef !== \"undefined\";\n\n/**\n * Allows disposable instances to be used\n */\nexport interface Disposable {\n  isDisposed?(): boolean;\n}\n\n/**\n * WeakRef wrapper around a HTMLElement that also supports IE11\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef}\n * @internal\n */\nexport class WeakRefInstance<T extends Disposable | object> {\n  private _weakRef?: WeakRef<T>;\n  private _instance?: T;\n\n  constructor(instance: T) {\n    if (_canUseWeakRef && typeof instance === \"object\") {\n      this._weakRef = new WeakRef(instance);\n    } else {\n      this._instance = instance;\n    }\n  }\n\n  /**\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref}\n   */\n  deref(): T | undefined {\n    let instance: T | undefined;\n\n    if (this._weakRef) {\n      instance = this._weakRef?.deref();\n\n      if (!instance) {\n        delete this._weakRef;\n      }\n    } else {\n      instance = this._instance;\n      if ((instance as Disposable)?.isDisposed?.()) {\n        delete this._instance;\n      }\n    }\n\n    return instance;\n  }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { WeakRefInstance } from \"./WeakRefInstance\";\n\nexport const KEYBORG_FOCUSIN = \"keyborg:focusin\";\nexport const KEYBORG_FOCUSOUT = \"keyborg:focusout\";\n\ninterface KeyborgFocus {\n  /**\n   * This is the native `focus` function that is retained so that it can be restored when keyborg is disposed\n   */\n  __keyborgNativeFocus?: (options?: FocusOptions | undefined) => void;\n}\n\ninterface KeyborgFocusEventData {\n  focusInHandler: (e: FocusEvent) => void;\n  focusOutHandler: (e: FocusEvent) => void;\n  lastFocusedProgrammatically?: WeakRefInstance<HTMLElement>;\n  shadowTargets: Set<WeakRefInstance<ShadowRoot>>;\n}\n\n/**\n * Extends the global window with keyborg focus event data\n */\ninterface WindowWithKeyborgFocusEvent extends Window {\n  HTMLElement: typeof HTMLElement;\n  __keyborgData?: KeyborgFocusEventData;\n}\n\nfunction canOverrideNativeFocus(win: Window): boolean {\n  const HTMLElement = (win as WindowWithKeyborgFocusEvent).HTMLElement;\n  const origFocus = HTMLElement.prototype.focus;\n\n  let isCustomFocusCalled = false;\n\n  HTMLElement.prototype.focus = function focus(): void {\n    isCustomFocusCalled = true;\n  };\n\n  const btn = win.document.createElement(\"button\");\n\n  btn.focus();\n\n  HTMLElement.prototype.focus = origFocus;\n\n  return isCustomFocusCalled;\n}\n\nlet _canOverrideNativeFocus = false;\n\nexport interface KeyborgFocusInEventDetails {\n  relatedTarget?: HTMLElement;\n  isFocusedProgrammatically?: boolean;\n  originalEvent?: FocusEvent;\n}\n\nexport interface KeyborgFocusInEvent\n  extends CustomEvent<KeyborgFocusInEventDetails> {\n  /**\n   * @deprecated - used `event.detail`\n   */\n  details?: KeyborgFocusInEventDetails;\n}\n\nexport interface KeyborgFocusOutEventDetails {\n  originalEvent: FocusEvent;\n}\n\nexport type KeyborgFocusOutEvent = CustomEvent<KeyborgFocusOutEventDetails>;\n\n/**\n * Guarantees that the native `focus` will be used\n */\nexport function nativeFocus(element: HTMLElement): void {\n  const focus = element.focus as KeyborgFocus;\n\n  if (focus.__keyborgNativeFocus) {\n    focus.__keyborgNativeFocus.call(element);\n  } else {\n    element.focus();\n  }\n}\n\n/**\n * Overrides the native `focus` and setups the keyborg focus event\n */\nexport function setupFocusEvent(win: Window): void {\n  const kwin = win as WindowWithKeyborgFocusEvent;\n\n  if (!_canOverrideNativeFocus) {\n    _canOverrideNativeFocus = canOverrideNativeFocus(kwin);\n  }\n\n  const origFocus = kwin.HTMLElement.prototype.focus;\n\n  if ((origFocus as KeyborgFocus).__keyborgNativeFocus) {\n    // Already set up.\n    return;\n  }\n\n  kwin.HTMLElement.prototype.focus = focus;\n\n  const shadowTargets: Set<WeakRefInstance<ShadowRoot>> = new Set();\n\n  const focusOutHandler = (e: FocusEvent) => {\n    const target = e.target as HTMLElement;\n\n    if (!target) {\n      return;\n    }\n\n    const event: KeyborgFocusOutEvent = new CustomEvent(KEYBORG_FOCUSOUT, {\n      cancelable: true,\n      bubbles: true,\n      // Allows the event to bubble past an open shadow root\n      composed: true,\n      detail: {\n        originalEvent: e,\n      },\n    });\n\n    target.dispatchEvent(event);\n  };\n\n  const focusInHandler = (e: FocusEvent) => {\n    const target = e.target as HTMLElement;\n\n    if (!target) {\n      return;\n    }\n\n    let node: Node | null | undefined = e.composedPath()[0] as\n      | Node\n      | null\n      | undefined;\n\n    const currentShadows: Set<ShadowRoot> = new Set();\n\n    while (node) {\n      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        currentShadows.add(node as ShadowRoot);\n        node = (node as ShadowRoot).host;\n      } else {\n        node = node.parentNode;\n      }\n    }\n\n    for (const shadowRootWeakRef of shadowTargets) {\n      const shadowRoot = shadowRootWeakRef.deref();\n\n      if (!shadowRoot || !currentShadows.has(shadowRoot)) {\n        shadowTargets.delete(shadowRootWeakRef);\n\n        if (shadowRoot) {\n          shadowRoot.removeEventListener(\"focusin\", focusInHandler, true);\n          shadowRoot.removeEventListener(\"focusout\", focusOutHandler, true);\n        }\n      }\n    }\n\n    onFocusIn(target, (e.relatedTarget as HTMLElement | null) || undefined);\n  };\n\n  const onFocusIn = (\n    target: Element,\n    relatedTarget?: HTMLElement,\n    originalEvent?: FocusEvent,\n  ) => {\n    const shadowRoot = target.shadowRoot;\n\n    if (shadowRoot) {\n      /**\n       * https://bugs.chromium.org/p/chromium/issues/detail?id=1512028\n       * focusin events don't bubble up through an open shadow root once focus is inside\n       * once focus moves into a shadow root - we drop the same focusin handler there\n       * keyborg's custom event will still bubble up since it is composed\n       * event handlers should be cleaned up once focus leaves the shadow root.\n       *\n       * When a focusin event is dispatched from a shadow root, its target is the shadow root parent.\n       * Each shadow root encounter requires a new capture listener.\n       * Why capture? - we want to follow the focus event in order or descending nested shadow roots\n       * When there are no more shadow root targets - dispatch the keyborg:focusin event\n       *\n       * 1. no focus event\n       * > document - capture listener ✅\n       *   > shadow root 1\n       *     > shadow root 2\n       *       > shadow root 3\n       *         > focused element\n       *\n       * 2. focus event received by document listener\n       * > document - capture listener ✅ (focus event here)\n       *   > shadow root 1 - capture listener ✅\n       *     > shadow root 2\n       *       > shadow root 3\n       *         > focused element\n\n       * 3. focus event received by root l1 listener\n       * > document - capture listener ✅\n       *   > shadow root 1 - capture listener ✅ (focus event here)\n       *     > shadow root 2 - capture listener ✅\n       *       > shadow root 3\n       *         > focused element\n       *\n       * 4. focus event received by root l2 listener\n       * > document - capture listener ✅\n       *   > shadow root 1 - capture listener ✅\n       *     > shadow root 2 - capture listener ✅ (focus event here)\n       *       > shadow root 3 - capture listener ✅\n       *         > focused element\n       *\n       * 5. focus event received by root l3 listener, no more shadow root targets\n       * > document - capture listener ✅\n       *   > shadow root 1 - capture listener ✅\n       *     > shadow root 2 - capture listener ✅\n       *       > shadow root 3 - capture listener ✅ (focus event here)\n       *         > focused element ✅ (no shadow root - dispatch keyborg event)\n       */\n\n      for (const shadowRootWeakRef of shadowTargets) {\n        if (shadowRootWeakRef.deref() === shadowRoot) {\n          return;\n        }\n      }\n\n      shadowRoot.addEventListener(\"focusin\", focusInHandler, true);\n      shadowRoot.addEventListener(\"focusout\", focusOutHandler, true);\n\n      shadowTargets.add(new WeakRefInstance(shadowRoot));\n\n      return;\n    }\n\n    const details: KeyborgFocusInEventDetails = {\n      relatedTarget,\n      originalEvent,\n    };\n\n    const event: KeyborgFocusInEvent = new CustomEvent(KEYBORG_FOCUSIN, {\n      cancelable: true,\n      bubbles: true,\n      // Allows the event to bubble past an open shadow root\n      composed: true,\n      detail: details,\n    });\n\n    // Tabster (and other users) can still use the legacy details field - keeping for backwards compat\n    event.details = details;\n\n    if (_canOverrideNativeFocus || data.lastFocusedProgrammatically) {\n      details.isFocusedProgrammatically =\n        target === data.lastFocusedProgrammatically?.deref();\n\n      data.lastFocusedProgrammatically = undefined;\n    }\n\n    target.dispatchEvent(event);\n  };\n\n  const data: KeyborgFocusEventData = (kwin.__keyborgData = {\n    focusInHandler,\n    focusOutHandler,\n    shadowTargets,\n  });\n\n  kwin.document.addEventListener(\n    \"focusin\",\n    kwin.__keyborgData.focusInHandler,\n    true,\n  );\n\n  kwin.document.addEventListener(\n    \"focusout\",\n    kwin.__keyborgData.focusOutHandler,\n    true,\n  );\n\n  function focus(this: HTMLElement) {\n    const keyborgNativeFocusEvent = (kwin as WindowWithKeyborgFocusEvent)\n      .__keyborgData;\n\n    if (keyborgNativeFocusEvent) {\n      keyborgNativeFocusEvent.lastFocusedProgrammatically = new WeakRefInstance(\n        this,\n      );\n    }\n\n    // eslint-disable-next-line prefer-rest-params\n    return origFocus.apply(this, arguments);\n  }\n\n  let activeElement = kwin.document.activeElement as Element | null;\n\n  // If keyborg is created with the focus inside shadow root, we need\n  // to go through the shadows up to make sure all relevant shadows\n  // have focus handlers attached.\n  while (activeElement && activeElement.shadowRoot) {\n    onFocusIn(activeElement);\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n\n  (focus as KeyborgFocus).__keyborgNativeFocus = origFocus;\n}\n\n/**\n * Removes keyborg event listeners and custom focus override\n * @param win The window that stores keyborg focus events\n */\nexport function disposeFocusEvent(win: Window): void {\n  const kwin = win as WindowWithKeyborgFocusEvent;\n  const proto = kwin.HTMLElement.prototype;\n  const origFocus = (proto.focus as KeyborgFocus).__keyborgNativeFocus;\n  const keyborgNativeFocusEvent = kwin.__keyborgData;\n\n  if (keyborgNativeFocusEvent) {\n    kwin.document.removeEventListener(\n      \"focusin\",\n      keyborgNativeFocusEvent.focusInHandler,\n      true,\n    );\n\n    kwin.document.removeEventListener(\n      \"focusout\",\n      keyborgNativeFocusEvent.focusOutHandler,\n      true,\n    );\n\n    for (const shadowRootWeakRef of keyborgNativeFocusEvent.shadowTargets) {\n      const shadowRoot = shadowRootWeakRef.deref();\n\n      if (shadowRoot) {\n        shadowRoot.removeEventListener(\n          \"focusin\",\n          keyborgNativeFocusEvent.focusInHandler,\n          true,\n        );\n        shadowRoot.removeEventListener(\n          \"focusout\",\n          keyborgNativeFocusEvent.focusOutHandler,\n          true,\n        );\n      }\n    }\n\n    keyborgNativeFocusEvent.shadowTargets.clear();\n\n    delete kwin.__keyborgData;\n  }\n\n  if (origFocus) {\n    proto.focus = origFocus;\n  }\n}\n\n/**\n * @param win The window that stores keyborg focus events\n * @returns The last element focused with element.focus()\n */\nexport function getLastFocusedProgrammatically(\n  win: Window,\n): HTMLElement | null | undefined {\n  const keyborgNativeFocusEvent = (win as WindowWithKeyborgFocusEvent)\n    .__keyborgData;\n\n  return keyborgNativeFocusEvent\n    ? keyborgNativeFocusEvent.lastFocusedProgrammatically?.deref() || null\n    : undefined;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n  disposeFocusEvent,\n  KeyborgFocusInEvent,\n  KEYBORG_FOCUSIN,\n  setupFocusEvent,\n} from \"./FocusEvent\";\nimport { Disposable } from \"./WeakRefInstance\";\n\ninterface WindowWithKeyborg extends Window {\n  __keyborg?: {\n    core: KeyborgCore;\n    refs: { [id: string]: Keyborg };\n  };\n}\n\nconst _dismissTimeout = 500; // When a key from dismissKeys is pressed and the focus is not moved\n// during _dismissTimeout time, dismiss the keyboard navigation mode.\n\nlet _lastId = 0;\n\nexport interface KeyborgProps {\n  // Keys to be used to trigger keyboard navigation mode. By default, any key will trigger\n  // it. Could be limited to, for example, just Tab (or Tab and arrow keys).\n  triggerKeys?: number[];\n  // Keys to be used to dismiss keyboard navigation mode using keyboard (in addition to\n  // mouse clicks which dismiss it). For example, Esc could be used to dismiss.\n  dismissKeys?: number[];\n}\n\nexport type KeyborgCallback = (isNavigatingWithKeyboard: boolean) => void;\n\n/**\n * Manages a collection of Keyborg instances in a window/document and updates keyborg state\n */\nclass KeyborgCore implements Disposable {\n  readonly id: string;\n\n  private _win?: WindowWithKeyborg;\n  private _isMouseUsedTimer: number | undefined;\n  private _dismissTimer: number | undefined;\n  private _triggerKeys?: Set<number>;\n  private _dismissKeys?: Set<number>;\n  private _isNavigatingWithKeyboard_DO_NOT_USE = false;\n\n  constructor(win: WindowWithKeyborg, props?: KeyborgProps) {\n    this.id = \"c\" + ++_lastId;\n    this._win = win;\n    const doc = win.document;\n\n    if (props) {\n      const triggerKeys = props.triggerKeys;\n      const dismissKeys = props.dismissKeys;\n\n      if (triggerKeys?.length) {\n        this._triggerKeys = new Set(triggerKeys);\n      }\n\n      if (dismissKeys?.length) {\n        this._dismissKeys = new Set(dismissKeys);\n      }\n    }\n\n    doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true); // Capture!\n    doc.addEventListener(\"mousedown\", this._onMouseDown, true); // Capture!\n    win.addEventListener(\"keydown\", this._onKeyDown, true); // Capture!\n\n    setupFocusEvent(win);\n  }\n\n  get isNavigatingWithKeyboard() {\n    return this._isNavigatingWithKeyboard_DO_NOT_USE;\n  }\n\n  set isNavigatingWithKeyboard(val: boolean) {\n    if (this._isNavigatingWithKeyboard_DO_NOT_USE !== val) {\n      this._isNavigatingWithKeyboard_DO_NOT_USE = val;\n      this.update();\n    }\n  }\n\n  dispose(): void {\n    const win = this._win;\n\n    if (win) {\n      if (this._isMouseUsedTimer) {\n        win.clearTimeout(this._isMouseUsedTimer);\n        this._isMouseUsedTimer = undefined;\n      }\n\n      if (this._dismissTimer) {\n        win.clearTimeout(this._dismissTimer);\n        this._dismissTimer = undefined;\n      }\n\n      disposeFocusEvent(win);\n\n      const doc = win.document;\n\n      doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true); // Capture!\n      doc.removeEventListener(\"mousedown\", this._onMouseDown, true); // Capture!\n      win.removeEventListener(\"keydown\", this._onKeyDown, true); // Capture!\n\n      delete this._win;\n    }\n  }\n\n  isDisposed(): boolean {\n    return !!this._win;\n  }\n\n  /**\n   * Updates all keyborg instances with the keyboard navigation state\n   */\n  update(): void {\n    const keyborgs = this._win?.__keyborg?.refs;\n\n    if (keyborgs) {\n      for (const id of Object.keys(keyborgs)) {\n        Keyborg.update(keyborgs[id], this.isNavigatingWithKeyboard);\n      }\n    }\n  }\n\n  private _onFocusIn = (e: KeyborgFocusInEvent) => {\n    // When the focus is moved not programmatically and without keydown events,\n    // it is likely that the focus is moved by screen reader (as it might swallow\n    // the events when the screen reader shortcuts are used). The screen reader\n    // usage is keyboard navigation.\n\n    if (this._isMouseUsedTimer) {\n      // There was a mouse event recently.\n      return;\n    }\n\n    if (this.isNavigatingWithKeyboard) {\n      return;\n    }\n\n    const details = e.detail;\n\n    if (!details.relatedTarget) {\n      return;\n    }\n\n    if (\n      details.isFocusedProgrammatically ||\n      details.isFocusedProgrammatically === undefined\n    ) {\n      // The element is focused programmatically, or the programmatic focus detection\n      // is not working.\n      return;\n    }\n\n    this.isNavigatingWithKeyboard = true;\n  };\n\n  private _onMouseDown = (e: MouseEvent): void => {\n    if (\n      e.buttons === 0 ||\n      (e.clientX === 0 && e.clientY === 0 && e.screenX === 0 && e.screenY === 0)\n    ) {\n      // This is most likely an event triggered by the screen reader to perform\n      // an action on an element, do not dismiss the keyboard navigation mode.\n      return;\n    }\n\n    const win = this._win;\n\n    if (win) {\n      if (this._isMouseUsedTimer) {\n        win.clearTimeout(this._isMouseUsedTimer);\n      }\n\n      this._isMouseUsedTimer = win.setTimeout(() => {\n        delete this._isMouseUsedTimer;\n      }, 1000); // Keeping the indication of the mouse usage for some time.\n    }\n\n    this.isNavigatingWithKeyboard = false;\n  };\n\n  private _onKeyDown = (e: KeyboardEvent): void => {\n    const isNavigatingWithKeyboard = this.isNavigatingWithKeyboard;\n\n    if (isNavigatingWithKeyboard) {\n      if (this._shouldDismissKeyboardNavigation(e)) {\n        this._scheduleDismiss();\n      }\n    } else {\n      if (this._shouldTriggerKeyboardNavigation(e)) {\n        this.isNavigatingWithKeyboard = true;\n      }\n    }\n  };\n\n  /**\n   * @returns whether the keyboard event should trigger keyboard navigation mode\n   */\n  private _shouldTriggerKeyboardNavigation(e: KeyboardEvent) {\n    // TODO Some rich text fields can allow Tab key for indentation so it doesn't\n    // need to be a navigation key. If there is a bug regarding that we should revisit\n    if (e.key === \"Tab\") {\n      return true;\n    }\n\n    const activeElement = this._win?.document\n      .activeElement as HTMLElement | null;\n    const isTriggerKey = !this._triggerKeys || this._triggerKeys.has(e.keyCode);\n\n    const isEditable =\n      activeElement &&\n      (activeElement.tagName === \"INPUT\" ||\n        activeElement.tagName === \"TEXTAREA\" ||\n        activeElement.isContentEditable);\n\n    return isTriggerKey && !isEditable;\n  }\n\n  /**\n   * @returns whether the keyboard event should dismiss keyboard navigation mode\n   */\n  private _shouldDismissKeyboardNavigation(e: KeyboardEvent) {\n    return this._dismissKeys?.has(e.keyCode);\n  }\n\n  private _scheduleDismiss(): void {\n    const win = this._win;\n\n    if (win) {\n      if (this._dismissTimer) {\n        win.clearTimeout(this._dismissTimer);\n        this._dismissTimer = undefined;\n      }\n\n      const was = win.document.activeElement;\n\n      this._dismissTimer = win.setTimeout(() => {\n        this._dismissTimer = undefined;\n\n        const cur = win.document.activeElement;\n\n        if (was && cur && was === cur) {\n          // Esc was pressed, currently focused element hasn't changed.\n          // Just dismiss the keyboard navigation mode.\n          this.isNavigatingWithKeyboard = false;\n        }\n      }, _dismissTimeout);\n    }\n  }\n}\n\n/**\n * Used to determine the keyboard navigation state\n */\nexport class Keyborg {\n  private _id: string;\n  private _win?: WindowWithKeyborg;\n  private _core?: KeyborgCore;\n  private _cb: KeyborgCallback[] = [];\n\n  static create(win: WindowWithKeyborg, props?: KeyborgProps): Keyborg {\n    return new Keyborg(win, props);\n  }\n\n  static dispose(instance: Keyborg): void {\n    instance.dispose();\n  }\n\n  /**\n   * Updates all subscribed callbacks with the keyboard navigation state\n   */\n  static update(instance: Keyborg, isNavigatingWithKeyboard: boolean): void {\n    instance._cb.forEach((callback) => callback(isNavigatingWithKeyboard));\n  }\n\n  private constructor(win: WindowWithKeyborg, props?: KeyborgProps) {\n    this._id = \"k\" + ++_lastId;\n    this._win = win;\n\n    const current = win.__keyborg;\n\n    if (current) {\n      this._core = current.core;\n      current.refs[this._id] = this;\n    } else {\n      this._core = new KeyborgCore(win, props);\n      win.__keyborg = {\n        core: this._core,\n        refs: { [this._id]: this },\n      };\n    }\n  }\n\n  private dispose(): void {\n    const current = this._win?.__keyborg;\n\n    if (current?.refs[this._id]) {\n      delete current.refs[this._id];\n\n      if (Object.keys(current.refs).length === 0) {\n        current.core.dispose();\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        delete this._win!.__keyborg;\n      }\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.error(\n        `Keyborg instance ${this._id} is being disposed incorrectly.`,\n      );\n    }\n\n    this._cb = [];\n    delete this._core;\n    delete this._win;\n  }\n\n  /**\n   * @returns Whether the user is navigating with keyboard\n   */\n  isNavigatingWithKeyboard(): boolean {\n    return !!this._core?.isNavigatingWithKeyboard;\n  }\n\n  /**\n   * @param callback - Called when the keyboard navigation state changes\n   */\n  subscribe(callback: KeyborgCallback): void {\n    this._cb.push(callback);\n  }\n\n  /**\n   * @param callback - Registered with subscribe\n   */\n  unsubscribe(callback: KeyborgCallback): void {\n    const index = this._cb.indexOf(callback);\n\n    if (index >= 0) {\n      this._cb.splice(index, 1);\n    }\n  }\n\n  /**\n   * Manually set the keyboard navigtion state\n   */\n  setVal(isNavigatingWithKeyboard: boolean): void {\n    if (this._core) {\n      this._core.isNavigatingWithKeyboard = isNavigatingWithKeyboard;\n    }\n  }\n}\n\nexport function createKeyborg(win: Window, props?: KeyborgProps): Keyborg {\n  return Keyborg.create(win, props);\n}\n\nexport function disposeKeyborg(instance: Keyborg) {\n  Keyborg.dispose(instance);\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport type { Keyborg, KeyborgCallback } from \"./Keyborg\";\nexport { createKeyborg, disposeKeyborg } from \"./Keyborg\";\n\nexport type {\n  KeyborgFocusInEvent,\n  KeyborgFocusInEventDetails,\n  KeyborgFocusOutEvent,\n  KeyborgFocusOutEventDetails,\n} from \"./FocusEvent\";\nexport {\n  getLastFocusedProgrammatically,\n  nativeFocus,\n  KEYBORG_FOCUSIN,\n  KEYBORG_FOCUSOUT,\n} from \"./FocusEvent\";\n\nexport const version = process.env.PKG_VERSION;\n"],"mappings":"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","names":[]}