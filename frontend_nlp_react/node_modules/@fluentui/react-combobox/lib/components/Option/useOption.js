import * as React from 'react';
import { getIntrinsicElementProps, useId, useMergedRefs, slot } from '@fluentui/react-utilities';
import { useContextSelector } from '@fluentui/react-context-selector';
import { CheckmarkFilled, Checkmark12Filled } from '@fluentui/react-icons';
import { ComboboxContext } from '../../contexts/ComboboxContext';
import { ListboxContext } from '../../contexts/ListboxContext';
function getTextString(text, children) {
    if (text !== undefined) {
        return text;
    }
    let textString = '';
    let hasNonStringChild = false;
    React.Children.forEach(children, (child)=>{
        if (typeof child === 'string') {
            textString += child;
        } else {
            hasNonStringChild = true;
        }
    });
    // warn if an Option has non-string children and no text prop
    if (hasNonStringChild) {
        // eslint-disable-next-line no-console
        console.warn('Provide a `text` prop to Option components when they contain non-string children.');
    }
    return textString;
}
/**
 * Create the state required to render Option.
 *
 * The returned state can be modified with hooks such as useOptionStyles_unstable,
 * before being passed to renderOption_unstable.
 *
 * @param props - props from this instance of Option
 * @param ref - reference to root HTMLElement of Option
 */ export const useOption_unstable = (props, ref)=>{
    const { children, disabled, text, value } = props;
    const optionRef = React.useRef(null);
    const optionText = getTextString(text, children);
    const optionValue = value !== null && value !== void 0 ? value : optionText;
    // use the id if provided, otherwise use a generated id
    const id = useId('fluent-option', props.id);
    // data used for context registration & events
    const optionData = React.useMemo(()=>({
            id,
            disabled,
            text: optionText,
            value: optionValue
        }), [
        id,
        disabled,
        optionText,
        optionValue
    ]);
    // context values
    const focusVisible = useContextSelector(ListboxContext, (ctx)=>ctx.focusVisible);
    const multiselect = useContextSelector(ListboxContext, (ctx)=>ctx.multiselect);
    const registerOption = useContextSelector(ListboxContext, (ctx)=>ctx.registerOption);
    const selected = useContextSelector(ListboxContext, (ctx)=>{
        const selectedOptions = ctx.selectedOptions;
        return !!optionValue && !!selectedOptions.find((o)=>o === optionValue);
    });
    const selectOption = useContextSelector(ListboxContext, (ctx)=>ctx.selectOption);
    const setActiveOption = useContextSelector(ListboxContext, (ctx)=>ctx.setActiveOption);
    const setOpen = useContextSelector(ComboboxContext, (ctx)=>ctx.setOpen);
    // current active option?
    const active = useContextSelector(ListboxContext, (ctx)=>{
        var _ctx_activeOption, _ctx_activeOption1;
        return ((_ctx_activeOption = ctx.activeOption) === null || _ctx_activeOption === void 0 ? void 0 : _ctx_activeOption.id) !== undefined && ((_ctx_activeOption1 = ctx.activeOption) === null || _ctx_activeOption1 === void 0 ? void 0 : _ctx_activeOption1.id) === id;
    });
    // check icon
    let CheckIcon = /*#__PURE__*/ React.createElement(CheckmarkFilled, null);
    if (multiselect) {
        CheckIcon = selected ? /*#__PURE__*/ React.createElement(Checkmark12Filled, null) : '';
    }
    const onClick = (event)=>{
        var _props_onClick;
        if (disabled) {
            event.preventDefault();
            return;
        }
        // clicked option should always become active option
        setActiveOption(optionData);
        // close on option click for single-select options in a combobox
        if (!multiselect) {
            setOpen === null || setOpen === void 0 ? void 0 : setOpen(event, false);
        }
        // handle selection change
        selectOption(event, optionData);
        (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, event);
    };
    // register option data with context
    React.useEffect(()=>{
        if (id && optionRef.current) {
            return registerOption(optionData, optionRef.current);
        }
    }, [
        id,
        optionData,
        registerOption
    ]);
    const semanticProps = multiselect ? {
        role: 'menuitemcheckbox',
        'aria-checked': selected
    } : {
        role: 'option',
        'aria-selected': selected
    };
    return {
        components: {
            root: 'div',
            checkIcon: 'span'
        },
        root: slot.always(getIntrinsicElementProps('div', {
            // FIXME:
            // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
            // but since it would be a breaking change to fix it, we are casting ref to it's proper type
            ref: useMergedRefs(ref, optionRef),
            'aria-disabled': disabled ? 'true' : undefined,
            id,
            ...semanticProps,
            ...props,
            onClick
        }), {
            elementType: 'div'
        }),
        checkIcon: slot.optional(props.checkIcon, {
            renderByDefault: true,
            defaultProps: {
                'aria-hidden': 'true',
                children: CheckIcon
            },
            elementType: 'span'
        }),
        active,
        disabled,
        focusVisible,
        multiselect,
        selected
    };
};
