"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useTriggerSlot", {
    enumerable: true,
    get: function() {
        return useTriggerSlot;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _reactutilities = require("@fluentui/react-utilities");
const _dropdownKeyActions = require("../utils/dropdownKeyActions");
function useTriggerSlot(triggerSlotFromProp, ref, options) {
    const { state: { activeOption, getCount, getIndexOfId, getOptionAtIndex, open, selectOption, setActiveOption, setFocusVisible, setOpen, multiselect, setHasFocus }, defaultProps, elementType } = options;
    const trigger = _reactutilities.slot.always(triggerSlotFromProp, {
        defaultProps: {
            type: 'text',
            'aria-expanded': open,
            'aria-activedescendant': open ? activeOption === null || activeOption === void 0 ? void 0 : activeOption.id : undefined,
            role: 'combobox',
            ...typeof defaultProps === 'object' && defaultProps
        },
        elementType
    });
    // handle trigger focus/blur
    const triggerRef = _react.useRef(null);
    trigger.ref = (0, _reactutilities.useMergedRefs)(triggerRef, trigger.ref, ref);
    // the trigger should open/close the popup on click or blur
    trigger.onBlur = (0, _reactutilities.mergeCallbacks)((event)=>{
        setOpen(event, false);
        setHasFocus(false);
    }, trigger.onBlur);
    trigger.onFocus = (0, _reactutilities.mergeCallbacks)((event)=>{
        if (event.target === event.currentTarget) {
            setHasFocus(true);
        }
    }, trigger.onFocus);
    trigger.onClick = (0, _reactutilities.mergeCallbacks)((event)=>{
        setOpen(event, !open);
    }, trigger.onClick);
    // handle combobox keyboard interaction
    trigger.onKeyDown = (0, _reactutilities.mergeCallbacks)((event)=>{
        const action = (0, _dropdownKeyActions.getDropdownActionFromKey)(event, {
            open,
            multiselect
        });
        const maxIndex = getCount() - 1;
        const activeIndex = activeOption ? getIndexOfId(activeOption.id) : -1;
        let newIndex = activeIndex;
        switch(action){
            case 'Open':
                event.preventDefault();
                setFocusVisible(true);
                setOpen(event, true);
                break;
            case 'Close':
                // stop propagation for escape key to avoid dismissing any parent popups
                event.stopPropagation();
                event.preventDefault();
                setOpen(event, false);
                break;
            case 'CloseSelect':
                !multiselect && !(activeOption === null || activeOption === void 0 ? void 0 : activeOption.disabled) && setOpen(event, false);
            // fallthrough
            case 'Select':
                activeOption && selectOption(event, activeOption);
                event.preventDefault();
                break;
            case 'Tab':
                !multiselect && activeOption && selectOption(event, activeOption);
                break;
            default:
                newIndex = (0, _dropdownKeyActions.getIndexFromAction)(action, activeIndex, maxIndex);
        }
        if (newIndex !== activeIndex) {
            // prevent default page scroll/keyboard action if the index changed
            event.preventDefault();
            setActiveOption(getOptionAtIndex(newIndex));
            setFocusVisible(true);
        }
    }, trigger.onKeyDown);
    trigger.onMouseOver = (0, _reactutilities.mergeCallbacks)((event)=>{
        setFocusVisible(false);
    }, trigger.onMouseOver);
    // TODO fix cast
    return trigger;
}
