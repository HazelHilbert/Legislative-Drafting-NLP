"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useListbox_unstable", {
    enumerable: true,
    get: function() {
        return useListbox_unstable;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _reactutilities = require("@fluentui/react-utilities");
const _reactcontextselector = require("@fluentui/react-context-selector");
const _dropdownKeyActions = require("../../utils/dropdownKeyActions");
const _useOptionCollection = require("../../utils/useOptionCollection");
const _useScrollOptionsIntoView = require("../../utils/useScrollOptionsIntoView");
const _useSelection = require("../../utils/useSelection");
const _ComboboxContext = require("../../contexts/ComboboxContext");
const useListbox_unstable = (props, ref)=>{
    const { multiselect } = props;
    const optionCollection = (0, _useOptionCollection.useOptionCollection)();
    const { getCount, getOptionAtIndex, getIndexOfId } = optionCollection;
    const { clearSelection, selectedOptions, selectOption } = (0, _useSelection.useSelection)(props);
    const [activeOption, setActiveOption] = _react.useState();
    // track whether keyboard focus outline should be shown
    // tabster/keyborg doesn't work here, since the actual keyboard focus target doesn't move
    const [focusVisible, setFocusVisible] = _react.useState(false);
    const onKeyDown = (event)=>{
        const action = (0, _dropdownKeyActions.getDropdownActionFromKey)(event, {
            open: true
        });
        const maxIndex = getCount() - 1;
        const activeIndex = activeOption ? getIndexOfId(activeOption.id) : -1;
        let newIndex = activeIndex;
        switch(action){
            case 'Select':
            case 'CloseSelect':
                activeOption && selectOption(event, activeOption);
                break;
            default:
                newIndex = (0, _dropdownKeyActions.getIndexFromAction)(action, activeIndex, maxIndex);
        }
        if (newIndex !== activeIndex) {
            // prevent default page scroll/keyboard action if the index changed
            event.preventDefault();
            setActiveOption(getOptionAtIndex(newIndex));
            setFocusVisible(true);
        }
    };
    const onMouseOver = (event)=>{
        setFocusVisible(false);
    };
    // get state from parent combobox, if it exists
    const hasComboboxContext = (0, _reactcontextselector.useHasParentContext)(_ComboboxContext.ComboboxContext);
    const comboboxActiveOption = (0, _reactcontextselector.useContextSelector)(_ComboboxContext.ComboboxContext, (ctx)=>ctx.activeOption);
    const comboboxFocusVisible = (0, _reactcontextselector.useContextSelector)(_ComboboxContext.ComboboxContext, (ctx)=>ctx.focusVisible);
    const comboboxSelectedOptions = (0, _reactcontextselector.useContextSelector)(_ComboboxContext.ComboboxContext, (ctx)=>ctx.selectedOptions);
    const comboboxSelectOption = (0, _reactcontextselector.useContextSelector)(_ComboboxContext.ComboboxContext, (ctx)=>ctx.selectOption);
    const comboboxSetActiveOption = (0, _reactcontextselector.useContextSelector)(_ComboboxContext.ComboboxContext, (ctx)=>ctx.setActiveOption);
    // without a parent combobox context, provide values directly from Listbox
    const optionContextValues = hasComboboxContext ? {
        activeOption: comboboxActiveOption,
        focusVisible: comboboxFocusVisible,
        selectedOptions: comboboxSelectedOptions,
        selectOption: comboboxSelectOption,
        setActiveOption: comboboxSetActiveOption
    } : {
        activeOption,
        focusVisible,
        selectedOptions,
        selectOption,
        setActiveOption
    };
    const state = {
        components: {
            root: 'div'
        },
        root: _reactutilities.slot.always((0, _reactutilities.getIntrinsicElementProps)('div', {
            // FIXME:
            // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
            // but since it would be a breaking change to fix it, we are casting ref to it's proper type
            ref: ref,
            role: multiselect ? 'menu' : 'listbox',
            'aria-activedescendant': hasComboboxContext ? undefined : activeOption === null || activeOption === void 0 ? void 0 : activeOption.id,
            tabIndex: 0,
            ...props
        }), {
            elementType: 'div'
        }),
        multiselect,
        clearSelection,
        ...optionCollection,
        ...optionContextValues
    };
    const scrollContainerRef = (0, _useScrollOptionsIntoView.useScrollOptionsIntoView)(state);
    state.root.ref = (0, _reactutilities.useMergedRefs)(state.root.ref, scrollContainerRef);
    state.root.onKeyDown = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)(state.root.onKeyDown, onKeyDown));
    state.root.onMouseOver = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)(state.root.onMouseOver, onMouseOver));
    return state;
};
