"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getCSSStyle: function() {
        return getCSSStyle;
    },
    hasCSSOMSupport: function() {
        return hasCSSOMSupport;
    },
    getElementComputedStyle: function() {
        return getElementComputedStyle;
    },
    toMs: function() {
        return toMs;
    },
    getComputedMapProp: function() {
        return getComputedMapProp;
    },
    getComputedStyleProp: function() {
        return getComputedStyleProp;
    },
    getMaxCSSDuration: function() {
        return getMaxCSSDuration;
    },
    getMotionDuration: function() {
        return getMotionDuration;
    }
});
const _reactutilities = require("@fluentui/react-utilities");
const getCSSStyle = (node)=>{
    if (hasCSSOMSupport(node)) {
        return node.computedStyleMap();
    }
    return getElementComputedStyle(node);
};
const hasCSSOMSupport = (node)=>{
    /**
   * As we are using the experimental CSSOM API, we need to check if the browser supports it.
   * The typecast here is to allow the use of the `number` function that is not yet part of the CSSOM typings.
   * @see https://www.npmjs.com/package/@types/w3c-css-typed-object-model-level-1
   */ return Boolean(typeof CSS !== 'undefined' && CSS.number && node.computedStyleMap);
};
const getElementComputedStyle = (node)=>{
    var _node_ownerDocument;
    var _node_ownerDocument_defaultView;
    const win = (0, _reactutilities.canUseDOM)() && ((_node_ownerDocument_defaultView = (_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.defaultView) !== null && _node_ownerDocument_defaultView !== void 0 ? _node_ownerDocument_defaultView : window);
    if (!win) {
        return {
            getPropertyValue: (_)=>''
        };
    }
    return win.getComputedStyle(node, null);
};
function toMs(duration) {
    const trimmed = duration.trim();
    if (trimmed.includes('auto')) {
        return 0;
    }
    if (trimmed.endsWith('ms')) {
        const parsed = Number(trimmed.replace('ms', ''));
        return isNaN(parsed) ? 0 : parsed;
    }
    return Number(trimmed.slice(0, -1).replace(',', '.')) * 1000;
}
const getComputedMapProp = (computedStyle, prop)=>{
    const props = computedStyle.getAll(prop);
    if (props.length > 0) {
        return props.map(({ value, unit })=>`${value}${unit}`);
    }
    return [
        '0'
    ];
};
const getComputedStyleProp = (computedStyle, prop)=>{
    const propValue = computedStyle.getPropertyValue(prop);
    return propValue ? propValue.split(',') : [
        '0'
    ];
};
const getMaxCSSDuration = (durations, delays)=>{
    const totalProps = Math.max(durations.length, delays.length);
    const totalDurations = [];
    if (totalProps === 0) {
        return 0;
    }
    for(let i = 0; i < totalProps; i++){
        const duration = toMs(durations[i] || '0');
        const delay = toMs(delays[i] || '0');
        totalDurations.push(duration + delay);
    }
    return Math.max(...totalDurations);
};
const getMotionDuration = (node)=>{
    const hasModernCSSSupport = hasCSSOMSupport(node);
    const computedStyle = getCSSStyle(node);
    const getProp = (prop)=>{
        return hasModernCSSSupport ? getComputedMapProp(computedStyle, prop) : getComputedStyleProp(computedStyle, prop);
    };
    const transitionDuration = getMaxCSSDuration(getProp('transition-duration'), getProp('transition-delay'));
    const animationDuration = getMaxCSSDuration(getProp('animation-duration'), getProp('animation-delay'));
    return Math.max(transitionDuration, animationDuration);
};
