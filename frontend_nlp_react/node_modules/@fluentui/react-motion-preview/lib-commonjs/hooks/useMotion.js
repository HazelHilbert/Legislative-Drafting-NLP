"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getDefaultMotionState: function() {
        return getDefaultMotionState;
    },
    useMotion: function() {
        return useMotion;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _reactutilities = require("@fluentui/react-utilities");
const _useReducedMotion = require("./useReducedMotion");
const _domstyle = require("../utils/dom-style");
/**
 * @internal
 *
 * Checks if components was mounted after first render and a certain condition is met.
 *
 * @param condition - Condition to check
 */ const useFirstMountCondition = (condition)=>{
    const isFirst = _react.useRef(true);
    if (isFirst.current && condition) {
        isFirst.current = false;
        return true;
    }
    return isFirst.current;
};
/**
 * @internal
 *
 * Hook to manage the presence of an element in the DOM based on its CSS transition/animation state.
 *
 * @param present - Whether the element should be present in the DOM
 * @param events - Callbacks for when the element enters or exits the DOM
 */ function useMotionPresence(presence, options = {}) {
    const { animateOnFirstMount, duration } = {
        animateOnFirstMount: false,
        ...options
    };
    const [type, setType] = _react.useState(presence && animateOnFirstMount ? 'entering' : presence ? 'idle' : 'unmounted');
    const [active, setActive] = _react.useState(!animateOnFirstMount && presence);
    const [setAnimationTimeout, clearAnimationTimeout] = (0, _reactutilities.useTimeout)();
    const [setTickTimeout, clearTickTimeout] = (0, _reactutilities.useTimeout)();
    const [setAnimationFrame, cancelAnimationFrame] = (0, _reactutilities.useAnimationFrame)();
    const [currentElement, setCurrentElement] = _react.useState(null);
    const isReducedMotion = (0, _useReducedMotion.useReducedMotion)();
    const isFirstReactRender = (0, _reactutilities.useFirstMount)();
    const isFirstDOMRender = useFirstMountCondition(!!currentElement);
    const isInitiallyPresent = _react.useRef(presence).current;
    const disableAnimation = isReducedMotion || isFirstDOMRender && isInitiallyPresent && !animateOnFirstMount;
    const ref = _react.useCallback((node)=>{
        if (!node) {
            return;
        }
        setCurrentElement(node);
    }, []);
    const nextTick = _react.useCallback((cb)=>{
        setTickTimeout(()=>setAnimationFrame(cb), 0);
        return ()=>{
            clearTickTimeout();
            cancelAnimationFrame();
        };
    }, [
        cancelAnimationFrame,
        clearTickTimeout,
        setAnimationFrame,
        setTickTimeout
    ]);
    const onFinished = _react.useCallback(()=>{
        setType(presence ? 'entered' : 'exited');
        nextTick(()=>setType(presence ? 'idle' : 'unmounted'));
    }, [
        nextTick,
        presence
    ]);
    _react.useEffect(()=>{
        if (isFirstReactRender) {
            return;
        }
        // In case animation is disabled, we can skip the animation and go straight to the idle state.
        if (disableAnimation) {
            setType(presence ? 'idle' : 'unmounted');
            setActive(presence);
            return;
        }
        setType(presence ? 'entering' : 'exiting');
        // If the element is not rendered, nothing to do.
        if (!currentElement) {
            return;
        }
        // Wait for the next frame to ensure the element is rendered and the animation can start.
        nextTick(()=>{
            setActive(presence);
            // Wait for the next frame to ensure the animation has started.
            nextTick(()=>{
                const finalDuration = duration || (0, _domstyle.getMotionDuration)(currentElement);
                if (finalDuration === 0) {
                    onFinished();
                    return;
                }
                /**
         * Wait for the animation to finish before updating the state.
         * This is an alternative to using the `transitionend` event which can be unreliable as it fires multiple times
         * if the transition has multiple properties.
         */ setAnimationTimeout(()=>onFinished(), finalDuration);
            });
        });
        return ()=>clearAnimationTimeout();
    /*
     * Only tracks dependencies that are either not stable or are used in the callbacks
     * This is to avoid re-running the effect on every render, especially when the DOM element is not rendered
     */ // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        currentElement,
        disableAnimation,
        onFinished,
        presence
    ]);
    return _react.useMemo(()=>({
            ref,
            type,
            active,
            canRender: presence || type !== 'unmounted'
        }), // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        active,
        type,
        presence
    ]);
}
function getDefaultMotionState() {
    return {
        ref: /*#__PURE__*/ _react.createRef(),
        type: 'unmounted',
        active: false,
        canRender: false
    };
}
function useMotion(shorthand, options) {
    const isShorthand = typeof shorthand === 'object';
    const motion = useMotionPresence(isShorthand ? false : shorthand, options);
    return isShorthand ? shorthand : motion;
}
