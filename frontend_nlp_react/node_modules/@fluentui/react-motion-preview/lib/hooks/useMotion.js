import * as React from 'react';
import { useAnimationFrame, useTimeout, useFirstMount } from '@fluentui/react-utilities';
import { useReducedMotion } from './useReducedMotion';
import { getMotionDuration } from '../utils/dom-style';
/**
 * @internal
 *
 * Checks if components was mounted after first render and a certain condition is met.
 *
 * @param condition - Condition to check
 */ const useFirstMountCondition = (condition)=>{
    const isFirst = React.useRef(true);
    if (isFirst.current && condition) {
        isFirst.current = false;
        return true;
    }
    return isFirst.current;
};
/**
 * @internal
 *
 * Hook to manage the presence of an element in the DOM based on its CSS transition/animation state.
 *
 * @param present - Whether the element should be present in the DOM
 * @param events - Callbacks for when the element enters or exits the DOM
 */ function useMotionPresence(presence, options = {}) {
    const { animateOnFirstMount, duration } = {
        animateOnFirstMount: false,
        ...options
    };
    const [type, setType] = React.useState(presence && animateOnFirstMount ? 'entering' : presence ? 'idle' : 'unmounted');
    const [active, setActive] = React.useState(!animateOnFirstMount && presence);
    const [setAnimationTimeout, clearAnimationTimeout] = useTimeout();
    const [setTickTimeout, clearTickTimeout] = useTimeout();
    const [setAnimationFrame, cancelAnimationFrame] = useAnimationFrame();
    const [currentElement, setCurrentElement] = React.useState(null);
    const isReducedMotion = useReducedMotion();
    const isFirstReactRender = useFirstMount();
    const isFirstDOMRender = useFirstMountCondition(!!currentElement);
    const isInitiallyPresent = React.useRef(presence).current;
    const disableAnimation = isReducedMotion || isFirstDOMRender && isInitiallyPresent && !animateOnFirstMount;
    const ref = React.useCallback((node)=>{
        if (!node) {
            return;
        }
        setCurrentElement(node);
    }, []);
    const nextTick = React.useCallback((cb)=>{
        setTickTimeout(()=>setAnimationFrame(cb), 0);
        return ()=>{
            clearTickTimeout();
            cancelAnimationFrame();
        };
    }, [
        cancelAnimationFrame,
        clearTickTimeout,
        setAnimationFrame,
        setTickTimeout
    ]);
    const onFinished = React.useCallback(()=>{
        setType(presence ? 'entered' : 'exited');
        nextTick(()=>setType(presence ? 'idle' : 'unmounted'));
    }, [
        nextTick,
        presence
    ]);
    React.useEffect(()=>{
        if (isFirstReactRender) {
            return;
        }
        // In case animation is disabled, we can skip the animation and go straight to the idle state.
        if (disableAnimation) {
            setType(presence ? 'idle' : 'unmounted');
            setActive(presence);
            return;
        }
        setType(presence ? 'entering' : 'exiting');
        // If the element is not rendered, nothing to do.
        if (!currentElement) {
            return;
        }
        // Wait for the next frame to ensure the element is rendered and the animation can start.
        nextTick(()=>{
            setActive(presence);
            // Wait for the next frame to ensure the animation has started.
            nextTick(()=>{
                const finalDuration = duration || getMotionDuration(currentElement);
                if (finalDuration === 0) {
                    onFinished();
                    return;
                }
                /**
         * Wait for the animation to finish before updating the state.
         * This is an alternative to using the `transitionend` event which can be unreliable as it fires multiple times
         * if the transition has multiple properties.
         */ setAnimationTimeout(()=>onFinished(), finalDuration);
            });
        });
        return ()=>clearAnimationTimeout();
    /*
     * Only tracks dependencies that are either not stable or are used in the callbacks
     * This is to avoid re-running the effect on every render, especially when the DOM element is not rendered
     */ // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        currentElement,
        disableAnimation,
        onFinished,
        presence
    ]);
    return React.useMemo(()=>({
            ref,
            type,
            active,
            canRender: presence || type !== 'unmounted'
        }), // No need to add ref to the deps array as it is stable
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        active,
        type,
        presence
    ]);
}
/**
 * Returns a default motion state.
 */ export function getDefaultMotionState() {
    return {
        ref: React.createRef(),
        type: 'unmounted',
        active: false,
        canRender: false
    };
}
/**
 * Hook to manage the presence of an element in the DOM based on its CSS transition/animation state.
 *
 * @param props - Motion props to manage the presence of an element in the DOM
 * @param options - Motion options to configure the hook
 */ export function useMotion(shorthand, options) {
    const isShorthand = typeof shorthand === 'object';
    const motion = useMotionPresence(isShorthand ? false : shorthand, options);
    return isShorthand ? shorthand : motion;
}
