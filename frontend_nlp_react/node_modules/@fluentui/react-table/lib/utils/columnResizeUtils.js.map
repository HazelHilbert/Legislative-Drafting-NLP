{"version":3,"sources":["columnResizeUtils.ts"],"sourcesContent":["import { TableColumnDefinition, ColumnWidthState, TableColumnId, TableColumnSizingOptions } from '../hooks';\n\nconst DEFAULT_WIDTH = 150;\nconst DEFAULT_MIN_WIDTH = 100;\n\n/**\n * This function takes the column definitions and the curent ColumnWidthState and returns new state.\n *  - It uses existing state for existing columns.\n *  - It removes any state for columns no longer present.\n *  - It checks if any column has been replaced and returns updated state if so\n *  - It returns old state if no changes in the state have been made (so that react doesn't call effects)\n * @param columns\n * @param state\n * @returns\n */\n\nexport function columnDefinitionsToState<T>(\n  columns: TableColumnDefinition<T>[],\n  state: ColumnWidthState[] = [],\n  columnSizingOptions: TableColumnSizingOptions = {},\n): ColumnWidthState[] {\n  let updated = false;\n  const stateMap = new Map(state.map(s => [s.columnId, s]));\n\n  const updatedState = columns.map(column => {\n    const existingColumnState = stateMap.get(column.columnId);\n\n    if (existingColumnState) {\n      const {\n        idealWidth = existingColumnState.idealWidth,\n        minWidth = existingColumnState.minWidth,\n        padding = existingColumnState.padding,\n      } = columnSizingOptions[column.columnId] ?? {};\n\n      if (\n        idealWidth !== existingColumnState.idealWidth ||\n        minWidth !== existingColumnState.minWidth ||\n        padding !== existingColumnState.padding\n      ) {\n        updated = true;\n        return {\n          ...existingColumnState,\n          idealWidth,\n          width: idealWidth,\n          minWidth,\n          padding,\n        };\n      }\n      return existingColumnState;\n    }\n\n    const {\n      defaultWidth,\n      idealWidth = DEFAULT_WIDTH,\n      minWidth = DEFAULT_MIN_WIDTH,\n      padding,\n    } = columnSizingOptions[column.columnId] ?? {};\n\n    updated = true;\n    return {\n      columnId: column.columnId,\n      width: Math.max(defaultWidth ?? idealWidth, minWidth),\n      minWidth,\n      idealWidth: Math.max(defaultWidth ?? idealWidth, minWidth),\n      padding: padding ?? 16,\n    };\n  });\n\n  // If the length of the new state changed (column was added or removed) or any of\n  // the individual states has a new reference (column was replaced),\n  // we have to reset the column widths to their ideal width (because the column which was last may not be last now).\n  // Then the adjustColumnWidthsToFitContainer can do its job and properly stretch the last column.\n  if (updatedState.length !== state.length || updated) {\n    const column = updatedState.find(col => col.width > col.idealWidth);\n    if (column) {\n      column.width = column.idealWidth;\n    }\n\n    updated = true;\n  }\n\n  return updated ? updatedState : state;\n}\n\nexport function getColumnById(state: ColumnWidthState[], columnId: TableColumnId) {\n  return state.find(c => c.columnId === columnId);\n}\n\nexport function getColumnByIndex(state: ColumnWidthState[], index: number) {\n  return state[index];\n}\n\nexport function getTotalWidth(state: ColumnWidthState[]): number {\n  return state.reduce((sum, column) => sum + column.width + column.padding, 0);\n}\n\nexport function getLength(state: ColumnWidthState[]) {\n  return state.length;\n}\n\nexport function getColumnWidth(state: ColumnWidthState[], columnId: TableColumnId): number {\n  const column = getColumnById(state, columnId);\n  return column?.width ?? 0;\n}\n\n/**\n * This function takes the current state and returns an updated state, so that it can be set.\n * The reason for this is that we can update the state multiple times before commiting to render.\n * This is an optimization and also prevents flickering.\n * It also returns new copy of the state only if the value is different than the one currently in\n * the state, further preventing unnecessary updates.\n * @param localState\n * @param columnId\n * @param property\n * @param value\n * @returns\n */\nexport function setColumnProperty(\n  localState: ColumnWidthState[],\n  columnId: TableColumnId,\n  property: keyof ColumnWidthState,\n  value: number,\n) {\n  const currentColumn = getColumnById(localState, columnId);\n\n  if (!currentColumn || currentColumn?.[property] === value) {\n    return localState;\n  }\n\n  const updatedColumn = { ...currentColumn, [property]: value };\n\n  const newState = localState.reduce((acc, current) => {\n    if (current.columnId === updatedColumn.columnId) {\n      return [...acc, updatedColumn];\n    }\n    return [...acc, current];\n  }, [] as ColumnWidthState[]);\n\n  return newState;\n}\n\n/**\n * This function takes the state and container width and makes sure the each column in the state\n * is its optimal width, and that the columns\n * a) fit to the container\n * b) always fill the whole container\n * @param state\n * @param containerWidth\n * @returns\n */\nexport function adjustColumnWidthsToFitContainer(state: ColumnWidthState[], containerWidth: number) {\n  let newState = state;\n  const totalWidth = getTotalWidth(newState);\n\n  // The total width is smaller, we are expanding columns\n  if (totalWidth < containerWidth) {\n    let difference = containerWidth - totalWidth;\n    let i = 0;\n    // We start at the beginning and assign the columns their ideal width\n    while (i < newState.length && difference > 0) {\n      const currentCol = getColumnByIndex(newState, i);\n      const colAdjustment = Math.min(currentCol.idealWidth - currentCol.width, difference);\n      newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width + colAdjustment);\n      difference -= colAdjustment;\n\n      // if there is still empty space, after all columns are their ideal sizes, assign it to the last column\n      if (i === newState.length - 1 && difference !== 0) {\n        const lastCol = getColumnByIndex(newState, i);\n        newState = setColumnProperty(newState, lastCol.columnId, 'width', lastCol.width + difference);\n      }\n\n      i++;\n    }\n  }\n\n  // The total width is larger than container, we need to squash the columns\n  else if (totalWidth >= containerWidth) {\n    let difference = totalWidth - containerWidth;\n    // We start with the last column\n    let j = newState.length - 1;\n    while (j >= 0 && difference > 0) {\n      const currentCol = getColumnByIndex(newState, j);\n      if (currentCol.width > currentCol.minWidth) {\n        const colAdjustment = Math.min(currentCol.width - currentCol.minWidth, difference);\n        difference -= colAdjustment;\n        newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width - colAdjustment);\n      }\n      j--;\n    }\n  }\n\n  return newState;\n}\n"],"names":["DEFAULT_WIDTH","DEFAULT_MIN_WIDTH","columnDefinitionsToState","columns","state","columnSizingOptions","updated","stateMap","Map","map","s","columnId","updatedState","column","existingColumnState","get","idealWidth","minWidth","padding","width","defaultWidth","Math","max","length","find","col","getColumnById","c","getColumnByIndex","index","getTotalWidth","reduce","sum","getLength","getColumnWidth","setColumnProperty","localState","property","value","currentColumn","updatedColumn","newState","acc","current","adjustColumnWidthsToFitContainer","containerWidth","totalWidth","difference","i","currentCol","colAdjustment","min","lastCol","j"],"mappings":"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"}