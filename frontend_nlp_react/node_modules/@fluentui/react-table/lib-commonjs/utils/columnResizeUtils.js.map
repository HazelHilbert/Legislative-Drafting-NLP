{"version":3,"sources":["columnResizeUtils.js"],"sourcesContent":["const DEFAULT_WIDTH = 150;\nconst DEFAULT_MIN_WIDTH = 100;\n/**\n * This function takes the column definitions and the curent ColumnWidthState and returns new state.\n *  - It uses existing state for existing columns.\n *  - It removes any state for columns no longer present.\n *  - It checks if any column has been replaced and returns updated state if so\n *  - It returns old state if no changes in the state have been made (so that react doesn't call effects)\n * @param columns\n * @param state\n * @returns\n */ export function columnDefinitionsToState(columns, state = [], columnSizingOptions = {}) {\n    let updated = false;\n    const stateMap = new Map(state.map((s)=>[\n            s.columnId,\n            s\n        ]));\n    const updatedState = columns.map((column)=>{\n        const existingColumnState = stateMap.get(column.columnId);\n        if (existingColumnState) {\n            var _columnSizingOptions_column_columnId;\n            const { idealWidth = existingColumnState.idealWidth, minWidth = existingColumnState.minWidth, padding = existingColumnState.padding } = (_columnSizingOptions_column_columnId = columnSizingOptions[column.columnId]) !== null && _columnSizingOptions_column_columnId !== void 0 ? _columnSizingOptions_column_columnId : {};\n            if (idealWidth !== existingColumnState.idealWidth || minWidth !== existingColumnState.minWidth || padding !== existingColumnState.padding) {\n                updated = true;\n                return {\n                    ...existingColumnState,\n                    idealWidth,\n                    width: idealWidth,\n                    minWidth,\n                    padding\n                };\n            }\n            return existingColumnState;\n        }\n        var _columnSizingOptions_column_columnId1;\n        const { defaultWidth, idealWidth = DEFAULT_WIDTH, minWidth = DEFAULT_MIN_WIDTH, padding } = (_columnSizingOptions_column_columnId1 = columnSizingOptions[column.columnId]) !== null && _columnSizingOptions_column_columnId1 !== void 0 ? _columnSizingOptions_column_columnId1 : {};\n        updated = true;\n        return {\n            columnId: column.columnId,\n            width: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),\n            minWidth,\n            idealWidth: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),\n            padding: padding !== null && padding !== void 0 ? padding : 16\n        };\n    });\n    // If the length of the new state changed (column was added or removed) or any of\n    // the individual states has a new reference (column was replaced),\n    // we have to reset the column widths to their ideal width (because the column which was last may not be last now).\n    // Then the adjustColumnWidthsToFitContainer can do its job and properly stretch the last column.\n    if (updatedState.length !== state.length || updated) {\n        const column = updatedState.find((col)=>col.width > col.idealWidth);\n        if (column) {\n            column.width = column.idealWidth;\n        }\n        updated = true;\n    }\n    return updated ? updatedState : state;\n}\nexport function getColumnById(state, columnId) {\n    return state.find((c)=>c.columnId === columnId);\n}\nexport function getColumnByIndex(state, index) {\n    return state[index];\n}\nexport function getTotalWidth(state) {\n    return state.reduce((sum, column)=>sum + column.width + column.padding, 0);\n}\nexport function getLength(state) {\n    return state.length;\n}\nexport function getColumnWidth(state, columnId) {\n    const column = getColumnById(state, columnId);\n    var _column_width;\n    return (_column_width = column === null || column === void 0 ? void 0 : column.width) !== null && _column_width !== void 0 ? _column_width : 0;\n}\n/**\n * This function takes the current state and returns an updated state, so that it can be set.\n * The reason for this is that we can update the state multiple times before commiting to render.\n * This is an optimization and also prevents flickering.\n * It also returns new copy of the state only if the value is different than the one currently in\n * the state, further preventing unnecessary updates.\n * @param localState\n * @param columnId\n * @param property\n * @param value\n * @returns\n */ export function setColumnProperty(localState, columnId, property, value) {\n    const currentColumn = getColumnById(localState, columnId);\n    if (!currentColumn || (currentColumn === null || currentColumn === void 0 ? void 0 : currentColumn[property]) === value) {\n        return localState;\n    }\n    const updatedColumn = {\n        ...currentColumn,\n        [property]: value\n    };\n    const newState = localState.reduce((acc, current)=>{\n        if (current.columnId === updatedColumn.columnId) {\n            return [\n                ...acc,\n                updatedColumn\n            ];\n        }\n        return [\n            ...acc,\n            current\n        ];\n    }, []);\n    return newState;\n}\n/**\n * This function takes the state and container width and makes sure the each column in the state\n * is its optimal width, and that the columns\n * a) fit to the container\n * b) always fill the whole container\n * @param state\n * @param containerWidth\n * @returns\n */ export function adjustColumnWidthsToFitContainer(state, containerWidth) {\n    let newState = state;\n    const totalWidth = getTotalWidth(newState);\n    // The total width is smaller, we are expanding columns\n    if (totalWidth < containerWidth) {\n        let difference = containerWidth - totalWidth;\n        let i = 0;\n        // We start at the beginning and assign the columns their ideal width\n        while(i < newState.length && difference > 0){\n            const currentCol = getColumnByIndex(newState, i);\n            const colAdjustment = Math.min(currentCol.idealWidth - currentCol.width, difference);\n            newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width + colAdjustment);\n            difference -= colAdjustment;\n            // if there is still empty space, after all columns are their ideal sizes, assign it to the last column\n            if (i === newState.length - 1 && difference !== 0) {\n                const lastCol = getColumnByIndex(newState, i);\n                newState = setColumnProperty(newState, lastCol.columnId, 'width', lastCol.width + difference);\n            }\n            i++;\n        }\n    } else if (totalWidth >= containerWidth) {\n        let difference = totalWidth - containerWidth;\n        // We start with the last column\n        let j = newState.length - 1;\n        while(j >= 0 && difference > 0){\n            const currentCol = getColumnByIndex(newState, j);\n            if (currentCol.width > currentCol.minWidth) {\n                const colAdjustment = Math.min(currentCol.width - currentCol.minWidth, difference);\n                difference -= colAdjustment;\n                newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width - colAdjustment);\n            }\n            j--;\n        }\n    }\n    return newState;\n}\n"],"names":["columnDefinitionsToState","getColumnById","getColumnByIndex","getTotalWidth","getLength","getColumnWidth","setColumnProperty","adjustColumnWidthsToFitContainer","DEFAULT_WIDTH","DEFAULT_MIN_WIDTH","columns","state","columnSizingOptions","updated","stateMap","Map","map","s","columnId","updatedState","column","existingColumnState","get","_columnSizingOptions_column_columnId","idealWidth","minWidth","padding","width","_columnSizingOptions_column_columnId1","defaultWidth","Math","max","length","find","col","c","index","reduce","sum","_column_width","localState","property","value","currentColumn","updatedColumn","newState","acc","current","containerWidth","totalWidth","difference","i","currentCol","colAdjustment","min","lastCol","j"],"mappings":"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"}