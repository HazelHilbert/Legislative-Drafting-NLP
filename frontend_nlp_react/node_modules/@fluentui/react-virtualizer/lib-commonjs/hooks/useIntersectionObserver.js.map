{"version":3,"sources":["useIntersectionObserver.js"],"sourcesContent":["import * as React from 'react';\nimport { useIsomorphicLayoutEffect } from '@fluentui/react-utilities';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nconst { useCallback, useState, useRef } = React;\nimport { useMutationObserver } from './useMutationObserver';\n/**\n * This function will take the rootMargin and flip the sides if we are in RTL based on the computed reading direction of the target element.\n * @param ltrRootMargin the margin to be processed and flipped if required\n * @param target target element that will have its current reading direction determined\n * @returns the corrected rootMargin (if it was necessary to correct)\n */ export const getRTLRootMargin = (ltrRootMargin, target)=>{\n    if (target) {\n        // get the computed dir for the target element\n        const newDir = getComputedStyle(target).direction;\n        // If we're in rtl reading direction, we might need to flip the margins on the left/right sides\n        if (newDir === 'rtl') {\n            let newMargin = ltrRootMargin;\n            const splitMargins = ltrRootMargin.split(' ');\n            // We only need to do this if we get four values, otherwise the sides are equal and don't require flipping.\n            if (splitMargins.length === 4) {\n                newMargin = `${splitMargins[0]} ${splitMargins[3]} ${splitMargins[2]} ${splitMargins[1]}`;\n            }\n            return newMargin;\n        } else {\n            return ltrRootMargin;\n        }\n    }\n    return ltrRootMargin;\n};\n/**\n * React hook that allows easy usage of the browser API IntersectionObserver within React\n * @param callback - A function called when the percentage of the target element is visible crosses a threshold.\n * @param options - An optional object which customizes the observer. If options isn't specified, the observer uses the\n * document's viewport as the root, with no margin, and a 0% threshold (meaning that even a one-pixel change is\n * enough to trigger a callback).\n * @returns An array containing a callback to update the list of Elements the observer should listen to, a callback to\n * update the init options of the IntersectionObserver and a ref to the IntersectionObserver instance itself.\n */ export const useIntersectionObserver = (callback, options)=>{\n    const observer = useRef();\n    const [observerList, setObserverList] = useState();\n    const { targetDocument } = useFluent();\n    var _options_rootMargin;\n    // set the initial init with corrected margins based on the observed root's calculated reading direction.\n    const [observerInit, setObserverInit] = useState(options && {\n        ...options,\n        rootMargin: getRTLRootMargin((_options_rootMargin = options.rootMargin) !== null && _options_rootMargin !== void 0 ? _options_rootMargin : '0px', options.root)\n    });\n    var _options_rootMargin1;\n    // We have to assume that any values passed in for rootMargin by the consuming app are ltr values. As such we will store the ltr value.\n    const ltrRootMargin = useRef((_options_rootMargin1 = options === null || options === void 0 ? void 0 : options.rootMargin) !== null && _options_rootMargin1 !== void 0 ? _options_rootMargin1 : '0px');\n    // Callback function to execute when mutations are observed\n    const mutationObserverCallback = useCallback((mutationList)=>{\n        for (const mutation of mutationList){\n            // Ensuring that the right attribute is being observed and that the root is within the tree of the element being mutated.\n            if (mutation.type === 'attributes' && mutation.attributeName === 'dir' && (options === null || options === void 0 ? void 0 : options.root) && mutation.target.contains(options === null || options === void 0 ? void 0 : options.root)) {\n                setObserverInit({\n                    ...observerInit,\n                    rootMargin: getRTLRootMargin(ltrRootMargin.current, observerInit === null || observerInit === void 0 ? void 0 : observerInit.root)\n                });\n            }\n        }\n    }, [\n        ltrRootMargin,\n        observerInit,\n        options === null || options === void 0 ? void 0 : options.root\n    ]);\n    // Mutation observer for dir attribute changes in the document\n    useMutationObserver(targetDocument, mutationObserverCallback, {\n        attributes: true,\n        subtree: true,\n        attributeFilter: [\n            'dir'\n        ]\n    });\n    // Observer elements in passed in list and clean up previous list\n    // This effect is only triggered when observerList is updated\n    useIsomorphicLayoutEffect(()=>{\n        observer.current = new IntersectionObserver(callback, {\n            ...observerInit,\n            rootMargin: getRTLRootMargin(ltrRootMargin.current, observerInit === null || observerInit === void 0 ? void 0 : observerInit.root)\n        });\n        observer.current = new IntersectionObserver(callback, observerInit);\n        // If we have an instance of IO and a list with elements, observer the elements\n        if (observer.current && observerList && observerList.length > 0) {\n            observerList.forEach((element)=>{\n                var _observer_current;\n                (_observer_current = observer.current) === null || _observer_current === void 0 ? void 0 : _observer_current.observe(element);\n            });\n        }\n        // clean up previous elements being listened to\n        return ()=>{\n            if (observer.current) {\n                observer.current.disconnect();\n            }\n        };\n    }, [\n        observerList,\n        observerInit,\n        callback\n    ]);\n    // Do not use internally, we need to track external settings only here\n    const setObserverInitExternal = useCallback((newInit)=>{\n        var _newInit_rootMargin;\n        // Since we know this is coming from consumers, we can store this value as LTR somewhat safely.\n        ltrRootMargin.current = (_newInit_rootMargin = newInit === null || newInit === void 0 ? void 0 : newInit.rootMargin) !== null && _newInit_rootMargin !== void 0 ? _newInit_rootMargin : '0px';\n        // Call the internal setter to update the value and ensure if our calculated direction is rtl, we flip the margin\n        setObserverInit({\n            ...newInit,\n            rootMargin: getRTLRootMargin(ltrRootMargin.current, newInit === null || newInit === void 0 ? void 0 : newInit.root)\n        });\n    }, [\n        ltrRootMargin,\n        setObserverInit\n    ]);\n    return {\n        setObserverList,\n        setObserverInit: setObserverInitExternal,\n        observer\n    };\n};\n"],"names":["getRTLRootMargin","useIntersectionObserver","useCallback","useState","useRef","React","ltrRootMargin","target","newDir","getComputedStyle","direction","newMargin","splitMargins","split","length","callback","options","observer","observerList","setObserverList","targetDocument","useFluent","_options_rootMargin","observerInit","setObserverInit","rootMargin","root","_options_rootMargin1","mutationObserverCallback","mutationList","mutation","type","attributeName","contains","current","useMutationObserver","attributes","subtree","attributeFilter","useIsomorphicLayoutEffect","IntersectionObserver","forEach","element","_observer_current","observe","disconnect","setObserverInitExternal","newInit","_newInit_rootMargin"],"mappings":"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"}