{"version":3,"sources":["useVirtualizerMeasure.js"],"sourcesContent":["import * as React from 'react';\nimport { useResizeObserverRef_unstable } from './useResizeObserverRef';\n/**\n * React hook that measures virtualized space based on a static size to ensure optimized virtualization length.\n */ export const useStaticVirtualizerMeasure = (virtualizerProps)=>{\n    const { defaultItemSize, direction = 'vertical' } = virtualizerProps;\n    const [state, setState] = React.useState({\n        virtualizerLength: 0,\n        bufferSize: 0,\n        bufferItems: 0\n    });\n    const { virtualizerLength, bufferItems, bufferSize } = state;\n    const resizeCallback = React.useCallback((_entries, _observer, scrollRef)=>{\n        if (!(scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {\n            return;\n        }\n        const containerSize = direction === 'vertical' ? scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current.getBoundingClientRect().height : scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current.getBoundingClientRect().width;\n        /*\n       * Number of items required to cover viewport.\n       */ const length = Math.ceil(containerSize / defaultItemSize + 1);\n        /*\n       * Number of items to append at each end, i.e. 'preload' each side before entering view.\n       */ const newBufferItems = Math.max(Math.floor(length / 4), 2);\n        /*\n       * This is how far we deviate into the bufferItems to detect a redraw.\n       */ const newBufferSize = Math.max(Math.floor(length / 8 * defaultItemSize), 1);\n        const totalLength = length + newBufferItems * 2 + 1;\n        setState({\n            virtualizerLength: totalLength,\n            bufferItems: newBufferItems,\n            bufferSize: newBufferSize\n        });\n    }, [\n        defaultItemSize,\n        direction\n    ]);\n    const scrollRef = useResizeObserverRef_unstable(resizeCallback);\n    return {\n        virtualizerLength,\n        bufferItems,\n        bufferSize,\n        scrollRef\n    };\n};\n"],"names":["useStaticVirtualizerMeasure","virtualizerProps","defaultItemSize","direction","state","setState","React","useState","virtualizerLength","bufferSize","bufferItems","resizeCallback","useCallback","_entries","_observer","scrollRef","current","containerSize","getBoundingClientRect","height","width","length","Math","ceil","newBufferItems","max","floor","newBufferSize","totalLength","useResizeObserverRef_unstable"],"mappings":";;;;+BAIiBA;;;eAAAA;;;;iEAJM;sCACuB;AAGnC,MAAMA,8BAA8B,CAACC;IAC5C,MAAM,EAAEC,eAAe,EAAEC,YAAY,UAAU,EAAE,GAAGF;IACpD,MAAM,CAACG,OAAOC,SAAS,GAAGC,OAAMC,QAAQ,CAAC;QACrCC,mBAAmB;QACnBC,YAAY;QACZC,aAAa;IACjB;IACA,MAAM,EAAEF,iBAAiB,EAAEE,WAAW,EAAED,UAAU,EAAE,GAAGL;IACvD,MAAMO,iBAAiBL,OAAMM,WAAW,CAAC,CAACC,UAAUC,WAAWC;QAC3D,IAAI,CAAEA,CAAAA,cAAc,QAAQA,cAAc,KAAK,IAAI,KAAK,IAAIA,UAAUC,OAAO,AAAD,GAAI;YAC5E;QACJ;QACA,MAAMC,gBAAgBd,cAAc,aAAaY,cAAc,QAAQA,cAAc,KAAK,IAAI,KAAK,IAAIA,UAAUC,OAAO,CAACE,qBAAqB,GAAGC,MAAM,GAAGJ,cAAc,QAAQA,cAAc,KAAK,IAAI,KAAK,IAAIA,UAAUC,OAAO,CAACE,qBAAqB,GAAGE,KAAK;QAC/P;;OAED,GAAG,MAAMC,SAASC,KAAKC,IAAI,CAACN,gBAAgBf,kBAAkB;QAC7D;;OAED,GAAG,MAAMsB,iBAAiBF,KAAKG,GAAG,CAACH,KAAKI,KAAK,CAACL,SAAS,IAAI;QAC1D;;OAED,GAAG,MAAMM,gBAAgBL,KAAKG,GAAG,CAACH,KAAKI,KAAK,CAACL,SAAS,IAAInB,kBAAkB;QAC3E,MAAM0B,cAAcP,SAASG,iBAAiB,IAAI;QAClDnB,SAAS;YACLG,mBAAmBoB;YACnBlB,aAAac;YACbf,YAAYkB;QAChB;IACJ,GAAG;QACCzB;QACAC;KACH;IACD,MAAMY,YAAYc,IAAAA,mDAA6B,EAAClB;IAChD,OAAO;QACHH;QACAE;QACAD;QACAM;IACJ;AACJ"}