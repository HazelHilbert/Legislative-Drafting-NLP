{"version":3,"sources":["useVirtualizer.js"],"sourcesContent":["import { useEffect, useRef, useCallback, useReducer, useImperativeHandle, useState } from 'react';\nimport { useIntersectionObserver } from '../../hooks/useIntersectionObserver';\nimport { flushSync } from 'react-dom';\nimport { useVirtualizerContextState_unstable } from '../../Utilities';\nimport { slot } from '@fluentui/react-utilities';\nexport function useVirtualizer_unstable(props) {\n    const { itemSize, numItems, virtualizerLength, children: renderChild, getItemSize, bufferItems = Math.round(virtualizerLength / 4.0), bufferSize = Math.floor(bufferItems / 2.0) * itemSize, scrollViewRef, axis = 'vertical', reversed = false, virtualizerContext, onRenderedFlaggedIndex, imperativeVirtualizerRef } = props;\n    /* The context is optional, it's useful for injecting additional index logic, or performing uniform state updates*/ const _virtualizerContext = useVirtualizerContextState_unstable(virtualizerContext);\n    // We use this ref as a constant source to access the virtualizer's state imperatively\n    const actualIndexRef = useRef(_virtualizerContext.contextIndex);\n    if (actualIndexRef.current !== _virtualizerContext.contextIndex) {\n        actualIndexRef.current = _virtualizerContext.contextIndex;\n    }\n    const flaggedIndex = useRef(null);\n    const actualIndex = _virtualizerContext.contextIndex;\n    const setActualIndex = _virtualizerContext.setContextIndex;\n    // Store ref to before padding element\n    const beforeElementRef = useRef(null);\n    // Store ref to before padding element\n    const afterElementRef = useRef(null);\n    // We need to store an array to track dynamic sizes, we can use this to incrementally update changes\n    const childSizes = useRef(new Array(getItemSize ? numItems : 0));\n    /* We keep track of the progressive sizing/placement down the list,\n  this helps us skip re-calculations unless children/size changes */ const childProgressiveSizes = useRef(new Array(getItemSize ? numItems : 0));\n    // The internal tracking REF for child array (updates often).\n    const childArray = useRef(new Array(virtualizerLength));\n    // We want to be methodical about updating the render with child reference array\n    const forceUpdate = useReducer(()=>({}), {})[1];\n    const horizontal = axis === 'horizontal';\n    const populateSizeArrays = ()=>{\n        if (!getItemSize) {\n            // Static sizes, never mind!\n            return;\n        }\n        if (numItems !== childSizes.current.length) {\n            childSizes.current = new Array(numItems);\n        }\n        if (numItems !== childProgressiveSizes.current.length) {\n            childProgressiveSizes.current = new Array(numItems);\n        }\n        for(let index = 0; index < numItems; index++){\n            childSizes.current[index] = getItemSize(index);\n            if (index === 0) {\n                childProgressiveSizes.current[index] = childSizes.current[index];\n            } else {\n                childProgressiveSizes.current[index] = childProgressiveSizes.current[index - 1] + childSizes.current[index];\n            }\n        }\n    };\n    const [isScrolling, setIsScrolling] = useState(false);\n    const scrollTimer = useRef();\n    const scrollCounter = useRef(0);\n    const initializeScrollingTimer = ()=>{\n        /*\n     * This can be considered the 'velocity' required to start 'isScrolling'\n     * INIT_SCROLL_FLAG_REQ: Number of renders required to activate isScrolling\n     * INIT_SCROLL_FLAG_DELAY: Amount of time (ms) before current number of renders is reset\n     *  - Maybe we should let users customize these in the future.\n     */ const INIT_SCROLL_FLAG_REQ = 10;\n        const INIT_SCROLL_FLAG_DELAY = 100;\n        scrollCounter.current++;\n        if (scrollCounter.current >= INIT_SCROLL_FLAG_REQ) {\n            setIsScrolling(true);\n        }\n        if (scrollTimer.current) {\n            clearTimeout(scrollTimer.current);\n        }\n        scrollTimer.current = setTimeout(()=>{\n            setIsScrolling(false);\n            scrollCounter.current = 0;\n        }, INIT_SCROLL_FLAG_DELAY);\n    };\n    useEffect(()=>{\n        initializeScrollingTimer();\n    }, [\n        actualIndex\n    ]);\n    const batchUpdateNewIndex = (index)=>{\n        // Local updates\n        updateChildRows(index);\n        updateCurrentItemSizes(index);\n        // Set before 'setActualIndex' call\n        // If it changes before render, or injected via context, re-render will update ref.\n        actualIndexRef.current = index;\n        // State setters\n        setActualIndex(index);\n    };\n    // Observe intersections of virtualized components\n    const { setObserverList } = useIntersectionObserver((entries, observer)=>{\n        /* Sanity check - do we even need virtualization? */ if (virtualizerLength > numItems) {\n            if (actualIndex !== 0) {\n                batchUpdateNewIndex(0);\n            }\n            // No-op\n            return;\n        }\n        /* IO initiates this function when needed (bookend entering view) */ let measurementPos = 0;\n        let bufferCount = bufferItems;\n        // Grab latest entry that is intersecting\n        const latestEntry = entries.length === 1 ? entries[0] : entries.sort((entry1, entry2)=>entry2.time - entry1.time).find((entry)=>{\n            return entry.intersectionRatio > 0;\n        });\n        if (!latestEntry) {\n            // If we don't find an intersecting area, ignore for now.\n            return;\n        }\n        if (latestEntry.target === afterElementRef.current) {\n            // We need to inverse the buffer count\n            bufferCount = virtualizerLength - bufferItems;\n            measurementPos = reversed ? calculateAfter() : calculateTotalSize() - calculateAfter();\n            if (!horizontal) {\n                if (reversed) {\n                    // Scrolling 'up' and hit the after element below\n                    measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n                } else if (latestEntry.boundingClientRect.top < 0) {\n                    // Scrolling 'down' and hit the after element above top: 0\n                    measurementPos -= latestEntry.boundingClientRect.top;\n                }\n            } else {\n                if (reversed) {\n                    // Scrolling 'left' and hit the after element\n                    measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n                } else if (latestEntry.boundingClientRect.left < 0) {\n                    // Scrolling 'right' and hit the after element\n                    measurementPos -= latestEntry.boundingClientRect.left;\n                }\n            }\n        } else if (latestEntry.target === beforeElementRef.current) {\n            measurementPos = reversed ? calculateTotalSize() - calculateBefore() : calculateBefore();\n            if (!horizontal) {\n                if (!reversed) {\n                    measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n                } else if (latestEntry.boundingClientRect.top < 0) {\n                    // Scrolling 'down' in reverse order and hit the before element above top: 0\n                    measurementPos -= latestEntry.boundingClientRect.top;\n                }\n            } else {\n                if (!reversed) {\n                    measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n                } else if (latestEntry.boundingClientRect.left < 0) {\n                    // Scrolling 'left' and hit before element\n                    measurementPos -= latestEntry.boundingClientRect.left;\n                }\n            }\n        }\n        if (reversed) {\n            // We're reversed, up is down, left is right, invert the scroll measure.\n            measurementPos = Math.max(calculateTotalSize() - Math.abs(measurementPos), 0);\n        }\n        // For now lets use hardcoded size to assess current element to paginate on\n        const startIndex = getIndexFromScrollPosition(measurementPos);\n        const bufferedIndex = Math.max(startIndex - bufferCount, 0);\n        // Safety limits\n        const maxIndex = Math.max(numItems - virtualizerLength, 0);\n        const newStartIndex = Math.min(Math.max(bufferedIndex, 0), maxIndex);\n        if (actualIndex !== newStartIndex) {\n            // We flush sync this and perform an immediate state update\n            flushSync(()=>{\n                batchUpdateNewIndex(newStartIndex);\n            });\n        }\n    }, {\n        root: scrollViewRef ? scrollViewRef === null || scrollViewRef === void 0 ? void 0 : scrollViewRef.current : null,\n        rootMargin: '0px',\n        threshold: 0\n    });\n    const findIndexRecursive = (scrollPos, lowIndex, highIndex)=>{\n        if (lowIndex > highIndex) {\n            // We shouldn't get here - but no-op the index if we do.\n            return actualIndex;\n        }\n        const midpoint = Math.floor((lowIndex + highIndex) / 2);\n        const iBefore = Math.max(midpoint - 1, 0);\n        const iAfter = Math.min(midpoint + 1, childProgressiveSizes.current.length - 1);\n        const indexValue = childProgressiveSizes.current[midpoint];\n        const afterIndexValue = childProgressiveSizes.current[iAfter];\n        const beforeIndexValue = childProgressiveSizes.current[iBefore];\n        if (scrollPos <= afterIndexValue && scrollPos >= beforeIndexValue) {\n            /* We've found our index - if we are exactly matching before/after index that's ok,\n      better to reduce checks if it's right on the boundary. */ return midpoint;\n        }\n        if (indexValue > scrollPos) {\n            return findIndexRecursive(scrollPos, lowIndex, midpoint - 1);\n        } else {\n            return findIndexRecursive(scrollPos, midpoint + 1, highIndex);\n        }\n    };\n    const getIndexFromSizeArray = (scrollPos)=>{\n        /* Quick searches our progressive height array */ if (scrollPos === 0 || childProgressiveSizes.current.length === 0 || scrollPos <= childProgressiveSizes.current[0]) {\n            // Check start\n            return 0;\n        }\n        if (scrollPos >= childProgressiveSizes.current[childProgressiveSizes.current.length - 1]) {\n            // Check end\n            return childProgressiveSizes.current.length - 1;\n        }\n        return findIndexRecursive(scrollPos, 0, childProgressiveSizes.current.length - 1);\n    };\n    const getIndexFromScrollPosition = (scrollPos)=>{\n        if (!getItemSize) {\n            return Math.round(scrollPos / itemSize);\n        }\n        return getIndexFromSizeArray(scrollPos);\n    };\n    const calculateTotalSize = useCallback(()=>{\n        if (!getItemSize) {\n            return itemSize * numItems;\n        }\n        // Time for custom size calcs\n        return childProgressiveSizes.current[numItems - 1];\n    }, [\n        getItemSize,\n        itemSize,\n        numItems\n    ]);\n    const calculateBefore = useCallback(()=>{\n        const currentIndex = Math.min(actualIndex, numItems - 1);\n        if (!getItemSize) {\n            // The missing items from before virtualization starts height\n            return currentIndex * itemSize;\n        }\n        if (currentIndex <= 0) {\n            return 0;\n        }\n        // Time for custom size calcs\n        return childProgressiveSizes.current[currentIndex - 1];\n    }, [\n        actualIndex,\n        getItemSize,\n        itemSize,\n        numItems\n    ]);\n    const calculateAfter = useCallback(()=>{\n        if (numItems === 0 || actualIndex + virtualizerLength >= numItems) {\n            return 0;\n        }\n        const lastItemIndex = Math.min(actualIndex + virtualizerLength, numItems);\n        if (!getItemSize) {\n            // The missing items from after virtualization ends height\n            const remainingItems = numItems - lastItemIndex;\n            return remainingItems * itemSize;\n        }\n        // Time for custom size calcs\n        return childProgressiveSizes.current[numItems - 1] - childProgressiveSizes.current[lastItemIndex - 1];\n    }, [\n        actualIndex,\n        getItemSize,\n        itemSize,\n        numItems,\n        virtualizerLength\n    ]);\n    const updateChildRows = useCallback((newIndex)=>{\n        if (numItems === 0) {\n            /* Nothing to virtualize */ return;\n        }\n        /*\n        We reset the array every time to ensure children are re-rendered\n        This function should only be called when update is nessecary\n       */ childArray.current = new Array(virtualizerLength);\n        const _actualIndex = Math.max(newIndex, 0);\n        const end = Math.min(_actualIndex + virtualizerLength, numItems);\n        for(let i = _actualIndex; i < end; i++){\n            childArray.current[i - _actualIndex] = renderChild(i, isScrolling);\n        }\n    }, [\n        isScrolling,\n        numItems,\n        renderChild,\n        virtualizerLength\n    ]);\n    const setBeforeRef = useCallback((element)=>{\n        if (!element || beforeElementRef.current === element) {\n            return;\n        }\n        beforeElementRef.current = element;\n        const newList = [];\n        newList.push(beforeElementRef.current);\n        if (afterElementRef.current) {\n            newList.push(afterElementRef.current);\n        }\n        // Ensure we update array if before element changed\n        setObserverList(newList);\n    }, [\n        setObserverList\n    ]);\n    const setAfterRef = useCallback((element)=>{\n        if (!element || afterElementRef.current === element) {\n            return;\n        }\n        afterElementRef.current = element;\n        const newList = [];\n        if (beforeElementRef.current) {\n            newList.push(beforeElementRef.current);\n        }\n        newList.push(afterElementRef.current);\n        // Ensure we update array if after element changed\n        setObserverList(newList);\n    }, [\n        setObserverList\n    ]);\n    const updateCurrentItemSizes = (newIndex)=>{\n        if (!getItemSize) {\n            // Static sizes, not required.\n            return;\n        }\n        // We should always call our size function on index change (only for the items that will be rendered)\n        // This ensures we request the latest data for incoming items in case sizing has changed.\n        const endIndex = Math.min(newIndex + virtualizerLength, numItems);\n        const startIndex = Math.max(newIndex, 0);\n        let didUpdate = false;\n        for(let i = startIndex; i < endIndex; i++){\n            const newSize = getItemSize(i);\n            if (newSize !== childSizes.current[i]) {\n                childSizes.current[i] = newSize;\n                didUpdate = true;\n            }\n        }\n        if (didUpdate) {\n            // Update our progressive size array\n            for(let i = startIndex; i < numItems; i++){\n                const prevSize = i > 0 ? childProgressiveSizes.current[i - 1] : 0;\n                childProgressiveSizes.current[i] = prevSize + childSizes.current[i];\n            }\n        }\n    };\n    // Initialize the size array before first render.\n    const hasInitialized = useRef(false);\n    const initializeSizeArray = ()=>{\n        if (hasInitialized.current === false) {\n            hasInitialized.current = true;\n            populateSizeArrays();\n        }\n    };\n    useImperativeHandle(imperativeVirtualizerRef, ()=>{\n        return {\n            progressiveSizes: childProgressiveSizes,\n            nodeSizes: childSizes,\n            setFlaggedIndex: (index)=>flaggedIndex.current = index,\n            currentIndex: actualIndexRef\n        };\n    }, [\n        childProgressiveSizes,\n        childSizes\n    ]);\n    // Initialization on mount - update array index to 0 (ready state).\n    // Only fire on mount (no deps).\n    useEffect(()=>{\n        if (actualIndex < 0) {\n            batchUpdateNewIndex(0);\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    // If the user passes in an updated renderChild function - update current children\n    useEffect(()=>{\n        if (actualIndex >= 0) {\n            updateChildRows(actualIndex);\n            forceUpdate();\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        renderChild,\n        updateChildRows\n    ]);\n    useEffect(()=>{\n        // Ensure we repopulate if getItemSize callback changes\n        populateSizeArrays();\n    // We only run this effect on getItemSize change (recalc dynamic sizes)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        getItemSize\n    ]);\n    // Effect to check flag index on updates\n    useEffect(()=>{\n        if (!onRenderedFlaggedIndex || flaggedIndex.current === null) {\n            return;\n        }\n        if (actualIndex <= flaggedIndex.current && actualIndex + virtualizerLength >= flaggedIndex.current) {\n            onRenderedFlaggedIndex(flaggedIndex.current);\n            flaggedIndex.current = null;\n        }\n    }, [\n        actualIndex,\n        onRenderedFlaggedIndex,\n        virtualizerLength\n    ]);\n    // Ensure we have run through and updated the whole size list array at least once.\n    initializeSizeArray();\n    if (getItemSize && (numItems !== childSizes.current.length || numItems !== childProgressiveSizes.current.length)) {\n        // Child length mismatch, repopulate size arrays.\n        populateSizeArrays();\n    }\n    // Ensure we recalc if virtualizer length changes\n    const maxCompare = Math.min(virtualizerLength, numItems);\n    if (childArray.current.length !== maxCompare && actualIndex + childArray.current.length < numItems) {\n        updateChildRows(actualIndex);\n    }\n    const isFullyInitialized = hasInitialized.current && actualIndex >= 0;\n    return {\n        components: {\n            before: 'div',\n            after: 'div',\n            beforeContainer: 'div',\n            afterContainer: 'div'\n        },\n        virtualizedChildren: childArray.current,\n        before: slot.always(props.before, {\n            defaultProps: {\n                ref: setBeforeRef,\n                role: 'none'\n            },\n            elementType: 'div'\n        }),\n        after: slot.always(props.after, {\n            defaultProps: {\n                ref: setAfterRef,\n                role: 'none'\n            },\n            elementType: 'div'\n        }),\n        beforeContainer: slot.always(props.beforeContainer, {\n            defaultProps: {\n                role: 'none'\n            },\n            elementType: 'div'\n        }),\n        afterContainer: slot.always(props.afterContainer, {\n            defaultProps: {\n                role: 'none'\n            },\n            elementType: 'div'\n        }),\n        beforeBufferHeight: isFullyInitialized ? calculateBefore() : 0,\n        afterBufferHeight: isFullyInitialized ? calculateAfter() : 0,\n        totalVirtualizerHeight: isFullyInitialized ? calculateTotalSize() : virtualizerLength * itemSize,\n        virtualizerStartIndex: actualIndex,\n        axis,\n        bufferSize,\n        reversed,\n        childSizes,\n        childProgressiveSizes\n    };\n}\n"],"names":["useVirtualizer_unstable","props","itemSize","numItems","virtualizerLength","children","renderChild","getItemSize","bufferItems","Math","round","bufferSize","floor","scrollViewRef","axis","reversed","virtualizerContext","onRenderedFlaggedIndex","imperativeVirtualizerRef","_virtualizerContext","useVirtualizerContextState_unstable","actualIndexRef","useRef","contextIndex","current","flaggedIndex","actualIndex","setActualIndex","setContextIndex","beforeElementRef","afterElementRef","childSizes","Array","childProgressiveSizes","childArray","forceUpdate","useReducer","horizontal","populateSizeArrays","length","index","isScrolling","setIsScrolling","useState","scrollTimer","scrollCounter","initializeScrollingTimer","INIT_SCROLL_FLAG_REQ","INIT_SCROLL_FLAG_DELAY","clearTimeout","setTimeout","useEffect","batchUpdateNewIndex","updateChildRows","updateCurrentItemSizes","setObserverList","useIntersectionObserver","entries","observer","measurementPos","bufferCount","latestEntry","sort","entry1","entry2","time","find","entry","intersectionRatio","target","calculateAfter","calculateTotalSize","abs","boundingClientRect","bottom","top","right","left","calculateBefore","max","startIndex","getIndexFromScrollPosition","bufferedIndex","maxIndex","newStartIndex","min","flushSync","root","rootMargin","threshold","findIndexRecursive","scrollPos","lowIndex","highIndex","midpoint","iBefore","iAfter","indexValue","afterIndexValue","beforeIndexValue","getIndexFromSizeArray","useCallback","currentIndex","lastItemIndex","remainingItems","newIndex","_actualIndex","end","i","setBeforeRef","element","newList","push","setAfterRef","endIndex","didUpdate","newSize","prevSize","hasInitialized","initializeSizeArray","useImperativeHandle","progressiveSizes","nodeSizes","setFlaggedIndex","maxCompare","isFullyInitialized","components","before","after","beforeContainer","afterContainer","virtualizedChildren","slot","always","defaultProps","ref","role","elementType","beforeBufferHeight","afterBufferHeight","totalVirtualizerHeight","virtualizerStartIndex"],"mappings":"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"}