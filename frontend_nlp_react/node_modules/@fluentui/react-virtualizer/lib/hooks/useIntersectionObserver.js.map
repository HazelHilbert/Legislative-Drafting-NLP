{"version":3,"sources":["useIntersectionObserver.ts"],"sourcesContent":["import type { Dispatch, MutableRefObject, SetStateAction } from 'react';\nimport * as React from 'react';\nimport { useIsomorphicLayoutEffect } from '@fluentui/react-utilities';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\n\nconst { useCallback, useState, useRef } = React;\nimport { useMutationObserver } from './useMutationObserver';\n\n/**\n * This function will take the rootMargin and flip the sides if we are in RTL based on the computed reading direction of the target element.\n * @param ltrRootMargin the margin to be processed and flipped if required\n * @param target target element that will have its current reading direction determined\n * @returns the corrected rootMargin (if it was necessary to correct)\n */\nexport const getRTLRootMargin = (ltrRootMargin: string, target?: Element | Document | null | undefined): string => {\n  if (target) {\n    // get the computed dir for the target element\n    const newDir = getComputedStyle(target as Element).direction;\n\n    // If we're in rtl reading direction, we might need to flip the margins on the left/right sides\n    if (newDir === 'rtl') {\n      let newMargin = ltrRootMargin;\n      const splitMargins = ltrRootMargin.split(' ');\n\n      // We only need to do this if we get four values, otherwise the sides are equal and don't require flipping.\n      if (splitMargins.length === 4) {\n        newMargin = `${splitMargins[0]} ${splitMargins[3]} ${splitMargins[2]} ${splitMargins[1]}`;\n      }\n\n      return newMargin;\n    } else {\n      return ltrRootMargin;\n    }\n  }\n\n  return ltrRootMargin;\n};\n\n/**\n * React hook that allows easy usage of the browser API IntersectionObserver within React\n * @param callback - A function called when the percentage of the target element is visible crosses a threshold.\n * @param options - An optional object which customizes the observer. If options isn't specified, the observer uses the\n * document's viewport as the root, with no margin, and a 0% threshold (meaning that even a one-pixel change is\n * enough to trigger a callback).\n * @returns An array containing a callback to update the list of Elements the observer should listen to, a callback to\n * update the init options of the IntersectionObserver and a ref to the IntersectionObserver instance itself.\n */\n\nexport const useIntersectionObserver = (\n  callback: IntersectionObserverCallback,\n  options?: IntersectionObserverInit,\n): {\n  setObserverList: Dispatch<SetStateAction<Element[] | undefined>>;\n  setObserverInit: (newInit: IntersectionObserverInit | undefined) => void;\n  observer: MutableRefObject<IntersectionObserver | undefined>;\n} => {\n  const observer = useRef<IntersectionObserver>();\n  const [observerList, setObserverList] = useState<Element[]>();\n  const { targetDocument } = useFluent();\n\n  // set the initial init with corrected margins based on the observed root's calculated reading direction.\n  const [observerInit, setObserverInit] = useState<IntersectionObserverInit | undefined>(\n    options && {\n      ...options,\n      rootMargin: getRTLRootMargin(options.rootMargin ?? '0px', options.root as Element),\n    },\n  );\n\n  // We have to assume that any values passed in for rootMargin by the consuming app are ltr values. As such we will store the ltr value.\n  const ltrRootMargin = useRef<string>(options?.rootMargin ?? '0px');\n\n  // Callback function to execute when mutations are observed\n  const mutationObserverCallback: MutationCallback = useCallback(\n    mutationList => {\n      for (const mutation of mutationList) {\n        // Ensuring that the right attribute is being observed and that the root is within the tree of the element being mutated.\n        if (\n          mutation.type === 'attributes' &&\n          mutation.attributeName === 'dir' &&\n          options?.root &&\n          mutation.target.contains(options?.root)\n        ) {\n          setObserverInit({\n            ...observerInit,\n            rootMargin: getRTLRootMargin(ltrRootMargin.current, observerInit?.root),\n          });\n        }\n      }\n    },\n    [ltrRootMargin, observerInit, options?.root],\n  );\n\n  // Mutation observer for dir attribute changes in the document\n  useMutationObserver(targetDocument, mutationObserverCallback, {\n    attributes: true,\n    subtree: true,\n    attributeFilter: ['dir'],\n  });\n\n  // Observer elements in passed in list and clean up previous list\n  // This effect is only triggered when observerList is updated\n  useIsomorphicLayoutEffect(() => {\n    observer.current = new IntersectionObserver(callback, {\n      ...observerInit,\n      rootMargin: getRTLRootMargin(ltrRootMargin.current, observerInit?.root),\n    });\n\n    observer.current = new IntersectionObserver(callback, observerInit);\n\n    // If we have an instance of IO and a list with elements, observer the elements\n    if (observer.current && observerList && observerList.length > 0) {\n      observerList.forEach(element => {\n        observer.current?.observe(element);\n      });\n    }\n\n    // clean up previous elements being listened to\n    return () => {\n      if (observer.current) {\n        observer.current.disconnect();\n      }\n    };\n  }, [observerList, observerInit, callback]);\n\n  // Do not use internally, we need to track external settings only here\n  const setObserverInitExternal = useCallback(\n    (newInit: IntersectionObserverInit | undefined) => {\n      // Since we know this is coming from consumers, we can store this value as LTR somewhat safely.\n      ltrRootMargin.current = newInit?.rootMargin ?? '0px';\n\n      // Call the internal setter to update the value and ensure if our calculated direction is rtl, we flip the margin\n      setObserverInit({\n        ...newInit,\n        rootMargin: getRTLRootMargin(ltrRootMargin.current, newInit?.root as Element),\n      });\n    },\n    [ltrRootMargin, setObserverInit],\n  );\n\n  return { setObserverList, setObserverInit: setObserverInitExternal, observer };\n};\n"],"names":["React","useIsomorphicLayoutEffect","useFluent_unstable","useFluent","useCallback","useState","useRef","useMutationObserver","getRTLRootMargin","ltrRootMargin","target","newDir","getComputedStyle","direction","newMargin","splitMargins","split","length","useIntersectionObserver","callback","options","observer","observerList","setObserverList","targetDocument","observerInit","setObserverInit","rootMargin","root","mutationObserverCallback","mutationList","mutation","type","attributeName","contains","current","attributes","subtree","attributeFilter","IntersectionObserver","forEach","element","observe","disconnect","setObserverInitExternal","newInit"],"mappings":"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"}