{"version":3,"sources":["useVirtualizerMeasure.ts"],"sourcesContent":["import * as React from 'react';\nimport { VirtualizerMeasureProps } from './hooks.types';\nimport { useResizeObserverRef_unstable } from './useResizeObserverRef';\n\n/**\n * React hook that measures virtualized space based on a static size to ensure optimized virtualization length.\n */\nexport const useStaticVirtualizerMeasure = <TElement extends HTMLElement>(\n  virtualizerProps: VirtualizerMeasureProps,\n): {\n  virtualizerLength: number;\n  bufferItems: number;\n  bufferSize: number;\n  scrollRef: (instance: TElement | null) => void;\n} => {\n  const { defaultItemSize, direction = 'vertical' } = virtualizerProps;\n\n  const [state, setState] = React.useState({\n    virtualizerLength: 0,\n    bufferSize: 0,\n    bufferItems: 0,\n  });\n\n  const { virtualizerLength, bufferItems, bufferSize } = state;\n\n  const resizeCallback = React.useCallback(\n    (\n      _entries: ResizeObserverEntry[],\n      _observer: ResizeObserver,\n      scrollRef?: React.MutableRefObject<HTMLElement | null>,\n    ) => {\n      if (!scrollRef?.current) {\n        return;\n      }\n\n      const containerSize =\n        direction === 'vertical'\n          ? scrollRef?.current.getBoundingClientRect().height\n          : scrollRef?.current.getBoundingClientRect().width;\n\n      /*\n       * Number of items required to cover viewport.\n       */\n      const length = Math.ceil(containerSize / defaultItemSize + 1);\n\n      /*\n       * Number of items to append at each end, i.e. 'preload' each side before entering view.\n       */\n      const newBufferItems = Math.max(Math.floor(length / 4), 2);\n\n      /*\n       * This is how far we deviate into the bufferItems to detect a redraw.\n       */\n      const newBufferSize = Math.max(Math.floor((length / 8) * defaultItemSize), 1);\n\n      const totalLength = length + newBufferItems * 2 + 1;\n\n      setState({\n        virtualizerLength: totalLength,\n        bufferItems: newBufferItems,\n        bufferSize: newBufferSize,\n      });\n    },\n    [defaultItemSize, direction],\n  );\n\n  const scrollRef = useResizeObserverRef_unstable(resizeCallback);\n\n  return {\n    virtualizerLength,\n    bufferItems,\n    bufferSize,\n    scrollRef,\n  };\n};\n"],"names":["React","useResizeObserverRef_unstable","useStaticVirtualizerMeasure","virtualizerProps","defaultItemSize","direction","state","setState","useState","virtualizerLength","bufferSize","bufferItems","resizeCallback","useCallback","_entries","_observer","scrollRef","current","containerSize","getBoundingClientRect","height","width","length","Math","ceil","newBufferItems","max","floor","newBufferSize","totalLength"],"mappings":"AAAA,YAAYA,WAAW,QAAQ;AAE/B,SAASC,6BAA6B,QAAQ,yBAAyB;AAEvE;;CAEC,GACD,OAAO,MAAMC,8BAA8B,CACzCC;IAOA,MAAM,EAAEC,eAAe,EAAEC,YAAY,UAAU,EAAE,GAAGF;IAEpD,MAAM,CAACG,OAAOC,SAAS,GAAGP,MAAMQ,QAAQ,CAAC;QACvCC,mBAAmB;QACnBC,YAAY;QACZC,aAAa;IACf;IAEA,MAAM,EAAEF,iBAAiB,EAAEE,WAAW,EAAED,UAAU,EAAE,GAAGJ;IAEvD,MAAMM,iBAAiBZ,MAAMa,WAAW,CACtC,CACEC,UACAC,WACAC;QAEA,IAAI,EAACA,sBAAAA,gCAAAA,UAAWC,OAAO,GAAE;YACvB;QACF;QAEA,MAAMC,gBACJb,cAAc,aACVW,sBAAAA,gCAAAA,UAAWC,OAAO,CAACE,qBAAqB,GAAGC,MAAM,GACjDJ,sBAAAA,gCAAAA,UAAWC,OAAO,CAACE,qBAAqB,GAAGE,KAAK;QAEtD;;OAEC,GACD,MAAMC,SAASC,KAAKC,IAAI,CAACN,gBAAgBd,kBAAkB;QAE3D;;OAEC,GACD,MAAMqB,iBAAiBF,KAAKG,GAAG,CAACH,KAAKI,KAAK,CAACL,SAAS,IAAI;QAExD;;OAEC,GACD,MAAMM,gBAAgBL,KAAKG,GAAG,CAACH,KAAKI,KAAK,CAAC,AAACL,SAAS,IAAKlB,kBAAkB;QAE3E,MAAMyB,cAAcP,SAASG,iBAAiB,IAAI;QAElDlB,SAAS;YACPE,mBAAmBoB;YACnBlB,aAAac;YACbf,YAAYkB;QACd;IACF,GACA;QAACxB;QAAiBC;KAAU;IAG9B,MAAMW,YAAYf,8BAA8BW;IAEhD,OAAO;QACLH;QACAE;QACAD;QACAM;IACF;AACF,EAAE"}