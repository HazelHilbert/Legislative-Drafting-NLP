{"version":3,"sources":["ImmutableSet.ts"],"sourcesContent":["export interface ImmutableSet<Value> {\n  /**\n   * The number of (unique) elements in a ImmutableSet.\n   */\n  readonly size: number;\n  /**\n   * Creates a new ImmutableSet containing all previous element plus the one provided as argument\n   * @param value - new value to be included in the new ImmutableSet instance\n   */\n  add(value: Value): ImmutableSet<Value>;\n  /**\n   * Returns a reference to ImmutableSet.emptySet\n   */\n  clear(): ImmutableSet<Value>;\n  /**\n   * Creates a new ImmutableSet with the original items and removes a specified value from the new ImmutableSet.\n   */\n  delete(value: Value): ImmutableSet<Value>;\n  /**\n   * @returns a boolean indicating whether an element with the specified value exists in the ImmutableSet or not.\n   */\n  has(value: Value): boolean;\n  /** Iterates over values in the ImmutableSet. */\n  [Symbol.iterator](): IterableIterator<Value>;\n  /**\n   * @internal\n   * Exposes the internal set used to store values.\n   * This is an internal API and should not be used directly.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  dangerouslyGetInternalSet_unstable(): Set<Value>;\n}\n\nconst emptyImmutableSet = createImmutableSet<never>();\n\n/**\n * Avoid using *dangerouslyCreateImmutableSet*, since this method will expose internally used set, use  createImmutableSet instead,\n * @param internalSet - a set that is used internally to store values.\n */\nfunction dangerouslyCreateImmutableSet<Value>(internalSet: Set<Value>): ImmutableSet<Value> {\n  return {\n    size: internalSet.size,\n    add(value) {\n      const nextSet = new Set(internalSet);\n      nextSet.add(value);\n      return dangerouslyCreateImmutableSet(nextSet);\n    },\n    clear() {\n      return emptyImmutableSet;\n    },\n    delete(value) {\n      const nextSet = new Set(internalSet);\n      nextSet.delete(value);\n      return dangerouslyCreateImmutableSet(nextSet);\n    },\n    has(value) {\n      return internalSet.has(value);\n    },\n    [Symbol.iterator]() {\n      return internalSet[Symbol.iterator]();\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    dangerouslyGetInternalSet_unstable: () => internalSet,\n  };\n}\n\nfunction isImmutableSet<Value>(value: unknown): value is ImmutableSet<Value> {\n  return typeof value === 'object' && value !== null && 'dangerouslyGetInternalSet_unstable' in value;\n}\n\n/**\n * properly creates an ImmutableSet instance from an iterable\n */\nfunction createImmutableSet<Value>(iterable?: Iterable<Value>): ImmutableSet<Value> {\n  const internalSet = new Set(iterable);\n  return dangerouslyCreateImmutableSet(internalSet);\n}\n\nexport const ImmutableSet = {\n  empty: emptyImmutableSet,\n  create: createImmutableSet,\n  isImmutableSet,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  dangerouslyCreate_unstable: dangerouslyCreateImmutableSet,\n};\n"],"names":["emptyImmutableSet","createImmutableSet","dangerouslyCreateImmutableSet","internalSet","size","add","value","nextSet","Set","clear","delete","has","Symbol","iterator","dangerouslyGetInternalSet_unstable","isImmutableSet","iterable","ImmutableSet","empty","create","dangerouslyCreate_unstable"],"mappings":"AAiCA,MAAMA,oBAAoBC;AAE1B;;;CAGC,GACD,SAASC,8BAAqCC,WAAuB;IACnE,OAAO;QACLC,MAAMD,YAAYC,IAAI;QACtBC,KAAIC,KAAK;YACP,MAAMC,UAAU,IAAIC,IAAIL;YACxBI,QAAQF,GAAG,CAACC;YACZ,OAAOJ,8BAA8BK;QACvC;QACAE;YACE,OAAOT;QACT;QACAU,QAAOJ,KAAK;YACV,MAAMC,UAAU,IAAIC,IAAIL;YACxBI,QAAQG,MAAM,CAACJ;YACf,OAAOJ,8BAA8BK;QACvC;QACAI,KAAIL,KAAK;YACP,OAAOH,YAAYQ,GAAG,CAACL;QACzB;QACA,CAACM,OAAOC,QAAQ,CAAC;YACf,OAAOV,WAAW,CAACS,OAAOC,QAAQ,CAAC;QACrC;QACA,gEAAgE;QAChEC,oCAAoC,IAAMX;IAC5C;AACF;AAEA,SAASY,eAAsBT,KAAc;IAC3C,OAAO,OAAOA,UAAU,YAAYA,UAAU,QAAQ,wCAAwCA;AAChG;AAEA;;CAEC,GACD,SAASL,mBAA0Be,QAA0B;IAC3D,MAAMb,cAAc,IAAIK,IAAIQ;IAC5B,OAAOd,8BAA8BC;AACvC;AAEA,OAAO,MAAMc,eAAe;IAC1BC,OAAOlB;IACPmB,QAAQlB;IACRc;IACA,gEAAgE;IAChEK,4BAA4BlB;AAC9B,EAAE"}