{"version":3,"sources":["createHeadlessTree.ts"],"sourcesContent":["import { TreeItemProps, TreeItemType, TreeItemValue } from '../TreeItem';\nimport { ImmutableSet } from './ImmutableSet';\n\nexport type HeadlessTreeItemProps = Omit<TreeItemProps, 'itemType' | 'value'> & {\n  value: TreeItemValue;\n  itemType?: TreeItemType;\n  parentValue?: TreeItemValue;\n};\n\n/**\n * The item that is returned by `createHeadlessTree`, it represents a wrapper around the properties provided to\n * `createHeadlessTree` but with extra information that might be useful on virtual tree scenarios\n */\nexport type HeadlessTreeItem<Props extends HeadlessTreeItemProps> = {\n  level: number;\n  index: number;\n  position: number;\n  childrenValues: TreeItemValue[];\n  value: TreeItemValue;\n  parentValue: TreeItemValue | undefined;\n  itemType: TreeItemType;\n  getTreeItemProps(): Required<Pick<Props, 'value' | 'aria-setsize' | 'aria-level' | 'aria-posinset' | 'itemType'>> &\n    Props;\n};\n\n/**\n * @internal\n */\nexport type HeadlessTree<Props extends HeadlessTreeItemProps> = {\n  /**\n   * the number of items in the virtual tree\n   */\n  readonly size: number;\n  /**\n   * the root item of the virtual tree\n   */\n  root: HeadlessTreeItem<HeadlessTreeItemProps>;\n  /**\n   * method to get a virtual tree item by its value\n   * @param key the key of the item to get\n   */\n  get(value: TreeItemValue): HeadlessTreeItem<Props> | undefined;\n  /**\n   * method to check if a virtual tree item exists by its value\n   * @param value the value of the item to check if exists\n   */\n  has(value: TreeItemValue): boolean;\n  /**\n   * method to add a new virtual tree item to the virtual tree\n   * @param props the props of the item to add\n   */\n  add(props: Props): void;\n  /**\n   * method to remove a virtual tree item from the virtual tree.\n   * When an item is removed:\n   * 1. all its children are also removed\n   * 2. all its siblings are repositioned\n   * @param value the value of the item to remove\n   */\n  // remove(value: TreeItemValue): void;\n  /**\n   * method to get the parent of a virtual tree item by its value\n   * @param value the value of the item to get the parent from\n   */\n  getParent(value: TreeItemValue): HeadlessTreeItem<Props>;\n  /**\n   * method to get the subtree of a virtual tree item by its value\n   * @param value the value of the item to get the subtree from\n   */\n  subtree(value: TreeItemValue): IterableIterator<HeadlessTreeItem<Props>>;\n  /**\n   * method to get the children of a virtual tree item by its value\n   * @param value the value of the item to get the children from\n   */\n  children(value: TreeItemValue): IterableIterator<HeadlessTreeItem<Props>>;\n  /**\n   * method to get the visible items of a virtual tree\n   * @param openItems the open items of the tree\n   */\n  visibleItems(openItems: ImmutableSet<TreeItemValue>): IterableIterator<HeadlessTreeItem<Props>>;\n  /**\n   * method to get the ancestors of a virtual tree item by its value\n   * @param value the value of the item to get the ancestors from\n   */\n  ancestors(value: TreeItemValue): IterableIterator<HeadlessTreeItem<Props>>;\n};\n\n/**\n * creates a list of virtual tree items\n * and provides a map to access each item by id\n */\nexport function createHeadlessTree<Props extends HeadlessTreeItemProps>(\n  initialProps: Props[] = [],\n): HeadlessTree<Props> {\n  const root = createHeadlessTreeRootItem();\n  const itemsPerValue = new Map<TreeItemValue, HeadlessTreeItem<HeadlessTreeItemProps>>([[root.value, root]]);\n\n  const headlessTree: HeadlessTree<HeadlessTreeItemProps> = {\n    root,\n    get size() {\n      return itemsPerValue.size;\n    },\n    getParent: key => itemsPerValue.get(itemsPerValue.get(key)?.parentValue ?? root.value) ?? root,\n    get: key => itemsPerValue.get(key),\n    has: key => itemsPerValue.has(key),\n    add(props) {\n      const { parentValue = headlessTreeRootId, ...propsWithoutParentValue } = props;\n      const parentItem = itemsPerValue.get(parentValue);\n      if (!parentItem) {\n        if (process.env.NODE_ENV === 'development') {\n          // eslint-disable-next-line no-console\n          console.error(/* #__DE-INDENT__ */ `\n            @fluentui/react-tree [createHeadlessTree]:\n            TreeItem \"${props.value}\" is wrongly positioned, did you properly ordered provided item props? make sure provided items are organized, parents should come before children\n          `);\n        }\n        return;\n      }\n      parentItem.itemType = 'branch';\n\n      const item: HeadlessTreeItem<HeadlessTreeItemProps> = {\n        value: props.value,\n        getTreeItemProps: () => ({\n          ...propsWithoutParentValue,\n          parentValue,\n          'aria-level': item.level,\n          'aria-posinset': item.position,\n          'aria-setsize': parentItem.childrenValues.length,\n          itemType: item.itemType,\n        }),\n        itemType: propsWithoutParentValue.itemType ?? 'leaf',\n        level: parentItem.level + 1,\n        parentValue,\n        childrenValues: [],\n        index: -1,\n        position: parentItem.childrenValues.push(props.value),\n      };\n      itemsPerValue.set(item.value, item);\n    },\n    // TODO: eventually it would be nice to have this method exported for the user to modify\n    // the internal state of the virtual tree\n    // remove(value) {\n    //   const itemToBeRemoved = itemsPerValue.get(value);\n    //   if (!itemToBeRemoved) {\n    //     return;\n    //   }\n    //   const parentItem = headlessTree.getParent(value);\n    //   parentItem.childrenValues.splice(itemToBeRemoved.position, 1);\n    //   itemsPerValue.delete(value);\n    //   if (parentItem.childrenValues.length === 0) {\n    //     parentItem.itemType = 'leaf';\n    //   }\n    //   for (let index = itemToBeRemoved.position; index < parentItem.childrenValues.length; index++) {\n    //     const child = itemsPerValue.get(parentItem.childrenValues[index]);\n    //     if (child) {\n    //       child.position = index + 1;\n    //     }\n    //   }\n    //   for (const descendant of HeadlessTreeSubtreeGenerator(value, headlessTree)) {\n    //     itemsPerValue.delete(descendant.value);\n    //   }\n    // },\n    subtree: key => HeadlessTreeSubtreeGenerator(key, headlessTree),\n    children: key => HeadlessTreeChildrenGenerator(key, headlessTree),\n    ancestors: key => HeadlessTreeAncestorsGenerator(key, headlessTree),\n    visibleItems: openItems => HeadlessTreeVisibleItemsGenerator(openItems, headlessTree),\n  };\n\n  initialProps.forEach(headlessTree.add);\n\n  return headlessTree as HeadlessTree<Props>;\n}\n\nexport const headlessTreeRootId = '__fuiHeadlessTreeRoot';\n\nfunction createHeadlessTreeRootItem(): HeadlessTreeItem<HeadlessTreeItemProps> {\n  return {\n    parentValue: undefined,\n    value: headlessTreeRootId,\n    itemType: 'branch',\n    getTreeItemProps: () => {\n      if (process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.error(/* #__DE-INDENT__ */ `\n          @fluentui/react-tree [createHeadlessTree]:\n          Internal error, trying to access treeitem props from invalid root element\n        `);\n      }\n      return {\n        id: headlessTreeRootId,\n        parentValue: undefined,\n        value: headlessTreeRootId,\n        'aria-setsize': -1,\n        'aria-level': -1,\n        'aria-posinset': -1,\n        itemType: 'branch',\n      };\n    },\n    childrenValues: [],\n    get index() {\n      if (process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.error(/* #__DE-INDENT__ */ `\n          @fluentui/react-tree [createHeadlessTree]:\n          Internal error, trying to access treeitem props from invalid root element\n        `);\n      }\n      return -1;\n    },\n    get position() {\n      if (process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.error(/* #__DE-INDENT__ */ `\n          @fluentui/react-tree [createHeadlessTree]:\n          Internal error, trying to access treeitem props from invalid root element\n        `);\n      }\n      return -1;\n    },\n    level: 0,\n  };\n}\n\n/**\n * Generator that returns all subtree of a given virtual tree item\n * @param key the key of the item to get the subtree from\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction* HeadlessTreeSubtreeGenerator<Props extends HeadlessTreeItemProps>(\n  key: TreeItemValue,\n  virtualTreeItems: HeadlessTree<Props>,\n): Generator<HeadlessTreeItem<Props>, void, void> {\n  const item = virtualTreeItems.get(key);\n  if (!item || item.childrenValues.length === 0) {\n    return;\n  }\n  for (const childValue of item.childrenValues) {\n    yield virtualTreeItems.get(childValue)!;\n    yield* HeadlessTreeSubtreeGenerator(childValue, virtualTreeItems);\n  }\n}\n\n/**\n * Generator that returns all children of a given virtual tree item\n * @param key the key of the item to get the children from\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction* HeadlessTreeChildrenGenerator<Props extends HeadlessTreeItemProps>(\n  key: TreeItemValue,\n  virtualTreeItems: HeadlessTree<Props>,\n): Generator<HeadlessTreeItem<Props>, void, void> {\n  const item = virtualTreeItems.get(key);\n  if (!item || item.childrenValues.length === 0) {\n    return;\n  }\n  for (const childValue of item.childrenValues) {\n    yield virtualTreeItems.get(childValue)!;\n  }\n}\n\n/**\n * Generator that returns all ancestors of a given virtual tree item\n * @param key the key of the item to get the children from\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction* HeadlessTreeAncestorsGenerator<Props extends HeadlessTreeItemProps>(\n  key: TreeItemValue,\n  virtualTreeItems: HeadlessTree<Props>,\n): Generator<HeadlessTreeItem<Props>, void, void> {\n  let parent = virtualTreeItems.getParent(key);\n  while (parent !== virtualTreeItems.root) {\n    yield parent;\n    parent = virtualTreeItems.getParent(parent.value);\n  }\n}\n\n/**\n * Generator that returns all visible items of a given virtual tree\n * @param openItems the open items of the tree\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction* HeadlessTreeVisibleItemsGenerator<Props extends HeadlessTreeItemProps>(\n  openItems: ImmutableSet<TreeItemValue>,\n  virtualTreeItems: HeadlessTree<Props>,\n): Generator<HeadlessTreeItem<Props>, void, void> {\n  let index = 0;\n  for (const item of HeadlessTreeSubtreeGenerator(virtualTreeItems.root.value, virtualTreeItems)) {\n    if (isItemVisible(item, openItems, virtualTreeItems)) {\n      item.index = index++;\n      yield item;\n    }\n  }\n}\n\nfunction isItemVisible(\n  item: HeadlessTreeItem<HeadlessTreeItemProps>,\n  openItems: ImmutableSet<TreeItemValue>,\n  virtualTreeItems: HeadlessTree<HeadlessTreeItemProps>,\n) {\n  if (item.level === 1) {\n    return true;\n  }\n  while (item.parentValue && item.parentValue !== virtualTreeItems.root.value) {\n    if (!openItems.has(item.parentValue)) {\n      return false;\n    }\n    const parent = virtualTreeItems.get(item.parentValue);\n    if (!parent) {\n      return false;\n    }\n    item = parent;\n  }\n  return true;\n}\n"],"names":["createHeadlessTree","initialProps","root","createHeadlessTreeRootItem","itemsPerValue","Map","value","headlessTree","size","getParent","key","get","parentValue","has","add","props","headlessTreeRootId","propsWithoutParentValue","parentItem","process","env","NODE_ENV","console","error","itemType","item","getTreeItemProps","level","position","childrenValues","length","index","push","set","subtree","HeadlessTreeSubtreeGenerator","children","HeadlessTreeChildrenGenerator","ancestors","HeadlessTreeAncestorsGenerator","visibleItems","openItems","HeadlessTreeVisibleItemsGenerator","forEach","undefined","id","virtualTreeItems","childValue","parent","isItemVisible"],"mappings":"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"}