{"version":3,"sources":["overflowManager.js"],"sourcesContent":["import { DATA_OVERFLOWING, DATA_OVERFLOW_GROUP } from './consts';\nimport { observeResize } from './createResizeObserver';\nimport { debounce } from './debounce';\nimport { createPriorityQueue } from './priorityQueue';\n/**\n * @internal\n * @returns overflow manager instance\n */ export function createOverflowManager() {\n    // calls to `offsetWidth or offsetHeight` can happen multiple times in an update\n    // Use a cache to avoid causing too many recalcs and avoid scripting time to meausure sizes\n    const sizeCache = new Map();\n    let container;\n    let overflowMenu;\n    // Set as true when resize observer is observing\n    let observing = false;\n    // If true, next update will dispatch to onUpdateOverflow even if queue top states don't change\n    // Initially true to force dispatch on first mount\n    let forceDispatch = true;\n    const options = {\n        padding: 10,\n        overflowAxis: 'horizontal',\n        overflowDirection: 'end',\n        minimumVisible: 0,\n        onUpdateItemVisibility: ()=>undefined,\n        onUpdateOverflow: ()=>undefined\n    };\n    const overflowItems = {};\n    const overflowDividers = {};\n    let disposeResizeObserver = ()=>null;\n    const getNextItem = (queueToDequeue, queueToEnqueue)=>{\n        const nextItem = queueToDequeue.dequeue();\n        queueToEnqueue.enqueue(nextItem);\n        return overflowItems[nextItem];\n    };\n    const groupManager = createGroupManager();\n    function compareItems(lt, rt) {\n        if (!lt || !rt) {\n            return 0;\n        }\n        const lte = overflowItems[lt];\n        const rte = overflowItems[rt];\n        if (lte.priority !== rte.priority) {\n            return lte.priority > rte.priority ? 1 : -1;\n        }\n        const positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_FOLLOWING : Node.DOCUMENT_POSITION_PRECEDING;\n        // eslint-disable-next-line no-bitwise\n        return lte.element.compareDocumentPosition(rte.element) & positionStatusBit ? 1 : -1;\n    }\n    function getElementAxisSize(horizontal, vertical, el) {\n        if (!sizeCache.has(el)) {\n            sizeCache.set(el, options.overflowAxis === 'horizontal' ? el[horizontal] : el[vertical]);\n        }\n        return sizeCache.get(el);\n    }\n    const getOffsetSize = getElementAxisSize.bind(null, 'offsetWidth', 'offsetHeight');\n    const getClientSize = getElementAxisSize.bind(null, 'clientWidth', 'clientHeight');\n    const invisibleItemQueue = createPriorityQueue((a, b)=>-1 * compareItems(a, b));\n    const visibleItemQueue = createPriorityQueue(compareItems);\n    function occupiedSize() {\n        const totalItemSize = visibleItemQueue.all().map((id)=>overflowItems[id].element).map(getOffsetSize).reduce((prev, current)=>prev + current, 0);\n        const totalDividerSize = Object.entries(groupManager.groupVisibility()).reduce((acc, [id, state])=>acc + (state !== 'hidden' && overflowDividers[id] ? getOffsetSize(overflowDividers[id].element) : 0), 0);\n        const overflowMenuSize = invisibleItemQueue.size() > 0 && overflowMenu ? getOffsetSize(overflowMenu) : 0;\n        return totalItemSize + totalDividerSize + overflowMenuSize;\n    }\n    const showItem = ()=>{\n        const item = getNextItem(invisibleItemQueue, visibleItemQueue);\n        options.onUpdateItemVisibility({\n            item,\n            visible: true\n        });\n        if (item.groupId) {\n            groupManager.showItem(item.id, item.groupId);\n            if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n                var _overflowDividers_item_groupId;\n                (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.removeAttribute(DATA_OVERFLOWING);\n            }\n        }\n    };\n    const hideItem = ()=>{\n        const item = getNextItem(visibleItemQueue, invisibleItemQueue);\n        options.onUpdateItemVisibility({\n            item,\n            visible: false\n        });\n        if (item.groupId) {\n            if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n                var _overflowDividers_item_groupId;\n                (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.setAttribute(DATA_OVERFLOWING, '');\n            }\n            groupManager.hideItem(item.id, item.groupId);\n        }\n    };\n    const dispatchOverflowUpdate = ()=>{\n        const visibleItemIds = visibleItemQueue.all();\n        const invisibleItemIds = invisibleItemQueue.all();\n        const visibleItems = visibleItemIds.map((itemId)=>overflowItems[itemId]);\n        const invisibleItems = invisibleItemIds.map((itemId)=>overflowItems[itemId]);\n        options.onUpdateOverflow({\n            visibleItems,\n            invisibleItems,\n            groupVisibility: groupManager.groupVisibility()\n        });\n    };\n    const processOverflowItems = ()=>{\n        if (!container) {\n            return false;\n        }\n        sizeCache.clear();\n        const availableSize = getClientSize(container) - options.padding;\n        // Snapshot of the visible/invisible state to compare for updates\n        const visibleTop = visibleItemQueue.peek();\n        const invisibleTop = invisibleItemQueue.peek();\n        while(compareItems(invisibleItemQueue.peek(), visibleItemQueue.peek()) > 0){\n            hideItem(); // hide elements whose priority become smaller than the highest priority of the hidden one\n        }\n        // Run the show/hide step twice - the first step might not be correct if\n        // it was triggered by a new item being added - new items are always visible by default.\n        for(let i = 0; i < 2; i++){\n            // Add items until available width is filled - can result in overflow\n            while(occupiedSize() < availableSize && invisibleItemQueue.size() > 0 || invisibleItemQueue.size() === 1 // attempt to show the last invisible item hoping it's size does not exceed overflow menu size\n            ){\n                showItem();\n            }\n            // Remove items until there's no more overflow\n            while(occupiedSize() > availableSize && visibleItemQueue.size() > options.minimumVisible){\n                hideItem();\n            }\n        }\n        // only update when the state of visible/invisible items has changed\n        return visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop;\n    };\n    const forceUpdate = ()=>{\n        if (processOverflowItems() || forceDispatch) {\n            forceDispatch = false;\n            dispatchOverflowUpdate();\n        }\n    };\n    const update = debounce(forceUpdate);\n    const observe = (observedContainer, userOptions)=>{\n        Object.assign(options, userOptions);\n        observing = true;\n        Object.values(overflowItems).forEach((item)=>visibleItemQueue.enqueue(item.id));\n        container = observedContainer;\n        disposeResizeObserver = observeResize(container, (entries)=>{\n            if (!entries[0] || !container) {\n                return;\n            }\n            update();\n        });\n    };\n    const addItem = (item)=>{\n        if (overflowItems[item.id]) {\n            return;\n        }\n        overflowItems[item.id] = item;\n        // some options can affect priority which are only set on `observe`\n        if (observing) {\n            // Updates to elements might not change the queue tops\n            // i.e. new element is enqueued but the top of the queue stays the same\n            // force a dispatch on the next batched update\n            forceDispatch = true;\n            visibleItemQueue.enqueue(item.id);\n        }\n        if (item.groupId) {\n            groupManager.addItem(item.id, item.groupId);\n            item.element.setAttribute(DATA_OVERFLOW_GROUP, item.groupId);\n        }\n        update();\n    };\n    const addOverflowMenu = (el)=>{\n        overflowMenu = el;\n    };\n    const addDivider = (divider)=>{\n        if (!divider.groupId || overflowDividers[divider.groupId]) {\n            return;\n        }\n        divider.element.setAttribute(DATA_OVERFLOW_GROUP, divider.groupId);\n        overflowDividers[divider.groupId] = divider;\n    };\n    const removeOverflowMenu = ()=>{\n        overflowMenu = undefined;\n    };\n    const removeDivider = (groupId)=>{\n        if (!overflowDividers[groupId]) {\n            return;\n        }\n        const divider = overflowDividers[groupId];\n        if (divider.groupId) {\n            delete overflowDividers[groupId];\n            divider.element.removeAttribute(DATA_OVERFLOW_GROUP);\n        }\n    };\n    const removeItem = (itemId)=>{\n        if (!overflowItems[itemId]) {\n            return;\n        }\n        const item = overflowItems[itemId];\n        visibleItemQueue.remove(itemId);\n        invisibleItemQueue.remove(itemId);\n        if (item.groupId) {\n            groupManager.removeItem(item.id, item.groupId);\n            item.element.removeAttribute(DATA_OVERFLOW_GROUP);\n        }\n        sizeCache.delete(item.element);\n        delete overflowItems[itemId];\n        update();\n    };\n    const disconnect = ()=>{\n        disposeResizeObserver();\n        // reset flags\n        container = undefined;\n        observing = false;\n        forceDispatch = true;\n        // clear all entries\n        Object.keys(overflowItems).forEach((itemId)=>removeItem(itemId));\n        Object.keys(overflowDividers).forEach((dividerId)=>removeDivider(dividerId));\n        removeOverflowMenu();\n        sizeCache.clear();\n    };\n    return {\n        addItem,\n        disconnect,\n        forceUpdate,\n        observe,\n        removeItem,\n        update,\n        addOverflowMenu,\n        removeOverflowMenu,\n        addDivider,\n        removeDivider\n    };\n}\nconst createGroupManager = ()=>{\n    const groupVisibility = {};\n    const groups = {};\n    function updateGroupVisibility(groupId) {\n        const group = groups[groupId];\n        if (group.invisibleItemIds.size && group.visibleItemIds.size) {\n            groupVisibility[groupId] = 'overflow';\n        } else if (group.visibleItemIds.size === 0) {\n            groupVisibility[groupId] = 'hidden';\n        } else {\n            groupVisibility[groupId] = 'visible';\n        }\n    }\n    function isGroupVisible(groupId) {\n        return groupVisibility[groupId] === 'visible' || groupVisibility[groupId] === 'overflow';\n    }\n    return {\n        groupVisibility: ()=>groupVisibility,\n        isSingleItemVisible (itemId, groupId) {\n            return isGroupVisible(groupId) && groups[groupId].visibleItemIds.has(itemId) && groups[groupId].visibleItemIds.size === 1;\n        },\n        addItem (itemId, groupId) {\n            var _groups, _groupId;\n            var _;\n            (_ = (_groups = groups)[_groupId = groupId]) !== null && _ !== void 0 ? _ : _groups[_groupId] = {\n                visibleItemIds: new Set(),\n                invisibleItemIds: new Set()\n            };\n            groups[groupId].visibleItemIds.add(itemId);\n            updateGroupVisibility(groupId);\n        },\n        removeItem (itemId, groupId) {\n            groups[groupId].invisibleItemIds.delete(itemId);\n            groups[groupId].visibleItemIds.delete(itemId);\n            updateGroupVisibility(groupId);\n        },\n        showItem (itemId, groupId) {\n            groups[groupId].invisibleItemIds.delete(itemId);\n            groups[groupId].visibleItemIds.add(itemId);\n            updateGroupVisibility(groupId);\n        },\n        hideItem (itemId, groupId) {\n            groups[groupId].invisibleItemIds.add(itemId);\n            groups[groupId].visibleItemIds.delete(itemId);\n            updateGroupVisibility(groupId);\n        }\n    };\n};\n"],"names":["createOverflowManager","sizeCache","Map","container","overflowMenu","observing","forceDispatch","options","padding","overflowAxis","overflowDirection","minimumVisible","onUpdateItemVisibility","undefined","onUpdateOverflow","overflowItems","overflowDividers","disposeResizeObserver","getNextItem","queueToDequeue","queueToEnqueue","nextItem","dequeue","enqueue","groupManager","createGroupManager","compareItems","lt","rt","lte","rte","priority","positionStatusBit","Node","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","element","compareDocumentPosition","getElementAxisSize","horizontal","vertical","el","has","set","get","getOffsetSize","bind","getClientSize","invisibleItemQueue","createPriorityQueue","a","b","visibleItemQueue","occupiedSize","totalItemSize","all","map","id","reduce","prev","current","totalDividerSize","Object","entries","groupVisibility","acc","state","overflowMenuSize","size","showItem","item","visible","groupId","isSingleItemVisible","_overflowDividers_item_groupId","removeAttribute","DATA_OVERFLOWING","hideItem","setAttribute","dispatchOverflowUpdate","visibleItemIds","invisibleItemIds","visibleItems","itemId","invisibleItems","processOverflowItems","clear","availableSize","visibleTop","peek","invisibleTop","i","forceUpdate","update","debounce","observe","observedContainer","userOptions","assign","values","forEach","observeResize","addItem","DATA_OVERFLOW_GROUP","addOverflowMenu","addDivider","divider","removeOverflowMenu","removeDivider","removeItem","remove","delete","disconnect","keys","dividerId","groups","updateGroupVisibility","group","isGroupVisible","_groups","_groupId","_","Set","add"],"mappings":"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"}