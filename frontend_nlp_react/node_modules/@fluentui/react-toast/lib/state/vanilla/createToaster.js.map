{"version":3,"sources":["createToaster.ts"],"sourcesContent":["import * as React from 'react';\nimport { createPriorityQueue } from '@fluentui/react-utilities';\nimport { Toast, ToasterOptions, ToastId, ToastImperativeRef, ToastOptions, UpdateToastEventDetail } from '../types';\n\nfunction assignDefined<T extends object>(a: Partial<T>, b: Partial<T>) {\n  // This cast is required, as Object.entries will return string as key which is not indexable\n  for (const [key, prop] of Object.entries(b) as [keyof T, T[keyof T]][]) {\n    // eslint-disable-next-line eqeqeq\n    if (prop != undefined) {\n      a[key] = prop;\n    }\n  }\n}\nconst defaulToastOptions: Pick<\n  ToastOptions,\n  'priority' | 'pauseOnHover' | 'pauseOnWindowBlur' | 'position' | 'timeout' | 'politeness' | 'onStatusChange'\n> = {\n  onStatusChange: undefined,\n  priority: 0,\n  pauseOnHover: false,\n  pauseOnWindowBlur: false,\n  position: 'bottom-end',\n  timeout: 3000,\n};\n\n// Multiple toasts can be dispatched in a single tick, use counter to prevent collisions\nlet counter = 0;\n\n/**\n * Toast are managed outside of the react lifecycle because they can be\n * dispatched imperatively. Therefore the state of toast visibility can't\n * really be managed properly by a declarative lifecycle.\n */\nexport function createToaster(options: Partial<ToasterOptions>) {\n  const { limit = Number.POSITIVE_INFINITY } = options;\n  const visibleToasts = new Set<ToastId>();\n  const toasts = new Map<ToastId, Toast>();\n\n  const queue = createPriorityQueue<ToastId>((ta, tb) => {\n    const a = toasts.get(ta);\n    const b = toasts.get(tb);\n    if (!a || !b) {\n      return 0;\n    }\n\n    if (a.priority === b.priority) {\n      return a.order - b.order;\n    }\n\n    return a.priority - b.priority;\n  });\n\n  const isToastVisible = (toastId: ToastId) => {\n    return visibleToasts.has(toastId);\n  };\n\n  /**\n   * Updates an existing toast with any available option\n   */\n  const updateToast = (toastOptions: UpdateToastEventDetail) => {\n    const { toastId } = toastOptions;\n    const toastToUpdate = toasts.get(toastId);\n    if (!toastToUpdate) {\n      return;\n    }\n\n    Object.assign(toastToUpdate, toastOptions);\n    toastToUpdate.updateId++;\n  };\n\n  /**\n   * Dismisses a toast with a specific id\n   */\n  const dismissToast = (toastId: ToastId) => {\n    visibleToasts.delete(toastId);\n  };\n\n  /**\n   * Dismisses all toasts and clears the queue\n   */\n  const dismissAllToasts = () => {\n    visibleToasts.clear();\n    queue.clear();\n  };\n\n  /**\n   * @param toastOptions user configured options\n   * @param onUpdate Some toast methods can result in UI changes (i.e. close) use this to dispatch callbacks\n   */\n  const buildToast = (toastOptions: Partial<ToastOptions> & { toastId: ToastId }, onUpdate: () => void) => {\n    const { toastId, content, toasterId } = toastOptions;\n\n    if (toasts.has(toastId)) {\n      return;\n    }\n\n    const close = () => {\n      const toast = toasts.get(toastId);\n      if (!toast) {\n        return;\n      }\n\n      visibleToasts.delete(toastId);\n      onUpdate();\n      toast.onStatusChange?.(null, { status: 'dismissed', ...toast });\n    };\n\n    const remove = () => {\n      const toast = toasts.get(toastId);\n      if (!toast) {\n        return;\n      }\n\n      toasts.delete(toastId);\n\n      if (visibleToasts.size < limit && queue.peek()) {\n        const nextToast = toasts.get(queue.dequeue());\n        if (!nextToast) {\n          return;\n        }\n\n        visibleToasts.add(nextToast.toastId);\n      }\n\n      onUpdate();\n    };\n\n    const toast: Toast = {\n      ...defaulToastOptions,\n      close,\n      remove,\n      toastId,\n      content,\n      updateId: 0,\n      toasterId,\n      order: counter++,\n      data: {},\n      imperativeRef: React.createRef<ToastImperativeRef>(),\n    };\n\n    assignDefined(toast, options);\n    assignDefined(toast, toastOptions);\n\n    toasts.set(toastId, toast);\n    toast.onStatusChange?.(null, { status: 'queued', ...toast });\n    if (visibleToasts.size >= limit) {\n      queue.enqueue(toastId);\n    } else {\n      visibleToasts.add(toastId);\n    }\n  };\n\n  return {\n    buildToast,\n    dismissAllToasts,\n    dismissToast,\n    isToastVisible,\n    updateToast,\n    visibleToasts,\n    toasts,\n  };\n}\n"],"names":["React","createPriorityQueue","assignDefined","a","b","key","prop","Object","entries","undefined","defaulToastOptions","onStatusChange","priority","pauseOnHover","pauseOnWindowBlur","position","timeout","counter","createToaster","options","limit","Number","POSITIVE_INFINITY","visibleToasts","Set","toasts","Map","queue","ta","tb","get","order","isToastVisible","toastId","has","updateToast","toastOptions","toastToUpdate","assign","updateId","dismissToast","delete","dismissAllToasts","clear","buildToast","onUpdate","toast","content","toasterId","close","status","remove","size","peek","nextToast","dequeue","add","data","imperativeRef","createRef","set","enqueue"],"mappings":"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"}