{"version":3,"sources":["createToaster.js"],"sourcesContent":["import * as React from 'react';\nimport { createPriorityQueue } from '@fluentui/react-utilities';\nfunction assignDefined(a, b) {\n    // This cast is required, as Object.entries will return string as key which is not indexable\n    for (const [key, prop] of Object.entries(b)){\n        // eslint-disable-next-line eqeqeq\n        if (prop != undefined) {\n            a[key] = prop;\n        }\n    }\n}\nconst defaulToastOptions = {\n    onStatusChange: undefined,\n    priority: 0,\n    pauseOnHover: false,\n    pauseOnWindowBlur: false,\n    position: 'bottom-end',\n    timeout: 3000\n};\n// Multiple toasts can be dispatched in a single tick, use counter to prevent collisions\nlet counter = 0;\n/**\n * Toast are managed outside of the react lifecycle because they can be\n * dispatched imperatively. Therefore the state of toast visibility can't\n * really be managed properly by a declarative lifecycle.\n */ export function createToaster(options) {\n    const { limit = Number.POSITIVE_INFINITY } = options;\n    const visibleToasts = new Set();\n    const toasts = new Map();\n    const queue = createPriorityQueue((ta, tb)=>{\n        const a = toasts.get(ta);\n        const b = toasts.get(tb);\n        if (!a || !b) {\n            return 0;\n        }\n        if (a.priority === b.priority) {\n            return a.order - b.order;\n        }\n        return a.priority - b.priority;\n    });\n    const isToastVisible = (toastId)=>{\n        return visibleToasts.has(toastId);\n    };\n    /**\n   * Updates an existing toast with any available option\n   */ const updateToast = (toastOptions)=>{\n        const { toastId } = toastOptions;\n        const toastToUpdate = toasts.get(toastId);\n        if (!toastToUpdate) {\n            return;\n        }\n        Object.assign(toastToUpdate, toastOptions);\n        toastToUpdate.updateId++;\n    };\n    /**\n   * Dismisses a toast with a specific id\n   */ const dismissToast = (toastId)=>{\n        visibleToasts.delete(toastId);\n    };\n    /**\n   * Dismisses all toasts and clears the queue\n   */ const dismissAllToasts = ()=>{\n        visibleToasts.clear();\n        queue.clear();\n    };\n    /**\n   * @param toastOptions user configured options\n   * @param onUpdate Some toast methods can result in UI changes (i.e. close) use this to dispatch callbacks\n   */ const buildToast = (toastOptions, onUpdate)=>{\n        var _toast_onStatusChange;\n        const { toastId, content, toasterId } = toastOptions;\n        if (toasts.has(toastId)) {\n            return;\n        }\n        const close = ()=>{\n            var _toast_onStatusChange;\n            const toast = toasts.get(toastId);\n            if (!toast) {\n                return;\n            }\n            visibleToasts.delete(toastId);\n            onUpdate();\n            (_toast_onStatusChange = toast.onStatusChange) === null || _toast_onStatusChange === void 0 ? void 0 : _toast_onStatusChange.call(toast, null, {\n                status: 'dismissed',\n                ...toast\n            });\n        };\n        const remove = ()=>{\n            const toast = toasts.get(toastId);\n            if (!toast) {\n                return;\n            }\n            toasts.delete(toastId);\n            if (visibleToasts.size < limit && queue.peek()) {\n                const nextToast = toasts.get(queue.dequeue());\n                if (!nextToast) {\n                    return;\n                }\n                visibleToasts.add(nextToast.toastId);\n            }\n            onUpdate();\n        };\n        const toast = {\n            ...defaulToastOptions,\n            close,\n            remove,\n            toastId,\n            content,\n            updateId: 0,\n            toasterId,\n            order: counter++,\n            data: {},\n            imperativeRef: React.createRef()\n        };\n        assignDefined(toast, options);\n        assignDefined(toast, toastOptions);\n        toasts.set(toastId, toast);\n        (_toast_onStatusChange = toast.onStatusChange) === null || _toast_onStatusChange === void 0 ? void 0 : _toast_onStatusChange.call(toast, null, {\n            status: 'queued',\n            ...toast\n        });\n        if (visibleToasts.size >= limit) {\n            queue.enqueue(toastId);\n        } else {\n            visibleToasts.add(toastId);\n        }\n    };\n    return {\n        buildToast,\n        dismissAllToasts,\n        dismissToast,\n        isToastVisible,\n        updateToast,\n        visibleToasts,\n        toasts\n    };\n}\n"],"names":["createToaster","assignDefined","a","b","key","prop","Object","entries","undefined","defaulToastOptions","onStatusChange","priority","pauseOnHover","pauseOnWindowBlur","position","timeout","counter","options","limit","Number","POSITIVE_INFINITY","visibleToasts","Set","toasts","Map","queue","createPriorityQueue","ta","tb","get","order","isToastVisible","toastId","has","updateToast","toastOptions","toastToUpdate","assign","updateId","dismissToast","delete","dismissAllToasts","clear","buildToast","onUpdate","_toast_onStatusChange","content","toasterId","close","toast","call","status","remove","size","peek","nextToast","dequeue","add","data","imperativeRef","React","createRef","set","enqueue"],"mappings":"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"}