{"version":3,"sources":["useOnMenuEnter.js"],"sourcesContent":["import * as React from 'react';\nimport { useEventCallback, elementContains } from '@fluentui/react-utilities';\n/**\n * Name of the custom event\n */ export const MENU_ENTER_EVENT = 'fuimenuenter';\n/**\n * This hook works similarly to @see useOnClickOutside\n *\n * Problem: Trying to behave the same as system menus:\n * When the mouse leaves a stack of nested menus the stack should not dismiss.\n * However if the mouse leaves a stack of menus and enters a parent menu all its children menu should dismiss.\n *\n * We don't use the native mouseenter event because it would trigger too many times in the document\n * Instead, dispatch custom DOM event from the menu so that it can bubble\n * Each nested menu can use the listener to check if the event is from a child or parent menu\n */ export const useOnMenuMouseEnter = (options)=>{\n    const { refs, callback, element, disabled } = options;\n    // Keep mouse event here because this is essentially a custom 'mouseenter' event\n    const listener = useEventCallback((ev)=>{\n        const popoverRef = refs[0];\n        const someMenuPopover = ev.target;\n        var _popoverRef_current;\n        // someMenu is a child -> will always be contained because of vParents\n        // someMenu is a parent -> will always not be contained because no vParent\n        // someMenu is the current popover -> it will contain itself\n        const isOutsidePopover = !elementContains((_popoverRef_current = popoverRef.current) !== null && _popoverRef_current !== void 0 ? _popoverRef_current : null, someMenuPopover);\n        if (isOutsidePopover && !disabled) {\n            callback(ev);\n        }\n    });\n    React.useEffect(()=>{\n        // eslint-disable-next-line eqeqeq\n        if (element == null) {\n            return;\n        }\n        if (!disabled) {\n            element.addEventListener(MENU_ENTER_EVENT, listener);\n        }\n        return ()=>{\n            element.removeEventListener(MENU_ENTER_EVENT, listener);\n        };\n    }, [\n        listener,\n        element,\n        disabled\n    ]);\n};\n/**\n * Dispatches the custom MouseEvent enter event. Similar to calling `el.click()`\n * @param el - element for the event target\n * @param nativeEvent - the native mouse event this is mapped to\n */ export const dispatchMenuEnterEvent = (el, nativeEvent)=>{\n    el.dispatchEvent(new CustomEvent(MENU_ENTER_EVENT, {\n        bubbles: true,\n        detail: {\n            nativeEvent\n        }\n    }));\n};\n"],"names":["MENU_ENTER_EVENT","useOnMenuMouseEnter","dispatchMenuEnterEvent","options","refs","callback","element","disabled","listener","useEventCallback","ev","popoverRef","someMenuPopover","target","_popoverRef_current","isOutsidePopover","elementContains","current","React","useEffect","addEventListener","removeEventListener","el","nativeEvent","dispatchEvent","CustomEvent","bubbles","detail"],"mappings":";;;;;;;;;;;IAIiBA,gBAAgB;eAAhBA;;IAWAC,mBAAmB;eAAnBA;;IAoCAC,sBAAsB;eAAtBA;;;;iEAnDM;gCAC2B;AAGvC,MAAMF,mBAAmB;AAWzB,MAAMC,sBAAsB,CAACE;IACpC,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,QAAQ,EAAE,GAAGJ;IAC9C,gFAAgF;IAChF,MAAMK,WAAWC,IAAAA,gCAAgB,EAAC,CAACC;QAC/B,MAAMC,aAAaP,IAAI,CAAC,EAAE;QAC1B,MAAMQ,kBAAkBF,GAAGG,MAAM;QACjC,IAAIC;QACJ,sEAAsE;QACtE,0EAA0E;QAC1E,4DAA4D;QAC5D,MAAMC,mBAAmB,CAACC,IAAAA,+BAAe,EAAC,AAACF,CAAAA,sBAAsBH,WAAWM,OAAO,AAAD,MAAO,QAAQH,wBAAwB,KAAK,IAAIA,sBAAsB,MAAMF;QAC9J,IAAIG,oBAAoB,CAACR,UAAU;YAC/BF,SAASK;QACb;IACJ;IACAQ,OAAMC,SAAS,CAAC;QACZ,kCAAkC;QAClC,IAAIb,WAAW,MAAM;YACjB;QACJ;QACA,IAAI,CAACC,UAAU;YACXD,QAAQc,gBAAgB,CAACpB,kBAAkBQ;QAC/C;QACA,OAAO;YACHF,QAAQe,mBAAmB,CAACrB,kBAAkBQ;QAClD;IACJ,GAAG;QACCA;QACAF;QACAC;KACH;AACL;AAKW,MAAML,yBAAyB,CAACoB,IAAIC;IAC3CD,GAAGE,aAAa,CAAC,IAAIC,YAAYzB,kBAAkB;QAC/C0B,SAAS;QACTC,QAAQ;YACJJ;QACJ;IACJ;AACJ"}