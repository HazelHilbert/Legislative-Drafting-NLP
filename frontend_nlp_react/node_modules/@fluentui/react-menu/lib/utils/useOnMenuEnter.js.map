{"version":3,"sources":["useOnMenuEnter.ts"],"sourcesContent":["import * as React from 'react';\nimport { useEventCallback, elementContains } from '@fluentui/react-utilities';\nimport type { UseOnClickOrScrollOutsideOptions } from '@fluentui/react-utilities';\n\n/**\n * Name of the custom event\n */\nexport const MENU_ENTER_EVENT = 'fuimenuenter';\n\n/**\n * This hook works similarly to @see useOnClickOutside\n *\n * Problem: Trying to behave the same as system menus:\n * When the mouse leaves a stack of nested menus the stack should not dismiss.\n * However if the mouse leaves a stack of menus and enters a parent menu all its children menu should dismiss.\n *\n * We don't use the native mouseenter event because it would trigger too many times in the document\n * Instead, dispatch custom DOM event from the menu so that it can bubble\n * Each nested menu can use the listener to check if the event is from a child or parent menu\n */\nexport const useOnMenuMouseEnter = (options: UseOnClickOrScrollOutsideOptions) => {\n  const { refs, callback, element, disabled } = options;\n\n  // Keep mouse event here because this is essentially a custom 'mouseenter' event\n  const listener = useEventCallback((ev: MouseEvent) => {\n    const popoverRef = refs[0];\n    const someMenuPopover = ev.target as HTMLElement;\n\n    // someMenu is a child -> will always be contained because of vParents\n    // someMenu is a parent -> will always not be contained because no vParent\n    // someMenu is the current popover -> it will contain itself\n    const isOutsidePopover = !elementContains(popoverRef.current ?? null, someMenuPopover);\n    if (isOutsidePopover && !disabled) {\n      callback(ev);\n    }\n  });\n\n  React.useEffect(() => {\n    // eslint-disable-next-line eqeqeq\n    if (element == null) {\n      return;\n    }\n\n    /**\n     * Because `addEventListener` type override falls back to 2nd definition (evt name is unknown string literal)\n     * evt is being typed as a base class of MouseEvent -> `Event`.\n     * This type is used to override `listener` calls to make TS happy\n     */\n\n    type ListenerOverride = (evt: Event) => void;\n\n    if (!disabled) {\n      element.addEventListener(MENU_ENTER_EVENT, listener as ListenerOverride);\n    }\n\n    return () => {\n      element.removeEventListener(MENU_ENTER_EVENT, listener as ListenerOverride);\n    };\n  }, [listener, element, disabled]);\n};\n\n/**\n * Dispatches the custom MouseEvent enter event. Similar to calling `el.click()`\n * @param el - element for the event target\n * @param nativeEvent - the native mouse event this is mapped to\n */\nexport const dispatchMenuEnterEvent = (el: HTMLElement, nativeEvent: MouseEvent) => {\n  el.dispatchEvent(new CustomEvent(MENU_ENTER_EVENT, { bubbles: true, detail: { nativeEvent } }));\n};\n"],"names":["React","useEventCallback","elementContains","MENU_ENTER_EVENT","useOnMenuMouseEnter","options","refs","callback","element","disabled","listener","ev","popoverRef","someMenuPopover","target","isOutsidePopover","current","useEffect","addEventListener","removeEventListener","dispatchMenuEnterEvent","el","nativeEvent","dispatchEvent","CustomEvent","bubbles","detail"],"mappings":"AAAA,YAAYA,WAAW,QAAQ;AAC/B,SAASC,gBAAgB,EAAEC,eAAe,QAAQ,4BAA4B;AAG9E;;CAEC,GACD,OAAO,MAAMC,mBAAmB,eAAe;AAE/C;;;;;;;;;;CAUC,GACD,OAAO,MAAMC,sBAAsB,CAACC;IAClC,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,QAAQ,EAAE,GAAGJ;IAE9C,gFAAgF;IAChF,MAAMK,WAAWT,iBAAiB,CAACU;QACjC,MAAMC,aAAaN,IAAI,CAAC,EAAE;QAC1B,MAAMO,kBAAkBF,GAAGG,MAAM;YAKSF;QAH1C,sEAAsE;QACtE,0EAA0E;QAC1E,4DAA4D;QAC5D,MAAMG,mBAAmB,CAACb,gBAAgBU,CAAAA,sBAAAA,WAAWI,OAAO,cAAlBJ,iCAAAA,sBAAsB,MAAMC;QACtE,IAAIE,oBAAoB,CAACN,UAAU;YACjCF,SAASI;QACX;IACF;IAEAX,MAAMiB,SAAS,CAAC;QACd,kCAAkC;QAClC,IAAIT,WAAW,MAAM;YACnB;QACF;QAUA,IAAI,CAACC,UAAU;YACbD,QAAQU,gBAAgB,CAACf,kBAAkBO;QAC7C;QAEA,OAAO;YACLF,QAAQW,mBAAmB,CAAChB,kBAAkBO;QAChD;IACF,GAAG;QAACA;QAAUF;QAASC;KAAS;AAClC,EAAE;AAEF;;;;CAIC,GACD,OAAO,MAAMW,yBAAyB,CAACC,IAAiBC;IACtDD,GAAGE,aAAa,CAAC,IAAIC,YAAYrB,kBAAkB;QAAEsB,SAAS;QAAMC,QAAQ;YAAEJ;QAAY;IAAE;AAC9F,EAAE"}