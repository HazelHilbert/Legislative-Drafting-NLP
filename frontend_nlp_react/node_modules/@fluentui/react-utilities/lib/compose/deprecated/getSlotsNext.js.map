{"version":3,"sources":["getSlotsNext.ts"],"sourcesContent":["import * as React from 'react';\nimport type { ComponentState, SlotPropsRecord, UnknownSlotProps } from '../types';\nimport { ObjectSlotProps, Slots } from './getSlots';\n\n/**\n * Similar to `getSlots`, main difference is that it's compatible with new custom jsx pragma\n *\n * @internal\n * This is an internal temporary method, this method will cease to exist eventually!\n *\n * * ❗️❗️ **DO NOT USE IT EXTERNALLY** ❗️❗️\n *\n * @deprecated use slot.always or slot.optional combined with assertSlots instead\n */\nexport function getSlotsNext<R extends SlotPropsRecord>(\n  state: ComponentState<R>,\n): {\n  // eslint-disable-next-line deprecation/deprecation\n  slots: Slots<R>;\n  // eslint-disable-next-line deprecation/deprecation\n  slotProps: ObjectSlotProps<R>;\n} {\n  // eslint-disable-next-line deprecation/deprecation\n  const slots = {} as Slots<R>;\n  const slotProps = {} as R;\n\n  const slotNames: (keyof R)[] = Object.keys(state.components);\n  for (const slotName of slotNames) {\n    // eslint-disable-next-line deprecation/deprecation\n    const [slot, props] = getSlotNext(state, slotName);\n    // eslint-disable-next-line deprecation/deprecation\n    slots[slotName] = slot as Slots<R>[typeof slotName];\n    slotProps[slotName] = props;\n  }\n  // eslint-disable-next-line deprecation/deprecation\n  return { slots, slotProps: slotProps as unknown as ObjectSlotProps<R> };\n}\n\n/**\n * @deprecated use slot.always or slot.optional combined with assertSlots instead\n */\nfunction getSlotNext<R extends SlotPropsRecord, K extends keyof R>(\n  state: ComponentState<R>,\n  slotName: K,\n): readonly [React.ElementType<R[K]> | null, R[K]] {\n  const props = state[slotName];\n\n  if (props === undefined) {\n    return [null, undefined as R[K]];\n  }\n\n  type NonUndefined<T> = T extends undefined ? never : T;\n  // TS Error: Property 'as' does not exist on type 'UnknownSlotProps | undefined'.ts(2339)\n  const { as: asProp, ...propsWithoutAs } = props as NonUndefined<typeof props>;\n\n  const slot = (\n    state.components?.[slotName] === undefined || typeof state.components[slotName] === 'string'\n      ? asProp || state.components?.[slotName] || 'div'\n      : state.components[slotName]\n  ) as React.ElementType<R[K]>;\n\n  const shouldOmitAsProp = typeof slot === 'string' && asProp;\n  const slotProps: UnknownSlotProps = shouldOmitAsProp ? propsWithoutAs : props;\n\n  return [slot, slotProps as R[K]];\n}\n"],"names":["React","getSlotsNext","state","slots","slotProps","slotNames","Object","keys","components","slotName","slot","props","getSlotNext","undefined","as","asProp","propsWithoutAs","shouldOmitAsProp"],"mappings":"AAAA,YAAYA,WAAW,QAAQ;AAI/B;;;;;;;;;CASC,GACD,OAAO,SAASC,aACdC,KAAwB;IAOxB,mDAAmD;IACnD,MAAMC,QAAQ,CAAC;IACf,MAAMC,YAAY,CAAC;IAEnB,MAAMC,YAAyBC,OAAOC,IAAI,CAACL,MAAMM,UAAU;IAC3D,KAAK,MAAMC,YAAYJ,UAAW;QAChC,mDAAmD;QACnD,MAAM,CAACK,MAAMC,MAAM,GAAGC,YAAYV,OAAOO;QACzC,mDAAmD;QACnDN,KAAK,CAACM,SAAS,GAAGC;QAClBN,SAAS,CAACK,SAAS,GAAGE;IACxB;IACA,mDAAmD;IACnD,OAAO;QAAER;QAAOC,WAAWA;IAA2C;AACxE;AAEA;;CAEC,GACD,SAASQ,YACPV,KAAwB,EACxBO,QAAW;QAaTP,mBACcA;IAZhB,MAAMS,QAAQT,KAAK,CAACO,SAAS;IAE7B,IAAIE,UAAUE,WAAW;QACvB,OAAO;YAAC;YAAMA;SAAkB;IAClC;IAGA,yFAAyF;IACzF,MAAM,EAAEC,IAAIC,MAAM,EAAE,GAAGC,gBAAgB,GAAGL;IAE1C,MAAMD,OACJR,EAAAA,oBAAAA,MAAMM,UAAU,cAAhBN,wCAAAA,iBAAkB,CAACO,SAAS,MAAKI,aAAa,OAAOX,MAAMM,UAAU,CAACC,SAAS,KAAK,WAChFM,YAAUb,qBAAAA,MAAMM,UAAU,cAAhBN,yCAAAA,kBAAkB,CAACO,SAAS,KAAI,QAC1CP,MAAMM,UAAU,CAACC,SAAS;IAGhC,MAAMQ,mBAAmB,OAAOP,SAAS,YAAYK;IACrD,MAAMX,YAA8Ba,mBAAmBD,iBAAiBL;IAExE,OAAO;QAACD;QAAMN;KAAkB;AAClC"}