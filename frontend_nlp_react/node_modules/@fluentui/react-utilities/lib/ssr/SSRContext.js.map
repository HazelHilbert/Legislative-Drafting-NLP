{"version":3,"sources":["SSRContext.tsx"],"sourcesContent":["import * as React from 'react';\nimport { canUseDOM } from './canUseDOM';\n\n/**\n * To support SSR, the auto incrementing id counter is stored in a context. This allows it to be reset on every request\n * to ensure the client and server are consistent.\n *\n * @internal\n */\nexport type SSRContextValue = {\n  current: number;\n};\n\n/**\n * Default context value to use in case there is no SSRProvider. This is fine for client-only apps.\n *\n * @internal\n */\nexport const defaultSSRContextValue: SSRContextValue = {\n  current: 0,\n};\n\nexport const SSRContext = React.createContext<SSRContextValue | undefined>(undefined) as React.Context<SSRContextValue>;\n\n/**\n * @internal\n */\nexport function useSSRContext(): SSRContextValue {\n  return React.useContext(SSRContext) ?? defaultSSRContextValue;\n}\n\n/**\n * When using SSR with Fluent UI, applications must be wrapped in an SSRProvider. This ensures that auto generated ids\n * are consistent between the client and server.\n *\n * @public\n */\nexport const SSRProvider: React.FC<{ children: React.ReactNode }> = props => {\n  const [value] = React.useState<SSRContextValue>(() => ({ current: 0 }));\n\n  return <SSRContext.Provider value={value}>{props.children}</SSRContext.Provider>;\n};\n\n/**\n * Returns whether the component is currently being server side rendered or hydrated on the client. Can be used to delay\n * browser-specific rendering until after hydration. May cause re-renders on a client when is used within SSRProvider.\n */\nexport function useIsSSR(): boolean {\n  const isInSSRContext = useSSRContext() !== defaultSSRContextValue;\n  const [isSSR, setIsSSR] = React.useState(isInSSRContext);\n\n  // If we are rendering in a non-DOM environment, and there's no SSRProvider, provide a warning to hint to the\n  // developer to add one.\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isInSSRContext && !canUseDOM()) {\n      // eslint-disable-next-line no-console\n      console.error(/** #__DE-INDENT__ */ `\n        @fluentui/react-components [${useIsSSR.name}]:\n        When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.\n\n\n        Check documentation at https://aka.ms/fluentui-ssr.\n      `);\n    }\n  }\n\n  // If on the client, and the component was initially server rendered, then schedule a layout effect to update the\n  // component after hydration.\n  if (canUseDOM() && isInSSRContext) {\n    // This if statement technically breaks the rules of hooks, but is safe because the condition never changes after\n    // mounting.\n    // eslint-disable-next-line\n    React.useLayoutEffect(() => {\n      setIsSSR(false);\n    }, []);\n  }\n\n  return isSSR;\n}\n"],"names":["React","canUseDOM","defaultSSRContextValue","current","SSRContext","createContext","undefined","useSSRContext","useContext","SSRProvider","props","value","useState","Provider","children","useIsSSR","isInSSRContext","isSSR","setIsSSR","process","env","NODE_ENV","console","error","name","useLayoutEffect"],"mappings":"AAAA,YAAYA,WAAW,QAAQ;AAC/B,SAASC,SAAS,QAAQ,cAAc;AAYxC;;;;CAIC,GACD,OAAO,MAAMC,yBAA0C;IACrDC,SAAS;AACX,EAAE;AAEF,OAAO,MAAMC,2BAAaJ,MAAMK,aAAa,CAA8BC,WAA6C;AAExH;;CAEC,GACD,OAAO,SAASC;QACPP;IAAP,OAAOA,CAAAA,oBAAAA,MAAMQ,UAAU,CAACJ,yBAAjBJ,+BAAAA,oBAAgCE;AACzC;AAEA;;;;;CAKC,GACD,OAAO,MAAMO,cAAuDC,CAAAA;IAClE,MAAM,CAACC,MAAM,GAAGX,MAAMY,QAAQ,CAAkB,IAAO,CAAA;YAAET,SAAS;QAAE,CAAA;IAEpE,qBAAO,oBAACC,WAAWS,QAAQ;QAACF,OAAOA;OAAQD,MAAMI,QAAQ;AAC3D,EAAE;AAEF;;;CAGC,GACD,OAAO,SAASC;IACd,MAAMC,iBAAiBT,oBAAoBL;IAC3C,MAAM,CAACe,OAAOC,SAAS,GAAGlB,MAAMY,QAAQ,CAACI;IAEzC,6GAA6G;IAC7G,wBAAwB;IACxB,IAAIG,QAAQC,GAAG,CAACC,QAAQ,KAAK,cAAc;QACzC,IAAI,CAACL,kBAAkB,CAACf,aAAa;YACnC,sCAAsC;YACtCqB,QAAQC,KAAK,CAAuB,CAAC,4BACP,EAAER,SAASS,IAAI,CAAC;;;;mDAK9C,CAAC;QACH;IACF;IAEA,iHAAiH;IACjH,6BAA6B;IAC7B,IAAIvB,eAAee,gBAAgB;QACjC,iHAAiH;QACjH,YAAY;QACZ,2BAA2B;QAC3BhB,MAAMyB,eAAe,CAAC;YACpBP,SAAS;QACX,GAAG,EAAE;IACP;IAEA,OAAOD;AACT"}