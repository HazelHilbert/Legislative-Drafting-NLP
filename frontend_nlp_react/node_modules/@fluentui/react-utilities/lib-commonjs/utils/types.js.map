{"version":3,"sources":["types.js"],"sourcesContent":["/**\n * Helper type that works similar to Omit,\n * but when modifying an union type it will distribute the omission to all the union members.\n *\n * See [distributive conditional types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types) for more information\n */ // Traditional Omit is basically equivalent to => Pick<T, Exclude<keyof T, K>>\n//\n// let's say we have Omit<{ a: string } | { b: string }, 'a'>\n// equivalent to: Pick<{ a: string } | { b: string }, Exclude<keyof ({ a: string } | { b: string }), 'a'>>\n// The expected result would be {} | { b: string }, the omission of 'a' from all the union members,\n// but keyof ({ a: string } | { b: string }) is never as they don't share common keys\n// so  Exclude<never, 'a'> is never,\n// and Pick<{ a: string } | { b: string }, never> is {}.\n//\n// With DistributiveOmit on the other hand it becomes like this:\n// DistributiveOmit<{ a: string } | { b: string }, 'a'>\n// equivalent to: Omit<{ a: string }, 'a'> | Omit<{ b: string }, 'a'>\n// Since every single Omit clause in this case is being applied to a single union member there's no conflicts on keyof evaluation and in the second clause Omit<{ b: string }, 'a'> becomes { b: string },\n// so the result is {} | { b: string }, as expected.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport { };\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAAG,8EAA8E;AAClF,EAAE;AACF,6DAA6D;AAC7D,0GAA0G;AAC1G,mGAAmG;AACnG,qFAAqF;AACrF,oCAAoC;AACpC,wDAAwD;AACxD,EAAE;AACF,gEAAgE;AAChE,uDAAuD;AACvD,qEAAqE;AACrE,0MAA0M;AAC1M,oDAAoD;AACpD,8DAA8D"}