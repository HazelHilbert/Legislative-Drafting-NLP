import { dispatchGroupperMoveFocusEvent } from 'tabster';
import { dispatchMoverMoveFocusEvent } from 'tabster';
import type { GriffelStyle } from '@griffel/react';
import { KEYBORG_FOCUSIN } from 'keyborg';
import { KeyborgFocusInEvent } from 'keyborg';
import { makeResetStyles } from '@griffel/react';
import * as React_2 from 'react';
import type { RefObject } from 'react';
import { Types as TabsterTypes } from 'tabster';

/**
 * @internal
 * @param scope - Applies the ponyfill to all DOM children
 * @param targetWindow - window
 */
export declare function applyFocusVisiblePolyfill(scope: HTMLElement, targetWindow: Window): () => void;

/**
 * Creates a style for @see makeStyles that includes the necessary selectors for focus.
 * Should be used only when @see createFocusOutlineStyle does not fit requirements
 *
 * If you're using `createCustomFocusIndicatorStyle` instead of `createFocusOutlineStyle`
 * keep in mind that the default outline style is not going to be removed
 * (as it is in `createFocusOutlineStyle`),
 * and is your responsibility to manually remove it from your styles.
 *
 * @example
 * ```ts
 * // Link styles
 * const useStyles = makeStyles({
 focusIndicator: createCustomFocusIndicatorStyle({
 textDecorationColor: tokens.colorStrokeFocus2,
 textDecorationLine: 'underline',
 textDecorationStyle: 'double',
 outlineStyle: 'none',
 }),
 // Common styles.
 root: {
 // ❗️ DO NOT FORGET TO REMOVE THE DEFAULT OUTLINE STYLE
 ':focus-visible': {
 outlineStyle: 'none',
 },
 * ```
 *
 * @param style - styling applied on focus, defaults to @see getDefaultFocusOutlineStyles
 * @param options - Configure the style of the focus outline
 */
export declare function createCustomFocusIndicatorStyle<TStyle extends GriffelStyle | GriffelResetStyle>(style: TStyle, { selector: selectorType, customizeSelector, }?: CreateCustomFocusIndicatorStyleOptions): TStyle extends GriffelStyle ? GriffelStyle : GriffelResetStyle;

export declare interface CreateCustomFocusIndicatorStyleOptions {
    /**
     * Control if the indicator appears when the corresponding element is focused,
     * or any child is focused within the corresponding element.
     * @default 'focus'
     * @alias selectorType
     */
    selector?: 'focus' | 'focus-within';
    /**
     * Customizes the selector provided based on the selector type.
     */
    customizeSelector?: (selector: string) => string;
    /**
     * Enables the browser default outline style
     * @deprecated The custom focus indicator no longer affects outline styles. Outline is overridden
     * in the default focus indicator function, `createFocusOutlineStyle`.
     */
    enableOutline?: boolean;
}

/**
 * NOTE: The element with the focus outline needs to have `position: relative` so that the
 * pseudo element can be properly positioned.
 *
 * @param options - Configure the style of the focus outline
 * @returns focus outline styles object for @see makeStyles
 */
export declare const createFocusOutlineStyle: ({ enableOutline, selector, customizeSelector, style, }?: CreateFocusOutlineStyleOptions) => GriffelStyle;

export declare interface CreateFocusOutlineStyleOptions extends Omit<CreateCustomFocusIndicatorStyleOptions, 'enableOutline'> {
    style?: Partial<FocusOutlineStyleOptions>;
    /**
     * Enables the browser default outline style
     */
    enableOutline?: boolean;
}

export { dispatchGroupperMoveFocusEvent }

export { dispatchMoverMoveFocusEvent }

export declare type FocusOutlineOffset = Record<'top' | 'bottom' | 'left' | 'right', string>;

export declare type FocusOutlineStyleOptions = {
    /**
     * Only property not supported by the native CSS `outline`, if this is no longer needed
     * we can just go native instead
     */
    outlineRadius: string;
    outlineColor: string;
    outlineWidth: string;
    outlineOffset?: string | FocusOutlineOffset;
};

declare type GriffelResetStyle = Parameters<typeof makeResetStyles>[0];

export { KEYBORG_FOCUSIN }

export { KeyborgFocusInEvent }

export declare type TabsterDOMAttribute = TabsterTypes.TabsterDOMAttribute;

export { TabsterTypes }

/**
 * A hook that returns the necessary tabster attributes to support arrow key navigation
 * @param options - Options to configure keyboard navigation
 */
export declare const useArrowNavigationGroup: (options?: UseArrowNavigationGroupOptions) => TabsterTypes.TabsterDOMAttribute;

export declare interface UseArrowNavigationGroupOptions {
    /**
     * Focus will navigate vertically, horizontally or in both directions (grid), defaults to horizontally
     * @defaultValue vertical
     */
    axis?: 'vertical' | 'horizontal' | 'grid' | 'grid-linear' | 'both';
    /**
     * Focus will cycle to the first/last elements of the group without stopping
     */
    circular?: boolean;
    /**
     * Last focused element in the group will be remembered and focused (if still
     * available) when tabbing from outside of the group
     * @default true
     */
    memorizeCurrent?: boolean;
    /**
     * Allow tabbing within the arrow navigation group items.
     */
    tabbable?: boolean;
    /**
     * Tabster should ignore default handling of keydown events
     */
    ignoreDefaultKeydown?: TabsterTypes.FocusableProps['ignoreKeydown'];
    /**
     * The default focusable item in the group will be an element with Focusable.isDefault property.
     * Note that there is no way in \@fluentui/react-tabster to set default focusable element,
     * and this option is currently for internal testing purposes only.
     */
    unstable_hasDefault?: boolean;
}

/**
 * A hook that returns the necessary tabster attributes to support groupping.
 * @param options - Options to configure keyboard navigation
 */
export declare const useFocusableGroup: (options?: UseFocusableGroupOptions) => TabsterTypes.TabsterDOMAttribute;

export declare interface UseFocusableGroupOptions {
    /**
     * Behavior for the Tab key.
     */
    tabBehavior?: 'unlimited' | 'limited' | 'limited-trap-focus';
    /**
     * Tabster can ignore default handling of keydown events
     */
    ignoreDefaultKeydown?: TabsterTypes.FocusableProps['ignoreKeydown'];
}

/**
 * Returns a set of helper functions that will traverse focusable elements in the context of a root DOM element
 */
export declare const useFocusFinders: () => {
    findAllFocusable: (container: HTMLElement, acceptCondition?: ((el: HTMLElement) => boolean) | undefined) => HTMLElement[];
    findFirstFocusable: (container: HTMLElement) => HTMLElement | null | undefined;
    findLastFocusable: (container: HTMLElement) => HTMLElement | null | undefined;
    findNextFocusable: (currentElement: HTMLElement, options?: Pick<Partial<TabsterTypes.FindNextProps>, 'container'>) => HTMLElement | null | undefined;
    findPrevFocusable: (currentElement: HTMLElement, options?: Pick<Partial<TabsterTypes.FindNextProps>, 'container'>) => HTMLElement | null | undefined;
};

/**
 *
 * @param name - The observed element to focus
 * @returns Function that will focus the
 */
export declare function useFocusObserved(name: string, options?: UseFocusObservedOptions): () => TabsterTypes.ObservedElementAsyncRequest<boolean>;

declare interface UseFocusObservedOptions {
    /**
     * After timeout the focus attempt fails
     */
    timeout?: number;
}

export declare function useFocusVisible<TElement extends HTMLElement = HTMLElement>(options?: UseFocusVisibleOptions): React_2.RefObject<TElement>;

declare type UseFocusVisibleOptions = {
    targetDocument?: Document;
};

/**
 * A ponyfill that allows `:focus-within` to support visibility based on keyboard/mouse navigation
 * like `:focus-visible` https://github.com/WICG/focus-visible/issues/151
 * @returns ref to the element that uses `:focus-within` styles
 */
export declare function useFocusWithin<TElement extends HTMLElement = HTMLElement>(): React_2.RefObject<TElement>;

/**
 * Instantiates [keyborg](https://github.com/microsoft/keyborg) and adds `data-keyboard-nav`
 * attribute to a referenced element to ensure keyboard navigation awareness
 * synced to keyborg logic without having to cause a re-render on react tree.
 */
export declare function useKeyboardNavAttribute<E extends HTMLElement>(): RefObject<E>;

/**
 * Merges a collection of tabster attributes.
 *
 * ⚠️The attributes passed as arguments to this  hook cannot change at runtime.
 * @internal
 * @param attributes - collection of tabster attributes from other react-tabster hooks
 * @returns single merged tabster attribute
 */
export declare const useMergedTabsterAttributes_unstable: (...attributes: TabsterTypes.TabsterDOMAttribute[]) => TabsterTypes.TabsterDOMAttribute;

/**
 * Applies modal dialog behaviour through DOM attributes
 * Modal element will focus trap and hide other content on the page
 * The trigger element will be focused if focus is lost after the modal element is removed
 *
 * @returns DOM attributes to apply to the modal element and its trigger
 */
export declare const useModalAttributes: (options?: UseModalAttributesOptions) => {
    modalAttributes: TabsterTypes.TabsterDOMAttribute;
    triggerAttributes: TabsterTypes.TabsterDOMAttribute;
};

export declare interface UseModalAttributesOptions {
    /**
     * Traps focus inside the elements the attributes are applied.
     * Prefer this to `legacyTrapFocus`
     * it forbids users to tab out of the focus trap into the actual browser.
     */
    trapFocus?: boolean;
    /**
     * Traps focus inside the elements the attributes are applied.
     * This prop enables legacy behavior to match previous versions of Fluent and is not
     * recommended for general use.
     * Enabling `legacyTrapFocus` prevents users from tabbing out of the focus trap and into
     * the actual browser. Prefer using `trapFocus` instead of this prop.
     */
    legacyTrapFocus?: boolean;
    /**
     * Always reachabled in Tab order
     */
    alwaysFocusable?: boolean;
    /**
     * Id to use for the modalizer. An id will be generated if not provided.
     */
    id?: string;
}

export declare function useObservedElement(name: string | string[]): TabsterTypes.TabsterDOMAttribute;

/**
 * Instantiates [keyborg](https://github.com/microsoft/keyborg) and subscribes to changes
 * in the keyboard navigation mode.
 *
 * @param callback - called every time the keyboard navigation state changes
 */
export declare function useOnKeyboardNavigationChange(callback: (isNavigatingWithKeyboard: boolean) => void): void;

/**
 * Focus will be restored to the most recent target element when it is lost from a source
 * @returns Attribute to apply to the element that might lose focus
 */
export declare function useRestoreFocusSource(): TabsterTypes.TabsterDOMAttribute;

/**
 * Focus will be restored to the most recent target element when it is lost from a source
 * @returns Attribute to apply to the target element where focus is restored
 */
export declare function useRestoreFocusTarget(): TabsterTypes.TabsterDOMAttribute;

/**
 */
export declare function useSetKeyboardNavigation(): (isNavigatingWithKeyboard: boolean) => void;

/**
 * @internal
 * Hook that returns tabster attributes while ensuring tabster exists
 */
export declare const useTabsterAttributes: (props: TabsterTypes.TabsterAttributeProps) => TabsterTypes.TabsterDOMAttribute;

/**
 * Designates an area where tabster does not control focus
 * @returns Attribute to apply to the target element that should be uncontrolled by tabster
 */
export declare function useUncontrolledFocus(): TabsterTypes.TabsterDOMAttribute;

export { }
