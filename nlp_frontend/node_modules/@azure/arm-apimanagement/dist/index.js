'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link Protocol} that the service accepts. */
exports.KnownProtocol = void 0;
(function (KnownProtocol) {
    /** Http */
    KnownProtocol["Http"] = "http";
    /** Https */
    KnownProtocol["Https"] = "https";
    /** Ws */
    KnownProtocol["Ws"] = "ws";
    /** Wss */
    KnownProtocol["Wss"] = "wss";
})(exports.KnownProtocol || (exports.KnownProtocol = {}));
/** Known values of {@link ApiVersionSetContractDetailsVersioningScheme} that the service accepts. */
exports.KnownApiVersionSetContractDetailsVersioningScheme = void 0;
(function (KnownApiVersionSetContractDetailsVersioningScheme) {
    /** Segment */
    KnownApiVersionSetContractDetailsVersioningScheme["Segment"] = "Segment";
    /** Query */
    KnownApiVersionSetContractDetailsVersioningScheme["Query"] = "Query";
    /** Header */
    KnownApiVersionSetContractDetailsVersioningScheme["Header"] = "Header";
})(exports.KnownApiVersionSetContractDetailsVersioningScheme || (exports.KnownApiVersionSetContractDetailsVersioningScheme = {}));
/** Known values of {@link BearerTokenSendingMethods} that the service accepts. */
exports.KnownBearerTokenSendingMethods = void 0;
(function (KnownBearerTokenSendingMethods) {
    /** Access token will be transmitted in the Authorization header using Bearer schema */
    KnownBearerTokenSendingMethods["AuthorizationHeader"] = "authorizationHeader";
    /** Access token will be transmitted as query parameters. */
    KnownBearerTokenSendingMethods["Query"] = "query";
})(exports.KnownBearerTokenSendingMethods || (exports.KnownBearerTokenSendingMethods = {}));
/** Known values of {@link ApiType} that the service accepts. */
exports.KnownApiType = void 0;
(function (KnownApiType) {
    /** Http */
    KnownApiType["Http"] = "http";
    /** Soap */
    KnownApiType["Soap"] = "soap";
    /** Websocket */
    KnownApiType["Websocket"] = "websocket";
    /** Graphql */
    KnownApiType["Graphql"] = "graphql";
})(exports.KnownApiType || (exports.KnownApiType = {}));
/** Known values of {@link ContentFormat} that the service accepts. */
exports.KnownContentFormat = void 0;
(function (KnownContentFormat) {
    /** The contents are inline and Content type is a WADL document. */
    KnownContentFormat["WadlXml"] = "wadl-xml";
    /** The WADL document is hosted on a publicly accessible internet address. */
    KnownContentFormat["WadlLinkJson"] = "wadl-link-json";
    /** The contents are inline and Content Type is a OpenAPI 2.0 JSON Document. */
    KnownContentFormat["SwaggerJson"] = "swagger-json";
    /** The OpenAPI 2.0 JSON document is hosted on a publicly accessible internet address. */
    KnownContentFormat["SwaggerLinkJson"] = "swagger-link-json";
    /** The contents are inline and the document is a WSDL/Soap document. */
    KnownContentFormat["Wsdl"] = "wsdl";
    /** The WSDL document is hosted on a publicly accessible internet address. */
    KnownContentFormat["WsdlLink"] = "wsdl-link";
    /** The contents are inline and Content Type is a OpenAPI 3.0 YAML Document. */
    KnownContentFormat["Openapi"] = "openapi";
    /** The contents are inline and Content Type is a OpenAPI 3.0 JSON Document. */
    KnownContentFormat["OpenapiJson"] = "openapi+json";
    /** The OpenAPI 3.0 YAML document is hosted on a publicly accessible internet address. */
    KnownContentFormat["OpenapiLink"] = "openapi-link";
    /** The OpenAPI 3.0 JSON document is hosted on a publicly accessible internet address. */
    KnownContentFormat["OpenapiJsonLink"] = "openapi+json-link";
    /** The GraphQL API endpoint hosted on a publicly accessible internet address. */
    KnownContentFormat["GraphqlLink"] = "graphql-link";
})(exports.KnownContentFormat || (exports.KnownContentFormat = {}));
/** Known values of {@link SoapApiType} that the service accepts. */
exports.KnownSoapApiType = void 0;
(function (KnownSoapApiType) {
    /** Imports a SOAP API having a RESTful front end. */
    KnownSoapApiType["SoapToRest"] = "http";
    /** Imports the SOAP API having a SOAP front end. */
    KnownSoapApiType["SoapPassThrough"] = "soap";
    /** Imports the API having a Websocket front end. */
    KnownSoapApiType["WebSocket"] = "websocket";
    /** Imports the API having a GraphQL front end. */
    KnownSoapApiType["GraphQL"] = "graphql";
})(exports.KnownSoapApiType || (exports.KnownSoapApiType = {}));
/** Known values of {@link PolicyContentFormat} that the service accepts. */
exports.KnownPolicyContentFormat = void 0;
(function (KnownPolicyContentFormat) {
    /** The contents are inline and Content type is an XML document. */
    KnownPolicyContentFormat["Xml"] = "xml";
    /** The policy XML document is hosted on a http endpoint accessible from the API Management service. */
    KnownPolicyContentFormat["XmlLink"] = "xml-link";
    /** The contents are inline and Content type is a non XML encoded policy document. */
    KnownPolicyContentFormat["Rawxml"] = "rawxml";
    /** The policy document is not Xml encoded and is hosted on a http endpoint accessible from the API Management service. */
    KnownPolicyContentFormat["RawxmlLink"] = "rawxml-link";
})(exports.KnownPolicyContentFormat || (exports.KnownPolicyContentFormat = {}));
/** Known values of {@link PolicyIdName} that the service accepts. */
exports.KnownPolicyIdName = void 0;
(function (KnownPolicyIdName) {
    /** Policy */
    KnownPolicyIdName["Policy"] = "policy";
})(exports.KnownPolicyIdName || (exports.KnownPolicyIdName = {}));
/** Known values of {@link PolicyExportFormat} that the service accepts. */
exports.KnownPolicyExportFormat = void 0;
(function (KnownPolicyExportFormat) {
    /** The contents are inline and Content type is an XML document. */
    KnownPolicyExportFormat["Xml"] = "xml";
    /** The contents are inline and Content type is a non XML encoded policy document. */
    KnownPolicyExportFormat["Rawxml"] = "rawxml";
})(exports.KnownPolicyExportFormat || (exports.KnownPolicyExportFormat = {}));
/** Known values of {@link AlwaysLog} that the service accepts. */
exports.KnownAlwaysLog = void 0;
(function (KnownAlwaysLog) {
    /** Always log all erroneous request regardless of sampling settings. */
    KnownAlwaysLog["AllErrors"] = "allErrors";
})(exports.KnownAlwaysLog || (exports.KnownAlwaysLog = {}));
/** Known values of {@link SamplingType} that the service accepts. */
exports.KnownSamplingType = void 0;
(function (KnownSamplingType) {
    /** Fixed-rate sampling. */
    KnownSamplingType["Fixed"] = "fixed";
})(exports.KnownSamplingType || (exports.KnownSamplingType = {}));
/** Known values of {@link DataMaskingMode} that the service accepts. */
exports.KnownDataMaskingMode = void 0;
(function (KnownDataMaskingMode) {
    /** Mask the value of an entity. */
    KnownDataMaskingMode["Mask"] = "Mask";
    /** Hide the presence of an entity. */
    KnownDataMaskingMode["Hide"] = "Hide";
})(exports.KnownDataMaskingMode || (exports.KnownDataMaskingMode = {}));
/** Known values of {@link HttpCorrelationProtocol} that the service accepts. */
exports.KnownHttpCorrelationProtocol = void 0;
(function (KnownHttpCorrelationProtocol) {
    /** Do not read and inject correlation headers. */
    KnownHttpCorrelationProtocol["None"] = "None";
    /** Inject Request-Id and Request-Context headers with request correlation data. See https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/HttpCorrelationProtocol.md. */
    KnownHttpCorrelationProtocol["Legacy"] = "Legacy";
    /** Inject Trace Context headers. See https://w3c.github.io/trace-context. */
    KnownHttpCorrelationProtocol["W3C"] = "W3C";
})(exports.KnownHttpCorrelationProtocol || (exports.KnownHttpCorrelationProtocol = {}));
/** Known values of {@link Verbosity} that the service accepts. */
exports.KnownVerbosity = void 0;
(function (KnownVerbosity) {
    /** All the traces emitted by trace policies will be sent to the logger attached to this diagnostic instance. */
    KnownVerbosity["Verbose"] = "verbose";
    /** Traces with 'severity' set to 'information' and 'error' will be sent to the logger attached to this diagnostic instance. */
    KnownVerbosity["Information"] = "information";
    /** Only traces with 'severity' set to 'error' will be sent to the logger attached to this diagnostic instance. */
    KnownVerbosity["Error"] = "error";
})(exports.KnownVerbosity || (exports.KnownVerbosity = {}));
/** Known values of {@link OperationNameFormat} that the service accepts. */
exports.KnownOperationNameFormat = void 0;
(function (KnownOperationNameFormat) {
    /** API_NAME;rev=API_REVISION - OPERATION_NAME */
    KnownOperationNameFormat["Name"] = "Name";
    /** HTTP_VERB URL */
    KnownOperationNameFormat["Url"] = "Url";
})(exports.KnownOperationNameFormat || (exports.KnownOperationNameFormat = {}));
/** Known values of {@link State} that the service accepts. */
exports.KnownState = void 0;
(function (KnownState) {
    /** The issue is proposed. */
    KnownState["Proposed"] = "proposed";
    /** The issue is opened. */
    KnownState["Open"] = "open";
    /** The issue was removed. */
    KnownState["Removed"] = "removed";
    /** The issue is now resolved. */
    KnownState["Resolved"] = "resolved";
    /** The issue was closed. */
    KnownState["Closed"] = "closed";
})(exports.KnownState || (exports.KnownState = {}));
/** Known values of {@link ExportFormat} that the service accepts. */
exports.KnownExportFormat = void 0;
(function (KnownExportFormat) {
    /** Export the Api Definition in OpenAPI 2.0 Specification as JSON document to the Storage Blob. */
    KnownExportFormat["Swagger"] = "swagger-link";
    /** Export the Api Definition in WSDL Schema to Storage Blob. This is only supported for APIs of Type `soap` */
    KnownExportFormat["Wsdl"] = "wsdl-link";
    /** Export the Api Definition in WADL Schema to Storage Blob. */
    KnownExportFormat["Wadl"] = "wadl-link";
    /** Export the Api Definition in OpenAPI 3.0 Specification as YAML document to Storage Blob. */
    KnownExportFormat["Openapi"] = "openapi-link";
    /** Export the Api Definition in OpenAPI 3.0 Specification as JSON document to Storage Blob. */
    KnownExportFormat["OpenapiJson"] = "openapi+json-link";
})(exports.KnownExportFormat || (exports.KnownExportFormat = {}));
/** Known values of {@link ExportApi} that the service accepts. */
exports.KnownExportApi = void 0;
(function (KnownExportApi) {
    /** True */
    KnownExportApi["True"] = "true";
})(exports.KnownExportApi || (exports.KnownExportApi = {}));
/** Known values of {@link ExportResultFormat} that the service accepts. */
exports.KnownExportResultFormat = void 0;
(function (KnownExportResultFormat) {
    /** The API Definition is exported in OpenAPI Specification 2.0 format to the Storage Blob. */
    KnownExportResultFormat["Swagger"] = "swagger-link-json";
    /** The API Definition is exported in WSDL Schema to Storage Blob. This is only supported for APIs of Type `soap` */
    KnownExportResultFormat["Wsdl"] = "wsdl-link+xml";
    /** Export the API Definition in WADL Schema to Storage Blob. */
    KnownExportResultFormat["Wadl"] = "wadl-link-json";
    /** Export the API Definition in OpenAPI Specification 3.0 to Storage Blob. */
    KnownExportResultFormat["OpenApi"] = "openapi-link";
})(exports.KnownExportResultFormat || (exports.KnownExportResultFormat = {}));
/** Known values of {@link VersioningScheme} that the service accepts. */
exports.KnownVersioningScheme = void 0;
(function (KnownVersioningScheme) {
    /** The API Version is passed in a path segment. */
    KnownVersioningScheme["Segment"] = "Segment";
    /** The API Version is passed in a query parameter. */
    KnownVersioningScheme["Query"] = "Query";
    /** The API Version is passed in a HTTP header. */
    KnownVersioningScheme["Header"] = "Header";
})(exports.KnownVersioningScheme || (exports.KnownVersioningScheme = {}));
/** Known values of {@link GrantType} that the service accepts. */
exports.KnownGrantType = void 0;
(function (KnownGrantType) {
    /** Authorization Code Grant flow as described https://tools.ietf.org/html/rfc6749#section-4.1. */
    KnownGrantType["AuthorizationCode"] = "authorizationCode";
    /** Implicit Code Grant flow as described https://tools.ietf.org/html/rfc6749#section-4.2. */
    KnownGrantType["Implicit"] = "implicit";
    /** Resource Owner Password Grant flow as described https://tools.ietf.org/html/rfc6749#section-4.3. */
    KnownGrantType["ResourceOwnerPassword"] = "resourceOwnerPassword";
    /** Client Credentials Grant flow as described https://tools.ietf.org/html/rfc6749#section-4.4. */
    KnownGrantType["ClientCredentials"] = "clientCredentials";
})(exports.KnownGrantType || (exports.KnownGrantType = {}));
/** Known values of {@link ClientAuthenticationMethod} that the service accepts. */
exports.KnownClientAuthenticationMethod = void 0;
(function (KnownClientAuthenticationMethod) {
    /** Basic Client Authentication method. */
    KnownClientAuthenticationMethod["Basic"] = "Basic";
    /** Body based Authentication method. */
    KnownClientAuthenticationMethod["Body"] = "Body";
})(exports.KnownClientAuthenticationMethod || (exports.KnownClientAuthenticationMethod = {}));
/** Known values of {@link BearerTokenSendingMethod} that the service accepts. */
exports.KnownBearerTokenSendingMethod = void 0;
(function (KnownBearerTokenSendingMethod) {
    /** AuthorizationHeader */
    KnownBearerTokenSendingMethod["AuthorizationHeader"] = "authorizationHeader";
    /** Query */
    KnownBearerTokenSendingMethod["Query"] = "query";
})(exports.KnownBearerTokenSendingMethod || (exports.KnownBearerTokenSendingMethod = {}));
/** Known values of {@link BackendProtocol} that the service accepts. */
exports.KnownBackendProtocol = void 0;
(function (KnownBackendProtocol) {
    /** The Backend is a RESTful service. */
    KnownBackendProtocol["Http"] = "http";
    /** The Backend is a SOAP service. */
    KnownBackendProtocol["Soap"] = "soap";
})(exports.KnownBackendProtocol || (exports.KnownBackendProtocol = {}));
/** Known values of {@link PreferredIPVersion} that the service accepts. */
exports.KnownPreferredIPVersion = void 0;
(function (KnownPreferredIPVersion) {
    /** IPv4 */
    KnownPreferredIPVersion["IPv4"] = "IPv4";
})(exports.KnownPreferredIPVersion || (exports.KnownPreferredIPVersion = {}));
/** Known values of {@link ConnectivityCheckProtocol} that the service accepts. */
exports.KnownConnectivityCheckProtocol = void 0;
(function (KnownConnectivityCheckProtocol) {
    /** TCP */
    KnownConnectivityCheckProtocol["TCP"] = "TCP";
    /** Http */
    KnownConnectivityCheckProtocol["Http"] = "HTTP";
    /** Https */
    KnownConnectivityCheckProtocol["Https"] = "HTTPS";
})(exports.KnownConnectivityCheckProtocol || (exports.KnownConnectivityCheckProtocol = {}));
/** Known values of {@link Method} that the service accepts. */
exports.KnownMethod = void 0;
(function (KnownMethod) {
    /** GET */
    KnownMethod["GET"] = "GET";
    /** Post */
    KnownMethod["Post"] = "POST";
})(exports.KnownMethod || (exports.KnownMethod = {}));
/** Known values of {@link Origin} that the service accepts. */
exports.KnownOrigin = void 0;
(function (KnownOrigin) {
    /** Local */
    KnownOrigin["Local"] = "Local";
    /** Inbound */
    KnownOrigin["Inbound"] = "Inbound";
    /** Outbound */
    KnownOrigin["Outbound"] = "Outbound";
})(exports.KnownOrigin || (exports.KnownOrigin = {}));
/** Known values of {@link Severity} that the service accepts. */
exports.KnownSeverity = void 0;
(function (KnownSeverity) {
    /** Error */
    KnownSeverity["Error"] = "Error";
    /** Warning */
    KnownSeverity["Warning"] = "Warning";
})(exports.KnownSeverity || (exports.KnownSeverity = {}));
/** Known values of {@link IssueType} that the service accepts. */
exports.KnownIssueType = void 0;
(function (KnownIssueType) {
    /** Unknown */
    KnownIssueType["Unknown"] = "Unknown";
    /** AgentStopped */
    KnownIssueType["AgentStopped"] = "AgentStopped";
    /** GuestFirewall */
    KnownIssueType["GuestFirewall"] = "GuestFirewall";
    /** DnsResolution */
    KnownIssueType["DnsResolution"] = "DnsResolution";
    /** SocketBind */
    KnownIssueType["SocketBind"] = "SocketBind";
    /** NetworkSecurityRule */
    KnownIssueType["NetworkSecurityRule"] = "NetworkSecurityRule";
    /** UserDefinedRoute */
    KnownIssueType["UserDefinedRoute"] = "UserDefinedRoute";
    /** PortThrottled */
    KnownIssueType["PortThrottled"] = "PortThrottled";
    /** Platform */
    KnownIssueType["Platform"] = "Platform";
})(exports.KnownIssueType || (exports.KnownIssueType = {}));
/** Known values of {@link ConnectionStatus} that the service accepts. */
exports.KnownConnectionStatus = void 0;
(function (KnownConnectionStatus) {
    /** Unknown */
    KnownConnectionStatus["Unknown"] = "Unknown";
    /** Connected */
    KnownConnectionStatus["Connected"] = "Connected";
    /** Disconnected */
    KnownConnectionStatus["Disconnected"] = "Disconnected";
    /** Degraded */
    KnownConnectionStatus["Degraded"] = "Degraded";
})(exports.KnownConnectionStatus || (exports.KnownConnectionStatus = {}));
/** Known values of {@link SkuType} that the service accepts. */
exports.KnownSkuType = void 0;
(function (KnownSkuType) {
    /** Developer SKU of Api Management. */
    KnownSkuType["Developer"] = "Developer";
    /** Standard SKU of Api Management. */
    KnownSkuType["Standard"] = "Standard";
    /** Premium SKU of Api Management. */
    KnownSkuType["Premium"] = "Premium";
    /** Basic SKU of Api Management. */
    KnownSkuType["Basic"] = "Basic";
    /** Consumption SKU of Api Management. */
    KnownSkuType["Consumption"] = "Consumption";
    /** Isolated SKU of Api Management. */
    KnownSkuType["Isolated"] = "Isolated";
})(exports.KnownSkuType || (exports.KnownSkuType = {}));
/** Known values of {@link ResourceSkuCapacityScaleType} that the service accepts. */
exports.KnownResourceSkuCapacityScaleType = void 0;
(function (KnownResourceSkuCapacityScaleType) {
    /** Supported scale type automatic. */
    KnownResourceSkuCapacityScaleType["Automatic"] = "automatic";
    /** Supported scale type manual. */
    KnownResourceSkuCapacityScaleType["Manual"] = "manual";
    /** Scaling not supported. */
    KnownResourceSkuCapacityScaleType["None"] = "none";
})(exports.KnownResourceSkuCapacityScaleType || (exports.KnownResourceSkuCapacityScaleType = {}));
/** Known values of {@link AccessType} that the service accepts. */
exports.KnownAccessType = void 0;
(function (KnownAccessType) {
    /** Use access key. */
    KnownAccessType["AccessKey"] = "AccessKey";
    /** Use system assigned managed identity. */
    KnownAccessType["SystemAssignedManagedIdentity"] = "SystemAssignedManagedIdentity";
    /** Use user assigned managed identity. */
    KnownAccessType["UserAssignedManagedIdentity"] = "UserAssignedManagedIdentity";
})(exports.KnownAccessType || (exports.KnownAccessType = {}));
/** Known values of {@link HostnameType} that the service accepts. */
exports.KnownHostnameType = void 0;
(function (KnownHostnameType) {
    /** Proxy */
    KnownHostnameType["Proxy"] = "Proxy";
    /** Portal */
    KnownHostnameType["Portal"] = "Portal";
    /** Management */
    KnownHostnameType["Management"] = "Management";
    /** Scm */
    KnownHostnameType["Scm"] = "Scm";
    /** DeveloperPortal */
    KnownHostnameType["DeveloperPortal"] = "DeveloperPortal";
})(exports.KnownHostnameType || (exports.KnownHostnameType = {}));
/** Known values of {@link CertificateSource} that the service accepts. */
exports.KnownCertificateSource = void 0;
(function (KnownCertificateSource) {
    /** Managed */
    KnownCertificateSource["Managed"] = "Managed";
    /** KeyVault */
    KnownCertificateSource["KeyVault"] = "KeyVault";
    /** Custom */
    KnownCertificateSource["Custom"] = "Custom";
    /** BuiltIn */
    KnownCertificateSource["BuiltIn"] = "BuiltIn";
})(exports.KnownCertificateSource || (exports.KnownCertificateSource = {}));
/** Known values of {@link CertificateStatus} that the service accepts. */
exports.KnownCertificateStatus = void 0;
(function (KnownCertificateStatus) {
    /** Completed */
    KnownCertificateStatus["Completed"] = "Completed";
    /** Failed */
    KnownCertificateStatus["Failed"] = "Failed";
    /** InProgress */
    KnownCertificateStatus["InProgress"] = "InProgress";
})(exports.KnownCertificateStatus || (exports.KnownCertificateStatus = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
exports.KnownPublicNetworkAccess = void 0;
(function (KnownPublicNetworkAccess) {
    /** Enabled */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = {}));
/** Known values of {@link PlatformVersion} that the service accepts. */
exports.KnownPlatformVersion = void 0;
(function (KnownPlatformVersion) {
    /** Platform version cannot be determined, as compute platform is not deployed. */
    KnownPlatformVersion["Undetermined"] = "undetermined";
    /** Platform running the service on Single Tenant V1 platform. */
    KnownPlatformVersion["Stv1"] = "stv1";
    /** Platform running the service on Single Tenant V2 platform. */
    KnownPlatformVersion["Stv2"] = "stv2";
    /** Platform running the service on Multi Tenant V1 platform. */
    KnownPlatformVersion["Mtv1"] = "mtv1";
})(exports.KnownPlatformVersion || (exports.KnownPlatformVersion = {}));
/** Known values of {@link CertificateConfigurationStoreName} that the service accepts. */
exports.KnownCertificateConfigurationStoreName = void 0;
(function (KnownCertificateConfigurationStoreName) {
    /** CertificateAuthority */
    KnownCertificateConfigurationStoreName["CertificateAuthority"] = "CertificateAuthority";
    /** Root */
    KnownCertificateConfigurationStoreName["Root"] = "Root";
})(exports.KnownCertificateConfigurationStoreName || (exports.KnownCertificateConfigurationStoreName = {}));
/** Known values of {@link VirtualNetworkType} that the service accepts. */
exports.KnownVirtualNetworkType = void 0;
(function (KnownVirtualNetworkType) {
    /** The service is not part of any Virtual Network. */
    KnownVirtualNetworkType["None"] = "None";
    /** The service is part of Virtual Network and it is accessible from Internet. */
    KnownVirtualNetworkType["External"] = "External";
    /** The service is part of Virtual Network and it is only accessible from within the virtual network. */
    KnownVirtualNetworkType["Internal"] = "Internal";
})(exports.KnownVirtualNetworkType || (exports.KnownVirtualNetworkType = {}));
/** Known values of {@link PrivateEndpointServiceConnectionStatus} that the service accepts. */
exports.KnownPrivateEndpointServiceConnectionStatus = void 0;
(function (KnownPrivateEndpointServiceConnectionStatus) {
    /** Pending */
    KnownPrivateEndpointServiceConnectionStatus["Pending"] = "Pending";
    /** Approved */
    KnownPrivateEndpointServiceConnectionStatus["Approved"] = "Approved";
    /** Rejected */
    KnownPrivateEndpointServiceConnectionStatus["Rejected"] = "Rejected";
})(exports.KnownPrivateEndpointServiceConnectionStatus || (exports.KnownPrivateEndpointServiceConnectionStatus = {}));
/** Known values of {@link ApimIdentityType} that the service accepts. */
exports.KnownApimIdentityType = void 0;
(function (KnownApimIdentityType) {
    /** SystemAssigned */
    KnownApimIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownApimIdentityType["UserAssigned"] = "UserAssigned";
    /** SystemAssignedUserAssigned */
    KnownApimIdentityType["SystemAssignedUserAssigned"] = "SystemAssigned, UserAssigned";
    /** None */
    KnownApimIdentityType["None"] = "None";
})(exports.KnownApimIdentityType || (exports.KnownApimIdentityType = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link TemplateName} that the service accepts. */
exports.KnownTemplateName = void 0;
(function (KnownTemplateName) {
    /** ApplicationApprovedNotificationMessage */
    KnownTemplateName["ApplicationApprovedNotificationMessage"] = "applicationApprovedNotificationMessage";
    /** AccountClosedDeveloper */
    KnownTemplateName["AccountClosedDeveloper"] = "accountClosedDeveloper";
    /** QuotaLimitApproachingDeveloperNotificationMessage */
    KnownTemplateName["QuotaLimitApproachingDeveloperNotificationMessage"] = "quotaLimitApproachingDeveloperNotificationMessage";
    /** NewDeveloperNotificationMessage */
    KnownTemplateName["NewDeveloperNotificationMessage"] = "newDeveloperNotificationMessage";
    /** EmailChangeIdentityDefault */
    KnownTemplateName["EmailChangeIdentityDefault"] = "emailChangeIdentityDefault";
    /** InviteUserNotificationMessage */
    KnownTemplateName["InviteUserNotificationMessage"] = "inviteUserNotificationMessage";
    /** NewCommentNotificationMessage */
    KnownTemplateName["NewCommentNotificationMessage"] = "newCommentNotificationMessage";
    /** ConfirmSignUpIdentityDefault */
    KnownTemplateName["ConfirmSignUpIdentityDefault"] = "confirmSignUpIdentityDefault";
    /** NewIssueNotificationMessage */
    KnownTemplateName["NewIssueNotificationMessage"] = "newIssueNotificationMessage";
    /** PurchaseDeveloperNotificationMessage */
    KnownTemplateName["PurchaseDeveloperNotificationMessage"] = "purchaseDeveloperNotificationMessage";
    /** PasswordResetIdentityDefault */
    KnownTemplateName["PasswordResetIdentityDefault"] = "passwordResetIdentityDefault";
    /** PasswordResetByAdminNotificationMessage */
    KnownTemplateName["PasswordResetByAdminNotificationMessage"] = "passwordResetByAdminNotificationMessage";
    /** RejectDeveloperNotificationMessage */
    KnownTemplateName["RejectDeveloperNotificationMessage"] = "rejectDeveloperNotificationMessage";
    /** RequestDeveloperNotificationMessage */
    KnownTemplateName["RequestDeveloperNotificationMessage"] = "requestDeveloperNotificationMessage";
})(exports.KnownTemplateName || (exports.KnownTemplateName = {}));
/** Known values of {@link UserState} that the service accepts. */
exports.KnownUserState = void 0;
(function (KnownUserState) {
    /** User state is active. */
    KnownUserState["Active"] = "active";
    /** User is blocked. Blocked users cannot authenticate at developer portal or call API. */
    KnownUserState["Blocked"] = "blocked";
    /** User account is pending. Requires identity confirmation before it can be made active. */
    KnownUserState["Pending"] = "pending";
    /** User account is closed. All identities and related entities are removed. */
    KnownUserState["Deleted"] = "deleted";
})(exports.KnownUserState || (exports.KnownUserState = {}));
/** Known values of {@link IdentityProviderType} that the service accepts. */
exports.KnownIdentityProviderType = void 0;
(function (KnownIdentityProviderType) {
    /** Facebook as Identity provider. */
    KnownIdentityProviderType["Facebook"] = "facebook";
    /** Google as Identity provider. */
    KnownIdentityProviderType["Google"] = "google";
    /** Microsoft Live as Identity provider. */
    KnownIdentityProviderType["Microsoft"] = "microsoft";
    /** Twitter as Identity provider. */
    KnownIdentityProviderType["Twitter"] = "twitter";
    /** Azure Active Directory as Identity provider. */
    KnownIdentityProviderType["Aad"] = "aad";
    /** Azure Active Directory B2C as Identity provider. */
    KnownIdentityProviderType["AadB2C"] = "aadB2C";
})(exports.KnownIdentityProviderType || (exports.KnownIdentityProviderType = {}));
/** Known values of {@link LoggerType} that the service accepts. */
exports.KnownLoggerType = void 0;
(function (KnownLoggerType) {
    /** Azure Event Hub as log destination. */
    KnownLoggerType["AzureEventHub"] = "azureEventHub";
    /** Azure Application Insights as log destination. */
    KnownLoggerType["ApplicationInsights"] = "applicationInsights";
    /** Azure Monitor */
    KnownLoggerType["AzureMonitor"] = "azureMonitor";
})(exports.KnownLoggerType || (exports.KnownLoggerType = {}));
/** Known values of {@link ConnectivityStatusType} that the service accepts. */
exports.KnownConnectivityStatusType = void 0;
(function (KnownConnectivityStatusType) {
    /** Initializing */
    KnownConnectivityStatusType["Initializing"] = "initializing";
    /** Success */
    KnownConnectivityStatusType["Success"] = "success";
    /** Failure */
    KnownConnectivityStatusType["Failure"] = "failure";
})(exports.KnownConnectivityStatusType || (exports.KnownConnectivityStatusType = {}));
/** Known values of {@link NotificationName} that the service accepts. */
exports.KnownNotificationName = void 0;
(function (KnownNotificationName) {
    /** The following email recipients and users will receive email notifications about subscription requests for API products requiring approval. */
    KnownNotificationName["RequestPublisherNotificationMessage"] = "RequestPublisherNotificationMessage";
    /** The following email recipients and users will receive email notifications about new API product subscriptions. */
    KnownNotificationName["PurchasePublisherNotificationMessage"] = "PurchasePublisherNotificationMessage";
    /** The following email recipients and users will receive email notifications when new applications are submitted to the application gallery. */
    KnownNotificationName["NewApplicationNotificationMessage"] = "NewApplicationNotificationMessage";
    /** The following recipients will receive blind carbon copies of all emails sent to developers. */
    KnownNotificationName["BCC"] = "BCC";
    /** The following email recipients and users will receive email notifications when a new issue or comment is submitted on the developer portal. */
    KnownNotificationName["NewIssuePublisherNotificationMessage"] = "NewIssuePublisherNotificationMessage";
    /** The following email recipients and users will receive email notifications when developer closes his account. */
    KnownNotificationName["AccountClosedPublisher"] = "AccountClosedPublisher";
    /** The following email recipients and users will receive email notifications when subscription usage gets close to usage quota. */
    KnownNotificationName["QuotaLimitApproachingPublisherNotificationMessage"] = "QuotaLimitApproachingPublisherNotificationMessage";
})(exports.KnownNotificationName || (exports.KnownNotificationName = {}));
/** Known values of {@link PortalRevisionStatus} that the service accepts. */
exports.KnownPortalRevisionStatus = void 0;
(function (KnownPortalRevisionStatus) {
    /** Portal's revision has been queued. */
    KnownPortalRevisionStatus["Pending"] = "pending";
    /** Portal's revision is being published. */
    KnownPortalRevisionStatus["Publishing"] = "publishing";
    /** Portal's revision publishing completed. */
    KnownPortalRevisionStatus["Completed"] = "completed";
    /** Portal's revision publishing failed. */
    KnownPortalRevisionStatus["Failed"] = "failed";
})(exports.KnownPortalRevisionStatus || (exports.KnownPortalRevisionStatus = {}));
/** Known values of {@link PrivateEndpointConnectionProvisioningState} that the service accepts. */
exports.KnownPrivateEndpointConnectionProvisioningState = void 0;
(function (KnownPrivateEndpointConnectionProvisioningState) {
    /** Succeeded */
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
    /** Creating */
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
})(exports.KnownPrivateEndpointConnectionProvisioningState || (exports.KnownPrivateEndpointConnectionProvisioningState = {}));
/** Known values of {@link SettingsTypeName} that the service accepts. */
exports.KnownSettingsTypeName = void 0;
(function (KnownSettingsTypeName) {
    /** Public */
    KnownSettingsTypeName["Public"] = "public";
})(exports.KnownSettingsTypeName || (exports.KnownSettingsTypeName = {}));
/** Known values of {@link AppType} that the service accepts. */
exports.KnownAppType = void 0;
(function (KnownAppType) {
    /** User create request was sent by legacy developer portal. */
    KnownAppType["Portal"] = "portal";
    /** User create request was sent by new developer portal. */
    KnownAppType["DeveloperPortal"] = "developerPortal";
})(exports.KnownAppType || (exports.KnownAppType = {}));
/** Known values of {@link AccessIdName} that the service accepts. */
exports.KnownAccessIdName = void 0;
(function (KnownAccessIdName) {
    /** Access */
    KnownAccessIdName["Access"] = "access";
    /** GitAccess */
    KnownAccessIdName["GitAccess"] = "gitAccess";
})(exports.KnownAccessIdName || (exports.KnownAccessIdName = {}));
/** Known values of {@link ConfigurationIdName} that the service accepts. */
exports.KnownConfigurationIdName = void 0;
(function (KnownConfigurationIdName) {
    /** Configuration */
    KnownConfigurationIdName["Configuration"] = "configuration";
})(exports.KnownConfigurationIdName || (exports.KnownConfigurationIdName = {}));
/** Known values of {@link Confirmation} that the service accepts. */
exports.KnownConfirmation = void 0;
(function (KnownConfirmation) {
    /** Send an e-mail to the user confirming they have successfully signed up. */
    KnownConfirmation["Signup"] = "signup";
    /** Send an e-mail inviting the user to sign-up and complete registration. */
    KnownConfirmation["Invite"] = "invite";
})(exports.KnownConfirmation || (exports.KnownConfirmation = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ApiCollection = {
    serializedName: "ApiCollection",
    type: {
        name: "Composite",
        className: "ApiCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "ApiContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiVersionSetContractDetails = {
    serializedName: "ApiVersionSetContractDetails",
    type: {
        name: "Composite",
        className: "ApiVersionSetContractDetails",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            versioningScheme: {
                serializedName: "versioningScheme",
                xmlName: "versioningScheme",
                type: {
                    name: "String"
                }
            },
            versionQueryName: {
                serializedName: "versionQueryName",
                xmlName: "versionQueryName",
                type: {
                    name: "String"
                }
            },
            versionHeaderName: {
                serializedName: "versionHeaderName",
                xmlName: "versionHeaderName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiEntityBaseContract = {
    serializedName: "ApiEntityBaseContract",
    type: {
        name: "Composite",
        className: "ApiEntityBaseContract",
        modelProperties: {
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            authenticationSettings: {
                serializedName: "authenticationSettings",
                xmlName: "authenticationSettings",
                type: {
                    name: "Composite",
                    className: "AuthenticationSettingsContract"
                }
            },
            subscriptionKeyParameterNames: {
                serializedName: "subscriptionKeyParameterNames",
                xmlName: "subscriptionKeyParameterNames",
                type: {
                    name: "Composite",
                    className: "SubscriptionKeyParameterNamesContract"
                }
            },
            apiType: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            apiRevision: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "apiRevision",
                xmlName: "apiRevision",
                type: {
                    name: "String"
                }
            },
            apiVersion: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "apiVersion",
                xmlName: "apiVersion",
                type: {
                    name: "String"
                }
            },
            isCurrent: {
                serializedName: "isCurrent",
                xmlName: "isCurrent",
                type: {
                    name: "Boolean"
                }
            },
            isOnline: {
                serializedName: "isOnline",
                readOnly: true,
                xmlName: "isOnline",
                type: {
                    name: "Boolean"
                }
            },
            apiRevisionDescription: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "apiRevisionDescription",
                xmlName: "apiRevisionDescription",
                type: {
                    name: "String"
                }
            },
            apiVersionDescription: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "apiVersionDescription",
                xmlName: "apiVersionDescription",
                type: {
                    name: "String"
                }
            },
            apiVersionSetId: {
                serializedName: "apiVersionSetId",
                xmlName: "apiVersionSetId",
                type: {
                    name: "String"
                }
            },
            subscriptionRequired: {
                serializedName: "subscriptionRequired",
                xmlName: "subscriptionRequired",
                type: {
                    name: "Boolean"
                }
            },
            termsOfServiceUrl: {
                serializedName: "termsOfServiceUrl",
                xmlName: "termsOfServiceUrl",
                type: {
                    name: "String"
                }
            },
            contact: {
                serializedName: "contact",
                xmlName: "contact",
                type: {
                    name: "Composite",
                    className: "ApiContactInformation"
                }
            },
            license: {
                serializedName: "license",
                xmlName: "license",
                type: {
                    name: "Composite",
                    className: "ApiLicenseInformation"
                }
            }
        }
    }
};
const AuthenticationSettingsContract = {
    serializedName: "AuthenticationSettingsContract",
    type: {
        name: "Composite",
        className: "AuthenticationSettingsContract",
        modelProperties: {
            oAuth2: {
                serializedName: "oAuth2",
                xmlName: "oAuth2",
                type: {
                    name: "Composite",
                    className: "OAuth2AuthenticationSettingsContract"
                }
            },
            openid: {
                serializedName: "openid",
                xmlName: "openid",
                type: {
                    name: "Composite",
                    className: "OpenIdAuthenticationSettingsContract"
                }
            }
        }
    }
};
const OAuth2AuthenticationSettingsContract = {
    serializedName: "OAuth2AuthenticationSettingsContract",
    type: {
        name: "Composite",
        className: "OAuth2AuthenticationSettingsContract",
        modelProperties: {
            authorizationServerId: {
                serializedName: "authorizationServerId",
                xmlName: "authorizationServerId",
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "scope",
                xmlName: "scope",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenIdAuthenticationSettingsContract = {
    serializedName: "OpenIdAuthenticationSettingsContract",
    type: {
        name: "Composite",
        className: "OpenIdAuthenticationSettingsContract",
        modelProperties: {
            openidProviderId: {
                serializedName: "openidProviderId",
                xmlName: "openidProviderId",
                type: {
                    name: "String"
                }
            },
            bearerTokenSendingMethods: {
                serializedName: "bearerTokenSendingMethods",
                xmlName: "bearerTokenSendingMethods",
                xmlElementName: "BearerTokenSendingMethods",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const SubscriptionKeyParameterNamesContract = {
    serializedName: "SubscriptionKeyParameterNamesContract",
    type: {
        name: "Composite",
        className: "SubscriptionKeyParameterNamesContract",
        modelProperties: {
            header: {
                serializedName: "header",
                xmlName: "header",
                type: {
                    name: "String"
                }
            },
            query: {
                serializedName: "query",
                xmlName: "query",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiContactInformation = {
    serializedName: "ApiContactInformation",
    type: {
        name: "Composite",
        className: "ApiContactInformation",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                xmlName: "url",
                type: {
                    name: "String"
                }
            },
            email: {
                serializedName: "email",
                xmlName: "email",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiLicenseInformation = {
    serializedName: "ApiLicenseInformation",
    type: {
        name: "Composite",
        className: "ApiLicenseInformation",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                xmlName: "url",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    serializedName: "Resource",
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    serializedName: "ErrorResponse",
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            code: {
                serializedName: "error.code",
                xmlName: "error.code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "error.message",
                xmlName: "error.message",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "error.details",
                xmlName: "error.details",
                xmlElementName: "ErrorFieldContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorFieldContract"
                        }
                    }
                }
            }
        }
    }
};
const ErrorResponseBody = {
    serializedName: "ErrorResponseBody",
    type: {
        name: "Composite",
        className: "ErrorResponseBody",
        modelProperties: {
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                xmlName: "details",
                xmlElementName: "ErrorFieldContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorFieldContract"
                        }
                    }
                }
            }
        }
    }
};
const ErrorFieldContract = {
    serializedName: "ErrorFieldContract",
    type: {
        name: "Composite",
        className: "ErrorFieldContract",
        modelProperties: {
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                xmlName: "target",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiCreateOrUpdateParameter = {
    serializedName: "ApiCreateOrUpdateParameter",
    type: {
        name: "Composite",
        className: "ApiCreateOrUpdateParameter",
        modelProperties: {
            description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            authenticationSettings: {
                serializedName: "properties.authenticationSettings",
                xmlName: "properties.authenticationSettings",
                type: {
                    name: "Composite",
                    className: "AuthenticationSettingsContract"
                }
            },
            subscriptionKeyParameterNames: {
                serializedName: "properties.subscriptionKeyParameterNames",
                xmlName: "properties.subscriptionKeyParameterNames",
                type: {
                    name: "Composite",
                    className: "SubscriptionKeyParameterNamesContract"
                }
            },
            apiType: {
                serializedName: "properties.type",
                xmlName: "properties.type",
                type: {
                    name: "String"
                }
            },
            apiRevision: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.apiRevision",
                xmlName: "properties.apiRevision",
                type: {
                    name: "String"
                }
            },
            apiVersion: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "properties.apiVersion",
                xmlName: "properties.apiVersion",
                type: {
                    name: "String"
                }
            },
            isCurrent: {
                serializedName: "properties.isCurrent",
                xmlName: "properties.isCurrent",
                type: {
                    name: "Boolean"
                }
            },
            isOnline: {
                serializedName: "properties.isOnline",
                readOnly: true,
                xmlName: "properties.isOnline",
                type: {
                    name: "Boolean"
                }
            },
            apiRevisionDescription: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "properties.apiRevisionDescription",
                xmlName: "properties.apiRevisionDescription",
                type: {
                    name: "String"
                }
            },
            apiVersionDescription: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "properties.apiVersionDescription",
                xmlName: "properties.apiVersionDescription",
                type: {
                    name: "String"
                }
            },
            apiVersionSetId: {
                serializedName: "properties.apiVersionSetId",
                xmlName: "properties.apiVersionSetId",
                type: {
                    name: "String"
                }
            },
            subscriptionRequired: {
                serializedName: "properties.subscriptionRequired",
                xmlName: "properties.subscriptionRequired",
                type: {
                    name: "Boolean"
                }
            },
            termsOfServiceUrl: {
                serializedName: "properties.termsOfServiceUrl",
                xmlName: "properties.termsOfServiceUrl",
                type: {
                    name: "String"
                }
            },
            contact: {
                serializedName: "properties.contact",
                xmlName: "properties.contact",
                type: {
                    name: "Composite",
                    className: "ApiContactInformation"
                }
            },
            license: {
                serializedName: "properties.license",
                xmlName: "properties.license",
                type: {
                    name: "Composite",
                    className: "ApiLicenseInformation"
                }
            },
            sourceApiId: {
                serializedName: "properties.sourceApiId",
                xmlName: "properties.sourceApiId",
                type: {
                    name: "String"
                }
            },
            displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            serviceUrl: {
                constraints: {
                    MaxLength: 2000
                },
                serializedName: "properties.serviceUrl",
                xmlName: "properties.serviceUrl",
                type: {
                    name: "String"
                }
            },
            path: {
                constraints: {
                    MaxLength: 400
                },
                serializedName: "properties.path",
                xmlName: "properties.path",
                type: {
                    name: "String"
                }
            },
            protocols: {
                serializedName: "properties.protocols",
                xmlName: "properties.protocols",
                xmlElementName: "Protocol",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            apiVersionSet: {
                serializedName: "properties.apiVersionSet",
                xmlName: "properties.apiVersionSet",
                type: {
                    name: "Composite",
                    className: "ApiVersionSetContractDetails"
                }
            },
            value: {
                serializedName: "properties.value",
                xmlName: "properties.value",
                type: {
                    name: "String"
                }
            },
            format: {
                serializedName: "properties.format",
                xmlName: "properties.format",
                type: {
                    name: "String"
                }
            },
            wsdlSelector: {
                serializedName: "properties.wsdlSelector",
                xmlName: "properties.wsdlSelector",
                type: {
                    name: "Composite",
                    className: "ApiCreateOrUpdatePropertiesWsdlSelector"
                }
            },
            soapApiType: {
                serializedName: "properties.apiType",
                xmlName: "properties.apiType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiCreateOrUpdatePropertiesWsdlSelector = {
    serializedName: "ApiCreateOrUpdatePropertiesWsdlSelector",
    type: {
        name: "Composite",
        className: "ApiCreateOrUpdatePropertiesWsdlSelector",
        modelProperties: {
            wsdlServiceName: {
                serializedName: "wsdlServiceName",
                xmlName: "wsdlServiceName",
                type: {
                    name: "String"
                }
            },
            wsdlEndpointName: {
                serializedName: "wsdlEndpointName",
                xmlName: "wsdlEndpointName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiUpdateContract = {
    serializedName: "ApiUpdateContract",
    type: {
        name: "Composite",
        className: "ApiUpdateContract",
        modelProperties: {
            description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            authenticationSettings: {
                serializedName: "properties.authenticationSettings",
                xmlName: "properties.authenticationSettings",
                type: {
                    name: "Composite",
                    className: "AuthenticationSettingsContract"
                }
            },
            subscriptionKeyParameterNames: {
                serializedName: "properties.subscriptionKeyParameterNames",
                xmlName: "properties.subscriptionKeyParameterNames",
                type: {
                    name: "Composite",
                    className: "SubscriptionKeyParameterNamesContract"
                }
            },
            apiType: {
                serializedName: "properties.type",
                xmlName: "properties.type",
                type: {
                    name: "String"
                }
            },
            apiRevision: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.apiRevision",
                xmlName: "properties.apiRevision",
                type: {
                    name: "String"
                }
            },
            apiVersion: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "properties.apiVersion",
                xmlName: "properties.apiVersion",
                type: {
                    name: "String"
                }
            },
            isCurrent: {
                serializedName: "properties.isCurrent",
                xmlName: "properties.isCurrent",
                type: {
                    name: "Boolean"
                }
            },
            isOnline: {
                serializedName: "properties.isOnline",
                readOnly: true,
                xmlName: "properties.isOnline",
                type: {
                    name: "Boolean"
                }
            },
            apiRevisionDescription: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "properties.apiRevisionDescription",
                xmlName: "properties.apiRevisionDescription",
                type: {
                    name: "String"
                }
            },
            apiVersionDescription: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "properties.apiVersionDescription",
                xmlName: "properties.apiVersionDescription",
                type: {
                    name: "String"
                }
            },
            apiVersionSetId: {
                serializedName: "properties.apiVersionSetId",
                xmlName: "properties.apiVersionSetId",
                type: {
                    name: "String"
                }
            },
            subscriptionRequired: {
                serializedName: "properties.subscriptionRequired",
                xmlName: "properties.subscriptionRequired",
                type: {
                    name: "Boolean"
                }
            },
            termsOfServiceUrl: {
                serializedName: "properties.termsOfServiceUrl",
                xmlName: "properties.termsOfServiceUrl",
                type: {
                    name: "String"
                }
            },
            contact: {
                serializedName: "properties.contact",
                xmlName: "properties.contact",
                type: {
                    name: "Composite",
                    className: "ApiContactInformation"
                }
            },
            license: {
                serializedName: "properties.license",
                xmlName: "properties.license",
                type: {
                    name: "Composite",
                    className: "ApiLicenseInformation"
                }
            },
            displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            serviceUrl: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "properties.serviceUrl",
                xmlName: "properties.serviceUrl",
                type: {
                    name: "String"
                }
            },
            path: {
                constraints: {
                    MaxLength: 400
                },
                serializedName: "properties.path",
                xmlName: "properties.path",
                type: {
                    name: "String"
                }
            },
            protocols: {
                serializedName: "properties.protocols",
                xmlName: "properties.protocols",
                xmlElementName: "Protocol",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ApiRevisionCollection = {
    serializedName: "ApiRevisionCollection",
    type: {
        name: "Composite",
        className: "ApiRevisionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "ApiRevisionContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiRevisionContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiRevisionContract = {
    serializedName: "ApiRevisionContract",
    type: {
        name: "Composite",
        className: "ApiRevisionContract",
        modelProperties: {
            apiId: {
                serializedName: "apiId",
                readOnly: true,
                xmlName: "apiId",
                type: {
                    name: "String"
                }
            },
            apiRevision: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "apiRevision",
                readOnly: true,
                xmlName: "apiRevision",
                type: {
                    name: "String"
                }
            },
            createdDateTime: {
                serializedName: "createdDateTime",
                readOnly: true,
                xmlName: "createdDateTime",
                type: {
                    name: "DateTime"
                }
            },
            updatedDateTime: {
                serializedName: "updatedDateTime",
                readOnly: true,
                xmlName: "updatedDateTime",
                type: {
                    name: "DateTime"
                }
            },
            description: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "description",
                readOnly: true,
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            privateUrl: {
                serializedName: "privateUrl",
                readOnly: true,
                xmlName: "privateUrl",
                type: {
                    name: "String"
                }
            },
            isOnline: {
                serializedName: "isOnline",
                readOnly: true,
                xmlName: "isOnline",
                type: {
                    name: "Boolean"
                }
            },
            isCurrent: {
                serializedName: "isCurrent",
                readOnly: true,
                xmlName: "isCurrent",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ApiReleaseCollection = {
    serializedName: "ApiReleaseCollection",
    type: {
        name: "Composite",
        className: "ApiReleaseCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "ApiReleaseContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiReleaseContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationCollection = {
    serializedName: "OperationCollection",
    type: {
        name: "Composite",
        className: "OperationCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "OperationContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationEntityBaseContract = {
    serializedName: "OperationEntityBaseContract",
    type: {
        name: "Composite",
        className: "OperationEntityBaseContract",
        modelProperties: {
            templateParameters: {
                serializedName: "templateParameters",
                xmlName: "templateParameters",
                xmlElementName: "ParameterContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterContract"
                        }
                    }
                }
            },
            description: {
                constraints: {
                    MaxLength: 1000
                },
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            request: {
                serializedName: "request",
                xmlName: "request",
                type: {
                    name: "Composite",
                    className: "RequestContract"
                }
            },
            responses: {
                serializedName: "responses",
                xmlName: "responses",
                xmlElementName: "ResponseContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResponseContract"
                        }
                    }
                }
            },
            policies: {
                serializedName: "policies",
                xmlName: "policies",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ParameterContract = {
    serializedName: "ParameterContract",
    type: {
        name: "Composite",
        className: "ParameterContract",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            defaultValue: {
                serializedName: "defaultValue",
                xmlName: "defaultValue",
                type: {
                    name: "String"
                }
            },
            required: {
                serializedName: "required",
                xmlName: "required",
                type: {
                    name: "Boolean"
                }
            },
            values: {
                serializedName: "values",
                xmlName: "values",
                xmlElementName: "ParameterContractValuesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            schemaId: {
                serializedName: "schemaId",
                xmlName: "schemaId",
                type: {
                    name: "String"
                }
            },
            typeName: {
                serializedName: "typeName",
                xmlName: "typeName",
                type: {
                    name: "String"
                }
            },
            examples: {
                serializedName: "examples",
                xmlName: "examples",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ParameterExampleContract" }
                    }
                }
            }
        }
    }
};
const ParameterExampleContract = {
    serializedName: "ParameterExampleContract",
    type: {
        name: "Composite",
        className: "ParameterExampleContract",
        modelProperties: {
            summary: {
                serializedName: "summary",
                xmlName: "summary",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "any"
                }
            },
            externalValue: {
                serializedName: "externalValue",
                xmlName: "externalValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RequestContract = {
    serializedName: "RequestContract",
    type: {
        name: "Composite",
        className: "RequestContract",
        modelProperties: {
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            queryParameters: {
                serializedName: "queryParameters",
                xmlName: "queryParameters",
                xmlElementName: "ParameterContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterContract"
                        }
                    }
                }
            },
            headers: {
                serializedName: "headers",
                xmlName: "headers",
                xmlElementName: "ParameterContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterContract"
                        }
                    }
                }
            },
            representations: {
                serializedName: "representations",
                xmlName: "representations",
                xmlElementName: "RepresentationContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RepresentationContract"
                        }
                    }
                }
            }
        }
    }
};
const RepresentationContract = {
    serializedName: "RepresentationContract",
    type: {
        name: "Composite",
        className: "RepresentationContract",
        modelProperties: {
            contentType: {
                serializedName: "contentType",
                required: true,
                xmlName: "contentType",
                type: {
                    name: "String"
                }
            },
            schemaId: {
                serializedName: "schemaId",
                xmlName: "schemaId",
                type: {
                    name: "String"
                }
            },
            typeName: {
                serializedName: "typeName",
                xmlName: "typeName",
                type: {
                    name: "String"
                }
            },
            formParameters: {
                serializedName: "formParameters",
                xmlName: "formParameters",
                xmlElementName: "ParameterContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterContract"
                        }
                    }
                }
            },
            examples: {
                serializedName: "examples",
                xmlName: "examples",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ParameterExampleContract" }
                    }
                }
            }
        }
    }
};
const ResponseContract = {
    serializedName: "ResponseContract",
    type: {
        name: "Composite",
        className: "ResponseContract",
        modelProperties: {
            statusCode: {
                serializedName: "statusCode",
                required: true,
                xmlName: "statusCode",
                type: {
                    name: "Number"
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            representations: {
                serializedName: "representations",
                xmlName: "representations",
                xmlElementName: "RepresentationContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RepresentationContract"
                        }
                    }
                }
            },
            headers: {
                serializedName: "headers",
                xmlName: "headers",
                xmlElementName: "ParameterContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterContract"
                        }
                    }
                }
            }
        }
    }
};
const OperationUpdateContract = {
    serializedName: "OperationUpdateContract",
    type: {
        name: "Composite",
        className: "OperationUpdateContract",
        modelProperties: {
            templateParameters: {
                serializedName: "properties.templateParameters",
                xmlName: "properties.templateParameters",
                xmlElementName: "ParameterContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterContract"
                        }
                    }
                }
            },
            description: {
                constraints: {
                    MaxLength: 1000
                },
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            request: {
                serializedName: "properties.request",
                xmlName: "properties.request",
                type: {
                    name: "Composite",
                    className: "RequestContract"
                }
            },
            responses: {
                serializedName: "properties.responses",
                xmlName: "properties.responses",
                xmlElementName: "ResponseContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResponseContract"
                        }
                    }
                }
            },
            policies: {
                serializedName: "properties.policies",
                xmlName: "properties.policies",
                type: {
                    name: "String"
                }
            },
            displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            method: {
                serializedName: "properties.method",
                xmlName: "properties.method",
                type: {
                    name: "String"
                }
            },
            urlTemplate: {
                constraints: {
                    MaxLength: 1000,
                    MinLength: 1
                },
                serializedName: "properties.urlTemplate",
                xmlName: "properties.urlTemplate",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicyCollection = {
    serializedName: "PolicyCollection",
    type: {
        name: "Composite",
        className: "PolicyCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "PolicyContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PolicyContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagCollection = {
    serializedName: "TagCollection",
    type: {
        name: "Composite",
        className: "TagCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "TagContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TagContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProductCollection = {
    serializedName: "ProductCollection",
    type: {
        name: "Composite",
        className: "ProductCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "ProductContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProductContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProductEntityBaseParameters = {
    serializedName: "ProductEntityBaseParameters",
    type: {
        name: "Composite",
        className: "ProductEntityBaseParameters",
        modelProperties: {
            description: {
                constraints: {
                    MaxLength: 1000
                },
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            terms: {
                serializedName: "terms",
                xmlName: "terms",
                type: {
                    name: "String"
                }
            },
            subscriptionRequired: {
                serializedName: "subscriptionRequired",
                xmlName: "subscriptionRequired",
                type: {
                    name: "Boolean"
                }
            },
            approvalRequired: {
                serializedName: "approvalRequired",
                xmlName: "approvalRequired",
                type: {
                    name: "Boolean"
                }
            },
            subscriptionsLimit: {
                serializedName: "subscriptionsLimit",
                xmlName: "subscriptionsLimit",
                type: {
                    name: "Number"
                }
            },
            state: {
                serializedName: "state",
                xmlName: "state",
                type: {
                    name: "Enum",
                    allowedValues: ["notPublished", "published"]
                }
            }
        }
    }
};
const SchemaCollection = {
    serializedName: "SchemaCollection",
    type: {
        name: "Composite",
        className: "SchemaCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "SchemaContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SchemaContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticCollection = {
    serializedName: "DiagnosticCollection",
    type: {
        name: "Composite",
        className: "DiagnosticCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "DiagnosticContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SamplingSettings = {
    serializedName: "SamplingSettings",
    type: {
        name: "Composite",
        className: "SamplingSettings",
        modelProperties: {
            samplingType: {
                serializedName: "samplingType",
                xmlName: "samplingType",
                type: {
                    name: "String"
                }
            },
            percentage: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "percentage",
                xmlName: "percentage",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PipelineDiagnosticSettings = {
    serializedName: "PipelineDiagnosticSettings",
    type: {
        name: "Composite",
        className: "PipelineDiagnosticSettings",
        modelProperties: {
            request: {
                serializedName: "request",
                xmlName: "request",
                type: {
                    name: "Composite",
                    className: "HttpMessageDiagnostic"
                }
            },
            response: {
                serializedName: "response",
                xmlName: "response",
                type: {
                    name: "Composite",
                    className: "HttpMessageDiagnostic"
                }
            }
        }
    }
};
const HttpMessageDiagnostic = {
    serializedName: "HttpMessageDiagnostic",
    type: {
        name: "Composite",
        className: "HttpMessageDiagnostic",
        modelProperties: {
            headers: {
                serializedName: "headers",
                xmlName: "headers",
                xmlElementName: "HttpMessageDiagnosticHeadersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            body: {
                serializedName: "body",
                xmlName: "body",
                type: {
                    name: "Composite",
                    className: "BodyDiagnosticSettings"
                }
            },
            dataMasking: {
                serializedName: "dataMasking",
                xmlName: "dataMasking",
                type: {
                    name: "Composite",
                    className: "DataMasking"
                }
            }
        }
    }
};
const BodyDiagnosticSettings = {
    serializedName: "BodyDiagnosticSettings",
    type: {
        name: "Composite",
        className: "BodyDiagnosticSettings",
        modelProperties: {
            bytes: {
                constraints: {
                    InclusiveMaximum: 8192
                },
                serializedName: "bytes",
                xmlName: "bytes",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DataMasking = {
    serializedName: "DataMasking",
    type: {
        name: "Composite",
        className: "DataMasking",
        modelProperties: {
            queryParams: {
                serializedName: "queryParams",
                xmlName: "queryParams",
                xmlElementName: "DataMaskingEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataMaskingEntity"
                        }
                    }
                }
            },
            headers: {
                serializedName: "headers",
                xmlName: "headers",
                xmlElementName: "DataMaskingEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataMaskingEntity"
                        }
                    }
                }
            }
        }
    }
};
const DataMaskingEntity = {
    serializedName: "DataMaskingEntity",
    type: {
        name: "Composite",
        className: "DataMaskingEntity",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            },
            mode: {
                serializedName: "mode",
                xmlName: "mode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IssueCollection = {
    serializedName: "IssueCollection",
    type: {
        name: "Composite",
        className: "IssueCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "IssueContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IssueContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IssueContractBaseProperties = {
    serializedName: "IssueContractBaseProperties",
    type: {
        name: "Composite",
        className: "IssueContractBaseProperties",
        modelProperties: {
            createdDate: {
                serializedName: "createdDate",
                xmlName: "createdDate",
                type: {
                    name: "DateTime"
                }
            },
            state: {
                serializedName: "state",
                xmlName: "state",
                type: {
                    name: "String"
                }
            },
            apiId: {
                serializedName: "apiId",
                xmlName: "apiId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IssueUpdateContract = {
    serializedName: "IssueUpdateContract",
    type: {
        name: "Composite",
        className: "IssueUpdateContract",
        modelProperties: {
            createdDate: {
                serializedName: "properties.createdDate",
                xmlName: "properties.createdDate",
                type: {
                    name: "DateTime"
                }
            },
            state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "String"
                }
            },
            apiId: {
                serializedName: "properties.apiId",
                xmlName: "properties.apiId",
                type: {
                    name: "String"
                }
            },
            title: {
                serializedName: "properties.title",
                xmlName: "properties.title",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            userId: {
                serializedName: "properties.userId",
                xmlName: "properties.userId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IssueCommentCollection = {
    serializedName: "IssueCommentCollection",
    type: {
        name: "Composite",
        className: "IssueCommentCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "IssueCommentContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IssueCommentContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IssueAttachmentCollection = {
    serializedName: "IssueAttachmentCollection",
    type: {
        name: "Composite",
        className: "IssueAttachmentCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "IssueAttachmentContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IssueAttachmentContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagDescriptionCollection = {
    serializedName: "TagDescriptionCollection",
    type: {
        name: "Composite",
        className: "TagDescriptionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "TagDescriptionContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TagDescriptionContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagDescriptionBaseProperties = {
    serializedName: "TagDescriptionBaseProperties",
    type: {
        name: "Composite",
        className: "TagDescriptionBaseProperties",
        modelProperties: {
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            externalDocsUrl: {
                constraints: {
                    MaxLength: 2000
                },
                serializedName: "externalDocsUrl",
                xmlName: "externalDocsUrl",
                type: {
                    name: "String"
                }
            },
            externalDocsDescription: {
                serializedName: "externalDocsDescription",
                xmlName: "externalDocsDescription",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagDescriptionCreateParameters = {
    serializedName: "TagDescriptionCreateParameters",
    type: {
        name: "Composite",
        className: "TagDescriptionCreateParameters",
        modelProperties: {
            description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            externalDocsUrl: {
                constraints: {
                    MaxLength: 2000
                },
                serializedName: "properties.externalDocsUrl",
                xmlName: "properties.externalDocsUrl",
                type: {
                    name: "String"
                }
            },
            externalDocsDescription: {
                serializedName: "properties.externalDocsDescription",
                xmlName: "properties.externalDocsDescription",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagResourceCollection = {
    serializedName: "TagResourceCollection",
    type: {
        name: "Composite",
        className: "TagResourceCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "TagResourceContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TagResourceContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagResourceContract = {
    serializedName: "TagResourceContract",
    type: {
        name: "Composite",
        className: "TagResourceContract",
        modelProperties: {
            tag: {
                serializedName: "tag",
                xmlName: "tag",
                type: {
                    name: "Composite",
                    className: "TagResourceContractProperties"
                }
            },
            api: {
                serializedName: "api",
                xmlName: "api",
                type: {
                    name: "Composite",
                    className: "ApiTagResourceContractProperties"
                }
            },
            operation: {
                serializedName: "operation",
                xmlName: "operation",
                type: {
                    name: "Composite",
                    className: "OperationTagResourceContractProperties"
                }
            },
            product: {
                serializedName: "product",
                xmlName: "product",
                type: {
                    name: "Composite",
                    className: "ProductTagResourceContractProperties"
                }
            }
        }
    }
};
const TagResourceContractProperties = {
    serializedName: "TagResourceContractProperties",
    type: {
        name: "Composite",
        className: "TagResourceContractProperties",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                constraints: {
                    MaxLength: 160,
                    MinLength: 1
                },
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationTagResourceContractProperties = {
    serializedName: "OperationTagResourceContractProperties",
    type: {
        name: "Composite",
        className: "OperationTagResourceContractProperties",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            apiName: {
                serializedName: "apiName",
                readOnly: true,
                xmlName: "apiName",
                type: {
                    name: "String"
                }
            },
            apiRevision: {
                serializedName: "apiRevision",
                readOnly: true,
                xmlName: "apiRevision",
                type: {
                    name: "String"
                }
            },
            apiVersion: {
                serializedName: "apiVersion",
                readOnly: true,
                xmlName: "apiVersion",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            method: {
                serializedName: "method",
                readOnly: true,
                xmlName: "method",
                type: {
                    name: "String"
                }
            },
            urlTemplate: {
                serializedName: "urlTemplate",
                readOnly: true,
                xmlName: "urlTemplate",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiExportResult = {
    serializedName: "ApiExportResult",
    type: {
        name: "Composite",
        className: "ApiExportResult",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            exportResultFormat: {
                serializedName: "format",
                xmlName: "format",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "Composite",
                    className: "ApiExportResultValue"
                }
            }
        }
    }
};
const ApiExportResultValue = {
    serializedName: "ApiExportResultValue",
    type: {
        name: "Composite",
        className: "ApiExportResultValue",
        modelProperties: {
            link: {
                serializedName: "link",
                xmlName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiVersionSetCollection = {
    serializedName: "ApiVersionSetCollection",
    type: {
        name: "Composite",
        className: "ApiVersionSetCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "ApiVersionSetContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiVersionSetContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiVersionSetEntityBase = {
    serializedName: "ApiVersionSetEntityBase",
    type: {
        name: "Composite",
        className: "ApiVersionSetEntityBase",
        modelProperties: {
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            versionQueryName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "versionQueryName",
                xmlName: "versionQueryName",
                type: {
                    name: "String"
                }
            },
            versionHeaderName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "versionHeaderName",
                xmlName: "versionHeaderName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiVersionSetUpdateParameters = {
    serializedName: "ApiVersionSetUpdateParameters",
    type: {
        name: "Composite",
        className: "ApiVersionSetUpdateParameters",
        modelProperties: {
            description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            versionQueryName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.versionQueryName",
                xmlName: "properties.versionQueryName",
                type: {
                    name: "String"
                }
            },
            versionHeaderName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.versionHeaderName",
                xmlName: "properties.versionHeaderName",
                type: {
                    name: "String"
                }
            },
            displayName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            versioningScheme: {
                serializedName: "properties.versioningScheme",
                xmlName: "properties.versioningScheme",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizationServerCollection = {
    serializedName: "AuthorizationServerCollection",
    type: {
        name: "Composite",
        className: "AuthorizationServerCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "AuthorizationServerContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AuthorizationServerContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizationServerContractBaseProperties = {
    serializedName: "AuthorizationServerContractBaseProperties",
    type: {
        name: "Composite",
        className: "AuthorizationServerContractBaseProperties",
        modelProperties: {
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            authorizationMethods: {
                serializedName: "authorizationMethods",
                xmlName: "authorizationMethods",
                xmlElementName: "AuthorizationMethod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "HEAD",
                                "OPTIONS",
                                "TRACE",
                                "GET",
                                "POST",
                                "PUT",
                                "PATCH",
                                "DELETE"
                            ]
                        }
                    }
                }
            },
            clientAuthenticationMethod: {
                serializedName: "clientAuthenticationMethod",
                xmlName: "clientAuthenticationMethod",
                xmlElementName: "ClientAuthenticationMethod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            tokenBodyParameters: {
                serializedName: "tokenBodyParameters",
                xmlName: "tokenBodyParameters",
                xmlElementName: "TokenBodyParameterContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TokenBodyParameterContract"
                        }
                    }
                }
            },
            tokenEndpoint: {
                serializedName: "tokenEndpoint",
                xmlName: "tokenEndpoint",
                type: {
                    name: "String"
                }
            },
            supportState: {
                serializedName: "supportState",
                xmlName: "supportState",
                type: {
                    name: "Boolean"
                }
            },
            defaultScope: {
                serializedName: "defaultScope",
                xmlName: "defaultScope",
                type: {
                    name: "String"
                }
            },
            bearerTokenSendingMethods: {
                serializedName: "bearerTokenSendingMethods",
                xmlName: "bearerTokenSendingMethods",
                xmlElementName: "BearerTokenSendingMethod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            resourceOwnerUsername: {
                serializedName: "resourceOwnerUsername",
                xmlName: "resourceOwnerUsername",
                type: {
                    name: "String"
                }
            },
            resourceOwnerPassword: {
                serializedName: "resourceOwnerPassword",
                xmlName: "resourceOwnerPassword",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TokenBodyParameterContract = {
    serializedName: "TokenBodyParameterContract",
    type: {
        name: "Composite",
        className: "TokenBodyParameterContract",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizationServerSecretsContract = {
    serializedName: "AuthorizationServerSecretsContract",
    type: {
        name: "Composite",
        className: "AuthorizationServerSecretsContract",
        modelProperties: {
            clientSecret: {
                serializedName: "clientSecret",
                xmlName: "clientSecret",
                type: {
                    name: "String"
                }
            },
            resourceOwnerUsername: {
                serializedName: "resourceOwnerUsername",
                xmlName: "resourceOwnerUsername",
                type: {
                    name: "String"
                }
            },
            resourceOwnerPassword: {
                serializedName: "resourceOwnerPassword",
                xmlName: "resourceOwnerPassword",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackendCollection = {
    serializedName: "BackendCollection",
    type: {
        name: "Composite",
        className: "BackendCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "BackendContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackendContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackendBaseParameters = {
    serializedName: "BackendBaseParameters",
    type: {
        name: "Composite",
        className: "BackendBaseParameters",
        modelProperties: {
            title: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "title",
                xmlName: "title",
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "resourceId",
                xmlName: "resourceId",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Composite",
                    className: "BackendProperties"
                }
            },
            credentials: {
                serializedName: "credentials",
                xmlName: "credentials",
                type: {
                    name: "Composite",
                    className: "BackendCredentialsContract"
                }
            },
            proxy: {
                serializedName: "proxy",
                xmlName: "proxy",
                type: {
                    name: "Composite",
                    className: "BackendProxyContract"
                }
            },
            tls: {
                serializedName: "tls",
                xmlName: "tls",
                type: {
                    name: "Composite",
                    className: "BackendTlsProperties"
                }
            }
        }
    }
};
const BackendProperties = {
    serializedName: "BackendProperties",
    type: {
        name: "Composite",
        className: "BackendProperties",
        modelProperties: {
            serviceFabricCluster: {
                serializedName: "serviceFabricCluster",
                xmlName: "serviceFabricCluster",
                type: {
                    name: "Composite",
                    className: "BackendServiceFabricClusterProperties"
                }
            }
        }
    }
};
const BackendServiceFabricClusterProperties = {
    serializedName: "BackendServiceFabricClusterProperties",
    type: {
        name: "Composite",
        className: "BackendServiceFabricClusterProperties",
        modelProperties: {
            clientCertificateId: {
                serializedName: "clientCertificateId",
                xmlName: "clientCertificateId",
                type: {
                    name: "String"
                }
            },
            clientCertificatethumbprint: {
                serializedName: "clientCertificatethumbprint",
                xmlName: "clientCertificatethumbprint",
                type: {
                    name: "String"
                }
            },
            maxPartitionResolutionRetries: {
                serializedName: "maxPartitionResolutionRetries",
                xmlName: "maxPartitionResolutionRetries",
                type: {
                    name: "Number"
                }
            },
            managementEndpoints: {
                serializedName: "managementEndpoints",
                required: true,
                xmlName: "managementEndpoints",
                xmlElementName: "BackendServiceFabricClusterPropertiesManagementEndpointsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            serverCertificateThumbprints: {
                serializedName: "serverCertificateThumbprints",
                xmlName: "serverCertificateThumbprints",
                xmlElementName: "BackendServiceFabricClusterPropertiesServerCertificateThumbprintsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            serverX509Names: {
                serializedName: "serverX509Names",
                xmlName: "serverX509Names",
                xmlElementName: "X509CertificateName",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "X509CertificateName"
                        }
                    }
                }
            }
        }
    }
};
const X509CertificateName = {
    serializedName: "X509CertificateName",
    type: {
        name: "Composite",
        className: "X509CertificateName",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            issuerCertificateThumbprint: {
                serializedName: "issuerCertificateThumbprint",
                xmlName: "issuerCertificateThumbprint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackendCredentialsContract = {
    serializedName: "BackendCredentialsContract",
    type: {
        name: "Composite",
        className: "BackendCredentialsContract",
        modelProperties: {
            certificateIds: {
                constraints: {
                    MaxItems: 32
                },
                serializedName: "certificateIds",
                xmlName: "certificateIds",
                xmlElementName: "BackendCredentialsContractCertificateIdsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            certificate: {
                constraints: {
                    MaxItems: 32
                },
                serializedName: "certificate",
                xmlName: "certificate",
                xmlElementName: "BackendCredentialsContractCertificateItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            query: {
                serializedName: "query",
                xmlName: "query",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Sequence", element: { type: { name: "String" } } }
                    }
                }
            },
            header: {
                serializedName: "header",
                xmlName: "header",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Sequence", element: { type: { name: "String" } } }
                    }
                }
            },
            authorization: {
                serializedName: "authorization",
                xmlName: "authorization",
                type: {
                    name: "Composite",
                    className: "BackendAuthorizationHeaderCredentials"
                }
            }
        }
    }
};
const BackendAuthorizationHeaderCredentials = {
    serializedName: "BackendAuthorizationHeaderCredentials",
    type: {
        name: "Composite",
        className: "BackendAuthorizationHeaderCredentials",
        modelProperties: {
            scheme: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "scheme",
                required: true,
                xmlName: "scheme",
                type: {
                    name: "String"
                }
            },
            parameter: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "parameter",
                required: true,
                xmlName: "parameter",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackendProxyContract = {
    serializedName: "BackendProxyContract",
    type: {
        name: "Composite",
        className: "BackendProxyContract",
        modelProperties: {
            url: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "url",
                required: true,
                xmlName: "url",
                type: {
                    name: "String"
                }
            },
            username: {
                serializedName: "username",
                xmlName: "username",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                xmlName: "password",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackendTlsProperties = {
    serializedName: "BackendTlsProperties",
    type: {
        name: "Composite",
        className: "BackendTlsProperties",
        modelProperties: {
            validateCertificateChain: {
                defaultValue: true,
                serializedName: "validateCertificateChain",
                xmlName: "validateCertificateChain",
                type: {
                    name: "Boolean"
                }
            },
            validateCertificateName: {
                defaultValue: true,
                serializedName: "validateCertificateName",
                xmlName: "validateCertificateName",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const BackendUpdateParameters = {
    serializedName: "BackendUpdateParameters",
    type: {
        name: "Composite",
        className: "BackendUpdateParameters",
        modelProperties: {
            title: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "properties.title",
                xmlName: "properties.title",
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "properties.resourceId",
                xmlName: "properties.resourceId",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties.properties",
                xmlName: "properties.properties",
                type: {
                    name: "Composite",
                    className: "BackendProperties"
                }
            },
            credentials: {
                serializedName: "properties.credentials",
                xmlName: "properties.credentials",
                type: {
                    name: "Composite",
                    className: "BackendCredentialsContract"
                }
            },
            proxy: {
                serializedName: "properties.proxy",
                xmlName: "properties.proxy",
                type: {
                    name: "Composite",
                    className: "BackendProxyContract"
                }
            },
            tls: {
                serializedName: "properties.tls",
                xmlName: "properties.tls",
                type: {
                    name: "Composite",
                    className: "BackendTlsProperties"
                }
            },
            url: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "properties.url",
                xmlName: "properties.url",
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "properties.protocol",
                xmlName: "properties.protocol",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheCollection = {
    serializedName: "CacheCollection",
    type: {
        name: "Composite",
        className: "CacheCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "CacheContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CacheContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheUpdateParameters = {
    serializedName: "CacheUpdateParameters",
    type: {
        name: "Composite",
        className: "CacheUpdateParameters",
        modelProperties: {
            description: {
                constraints: {
                    MaxLength: 2000
                },
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            connectionString: {
                constraints: {
                    MaxLength: 300
                },
                serializedName: "properties.connectionString",
                xmlName: "properties.connectionString",
                type: {
                    name: "String"
                }
            },
            useFromLocation: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "properties.useFromLocation",
                xmlName: "properties.useFromLocation",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                constraints: {
                    MaxLength: 2000
                },
                serializedName: "properties.resourceId",
                xmlName: "properties.resourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateCollection = {
    serializedName: "CertificateCollection",
    type: {
        name: "Composite",
        className: "CertificateCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "CertificateContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CertificateContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyVaultLastAccessStatusContractProperties = {
    serializedName: "KeyVaultLastAccessStatusContractProperties",
    type: {
        name: "Composite",
        className: "KeyVaultLastAccessStatusContractProperties",
        modelProperties: {
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String"
                }
            },
            timeStampUtc: {
                serializedName: "timeStampUtc",
                xmlName: "timeStampUtc",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const KeyVaultContractCreateProperties = {
    serializedName: "KeyVaultContractCreateProperties",
    type: {
        name: "Composite",
        className: "KeyVaultContractCreateProperties",
        modelProperties: {
            secretIdentifier: {
                serializedName: "secretIdentifier",
                xmlName: "secretIdentifier",
                type: {
                    name: "String"
                }
            },
            identityClientId: {
                serializedName: "identityClientId",
                xmlName: "identityClientId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateCreateOrUpdateParameters = {
    serializedName: "CertificateCreateOrUpdateParameters",
    type: {
        name: "Composite",
        className: "CertificateCreateOrUpdateParameters",
        modelProperties: {
            data: {
                serializedName: "properties.data",
                xmlName: "properties.data",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "properties.password",
                xmlName: "properties.password",
                type: {
                    name: "String"
                }
            },
            keyVault: {
                serializedName: "properties.keyVault",
                xmlName: "properties.keyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultContractCreateProperties"
                }
            }
        }
    }
};
const ConnectivityCheckRequest = {
    serializedName: "ConnectivityCheckRequest",
    type: {
        name: "Composite",
        className: "ConnectivityCheckRequest",
        modelProperties: {
            source: {
                serializedName: "source",
                xmlName: "source",
                type: {
                    name: "Composite",
                    className: "ConnectivityCheckRequestSource"
                }
            },
            destination: {
                serializedName: "destination",
                xmlName: "destination",
                type: {
                    name: "Composite",
                    className: "ConnectivityCheckRequestDestination"
                }
            },
            preferredIPVersion: {
                serializedName: "preferredIPVersion",
                xmlName: "preferredIPVersion",
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                xmlName: "protocol",
                type: {
                    name: "String"
                }
            },
            protocolConfiguration: {
                serializedName: "protocolConfiguration",
                xmlName: "protocolConfiguration",
                type: {
                    name: "Composite",
                    className: "ConnectivityCheckRequestProtocolConfiguration"
                }
            }
        }
    }
};
const ConnectivityCheckRequestSource = {
    serializedName: "ConnectivityCheckRequestSource",
    type: {
        name: "Composite",
        className: "ConnectivityCheckRequestSource",
        modelProperties: {
            region: {
                serializedName: "region",
                required: true,
                xmlName: "region",
                type: {
                    name: "String"
                }
            },
            instance: {
                serializedName: "instance",
                xmlName: "instance",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectivityCheckRequestDestination = {
    serializedName: "ConnectivityCheckRequestDestination",
    type: {
        name: "Composite",
        className: "ConnectivityCheckRequestDestination",
        modelProperties: {
            address: {
                serializedName: "address",
                required: true,
                xmlName: "address",
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                required: true,
                xmlName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectivityCheckRequestProtocolConfiguration = {
    serializedName: "ConnectivityCheckRequestProtocolConfiguration",
    type: {
        name: "Composite",
        className: "ConnectivityCheckRequestProtocolConfiguration",
        modelProperties: {
            httpConfiguration: {
                serializedName: "HTTPConfiguration",
                xmlName: "HTTPConfiguration",
                type: {
                    name: "Composite",
                    className: "ConnectivityCheckRequestProtocolConfigurationHttpConfiguration"
                }
            }
        }
    }
};
const ConnectivityCheckRequestProtocolConfigurationHttpConfiguration = {
    serializedName: "ConnectivityCheckRequestProtocolConfigurationHttpConfiguration",
    type: {
        name: "Composite",
        className: "ConnectivityCheckRequestProtocolConfigurationHttpConfiguration",
        modelProperties: {
            method: {
                serializedName: "method",
                xmlName: "method",
                type: {
                    name: "String"
                }
            },
            validStatusCodes: {
                serializedName: "validStatusCodes",
                xmlName: "validStatusCodes",
                xmlElementName: "ArrayItemschema",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            headers: {
                serializedName: "headers",
                xmlName: "headers",
                xmlElementName: "HttpHeader",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HttpHeader"
                        }
                    }
                }
            }
        }
    }
};
const HttpHeader = {
    serializedName: "HttpHeader",
    type: {
        name: "Composite",
        className: "HttpHeader",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectivityCheckResponse = {
    serializedName: "ConnectivityCheckResponse",
    type: {
        name: "Composite",
        className: "ConnectivityCheckResponse",
        modelProperties: {
            hops: {
                serializedName: "hops",
                readOnly: true,
                xmlName: "hops",
                xmlElementName: "ConnectivityHop",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityHop"
                        }
                    }
                }
            },
            connectionStatus: {
                serializedName: "connectionStatus",
                readOnly: true,
                xmlName: "connectionStatus",
                type: {
                    name: "String"
                }
            },
            avgLatencyInMs: {
                serializedName: "avgLatencyInMs",
                readOnly: true,
                xmlName: "avgLatencyInMs",
                type: {
                    name: "Number"
                }
            },
            minLatencyInMs: {
                serializedName: "minLatencyInMs",
                readOnly: true,
                xmlName: "minLatencyInMs",
                type: {
                    name: "Number"
                }
            },
            maxLatencyInMs: {
                serializedName: "maxLatencyInMs",
                readOnly: true,
                xmlName: "maxLatencyInMs",
                type: {
                    name: "Number"
                }
            },
            probesSent: {
                serializedName: "probesSent",
                readOnly: true,
                xmlName: "probesSent",
                type: {
                    name: "Number"
                }
            },
            probesFailed: {
                serializedName: "probesFailed",
                readOnly: true,
                xmlName: "probesFailed",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectivityHop = {
    serializedName: "ConnectivityHop",
    type: {
        name: "Composite",
        className: "ConnectivityHop",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            address: {
                serializedName: "address",
                readOnly: true,
                xmlName: "address",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                readOnly: true,
                xmlName: "resourceId",
                type: {
                    name: "String"
                }
            },
            nextHopIds: {
                serializedName: "nextHopIds",
                readOnly: true,
                xmlName: "nextHopIds",
                xmlElementName: "ConnectivityHopNextHopIdsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            issues: {
                serializedName: "issues",
                readOnly: true,
                xmlName: "issues",
                xmlElementName: "ConnectivityIssue",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityIssue"
                        }
                    }
                }
            }
        }
    }
};
const ConnectivityIssue = {
    serializedName: "ConnectivityIssue",
    type: {
        name: "Composite",
        className: "ConnectivityIssue",
        modelProperties: {
            origin: {
                serializedName: "origin",
                readOnly: true,
                xmlName: "origin",
                type: {
                    name: "String"
                }
            },
            severity: {
                serializedName: "severity",
                readOnly: true,
                xmlName: "severity",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            context: {
                serializedName: "context",
                readOnly: true,
                xmlName: "context",
                xmlElementName: "IssueContext",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Dictionary",
                            value: { type: { name: "String" } }
                        }
                    }
                }
            }
        }
    }
};
const ContentTypeCollection = {
    serializedName: "ContentTypeCollection",
    type: {
        name: "Composite",
        className: "ContentTypeCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "ContentTypeContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContentTypeContract"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContentItemCollection = {
    serializedName: "ContentItemCollection",
    type: {
        name: "Composite",
        className: "ContentItemCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "ContentItemContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContentItemContract"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedServicesCollection = {
    serializedName: "DeletedServicesCollection",
    type: {
        name: "Composite",
        className: "DeletedServicesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "DeletedServiceContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedServiceContract"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    serializedName: "OperationListResult",
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "Operation",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    serializedName: "Operation",
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                xmlName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                xmlName: "origin",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const OperationDisplay = {
    serializedName: "OperationDisplay",
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                xmlName: "provider",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                xmlName: "operation",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                xmlName: "resource",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceSkuResults = {
    serializedName: "ResourceSkuResults",
    type: {
        name: "Composite",
        className: "ResourceSkuResults",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ResourceSkuResult",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceSkuResult"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceSkuResult = {
    serializedName: "ResourceSkuResult",
    type: {
        name: "Composite",
        className: "ResourceSkuResult",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                xmlName: "resourceType",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "ResourceSku"
                }
            },
            capacity: {
                serializedName: "capacity",
                xmlName: "capacity",
                type: {
                    name: "Composite",
                    className: "ResourceSkuCapacity"
                }
            }
        }
    }
};
const ResourceSku = {
    serializedName: "ResourceSku",
    type: {
        name: "Composite",
        className: "ResourceSku",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceSkuCapacity = {
    serializedName: "ResourceSkuCapacity",
    type: {
        name: "Composite",
        className: "ResourceSkuCapacity",
        modelProperties: {
            minimum: {
                serializedName: "minimum",
                readOnly: true,
                xmlName: "minimum",
                type: {
                    name: "Number"
                }
            },
            maximum: {
                serializedName: "maximum",
                readOnly: true,
                xmlName: "maximum",
                type: {
                    name: "Number"
                }
            },
            default: {
                serializedName: "default",
                readOnly: true,
                xmlName: "default",
                type: {
                    name: "Number"
                }
            },
            scaleType: {
                serializedName: "scaleType",
                readOnly: true,
                xmlName: "scaleType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiManagementServiceBackupRestoreParameters = {
    serializedName: "ApiManagementServiceBackupRestoreParameters",
    type: {
        name: "Composite",
        className: "ApiManagementServiceBackupRestoreParameters",
        modelProperties: {
            storageAccount: {
                serializedName: "storageAccount",
                required: true,
                xmlName: "storageAccount",
                type: {
                    name: "String"
                }
            },
            containerName: {
                serializedName: "containerName",
                required: true,
                xmlName: "containerName",
                type: {
                    name: "String"
                }
            },
            backupName: {
                serializedName: "backupName",
                required: true,
                xmlName: "backupName",
                type: {
                    name: "String"
                }
            },
            accessType: {
                defaultValue: "AccessKey",
                serializedName: "accessType",
                xmlName: "accessType",
                type: {
                    name: "String"
                }
            },
            accessKey: {
                serializedName: "accessKey",
                xmlName: "accessKey",
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiManagementServiceBaseProperties = {
    serializedName: "ApiManagementServiceBaseProperties",
    type: {
        name: "Composite",
        className: "ApiManagementServiceBaseProperties",
        modelProperties: {
            notificationSenderEmail: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "notificationSenderEmail",
                xmlName: "notificationSenderEmail",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                xmlName: "provisioningState",
                type: {
                    name: "String"
                }
            },
            targetProvisioningState: {
                serializedName: "targetProvisioningState",
                readOnly: true,
                xmlName: "targetProvisioningState",
                type: {
                    name: "String"
                }
            },
            createdAtUtc: {
                serializedName: "createdAtUtc",
                readOnly: true,
                xmlName: "createdAtUtc",
                type: {
                    name: "DateTime"
                }
            },
            gatewayUrl: {
                serializedName: "gatewayUrl",
                readOnly: true,
                xmlName: "gatewayUrl",
                type: {
                    name: "String"
                }
            },
            gatewayRegionalUrl: {
                serializedName: "gatewayRegionalUrl",
                readOnly: true,
                xmlName: "gatewayRegionalUrl",
                type: {
                    name: "String"
                }
            },
            portalUrl: {
                serializedName: "portalUrl",
                readOnly: true,
                xmlName: "portalUrl",
                type: {
                    name: "String"
                }
            },
            managementApiUrl: {
                serializedName: "managementApiUrl",
                readOnly: true,
                xmlName: "managementApiUrl",
                type: {
                    name: "String"
                }
            },
            scmUrl: {
                serializedName: "scmUrl",
                readOnly: true,
                xmlName: "scmUrl",
                type: {
                    name: "String"
                }
            },
            developerPortalUrl: {
                serializedName: "developerPortalUrl",
                readOnly: true,
                xmlName: "developerPortalUrl",
                type: {
                    name: "String"
                }
            },
            hostnameConfigurations: {
                serializedName: "hostnameConfigurations",
                xmlName: "hostnameConfigurations",
                xmlElementName: "HostnameConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostnameConfiguration"
                        }
                    }
                }
            },
            publicIPAddresses: {
                serializedName: "publicIPAddresses",
                readOnly: true,
                xmlName: "publicIPAddresses",
                xmlElementName: "ApiManagementServiceBasePropertiesPublicIPAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            privateIPAddresses: {
                serializedName: "privateIPAddresses",
                readOnly: true,
                xmlName: "privateIPAddresses",
                xmlElementName: "ApiManagementServiceBasePropertiesPrivateIPAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            publicIpAddressId: {
                serializedName: "publicIpAddressId",
                xmlName: "publicIpAddressId",
                type: {
                    name: "String"
                }
            },
            publicNetworkAccess: {
                serializedName: "publicNetworkAccess",
                xmlName: "publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            virtualNetworkConfiguration: {
                serializedName: "virtualNetworkConfiguration",
                xmlName: "virtualNetworkConfiguration",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkConfiguration"
                }
            },
            additionalLocations: {
                serializedName: "additionalLocations",
                xmlName: "additionalLocations",
                xmlElementName: "AdditionalLocation",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdditionalLocation"
                        }
                    }
                }
            },
            customProperties: {
                serializedName: "customProperties",
                xmlName: "customProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            certificates: {
                serializedName: "certificates",
                xmlName: "certificates",
                xmlElementName: "CertificateConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CertificateConfiguration"
                        }
                    }
                }
            },
            enableClientCertificate: {
                defaultValue: false,
                serializedName: "enableClientCertificate",
                xmlName: "enableClientCertificate",
                type: {
                    name: "Boolean"
                }
            },
            disableGateway: {
                defaultValue: false,
                serializedName: "disableGateway",
                xmlName: "disableGateway",
                type: {
                    name: "Boolean"
                }
            },
            virtualNetworkType: {
                defaultValue: "None",
                serializedName: "virtualNetworkType",
                xmlName: "virtualNetworkType",
                type: {
                    name: "String"
                }
            },
            apiVersionConstraint: {
                serializedName: "apiVersionConstraint",
                xmlName: "apiVersionConstraint",
                type: {
                    name: "Composite",
                    className: "ApiVersionConstraint"
                }
            },
            restore: {
                defaultValue: false,
                serializedName: "restore",
                xmlName: "restore",
                type: {
                    name: "Boolean"
                }
            },
            privateEndpointConnections: {
                serializedName: "privateEndpointConnections",
                xmlName: "privateEndpointConnections",
                xmlElementName: "RemotePrivateEndpointConnectionWrapper",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RemotePrivateEndpointConnectionWrapper"
                        }
                    }
                }
            },
            platformVersion: {
                serializedName: "platformVersion",
                readOnly: true,
                xmlName: "platformVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HostnameConfiguration = {
    serializedName: "HostnameConfiguration",
    type: {
        name: "Composite",
        className: "HostnameConfiguration",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            hostName: {
                serializedName: "hostName",
                required: true,
                xmlName: "hostName",
                type: {
                    name: "String"
                }
            },
            keyVaultId: {
                serializedName: "keyVaultId",
                xmlName: "keyVaultId",
                type: {
                    name: "String"
                }
            },
            identityClientId: {
                serializedName: "identityClientId",
                xmlName: "identityClientId",
                type: {
                    name: "String"
                }
            },
            encodedCertificate: {
                serializedName: "encodedCertificate",
                xmlName: "encodedCertificate",
                type: {
                    name: "String"
                }
            },
            certificatePassword: {
                serializedName: "certificatePassword",
                xmlName: "certificatePassword",
                type: {
                    name: "String"
                }
            },
            defaultSslBinding: {
                defaultValue: false,
                serializedName: "defaultSslBinding",
                xmlName: "defaultSslBinding",
                type: {
                    name: "Boolean"
                }
            },
            negotiateClientCertificate: {
                defaultValue: false,
                serializedName: "negotiateClientCertificate",
                xmlName: "negotiateClientCertificate",
                type: {
                    name: "Boolean"
                }
            },
            certificate: {
                serializedName: "certificate",
                xmlName: "certificate",
                type: {
                    name: "Composite",
                    className: "CertificateInformation"
                }
            },
            certificateSource: {
                serializedName: "certificateSource",
                xmlName: "certificateSource",
                type: {
                    name: "String"
                }
            },
            certificateStatus: {
                serializedName: "certificateStatus",
                xmlName: "certificateStatus",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateInformation = {
    serializedName: "CertificateInformation",
    type: {
        name: "Composite",
        className: "CertificateInformation",
        modelProperties: {
            expiry: {
                serializedName: "expiry",
                required: true,
                xmlName: "expiry",
                type: {
                    name: "DateTime"
                }
            },
            thumbprint: {
                serializedName: "thumbprint",
                required: true,
                xmlName: "thumbprint",
                type: {
                    name: "String"
                }
            },
            subject: {
                serializedName: "subject",
                required: true,
                xmlName: "subject",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkConfiguration = {
    serializedName: "VirtualNetworkConfiguration",
    type: {
        name: "Composite",
        className: "VirtualNetworkConfiguration",
        modelProperties: {
            vnetid: {
                serializedName: "vnetid",
                readOnly: true,
                xmlName: "vnetid",
                type: {
                    name: "String"
                }
            },
            subnetname: {
                serializedName: "subnetname",
                readOnly: true,
                xmlName: "subnetname",
                type: {
                    name: "String"
                }
            },
            subnetResourceId: {
                constraints: {
                    Pattern: new RegExp("^\\/subscriptions\\/[^/]*\\/resourceGroups\\/[^/]*\\/providers\\/Microsoft.(ClassicNetwork|Network)\\/virtualNetworks\\/[^/]*\\/subnets\\/[^/]*$")
                },
                serializedName: "subnetResourceId",
                xmlName: "subnetResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AdditionalLocation = {
    serializedName: "AdditionalLocation",
    type: {
        name: "Composite",
        className: "AdditionalLocation",
        modelProperties: {
            location: {
                serializedName: "location",
                required: true,
                xmlName: "location",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "ApiManagementServiceSkuProperties"
                }
            },
            zones: {
                serializedName: "zones",
                xmlName: "zones",
                xmlElementName: "AdditionalLocationZonesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            publicIPAddresses: {
                serializedName: "publicIPAddresses",
                readOnly: true,
                xmlName: "publicIPAddresses",
                xmlElementName: "AdditionalLocationPublicIPAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            privateIPAddresses: {
                serializedName: "privateIPAddresses",
                readOnly: true,
                xmlName: "privateIPAddresses",
                xmlElementName: "AdditionalLocationPrivateIPAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            publicIpAddressId: {
                serializedName: "publicIpAddressId",
                xmlName: "publicIpAddressId",
                type: {
                    name: "String"
                }
            },
            virtualNetworkConfiguration: {
                serializedName: "virtualNetworkConfiguration",
                xmlName: "virtualNetworkConfiguration",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkConfiguration"
                }
            },
            gatewayRegionalUrl: {
                serializedName: "gatewayRegionalUrl",
                readOnly: true,
                xmlName: "gatewayRegionalUrl",
                type: {
                    name: "String"
                }
            },
            disableGateway: {
                defaultValue: false,
                serializedName: "disableGateway",
                xmlName: "disableGateway",
                type: {
                    name: "Boolean"
                }
            },
            platformVersion: {
                serializedName: "platformVersion",
                readOnly: true,
                xmlName: "platformVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiManagementServiceSkuProperties = {
    serializedName: "ApiManagementServiceSkuProperties",
    type: {
        name: "Composite",
        className: "ApiManagementServiceSkuProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                required: true,
                xmlName: "capacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CertificateConfiguration = {
    serializedName: "CertificateConfiguration",
    type: {
        name: "Composite",
        className: "CertificateConfiguration",
        modelProperties: {
            encodedCertificate: {
                serializedName: "encodedCertificate",
                xmlName: "encodedCertificate",
                type: {
                    name: "String"
                }
            },
            certificatePassword: {
                serializedName: "certificatePassword",
                xmlName: "certificatePassword",
                type: {
                    name: "String"
                }
            },
            storeName: {
                serializedName: "storeName",
                required: true,
                xmlName: "storeName",
                type: {
                    name: "String"
                }
            },
            certificate: {
                serializedName: "certificate",
                xmlName: "certificate",
                type: {
                    name: "Composite",
                    className: "CertificateInformation"
                }
            }
        }
    }
};
const ApiVersionConstraint = {
    serializedName: "ApiVersionConstraint",
    type: {
        name: "Composite",
        className: "ApiVersionConstraint",
        modelProperties: {
            minApiVersion: {
                serializedName: "minApiVersion",
                xmlName: "minApiVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RemotePrivateEndpointConnectionWrapper = {
    serializedName: "RemotePrivateEndpointConnectionWrapper",
    type: {
        name: "Composite",
        className: "RemotePrivateEndpointConnectionWrapper",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                xmlName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "ArmIdWrapper"
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                xmlName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            },
            groupIds: {
                serializedName: "properties.groupIds",
                readOnly: true,
                xmlName: "properties.groupIds",
                xmlElementName: "PrivateEndpointConnectionWrapperPropertiesGroupIdsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ArmIdWrapper = {
    serializedName: "ArmIdWrapper",
    type: {
        name: "Composite",
        className: "ArmIdWrapper",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    serializedName: "PrivateLinkServiceConnectionState",
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                xmlName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiManagementServiceIdentity = {
    serializedName: "ApiManagementServiceIdentity",
    type: {
        name: "Composite",
        className: "ApiManagementServiceIdentity",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                xmlName: "principalId",
                type: {
                    name: "Uuid"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                xmlName: "tenantId",
                type: {
                    name: "Uuid"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                xmlName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserIdentityProperties" }
                    }
                }
            }
        }
    }
};
const UserIdentityProperties = {
    serializedName: "UserIdentityProperties",
    type: {
        name: "Composite",
        className: "UserIdentityProperties",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                xmlName: "principalId",
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemData = {
    serializedName: "SystemData",
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                xmlName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                xmlName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                xmlName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                xmlName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                xmlName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                xmlName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ApimResource = {
    serializedName: "ApimResource",
    type: {
        name: "Composite",
        className: "ApimResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                xmlName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ApiManagementServiceListResult = {
    serializedName: "ApiManagementServiceListResult",
    type: {
        name: "Composite",
        className: "ApiManagementServiceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ApiManagementServiceResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiManagementServiceResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiManagementServiceGetSsoTokenResult = {
    serializedName: "ApiManagementServiceGetSsoTokenResult",
    type: {
        name: "Composite",
        className: "ApiManagementServiceGetSsoTokenResult",
        modelProperties: {
            redirectUri: {
                serializedName: "redirectUri",
                xmlName: "redirectUri",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiManagementServiceCheckNameAvailabilityParameters = {
    serializedName: "ApiManagementServiceCheckNameAvailabilityParameters",
    type: {
        name: "Composite",
        className: "ApiManagementServiceCheckNameAvailabilityParameters",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiManagementServiceNameAvailabilityResult = {
    serializedName: "ApiManagementServiceNameAvailabilityResult",
    type: {
        name: "Composite",
        className: "ApiManagementServiceNameAvailabilityResult",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                readOnly: true,
                xmlName: "nameAvailable",
                type: {
                    name: "Boolean"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                xmlName: "message",
                type: {
                    name: "String"
                }
            },
            reason: {
                serializedName: "reason",
                xmlName: "reason",
                type: {
                    name: "Enum",
                    allowedValues: ["Valid", "Invalid", "AlreadyExists"]
                }
            }
        }
    }
};
const ApiManagementServiceGetDomainOwnershipIdentifierResult = {
    serializedName: "ApiManagementServiceGetDomainOwnershipIdentifierResult",
    type: {
        name: "Composite",
        className: "ApiManagementServiceGetDomainOwnershipIdentifierResult",
        modelProperties: {
            domainOwnershipIdentifier: {
                serializedName: "domainOwnershipIdentifier",
                readOnly: true,
                xmlName: "domainOwnershipIdentifier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiManagementServiceApplyNetworkConfigurationParameters = {
    serializedName: "ApiManagementServiceApplyNetworkConfigurationParameters",
    type: {
        name: "Composite",
        className: "ApiManagementServiceApplyNetworkConfigurationParameters",
        modelProperties: {
            location: {
                serializedName: "location",
                xmlName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EmailTemplateCollection = {
    serializedName: "EmailTemplateCollection",
    type: {
        name: "Composite",
        className: "EmailTemplateCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "EmailTemplateContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EmailTemplateContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EmailTemplateParametersContractProperties = {
    serializedName: "EmailTemplateParametersContractProperties",
    type: {
        name: "Composite",
        className: "EmailTemplateParametersContractProperties",
        modelProperties: {
            name: {
                constraints: {
                    Pattern: new RegExp("^[A-Za-z0-9-._]+$"),
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            title: {
                constraints: {
                    MaxLength: 4096,
                    MinLength: 1
                },
                serializedName: "title",
                xmlName: "title",
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    Pattern: new RegExp("^[A-Za-z0-9-._]+$"),
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EmailTemplateUpdateParameters = {
    serializedName: "EmailTemplateUpdateParameters",
    type: {
        name: "Composite",
        className: "EmailTemplateUpdateParameters",
        modelProperties: {
            subject: {
                constraints: {
                    MaxLength: 1000,
                    MinLength: 1
                },
                serializedName: "properties.subject",
                xmlName: "properties.subject",
                type: {
                    name: "String"
                }
            },
            title: {
                serializedName: "properties.title",
                xmlName: "properties.title",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            body: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.body",
                xmlName: "properties.body",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "properties.parameters",
                xmlName: "properties.parameters",
                xmlElementName: "EmailTemplateParametersContractProperties",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EmailTemplateParametersContractProperties"
                        }
                    }
                }
            }
        }
    }
};
const GatewayCollection = {
    serializedName: "GatewayCollection",
    type: {
        name: "Composite",
        className: "GatewayCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "GatewayContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GatewayContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceLocationDataContract = {
    serializedName: "ResourceLocationDataContract",
    type: {
        name: "Composite",
        className: "ResourceLocationDataContract",
        modelProperties: {
            name: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            city: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "city",
                xmlName: "city",
                type: {
                    name: "String"
                }
            },
            district: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "district",
                xmlName: "district",
                type: {
                    name: "String"
                }
            },
            countryOrRegion: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "countryOrRegion",
                xmlName: "countryOrRegion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayKeysContract = {
    serializedName: "GatewayKeysContract",
    type: {
        name: "Composite",
        className: "GatewayKeysContract",
        modelProperties: {
            primary: {
                serializedName: "primary",
                xmlName: "primary",
                type: {
                    name: "String"
                }
            },
            secondary: {
                serializedName: "secondary",
                xmlName: "secondary",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayKeyRegenerationRequestContract = {
    serializedName: "GatewayKeyRegenerationRequestContract",
    type: {
        name: "Composite",
        className: "GatewayKeyRegenerationRequestContract",
        modelProperties: {
            keyType: {
                serializedName: "keyType",
                required: true,
                xmlName: "keyType",
                type: {
                    name: "Enum",
                    allowedValues: ["primary", "secondary"]
                }
            }
        }
    }
};
const GatewayTokenRequestContract = {
    serializedName: "GatewayTokenRequestContract",
    type: {
        name: "Composite",
        className: "GatewayTokenRequestContract",
        modelProperties: {
            keyType: {
                serializedName: "keyType",
                required: true,
                xmlName: "keyType",
                type: {
                    name: "Enum",
                    allowedValues: ["primary", "secondary"]
                }
            },
            expiry: {
                serializedName: "expiry",
                required: true,
                xmlName: "expiry",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const GatewayTokenContract = {
    serializedName: "GatewayTokenContract",
    type: {
        name: "Composite",
        className: "GatewayTokenContract",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayHostnameConfigurationCollection = {
    serializedName: "GatewayHostnameConfigurationCollection",
    type: {
        name: "Composite",
        className: "GatewayHostnameConfigurationCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "GatewayHostnameConfigurationContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GatewayHostnameConfigurationContract"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayCertificateAuthorityCollection = {
    serializedName: "GatewayCertificateAuthorityCollection",
    type: {
        name: "Composite",
        className: "GatewayCertificateAuthorityCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "GatewayCertificateAuthorityContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GatewayCertificateAuthorityContract"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GroupCollection = {
    serializedName: "GroupCollection",
    type: {
        name: "Composite",
        className: "GroupCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "GroupContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GroupContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GroupContractProperties = {
    serializedName: "GroupContractProperties",
    type: {
        name: "Composite",
        className: "GroupContractProperties",
        modelProperties: {
            displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "displayName",
                required: true,
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 1000
                },
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            },
            builtIn: {
                serializedName: "builtIn",
                readOnly: true,
                xmlName: "builtIn",
                type: {
                    name: "Boolean"
                }
            },
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["custom", "system", "external"]
                }
            },
            externalId: {
                serializedName: "externalId",
                xmlName: "externalId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GroupCreateParameters = {
    serializedName: "GroupCreateParameters",
    type: {
        name: "Composite",
        className: "GroupCreateParameters",
        modelProperties: {
            displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "properties.type",
                xmlName: "properties.type",
                type: {
                    name: "Enum",
                    allowedValues: ["custom", "system", "external"]
                }
            },
            externalId: {
                serializedName: "properties.externalId",
                xmlName: "properties.externalId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GroupUpdateParameters = {
    serializedName: "GroupUpdateParameters",
    type: {
        name: "Composite",
        className: "GroupUpdateParameters",
        modelProperties: {
            displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "properties.type",
                xmlName: "properties.type",
                type: {
                    name: "Enum",
                    allowedValues: ["custom", "system", "external"]
                }
            },
            externalId: {
                serializedName: "properties.externalId",
                xmlName: "properties.externalId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserCollection = {
    serializedName: "UserCollection",
    type: {
        name: "Composite",
        className: "UserCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "UserContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UserContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserEntityBaseParameters = {
    serializedName: "UserEntityBaseParameters",
    type: {
        name: "Composite",
        className: "UserEntityBaseParameters",
        modelProperties: {
            state: {
                defaultValue: "active",
                serializedName: "state",
                xmlName: "state",
                type: {
                    name: "String"
                }
            },
            note: {
                serializedName: "note",
                xmlName: "note",
                type: {
                    name: "String"
                }
            },
            identities: {
                serializedName: "identities",
                xmlName: "identities",
                xmlElementName: "UserIdentityContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UserIdentityContract"
                        }
                    }
                }
            }
        }
    }
};
const UserIdentityContract = {
    serializedName: "UserIdentityContract",
    type: {
        name: "Composite",
        className: "UserIdentityContract",
        modelProperties: {
            provider: {
                serializedName: "provider",
                xmlName: "provider",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdentityProviderList = {
    serializedName: "IdentityProviderList",
    type: {
        name: "Composite",
        className: "IdentityProviderList",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "IdentityProviderContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IdentityProviderContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdentityProviderBaseParameters = {
    serializedName: "IdentityProviderBaseParameters",
    type: {
        name: "Composite",
        className: "IdentityProviderBaseParameters",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String"
                }
            },
            signinTenant: {
                serializedName: "signinTenant",
                xmlName: "signinTenant",
                type: {
                    name: "String"
                }
            },
            allowedTenants: {
                constraints: {
                    MaxItems: 32
                },
                serializedName: "allowedTenants",
                xmlName: "allowedTenants",
                xmlElementName: "IdentityProviderBaseParametersAllowedTenantsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            authority: {
                serializedName: "authority",
                xmlName: "authority",
                type: {
                    name: "String"
                }
            },
            signupPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "signupPolicyName",
                xmlName: "signupPolicyName",
                type: {
                    name: "String"
                }
            },
            signinPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "signinPolicyName",
                xmlName: "signinPolicyName",
                type: {
                    name: "String"
                }
            },
            profileEditingPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "profileEditingPolicyName",
                xmlName: "profileEditingPolicyName",
                type: {
                    name: "String"
                }
            },
            passwordResetPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "passwordResetPolicyName",
                xmlName: "passwordResetPolicyName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdentityProviderUpdateParameters = {
    serializedName: "IdentityProviderUpdateParameters",
    type: {
        name: "Composite",
        className: "IdentityProviderUpdateParameters",
        modelProperties: {
            type: {
                serializedName: "properties.type",
                xmlName: "properties.type",
                type: {
                    name: "String"
                }
            },
            signinTenant: {
                serializedName: "properties.signinTenant",
                xmlName: "properties.signinTenant",
                type: {
                    name: "String"
                }
            },
            allowedTenants: {
                constraints: {
                    MaxItems: 32
                },
                serializedName: "properties.allowedTenants",
                xmlName: "properties.allowedTenants",
                xmlElementName: "IdentityProviderBaseParametersAllowedTenantsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            authority: {
                serializedName: "properties.authority",
                xmlName: "properties.authority",
                type: {
                    name: "String"
                }
            },
            signupPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.signupPolicyName",
                xmlName: "properties.signupPolicyName",
                type: {
                    name: "String"
                }
            },
            signinPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.signinPolicyName",
                xmlName: "properties.signinPolicyName",
                type: {
                    name: "String"
                }
            },
            profileEditingPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.profileEditingPolicyName",
                xmlName: "properties.profileEditingPolicyName",
                type: {
                    name: "String"
                }
            },
            passwordResetPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.passwordResetPolicyName",
                xmlName: "properties.passwordResetPolicyName",
                type: {
                    name: "String"
                }
            },
            clientId: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.clientId",
                xmlName: "properties.clientId",
                type: {
                    name: "String"
                }
            },
            clientSecret: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.clientSecret",
                xmlName: "properties.clientSecret",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClientSecretContract = {
    serializedName: "ClientSecretContract",
    type: {
        name: "Composite",
        className: "ClientSecretContract",
        modelProperties: {
            clientSecret: {
                serializedName: "clientSecret",
                xmlName: "clientSecret",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoggerCollection = {
    serializedName: "LoggerCollection",
    type: {
        name: "Composite",
        className: "LoggerCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "LoggerContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoggerContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoggerUpdateContract = {
    serializedName: "LoggerUpdateContract",
    type: {
        name: "Composite",
        className: "LoggerUpdateContract",
        modelProperties: {
            loggerType: {
                serializedName: "properties.loggerType",
                xmlName: "properties.loggerType",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "properties.credentials",
                xmlName: "properties.credentials",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            isBuffered: {
                serializedName: "properties.isBuffered",
                xmlName: "properties.isBuffered",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const NamedValueCollection = {
    serializedName: "NamedValueCollection",
    type: {
        name: "Composite",
        className: "NamedValueCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "NamedValueContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NamedValueContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NamedValueEntityBaseParameters = {
    serializedName: "NamedValueEntityBaseParameters",
    type: {
        name: "Composite",
        className: "NamedValueEntityBaseParameters",
        modelProperties: {
            tags: {
                constraints: {
                    MaxItems: 32
                },
                serializedName: "tags",
                xmlName: "tags",
                xmlElementName: "NamedValueEntityBaseParametersTagsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            secret: {
                serializedName: "secret",
                xmlName: "secret",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const NamedValueUpdateParameters = {
    serializedName: "NamedValueUpdateParameters",
    type: {
        name: "Composite",
        className: "NamedValueUpdateParameters",
        modelProperties: {
            tags: {
                constraints: {
                    MaxItems: 32
                },
                serializedName: "properties.tags",
                xmlName: "properties.tags",
                xmlElementName: "NamedValueEntityBaseParametersTagsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            secret: {
                serializedName: "properties.secret",
                xmlName: "properties.secret",
                type: {
                    name: "Boolean"
                }
            },
            displayName: {
                constraints: {
                    Pattern: new RegExp("^[A-Za-z0-9-._]+$"),
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            value: {
                constraints: {
                    MaxLength: 4096,
                    MinLength: 1
                },
                serializedName: "properties.value",
                xmlName: "properties.value",
                type: {
                    name: "String"
                }
            },
            keyVault: {
                serializedName: "properties.keyVault",
                xmlName: "properties.keyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultContractCreateProperties"
                }
            }
        }
    }
};
const NamedValueSecretContract = {
    serializedName: "NamedValueSecretContract",
    type: {
        name: "Composite",
        className: "NamedValueSecretContract",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkStatusContractByLocation = {
    serializedName: "NetworkStatusContractByLocation",
    type: {
        name: "Composite",
        className: "NetworkStatusContractByLocation",
        modelProperties: {
            location: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "location",
                xmlName: "location",
                type: {
                    name: "String"
                }
            },
            networkStatus: {
                serializedName: "networkStatus",
                xmlName: "networkStatus",
                type: {
                    name: "Composite",
                    className: "NetworkStatusContract"
                }
            }
        }
    }
};
const NetworkStatusContract = {
    serializedName: "NetworkStatusContract",
    type: {
        name: "Composite",
        className: "NetworkStatusContract",
        modelProperties: {
            dnsServers: {
                serializedName: "dnsServers",
                required: true,
                xmlName: "dnsServers",
                xmlElementName: "NetworkStatusContractDnsServersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            connectivityStatus: {
                serializedName: "connectivityStatus",
                required: true,
                xmlName: "connectivityStatus",
                xmlElementName: "ConnectivityStatusContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityStatusContract"
                        }
                    }
                }
            }
        }
    }
};
const ConnectivityStatusContract = {
    serializedName: "ConnectivityStatusContract",
    type: {
        name: "Composite",
        className: "ConnectivityStatusContract",
        modelProperties: {
            name: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                xmlName: "status",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "String"
                }
            },
            lastUpdated: {
                serializedName: "lastUpdated",
                required: true,
                xmlName: "lastUpdated",
                type: {
                    name: "DateTime"
                }
            },
            lastStatusChange: {
                serializedName: "lastStatusChange",
                required: true,
                xmlName: "lastStatusChange",
                type: {
                    name: "DateTime"
                }
            },
            resourceType: {
                serializedName: "resourceType",
                required: true,
                xmlName: "resourceType",
                type: {
                    name: "String"
                }
            },
            isOptional: {
                serializedName: "isOptional",
                required: true,
                xmlName: "isOptional",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const NotificationCollection = {
    serializedName: "NotificationCollection",
    type: {
        name: "Composite",
        className: "NotificationCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "NotificationContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NotificationContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RecipientsContractProperties = {
    serializedName: "RecipientsContractProperties",
    type: {
        name: "Composite",
        className: "RecipientsContractProperties",
        modelProperties: {
            emails: {
                serializedName: "emails",
                xmlName: "emails",
                xmlElementName: "RecipientsContractPropertiesEmailsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            users: {
                serializedName: "users",
                xmlName: "users",
                xmlElementName: "RecipientsContractPropertiesUsersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RecipientUserCollection = {
    serializedName: "RecipientUserCollection",
    type: {
        name: "Composite",
        className: "RecipientUserCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "RecipientUserContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecipientUserContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RecipientEmailCollection = {
    serializedName: "RecipientEmailCollection",
    type: {
        name: "Composite",
        className: "RecipientEmailCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "RecipientEmailContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecipientEmailContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenIdConnectProviderCollection = {
    serializedName: "OpenIdConnectProviderCollection",
    type: {
        name: "Composite",
        className: "OpenIdConnectProviderCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "OpenidConnectProviderContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OpenidConnectProviderContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenidConnectProviderUpdateContract = {
    serializedName: "OpenidConnectProviderUpdateContract",
    type: {
        name: "Composite",
        className: "OpenidConnectProviderUpdateContract",
        modelProperties: {
            displayName: {
                constraints: {
                    MaxLength: 50
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            metadataEndpoint: {
                serializedName: "properties.metadataEndpoint",
                xmlName: "properties.metadataEndpoint",
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "properties.clientId",
                xmlName: "properties.clientId",
                type: {
                    name: "String"
                }
            },
            clientSecret: {
                serializedName: "properties.clientSecret",
                xmlName: "properties.clientSecret",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OutboundEnvironmentEndpointList = {
    serializedName: "OutboundEnvironmentEndpointList",
    type: {
        name: "Composite",
        className: "OutboundEnvironmentEndpointList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "OutboundEnvironmentEndpoint",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutboundEnvironmentEndpoint"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OutboundEnvironmentEndpoint = {
    serializedName: "OutboundEnvironmentEndpoint",
    type: {
        name: "Composite",
        className: "OutboundEnvironmentEndpoint",
        modelProperties: {
            category: {
                serializedName: "category",
                xmlName: "category",
                type: {
                    name: "String"
                }
            },
            endpoints: {
                serializedName: "endpoints",
                xmlName: "endpoints",
                xmlElementName: "EndpointDependency",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointDependency"
                        }
                    }
                }
            }
        }
    }
};
const EndpointDependency = {
    serializedName: "EndpointDependency",
    type: {
        name: "Composite",
        className: "EndpointDependency",
        modelProperties: {
            domainName: {
                serializedName: "domainName",
                xmlName: "domainName",
                type: {
                    name: "String"
                }
            },
            endpointDetails: {
                serializedName: "endpointDetails",
                xmlName: "endpointDetails",
                xmlElementName: "EndpointDetail",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointDetail"
                        }
                    }
                }
            }
        }
    }
};
const EndpointDetail = {
    serializedName: "EndpointDetail",
    type: {
        name: "Composite",
        className: "EndpointDetail",
        modelProperties: {
            port: {
                serializedName: "port",
                xmlName: "port",
                type: {
                    name: "Number"
                }
            },
            region: {
                serializedName: "region",
                xmlName: "region",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicyDescriptionCollection = {
    serializedName: "PolicyDescriptionCollection",
    type: {
        name: "Composite",
        className: "PolicyDescriptionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "PolicyDescriptionContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PolicyDescriptionContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PortalRevisionCollection = {
    serializedName: "PortalRevisionCollection",
    type: {
        name: "Composite",
        className: "PortalRevisionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "PortalRevisionContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PortalRevisionContract"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PortalSettingsCollection = {
    serializedName: "PortalSettingsCollection",
    type: {
        name: "Composite",
        className: "PortalSettingsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "PortalSettingsContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PortalSettingsContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SubscriptionsDelegationSettingsProperties = {
    serializedName: "SubscriptionsDelegationSettingsProperties",
    type: {
        name: "Composite",
        className: "SubscriptionsDelegationSettingsProperties",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const RegistrationDelegationSettingsProperties = {
    serializedName: "RegistrationDelegationSettingsProperties",
    type: {
        name: "Composite",
        className: "RegistrationDelegationSettingsProperties",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const TermsOfServiceProperties = {
    serializedName: "TermsOfServiceProperties",
    type: {
        name: "Composite",
        className: "TermsOfServiceProperties",
        modelProperties: {
            text: {
                serializedName: "text",
                xmlName: "text",
                type: {
                    name: "String"
                }
            },
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            consentRequired: {
                serializedName: "consentRequired",
                xmlName: "consentRequired",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const PortalSettingValidationKeyContract = {
    serializedName: "PortalSettingValidationKeyContract",
    type: {
        name: "Composite",
        className: "PortalSettingValidationKeyContract",
        modelProperties: {
            validationKey: {
                serializedName: "validationKey",
                xmlName: "validationKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    serializedName: "PrivateEndpointConnectionListResult",
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "PrivateEndpointConnection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }
        }
    }
};
const PrivateEndpoint = {
    serializedName: "PrivateEndpoint",
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionRequest = {
    serializedName: "PrivateEndpointConnectionRequest",
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionRequest",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Composite",
                    className: "PrivateEndpointConnectionRequestProperties"
                }
            }
        }
    }
};
const PrivateEndpointConnectionRequestProperties = {
    serializedName: "PrivateEndpointConnectionRequestProperties",
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionRequestProperties",
        modelProperties: {
            privateLinkServiceConnectionState: {
                serializedName: "privateLinkServiceConnectionState",
                xmlName: "privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    serializedName: "PrivateLinkResourceListResult",
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "PrivateLinkResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const ProductUpdateParameters = {
    serializedName: "ProductUpdateParameters",
    type: {
        name: "Composite",
        className: "ProductUpdateParameters",
        modelProperties: {
            description: {
                constraints: {
                    MaxLength: 1000
                },
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            },
            terms: {
                serializedName: "properties.terms",
                xmlName: "properties.terms",
                type: {
                    name: "String"
                }
            },
            subscriptionRequired: {
                serializedName: "properties.subscriptionRequired",
                xmlName: "properties.subscriptionRequired",
                type: {
                    name: "Boolean"
                }
            },
            approvalRequired: {
                serializedName: "properties.approvalRequired",
                xmlName: "properties.approvalRequired",
                type: {
                    name: "Boolean"
                }
            },
            subscriptionsLimit: {
                serializedName: "properties.subscriptionsLimit",
                xmlName: "properties.subscriptionsLimit",
                type: {
                    name: "Number"
                }
            },
            state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["notPublished", "published"]
                }
            },
            displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubscriptionCollection = {
    serializedName: "SubscriptionCollection",
    type: {
        name: "Composite",
        className: "SubscriptionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "SubscriptionContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubscriptionContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QuotaCounterCollection = {
    serializedName: "QuotaCounterCollection",
    type: {
        name: "Composite",
        className: "QuotaCounterCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "QuotaCounterContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QuotaCounterContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QuotaCounterContract = {
    serializedName: "QuotaCounterContract",
    type: {
        name: "Composite",
        className: "QuotaCounterContract",
        modelProperties: {
            counterKey: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "counterKey",
                required: true,
                xmlName: "counterKey",
                type: {
                    name: "String"
                }
            },
            periodKey: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "periodKey",
                required: true,
                xmlName: "periodKey",
                type: {
                    name: "String"
                }
            },
            periodStartTime: {
                serializedName: "periodStartTime",
                required: true,
                xmlName: "periodStartTime",
                type: {
                    name: "DateTime"
                }
            },
            periodEndTime: {
                serializedName: "periodEndTime",
                required: true,
                xmlName: "periodEndTime",
                type: {
                    name: "DateTime"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "Composite",
                    className: "QuotaCounterValueContractProperties"
                }
            }
        }
    }
};
const QuotaCounterValueContractProperties = {
    serializedName: "QuotaCounterValueContractProperties",
    type: {
        name: "Composite",
        className: "QuotaCounterValueContractProperties",
        modelProperties: {
            callsCount: {
                serializedName: "callsCount",
                xmlName: "callsCount",
                type: {
                    name: "Number"
                }
            },
            kbTransferred: {
                serializedName: "kbTransferred",
                xmlName: "kbTransferred",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const QuotaCounterValueUpdateContract = {
    serializedName: "QuotaCounterValueUpdateContract",
    type: {
        name: "Composite",
        className: "QuotaCounterValueUpdateContract",
        modelProperties: {
            callsCount: {
                serializedName: "properties.callsCount",
                xmlName: "properties.callsCount",
                type: {
                    name: "Number"
                }
            },
            kbTransferred: {
                serializedName: "properties.kbTransferred",
                xmlName: "properties.kbTransferred",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const RegionListResult = {
    serializedName: "RegionListResult",
    type: {
        name: "Composite",
        className: "RegionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "RegionContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegionContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RegionContract = {
    serializedName: "RegionContract",
    type: {
        name: "Composite",
        className: "RegionContract",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            isMasterRegion: {
                serializedName: "isMasterRegion",
                xmlName: "isMasterRegion",
                type: {
                    name: "Boolean"
                }
            },
            isDeleted: {
                serializedName: "isDeleted",
                xmlName: "isDeleted",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ReportCollection = {
    serializedName: "ReportCollection",
    type: {
        name: "Composite",
        className: "ReportCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "ReportRecordContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ReportRecordContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReportRecordContract = {
    serializedName: "ReportRecordContract",
    type: {
        name: "Composite",
        className: "ReportRecordContract",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                xmlName: "timestamp",
                type: {
                    name: "DateTime"
                }
            },
            interval: {
                serializedName: "interval",
                xmlName: "interval",
                type: {
                    name: "String"
                }
            },
            country: {
                serializedName: "country",
                xmlName: "country",
                type: {
                    name: "String"
                }
            },
            region: {
                serializedName: "region",
                xmlName: "region",
                type: {
                    name: "String"
                }
            },
            zip: {
                serializedName: "zip",
                xmlName: "zip",
                type: {
                    name: "String"
                }
            },
            userId: {
                serializedName: "userId",
                readOnly: true,
                xmlName: "userId",
                type: {
                    name: "String"
                }
            },
            productId: {
                serializedName: "productId",
                readOnly: true,
                xmlName: "productId",
                type: {
                    name: "String"
                }
            },
            apiId: {
                serializedName: "apiId",
                xmlName: "apiId",
                type: {
                    name: "String"
                }
            },
            operationId: {
                serializedName: "operationId",
                xmlName: "operationId",
                type: {
                    name: "String"
                }
            },
            apiRegion: {
                serializedName: "apiRegion",
                xmlName: "apiRegion",
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                xmlName: "subscriptionId",
                type: {
                    name: "String"
                }
            },
            callCountSuccess: {
                serializedName: "callCountSuccess",
                xmlName: "callCountSuccess",
                type: {
                    name: "Number"
                }
            },
            callCountBlocked: {
                serializedName: "callCountBlocked",
                xmlName: "callCountBlocked",
                type: {
                    name: "Number"
                }
            },
            callCountFailed: {
                serializedName: "callCountFailed",
                xmlName: "callCountFailed",
                type: {
                    name: "Number"
                }
            },
            callCountOther: {
                serializedName: "callCountOther",
                xmlName: "callCountOther",
                type: {
                    name: "Number"
                }
            },
            callCountTotal: {
                serializedName: "callCountTotal",
                xmlName: "callCountTotal",
                type: {
                    name: "Number"
                }
            },
            bandwidth: {
                serializedName: "bandwidth",
                xmlName: "bandwidth",
                type: {
                    name: "Number"
                }
            },
            cacheHitCount: {
                serializedName: "cacheHitCount",
                xmlName: "cacheHitCount",
                type: {
                    name: "Number"
                }
            },
            cacheMissCount: {
                serializedName: "cacheMissCount",
                xmlName: "cacheMissCount",
                type: {
                    name: "Number"
                }
            },
            apiTimeAvg: {
                serializedName: "apiTimeAvg",
                xmlName: "apiTimeAvg",
                type: {
                    name: "Number"
                }
            },
            apiTimeMin: {
                serializedName: "apiTimeMin",
                xmlName: "apiTimeMin",
                type: {
                    name: "Number"
                }
            },
            apiTimeMax: {
                serializedName: "apiTimeMax",
                xmlName: "apiTimeMax",
                type: {
                    name: "Number"
                }
            },
            serviceTimeAvg: {
                serializedName: "serviceTimeAvg",
                xmlName: "serviceTimeAvg",
                type: {
                    name: "Number"
                }
            },
            serviceTimeMin: {
                serializedName: "serviceTimeMin",
                xmlName: "serviceTimeMin",
                type: {
                    name: "Number"
                }
            },
            serviceTimeMax: {
                serializedName: "serviceTimeMax",
                xmlName: "serviceTimeMax",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const RequestReportCollection = {
    serializedName: "RequestReportCollection",
    type: {
        name: "Composite",
        className: "RequestReportCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "RequestReportRecordContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RequestReportRecordContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const RequestReportRecordContract = {
    serializedName: "RequestReportRecordContract",
    type: {
        name: "Composite",
        className: "RequestReportRecordContract",
        modelProperties: {
            apiId: {
                serializedName: "apiId",
                xmlName: "apiId",
                type: {
                    name: "String"
                }
            },
            operationId: {
                serializedName: "operationId",
                xmlName: "operationId",
                type: {
                    name: "String"
                }
            },
            productId: {
                serializedName: "productId",
                readOnly: true,
                xmlName: "productId",
                type: {
                    name: "String"
                }
            },
            userId: {
                serializedName: "userId",
                readOnly: true,
                xmlName: "userId",
                type: {
                    name: "String"
                }
            },
            method: {
                serializedName: "method",
                xmlName: "method",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                xmlName: "url",
                type: {
                    name: "String"
                }
            },
            ipAddress: {
                serializedName: "ipAddress",
                xmlName: "ipAddress",
                type: {
                    name: "String"
                }
            },
            backendResponseCode: {
                serializedName: "backendResponseCode",
                xmlName: "backendResponseCode",
                type: {
                    name: "String"
                }
            },
            responseCode: {
                serializedName: "responseCode",
                xmlName: "responseCode",
                type: {
                    name: "Number"
                }
            },
            responseSize: {
                serializedName: "responseSize",
                xmlName: "responseSize",
                type: {
                    name: "Number"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                xmlName: "timestamp",
                type: {
                    name: "DateTime"
                }
            },
            cache: {
                serializedName: "cache",
                xmlName: "cache",
                type: {
                    name: "String"
                }
            },
            apiTime: {
                serializedName: "apiTime",
                xmlName: "apiTime",
                type: {
                    name: "Number"
                }
            },
            serviceTime: {
                serializedName: "serviceTime",
                xmlName: "serviceTime",
                type: {
                    name: "Number"
                }
            },
            apiRegion: {
                serializedName: "apiRegion",
                xmlName: "apiRegion",
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                xmlName: "subscriptionId",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "requestId",
                xmlName: "requestId",
                type: {
                    name: "String"
                }
            },
            requestSize: {
                serializedName: "requestSize",
                xmlName: "requestSize",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TenantSettingsCollection = {
    serializedName: "TenantSettingsCollection",
    type: {
        name: "Composite",
        className: "TenantSettingsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "TenantSettingsContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TenantSettingsContract"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiManagementSkusResult = {
    serializedName: "ApiManagementSkusResult",
    type: {
        name: "Composite",
        className: "ApiManagementSkusResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ApiManagementSku",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiManagementSku"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiManagementSku = {
    serializedName: "ApiManagementSku",
    type: {
        name: "Composite",
        className: "ApiManagementSku",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                xmlName: "resourceType",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                xmlName: "tier",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                readOnly: true,
                xmlName: "size",
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                readOnly: true,
                xmlName: "family",
                type: {
                    name: "String"
                }
            },
            kind: {
                serializedName: "kind",
                readOnly: true,
                xmlName: "kind",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                xmlName: "capacity",
                type: {
                    name: "Composite",
                    className: "ApiManagementSkuCapacity"
                }
            },
            locations: {
                serializedName: "locations",
                readOnly: true,
                xmlName: "locations",
                xmlElementName: "ApiManagementSkuLocationsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            locationInfo: {
                serializedName: "locationInfo",
                readOnly: true,
                xmlName: "locationInfo",
                xmlElementName: "ApiManagementSkuLocationInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiManagementSkuLocationInfo"
                        }
                    }
                }
            },
            apiVersions: {
                serializedName: "apiVersions",
                readOnly: true,
                xmlName: "apiVersions",
                xmlElementName: "ApiManagementSkuApiVersionsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            costs: {
                serializedName: "costs",
                readOnly: true,
                xmlName: "costs",
                xmlElementName: "ApiManagementSkuCosts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiManagementSkuCosts"
                        }
                    }
                }
            },
            capabilities: {
                serializedName: "capabilities",
                readOnly: true,
                xmlName: "capabilities",
                xmlElementName: "ApiManagementSkuCapabilities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiManagementSkuCapabilities"
                        }
                    }
                }
            },
            restrictions: {
                serializedName: "restrictions",
                readOnly: true,
                xmlName: "restrictions",
                xmlElementName: "ApiManagementSkuRestrictions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiManagementSkuRestrictions"
                        }
                    }
                }
            }
        }
    }
};
const ApiManagementSkuCapacity = {
    serializedName: "ApiManagementSkuCapacity",
    type: {
        name: "Composite",
        className: "ApiManagementSkuCapacity",
        modelProperties: {
            minimum: {
                serializedName: "minimum",
                readOnly: true,
                xmlName: "minimum",
                type: {
                    name: "Number"
                }
            },
            maximum: {
                serializedName: "maximum",
                readOnly: true,
                xmlName: "maximum",
                type: {
                    name: "Number"
                }
            },
            default: {
                serializedName: "default",
                readOnly: true,
                xmlName: "default",
                type: {
                    name: "Number"
                }
            },
            scaleType: {
                serializedName: "scaleType",
                readOnly: true,
                xmlName: "scaleType",
                type: {
                    name: "Enum",
                    allowedValues: ["Automatic", "Manual", "None"]
                }
            }
        }
    }
};
const ApiManagementSkuLocationInfo = {
    serializedName: "ApiManagementSkuLocationInfo",
    type: {
        name: "Composite",
        className: "ApiManagementSkuLocationInfo",
        modelProperties: {
            location: {
                serializedName: "location",
                readOnly: true,
                xmlName: "location",
                type: {
                    name: "String"
                }
            },
            zones: {
                serializedName: "zones",
                readOnly: true,
                xmlName: "zones",
                xmlElementName: "ApiManagementSkuLocationInfoZonesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            zoneDetails: {
                serializedName: "zoneDetails",
                readOnly: true,
                xmlName: "zoneDetails",
                xmlElementName: "ApiManagementSkuZoneDetails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiManagementSkuZoneDetails"
                        }
                    }
                }
            }
        }
    }
};
const ApiManagementSkuZoneDetails = {
    serializedName: "ApiManagementSkuZoneDetails",
    type: {
        name: "Composite",
        className: "ApiManagementSkuZoneDetails",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                xmlElementName: "ApiManagementSkuZoneDetailsNameItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            capabilities: {
                serializedName: "capabilities",
                readOnly: true,
                xmlName: "capabilities",
                xmlElementName: "ApiManagementSkuCapabilities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiManagementSkuCapabilities"
                        }
                    }
                }
            }
        }
    }
};
const ApiManagementSkuCapabilities = {
    serializedName: "ApiManagementSkuCapabilities",
    type: {
        name: "Composite",
        className: "ApiManagementSkuCapabilities",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiManagementSkuCosts = {
    serializedName: "ApiManagementSkuCosts",
    type: {
        name: "Composite",
        className: "ApiManagementSkuCosts",
        modelProperties: {
            meterID: {
                serializedName: "meterID",
                readOnly: true,
                xmlName: "meterID",
                type: {
                    name: "String"
                }
            },
            quantity: {
                serializedName: "quantity",
                readOnly: true,
                xmlName: "quantity",
                type: {
                    name: "Number"
                }
            },
            extendedUnit: {
                serializedName: "extendedUnit",
                readOnly: true,
                xmlName: "extendedUnit",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiManagementSkuRestrictions = {
    serializedName: "ApiManagementSkuRestrictions",
    type: {
        name: "Composite",
        className: "ApiManagementSkuRestrictions",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["Location", "Zone"]
                }
            },
            values: {
                serializedName: "values",
                readOnly: true,
                xmlName: "values",
                xmlElementName: "ApiManagementSkuRestrictionsValuesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            restrictionInfo: {
                serializedName: "restrictionInfo",
                xmlName: "restrictionInfo",
                type: {
                    name: "Composite",
                    className: "ApiManagementSkuRestrictionInfo"
                }
            },
            reasonCode: {
                serializedName: "reasonCode",
                readOnly: true,
                xmlName: "reasonCode",
                type: {
                    name: "Enum",
                    allowedValues: ["QuotaId", "NotAvailableForSubscription"]
                }
            }
        }
    }
};
const ApiManagementSkuRestrictionInfo = {
    serializedName: "ApiManagementSkuRestrictionInfo",
    type: {
        name: "Composite",
        className: "ApiManagementSkuRestrictionInfo",
        modelProperties: {
            locations: {
                serializedName: "locations",
                readOnly: true,
                xmlName: "locations",
                xmlElementName: "ApiManagementSkuRestrictionInfoLocationsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            zones: {
                serializedName: "zones",
                readOnly: true,
                xmlName: "zones",
                xmlElementName: "ApiManagementSkuRestrictionInfoZonesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const SubscriptionCreateParameters = {
    serializedName: "SubscriptionCreateParameters",
    type: {
        name: "Composite",
        className: "SubscriptionCreateParameters",
        modelProperties: {
            ownerId: {
                serializedName: "properties.ownerId",
                xmlName: "properties.ownerId",
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                xmlName: "properties.scope",
                type: {
                    name: "String"
                }
            },
            displayName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            primaryKey: {
                constraints: {
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "properties.primaryKey",
                xmlName: "properties.primaryKey",
                type: {
                    name: "String"
                }
            },
            secondaryKey: {
                constraints: {
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "properties.secondaryKey",
                xmlName: "properties.secondaryKey",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "suspended",
                        "active",
                        "expired",
                        "submitted",
                        "rejected",
                        "cancelled"
                    ]
                }
            },
            allowTracing: {
                serializedName: "properties.allowTracing",
                xmlName: "properties.allowTracing",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SubscriptionUpdateParameters = {
    serializedName: "SubscriptionUpdateParameters",
    type: {
        name: "Composite",
        className: "SubscriptionUpdateParameters",
        modelProperties: {
            ownerId: {
                serializedName: "properties.ownerId",
                xmlName: "properties.ownerId",
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                xmlName: "properties.scope",
                type: {
                    name: "String"
                }
            },
            expirationDate: {
                serializedName: "properties.expirationDate",
                xmlName: "properties.expirationDate",
                type: {
                    name: "DateTime"
                }
            },
            displayName: {
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            primaryKey: {
                constraints: {
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "properties.primaryKey",
                xmlName: "properties.primaryKey",
                type: {
                    name: "String"
                }
            },
            secondaryKey: {
                constraints: {
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "properties.secondaryKey",
                xmlName: "properties.secondaryKey",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "suspended",
                        "active",
                        "expired",
                        "submitted",
                        "rejected",
                        "cancelled"
                    ]
                }
            },
            stateComment: {
                serializedName: "properties.stateComment",
                xmlName: "properties.stateComment",
                type: {
                    name: "String"
                }
            },
            allowTracing: {
                serializedName: "properties.allowTracing",
                xmlName: "properties.allowTracing",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SubscriptionKeysContract = {
    serializedName: "SubscriptionKeysContract",
    type: {
        name: "Composite",
        className: "SubscriptionKeysContract",
        modelProperties: {
            primaryKey: {
                constraints: {
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "primaryKey",
                xmlName: "primaryKey",
                type: {
                    name: "String"
                }
            },
            secondaryKey: {
                constraints: {
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "secondaryKey",
                xmlName: "secondaryKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagCreateUpdateParameters = {
    serializedName: "TagCreateUpdateParameters",
    type: {
        name: "Composite",
        className: "TagCreateUpdateParameters",
        modelProperties: {
            displayName: {
                constraints: {
                    MaxLength: 160,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AccessInformationCollection = {
    serializedName: "AccessInformationCollection",
    type: {
        name: "Composite",
        className: "AccessInformationCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                xmlElementName: "AccessInformationContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AccessInformationContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AccessInformationCreateParameters = {
    serializedName: "AccessInformationCreateParameters",
    type: {
        name: "Composite",
        className: "AccessInformationCreateParameters",
        modelProperties: {
            principalId: {
                serializedName: "properties.principalId",
                xmlName: "properties.principalId",
                type: {
                    name: "String"
                }
            },
            primaryKey: {
                serializedName: "properties.primaryKey",
                xmlName: "properties.primaryKey",
                type: {
                    name: "String"
                }
            },
            secondaryKey: {
                serializedName: "properties.secondaryKey",
                xmlName: "properties.secondaryKey",
                type: {
                    name: "String"
                }
            },
            enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AccessInformationUpdateParameters = {
    serializedName: "AccessInformationUpdateParameters",
    type: {
        name: "Composite",
        className: "AccessInformationUpdateParameters",
        modelProperties: {
            enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AccessInformationSecretsContract = {
    serializedName: "AccessInformationSecretsContract",
    type: {
        name: "Composite",
        className: "AccessInformationSecretsContract",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "principalId",
                xmlName: "principalId",
                type: {
                    name: "String"
                }
            },
            primaryKey: {
                serializedName: "primaryKey",
                xmlName: "primaryKey",
                type: {
                    name: "String"
                }
            },
            secondaryKey: {
                serializedName: "secondaryKey",
                xmlName: "secondaryKey",
                type: {
                    name: "String"
                }
            },
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DeployConfigurationParameters = {
    serializedName: "DeployConfigurationParameters",
    type: {
        name: "Composite",
        className: "DeployConfigurationParameters",
        modelProperties: {
            branch: {
                serializedName: "properties.branch",
                xmlName: "properties.branch",
                type: {
                    name: "String"
                }
            },
            force: {
                serializedName: "properties.force",
                xmlName: "properties.force",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const OperationResultLogItemContract = {
    serializedName: "OperationResultLogItemContract",
    type: {
        name: "Composite",
        className: "OperationResultLogItemContract",
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                xmlName: "objectType",
                type: {
                    name: "String"
                }
            },
            action: {
                serializedName: "action",
                xmlName: "action",
                type: {
                    name: "String"
                }
            },
            objectKey: {
                serializedName: "objectKey",
                xmlName: "objectKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SaveConfigurationParameter = {
    serializedName: "SaveConfigurationParameter",
    type: {
        name: "Composite",
        className: "SaveConfigurationParameter",
        modelProperties: {
            branch: {
                serializedName: "properties.branch",
                xmlName: "properties.branch",
                type: {
                    name: "String"
                }
            },
            force: {
                serializedName: "properties.force",
                xmlName: "properties.force",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const UserCreateParameters = {
    serializedName: "UserCreateParameters",
    type: {
        name: "Composite",
        className: "UserCreateParameters",
        modelProperties: {
            state: {
                defaultValue: "active",
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "String"
                }
            },
            note: {
                serializedName: "properties.note",
                xmlName: "properties.note",
                type: {
                    name: "String"
                }
            },
            identities: {
                serializedName: "properties.identities",
                xmlName: "properties.identities",
                xmlElementName: "UserIdentityContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UserIdentityContract"
                        }
                    }
                }
            },
            email: {
                constraints: {
                    MaxLength: 254,
                    MinLength: 1
                },
                serializedName: "properties.email",
                xmlName: "properties.email",
                type: {
                    name: "String"
                }
            },
            firstName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.firstName",
                xmlName: "properties.firstName",
                type: {
                    name: "String"
                }
            },
            lastName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.lastName",
                xmlName: "properties.lastName",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "properties.password",
                xmlName: "properties.password",
                type: {
                    name: "String"
                }
            },
            appType: {
                serializedName: "properties.appType",
                xmlName: "properties.appType",
                type: {
                    name: "String"
                }
            },
            confirmation: {
                serializedName: "properties.confirmation",
                xmlName: "properties.confirmation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserUpdateParameters = {
    serializedName: "UserUpdateParameters",
    type: {
        name: "Composite",
        className: "UserUpdateParameters",
        modelProperties: {
            state: {
                defaultValue: "active",
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "String"
                }
            },
            note: {
                serializedName: "properties.note",
                xmlName: "properties.note",
                type: {
                    name: "String"
                }
            },
            identities: {
                serializedName: "properties.identities",
                xmlName: "properties.identities",
                xmlElementName: "UserIdentityContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UserIdentityContract"
                        }
                    }
                }
            },
            email: {
                constraints: {
                    MaxLength: 254,
                    MinLength: 1
                },
                serializedName: "properties.email",
                xmlName: "properties.email",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "properties.password",
                xmlName: "properties.password",
                type: {
                    name: "String"
                }
            },
            firstName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.firstName",
                xmlName: "properties.firstName",
                type: {
                    name: "String"
                }
            },
            lastName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.lastName",
                xmlName: "properties.lastName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GenerateSsoUrlResult = {
    serializedName: "GenerateSsoUrlResult",
    type: {
        name: "Composite",
        className: "GenerateSsoUrlResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserIdentityCollection = {
    serializedName: "UserIdentityCollection",
    type: {
        name: "Composite",
        className: "UserIdentityCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "UserIdentityContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UserIdentityContract"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserTokenParameters = {
    serializedName: "UserTokenParameters",
    type: {
        name: "Composite",
        className: "UserTokenParameters",
        modelProperties: {
            keyType: {
                serializedName: "properties.keyType",
                xmlName: "properties.keyType",
                type: {
                    name: "Enum",
                    allowedValues: ["primary", "secondary"]
                }
            },
            expiry: {
                serializedName: "properties.expiry",
                xmlName: "properties.expiry",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const UserTokenResult = {
    serializedName: "UserTokenResult",
    type: {
        name: "Composite",
        className: "UserTokenResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiRevisionInfoContract = {
    serializedName: "ApiRevisionInfoContract",
    type: {
        name: "Composite",
        className: "ApiRevisionInfoContract",
        modelProperties: {
            sourceApiId: {
                serializedName: "sourceApiId",
                xmlName: "sourceApiId",
                type: {
                    name: "String"
                }
            },
            apiVersionName: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "apiVersionName",
                xmlName: "apiVersionName",
                type: {
                    name: "String"
                }
            },
            apiRevisionDescription: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "apiRevisionDescription",
                xmlName: "apiRevisionDescription",
                type: {
                    name: "String"
                }
            },
            apiVersionSet: {
                serializedName: "apiVersionSet",
                xmlName: "apiVersionSet",
                type: {
                    name: "Composite",
                    className: "ApiVersionSetContractDetails"
                }
            }
        }
    }
};
const QuotaCounterValueContract = {
    serializedName: "QuotaCounterValueContract",
    type: {
        name: "Composite",
        className: "QuotaCounterValueContract",
        modelProperties: {
            callsCount: {
                serializedName: "value.callsCount",
                xmlName: "value.callsCount",
                type: {
                    name: "Number"
                }
            },
            kbTransferred: {
                serializedName: "value.kbTransferred",
                xmlName: "value.kbTransferred",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ApiContractProperties = {
    serializedName: "ApiContractProperties",
    type: {
        name: "Composite",
        className: "ApiContractProperties",
        modelProperties: Object.assign(Object.assign({}, ApiEntityBaseContract.type.modelProperties), { sourceApiId: {
                serializedName: "sourceApiId",
                xmlName: "sourceApiId",
                type: {
                    name: "String"
                }
            }, displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            }, serviceUrl: {
                constraints: {
                    MaxLength: 2000
                },
                serializedName: "serviceUrl",
                xmlName: "serviceUrl",
                type: {
                    name: "String"
                }
            }, path: {
                constraints: {
                    MaxLength: 400
                },
                serializedName: "path",
                required: true,
                xmlName: "path",
                type: {
                    name: "String"
                }
            }, protocols: {
                serializedName: "protocols",
                xmlName: "protocols",
                xmlElementName: "Protocol",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, apiVersionSet: {
                serializedName: "apiVersionSet",
                xmlName: "apiVersionSet",
                type: {
                    name: "Composite",
                    className: "ApiVersionSetContractDetails"
                }
            } })
    }
};
const ApiContractUpdateProperties = {
    serializedName: "ApiContractUpdateProperties",
    type: {
        name: "Composite",
        className: "ApiContractUpdateProperties",
        modelProperties: Object.assign(Object.assign({}, ApiEntityBaseContract.type.modelProperties), { displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            }, serviceUrl: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "serviceUrl",
                xmlName: "serviceUrl",
                type: {
                    name: "String"
                }
            }, path: {
                constraints: {
                    MaxLength: 400
                },
                serializedName: "path",
                xmlName: "path",
                type: {
                    name: "String"
                }
            }, protocols: {
                serializedName: "protocols",
                xmlName: "protocols",
                xmlElementName: "Protocol",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ApiTagResourceContractProperties = {
    serializedName: "ApiTagResourceContractProperties",
    type: {
        name: "Composite",
        className: "ApiTagResourceContractProperties",
        modelProperties: Object.assign(Object.assign({}, ApiEntityBaseContract.type.modelProperties), { id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            }, name: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String"
                }
            }, serviceUrl: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "serviceUrl",
                xmlName: "serviceUrl",
                type: {
                    name: "String"
                }
            }, path: {
                constraints: {
                    MaxLength: 400
                },
                serializedName: "path",
                xmlName: "path",
                type: {
                    name: "String"
                }
            }, protocols: {
                serializedName: "protocols",
                xmlName: "protocols",
                xmlElementName: "Protocol",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ApiContract = {
    serializedName: "ApiContract",
    type: {
        name: "Composite",
        className: "ApiContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, authenticationSettings: {
                serializedName: "properties.authenticationSettings",
                xmlName: "properties.authenticationSettings",
                type: {
                    name: "Composite",
                    className: "AuthenticationSettingsContract"
                }
            }, subscriptionKeyParameterNames: {
                serializedName: "properties.subscriptionKeyParameterNames",
                xmlName: "properties.subscriptionKeyParameterNames",
                type: {
                    name: "Composite",
                    className: "SubscriptionKeyParameterNamesContract"
                }
            }, apiType: {
                serializedName: "properties.type",
                xmlName: "properties.type",
                type: {
                    name: "String"
                }
            }, apiRevision: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.apiRevision",
                xmlName: "properties.apiRevision",
                type: {
                    name: "String"
                }
            }, apiVersion: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "properties.apiVersion",
                xmlName: "properties.apiVersion",
                type: {
                    name: "String"
                }
            }, isCurrent: {
                serializedName: "properties.isCurrent",
                xmlName: "properties.isCurrent",
                type: {
                    name: "Boolean"
                }
            }, isOnline: {
                serializedName: "properties.isOnline",
                readOnly: true,
                xmlName: "properties.isOnline",
                type: {
                    name: "Boolean"
                }
            }, apiRevisionDescription: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "properties.apiRevisionDescription",
                xmlName: "properties.apiRevisionDescription",
                type: {
                    name: "String"
                }
            }, apiVersionDescription: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "properties.apiVersionDescription",
                xmlName: "properties.apiVersionDescription",
                type: {
                    name: "String"
                }
            }, apiVersionSetId: {
                serializedName: "properties.apiVersionSetId",
                xmlName: "properties.apiVersionSetId",
                type: {
                    name: "String"
                }
            }, subscriptionRequired: {
                serializedName: "properties.subscriptionRequired",
                xmlName: "properties.subscriptionRequired",
                type: {
                    name: "Boolean"
                }
            }, termsOfServiceUrl: {
                serializedName: "properties.termsOfServiceUrl",
                xmlName: "properties.termsOfServiceUrl",
                type: {
                    name: "String"
                }
            }, contact: {
                serializedName: "properties.contact",
                xmlName: "properties.contact",
                type: {
                    name: "Composite",
                    className: "ApiContactInformation"
                }
            }, license: {
                serializedName: "properties.license",
                xmlName: "properties.license",
                type: {
                    name: "Composite",
                    className: "ApiLicenseInformation"
                }
            }, sourceApiId: {
                serializedName: "properties.sourceApiId",
                xmlName: "properties.sourceApiId",
                type: {
                    name: "String"
                }
            }, displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, serviceUrl: {
                constraints: {
                    MaxLength: 2000
                },
                serializedName: "properties.serviceUrl",
                xmlName: "properties.serviceUrl",
                type: {
                    name: "String"
                }
            }, path: {
                constraints: {
                    MaxLength: 400
                },
                serializedName: "properties.path",
                xmlName: "properties.path",
                type: {
                    name: "String"
                }
            }, protocols: {
                serializedName: "properties.protocols",
                xmlName: "properties.protocols",
                xmlElementName: "Protocol",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, apiVersionSet: {
                serializedName: "properties.apiVersionSet",
                xmlName: "properties.apiVersionSet",
                type: {
                    name: "Composite",
                    className: "ApiVersionSetContractDetails"
                }
            } })
    }
};
const ApiReleaseContract = {
    serializedName: "ApiReleaseContract",
    type: {
        name: "Composite",
        className: "ApiReleaseContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { apiId: {
                serializedName: "properties.apiId",
                xmlName: "properties.apiId",
                type: {
                    name: "String"
                }
            }, createdDateTime: {
                serializedName: "properties.createdDateTime",
                readOnly: true,
                xmlName: "properties.createdDateTime",
                type: {
                    name: "DateTime"
                }
            }, updatedDateTime: {
                serializedName: "properties.updatedDateTime",
                readOnly: true,
                xmlName: "properties.updatedDateTime",
                type: {
                    name: "DateTime"
                }
            }, notes: {
                serializedName: "properties.notes",
                xmlName: "properties.notes",
                type: {
                    name: "String"
                }
            } })
    }
};
const OperationContract = {
    serializedName: "OperationContract",
    type: {
        name: "Composite",
        className: "OperationContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { templateParameters: {
                serializedName: "properties.templateParameters",
                xmlName: "properties.templateParameters",
                xmlElementName: "ParameterContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterContract"
                        }
                    }
                }
            }, description: {
                constraints: {
                    MaxLength: 1000
                },
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, request: {
                serializedName: "properties.request",
                xmlName: "properties.request",
                type: {
                    name: "Composite",
                    className: "RequestContract"
                }
            }, responses: {
                serializedName: "properties.responses",
                xmlName: "properties.responses",
                xmlElementName: "ResponseContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResponseContract"
                        }
                    }
                }
            }, policies: {
                serializedName: "properties.policies",
                xmlName: "properties.policies",
                type: {
                    name: "String"
                }
            }, displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, method: {
                serializedName: "properties.method",
                xmlName: "properties.method",
                type: {
                    name: "String"
                }
            }, urlTemplate: {
                constraints: {
                    MaxLength: 1000,
                    MinLength: 1
                },
                serializedName: "properties.urlTemplate",
                xmlName: "properties.urlTemplate",
                type: {
                    name: "String"
                }
            } })
    }
};
const PolicyContract = {
    serializedName: "PolicyContract",
    type: {
        name: "Composite",
        className: "PolicyContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { value: {
                serializedName: "properties.value",
                xmlName: "properties.value",
                type: {
                    name: "String"
                }
            }, format: {
                defaultValue: "xml",
                serializedName: "properties.format",
                xmlName: "properties.format",
                type: {
                    name: "String"
                }
            } })
    }
};
const TagContract = {
    serializedName: "TagContract",
    type: {
        name: "Composite",
        className: "TagContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { displayName: {
                constraints: {
                    MaxLength: 160,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            } })
    }
};
const ProductContract = {
    serializedName: "ProductContract",
    type: {
        name: "Composite",
        className: "ProductContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                constraints: {
                    MaxLength: 1000
                },
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, terms: {
                serializedName: "properties.terms",
                xmlName: "properties.terms",
                type: {
                    name: "String"
                }
            }, subscriptionRequired: {
                serializedName: "properties.subscriptionRequired",
                xmlName: "properties.subscriptionRequired",
                type: {
                    name: "Boolean"
                }
            }, approvalRequired: {
                serializedName: "properties.approvalRequired",
                xmlName: "properties.approvalRequired",
                type: {
                    name: "Boolean"
                }
            }, subscriptionsLimit: {
                serializedName: "properties.subscriptionsLimit",
                xmlName: "properties.subscriptionsLimit",
                type: {
                    name: "Number"
                }
            }, state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["notPublished", "published"]
                }
            }, displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            } })
    }
};
const SchemaContract = {
    serializedName: "SchemaContract",
    type: {
        name: "Composite",
        className: "SchemaContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { contentType: {
                serializedName: "properties.contentType",
                xmlName: "properties.contentType",
                type: {
                    name: "String"
                }
            }, value: {
                serializedName: "properties.document.value",
                xmlName: "properties.document.value",
                type: {
                    name: "String"
                }
            }, definitions: {
                serializedName: "properties.document.definitions",
                xmlName: "properties.document.definitions",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, components: {
                serializedName: "properties.document.components",
                xmlName: "properties.document.components",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const DiagnosticContract = {
    serializedName: "DiagnosticContract",
    type: {
        name: "Composite",
        className: "DiagnosticContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { alwaysLog: {
                serializedName: "properties.alwaysLog",
                xmlName: "properties.alwaysLog",
                type: {
                    name: "String"
                }
            }, loggerId: {
                serializedName: "properties.loggerId",
                xmlName: "properties.loggerId",
                type: {
                    name: "String"
                }
            }, sampling: {
                serializedName: "properties.sampling",
                xmlName: "properties.sampling",
                type: {
                    name: "Composite",
                    className: "SamplingSettings"
                }
            }, frontend: {
                serializedName: "properties.frontend",
                xmlName: "properties.frontend",
                type: {
                    name: "Composite",
                    className: "PipelineDiagnosticSettings"
                }
            }, backend: {
                serializedName: "properties.backend",
                xmlName: "properties.backend",
                type: {
                    name: "Composite",
                    className: "PipelineDiagnosticSettings"
                }
            }, logClientIp: {
                serializedName: "properties.logClientIp",
                xmlName: "properties.logClientIp",
                type: {
                    name: "Boolean"
                }
            }, httpCorrelationProtocol: {
                serializedName: "properties.httpCorrelationProtocol",
                xmlName: "properties.httpCorrelationProtocol",
                type: {
                    name: "String"
                }
            }, verbosity: {
                serializedName: "properties.verbosity",
                xmlName: "properties.verbosity",
                type: {
                    name: "String"
                }
            }, operationNameFormat: {
                serializedName: "properties.operationNameFormat",
                xmlName: "properties.operationNameFormat",
                type: {
                    name: "String"
                }
            } })
    }
};
const IssueContract = {
    serializedName: "IssueContract",
    type: {
        name: "Composite",
        className: "IssueContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { createdDate: {
                serializedName: "properties.createdDate",
                xmlName: "properties.createdDate",
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "String"
                }
            }, apiId: {
                serializedName: "properties.apiId",
                xmlName: "properties.apiId",
                type: {
                    name: "String"
                }
            }, title: {
                serializedName: "properties.title",
                xmlName: "properties.title",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, userId: {
                serializedName: "properties.userId",
                xmlName: "properties.userId",
                type: {
                    name: "String"
                }
            } })
    }
};
const IssueCommentContract = {
    serializedName: "IssueCommentContract",
    type: {
        name: "Composite",
        className: "IssueCommentContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { text: {
                serializedName: "properties.text",
                xmlName: "properties.text",
                type: {
                    name: "String"
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                xmlName: "properties.createdDate",
                type: {
                    name: "DateTime"
                }
            }, userId: {
                serializedName: "properties.userId",
                xmlName: "properties.userId",
                type: {
                    name: "String"
                }
            } })
    }
};
const IssueAttachmentContract = {
    serializedName: "IssueAttachmentContract",
    type: {
        name: "Composite",
        className: "IssueAttachmentContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { title: {
                serializedName: "properties.title",
                xmlName: "properties.title",
                type: {
                    name: "String"
                }
            }, contentFormat: {
                serializedName: "properties.contentFormat",
                xmlName: "properties.contentFormat",
                type: {
                    name: "String"
                }
            }, content: {
                serializedName: "properties.content",
                xmlName: "properties.content",
                type: {
                    name: "String"
                }
            } })
    }
};
const TagDescriptionContract = {
    serializedName: "TagDescriptionContract",
    type: {
        name: "Composite",
        className: "TagDescriptionContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, externalDocsUrl: {
                constraints: {
                    MaxLength: 2000
                },
                serializedName: "properties.externalDocsUrl",
                xmlName: "properties.externalDocsUrl",
                type: {
                    name: "String"
                }
            }, externalDocsDescription: {
                serializedName: "properties.externalDocsDescription",
                xmlName: "properties.externalDocsDescription",
                type: {
                    name: "String"
                }
            }, tagId: {
                serializedName: "properties.tagId",
                xmlName: "properties.tagId",
                type: {
                    name: "String"
                }
            }, displayName: {
                constraints: {
                    MaxLength: 160,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            } })
    }
};
const ApiVersionSetContract = {
    serializedName: "ApiVersionSetContract",
    type: {
        name: "Composite",
        className: "ApiVersionSetContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, versionQueryName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.versionQueryName",
                xmlName: "properties.versionQueryName",
                type: {
                    name: "String"
                }
            }, versionHeaderName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.versionHeaderName",
                xmlName: "properties.versionHeaderName",
                type: {
                    name: "String"
                }
            }, displayName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, versioningScheme: {
                serializedName: "properties.versioningScheme",
                xmlName: "properties.versioningScheme",
                type: {
                    name: "String"
                }
            } })
    }
};
const AuthorizationServerContract = {
    serializedName: "AuthorizationServerContract",
    type: {
        name: "Composite",
        className: "AuthorizationServerContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, authorizationMethods: {
                serializedName: "properties.authorizationMethods",
                xmlName: "properties.authorizationMethods",
                xmlElementName: "AuthorizationMethod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "HEAD",
                                "OPTIONS",
                                "TRACE",
                                "GET",
                                "POST",
                                "PUT",
                                "PATCH",
                                "DELETE"
                            ]
                        }
                    }
                }
            }, clientAuthenticationMethod: {
                serializedName: "properties.clientAuthenticationMethod",
                xmlName: "properties.clientAuthenticationMethod",
                xmlElementName: "ClientAuthenticationMethod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, tokenBodyParameters: {
                serializedName: "properties.tokenBodyParameters",
                xmlName: "properties.tokenBodyParameters",
                xmlElementName: "TokenBodyParameterContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TokenBodyParameterContract"
                        }
                    }
                }
            }, tokenEndpoint: {
                serializedName: "properties.tokenEndpoint",
                xmlName: "properties.tokenEndpoint",
                type: {
                    name: "String"
                }
            }, supportState: {
                serializedName: "properties.supportState",
                xmlName: "properties.supportState",
                type: {
                    name: "Boolean"
                }
            }, defaultScope: {
                serializedName: "properties.defaultScope",
                xmlName: "properties.defaultScope",
                type: {
                    name: "String"
                }
            }, bearerTokenSendingMethods: {
                serializedName: "properties.bearerTokenSendingMethods",
                xmlName: "properties.bearerTokenSendingMethods",
                xmlElementName: "BearerTokenSendingMethod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, resourceOwnerUsername: {
                serializedName: "properties.resourceOwnerUsername",
                xmlName: "properties.resourceOwnerUsername",
                type: {
                    name: "String"
                }
            }, resourceOwnerPassword: {
                serializedName: "properties.resourceOwnerPassword",
                xmlName: "properties.resourceOwnerPassword",
                type: {
                    name: "String"
                }
            }, displayName: {
                constraints: {
                    MaxLength: 50,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, clientRegistrationEndpoint: {
                serializedName: "properties.clientRegistrationEndpoint",
                xmlName: "properties.clientRegistrationEndpoint",
                type: {
                    name: "String"
                }
            }, authorizationEndpoint: {
                serializedName: "properties.authorizationEndpoint",
                xmlName: "properties.authorizationEndpoint",
                type: {
                    name: "String"
                }
            }, grantTypes: {
                serializedName: "properties.grantTypes",
                xmlName: "properties.grantTypes",
                xmlElementName: "GrantType",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, clientId: {
                serializedName: "properties.clientId",
                xmlName: "properties.clientId",
                type: {
                    name: "String"
                }
            }, clientSecret: {
                serializedName: "properties.clientSecret",
                xmlName: "properties.clientSecret",
                type: {
                    name: "String"
                }
            } })
    }
};
const AuthorizationServerUpdateContract = {
    serializedName: "AuthorizationServerUpdateContract",
    type: {
        name: "Composite",
        className: "AuthorizationServerUpdateContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, authorizationMethods: {
                serializedName: "properties.authorizationMethods",
                xmlName: "properties.authorizationMethods",
                xmlElementName: "AuthorizationMethod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "HEAD",
                                "OPTIONS",
                                "TRACE",
                                "GET",
                                "POST",
                                "PUT",
                                "PATCH",
                                "DELETE"
                            ]
                        }
                    }
                }
            }, clientAuthenticationMethod: {
                serializedName: "properties.clientAuthenticationMethod",
                xmlName: "properties.clientAuthenticationMethod",
                xmlElementName: "ClientAuthenticationMethod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, tokenBodyParameters: {
                serializedName: "properties.tokenBodyParameters",
                xmlName: "properties.tokenBodyParameters",
                xmlElementName: "TokenBodyParameterContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TokenBodyParameterContract"
                        }
                    }
                }
            }, tokenEndpoint: {
                serializedName: "properties.tokenEndpoint",
                xmlName: "properties.tokenEndpoint",
                type: {
                    name: "String"
                }
            }, supportState: {
                serializedName: "properties.supportState",
                xmlName: "properties.supportState",
                type: {
                    name: "Boolean"
                }
            }, defaultScope: {
                serializedName: "properties.defaultScope",
                xmlName: "properties.defaultScope",
                type: {
                    name: "String"
                }
            }, bearerTokenSendingMethods: {
                serializedName: "properties.bearerTokenSendingMethods",
                xmlName: "properties.bearerTokenSendingMethods",
                xmlElementName: "BearerTokenSendingMethod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, resourceOwnerUsername: {
                serializedName: "properties.resourceOwnerUsername",
                xmlName: "properties.resourceOwnerUsername",
                type: {
                    name: "String"
                }
            }, resourceOwnerPassword: {
                serializedName: "properties.resourceOwnerPassword",
                xmlName: "properties.resourceOwnerPassword",
                type: {
                    name: "String"
                }
            }, displayName: {
                constraints: {
                    MaxLength: 50,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, clientRegistrationEndpoint: {
                serializedName: "properties.clientRegistrationEndpoint",
                xmlName: "properties.clientRegistrationEndpoint",
                type: {
                    name: "String"
                }
            }, authorizationEndpoint: {
                serializedName: "properties.authorizationEndpoint",
                xmlName: "properties.authorizationEndpoint",
                type: {
                    name: "String"
                }
            }, grantTypes: {
                serializedName: "properties.grantTypes",
                xmlName: "properties.grantTypes",
                xmlElementName: "GrantType",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, clientId: {
                serializedName: "properties.clientId",
                xmlName: "properties.clientId",
                type: {
                    name: "String"
                }
            }, clientSecret: {
                serializedName: "properties.clientSecret",
                xmlName: "properties.clientSecret",
                type: {
                    name: "String"
                }
            } })
    }
};
const BackendContract = {
    serializedName: "BackendContract",
    type: {
        name: "Composite",
        className: "BackendContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { title: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "properties.title",
                xmlName: "properties.title",
                type: {
                    name: "String"
                }
            }, description: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, resourceId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "properties.resourceId",
                xmlName: "properties.resourceId",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties.properties",
                xmlName: "properties.properties",
                type: {
                    name: "Composite",
                    className: "BackendProperties"
                }
            }, credentials: {
                serializedName: "properties.credentials",
                xmlName: "properties.credentials",
                type: {
                    name: "Composite",
                    className: "BackendCredentialsContract"
                }
            }, proxy: {
                serializedName: "properties.proxy",
                xmlName: "properties.proxy",
                type: {
                    name: "Composite",
                    className: "BackendProxyContract"
                }
            }, tls: {
                serializedName: "properties.tls",
                xmlName: "properties.tls",
                type: {
                    name: "Composite",
                    className: "BackendTlsProperties"
                }
            }, url: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "properties.url",
                xmlName: "properties.url",
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                xmlName: "properties.protocol",
                type: {
                    name: "String"
                }
            } })
    }
};
const BackendReconnectContract = {
    serializedName: "BackendReconnectContract",
    type: {
        name: "Composite",
        className: "BackendReconnectContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { after: {
                serializedName: "properties.after",
                xmlName: "properties.after",
                type: {
                    name: "TimeSpan"
                }
            } })
    }
};
const CacheContract = {
    serializedName: "CacheContract",
    type: {
        name: "Composite",
        className: "CacheContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                constraints: {
                    MaxLength: 2000
                },
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, connectionString: {
                constraints: {
                    MaxLength: 300
                },
                serializedName: "properties.connectionString",
                xmlName: "properties.connectionString",
                type: {
                    name: "String"
                }
            }, useFromLocation: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "properties.useFromLocation",
                xmlName: "properties.useFromLocation",
                type: {
                    name: "String"
                }
            }, resourceId: {
                constraints: {
                    MaxLength: 2000
                },
                serializedName: "properties.resourceId",
                xmlName: "properties.resourceId",
                type: {
                    name: "String"
                }
            } })
    }
};
const CertificateContract = {
    serializedName: "CertificateContract",
    type: {
        name: "Composite",
        className: "CertificateContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { subject: {
                serializedName: "properties.subject",
                xmlName: "properties.subject",
                type: {
                    name: "String"
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                xmlName: "properties.thumbprint",
                type: {
                    name: "String"
                }
            }, expirationDate: {
                serializedName: "properties.expirationDate",
                xmlName: "properties.expirationDate",
                type: {
                    name: "DateTime"
                }
            }, keyVault: {
                serializedName: "properties.keyVault",
                xmlName: "properties.keyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultContractProperties"
                }
            } })
    }
};
const ContentTypeContract = {
    serializedName: "ContentTypeContract",
    type: {
        name: "Composite",
        className: "ContentTypeContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { idPropertiesId: {
                serializedName: "properties.id",
                xmlName: "properties.id",
                type: {
                    name: "String"
                }
            }, namePropertiesName: {
                serializedName: "properties.name",
                xmlName: "properties.name",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, schema: {
                serializedName: "properties.schema",
                xmlName: "properties.schema",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, version: {
                serializedName: "properties.version",
                xmlName: "properties.version",
                type: {
                    name: "String"
                }
            } })
    }
};
const ContentItemContract = {
    serializedName: "ContentItemContract",
    type: {
        name: "Composite",
        className: "ContentItemContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const DeletedServiceContract = {
    serializedName: "DeletedServiceContract",
    type: {
        name: "Composite",
        className: "DeletedServiceContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                xmlName: "location",
                type: {
                    name: "String"
                }
            }, serviceId: {
                serializedName: "properties.serviceId",
                xmlName: "properties.serviceId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                serializedName: "properties.scheduledPurgeDate",
                xmlName: "properties.scheduledPurgeDate",
                type: {
                    name: "DateTime"
                }
            }, deletionDate: {
                serializedName: "properties.deletionDate",
                xmlName: "properties.deletionDate",
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const EmailTemplateContract = {
    serializedName: "EmailTemplateContract",
    type: {
        name: "Composite",
        className: "EmailTemplateContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { subject: {
                constraints: {
                    MaxLength: 1000,
                    MinLength: 1
                },
                serializedName: "properties.subject",
                xmlName: "properties.subject",
                type: {
                    name: "String"
                }
            }, body: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.body",
                xmlName: "properties.body",
                type: {
                    name: "String"
                }
            }, title: {
                serializedName: "properties.title",
                xmlName: "properties.title",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, isDefault: {
                serializedName: "properties.isDefault",
                readOnly: true,
                xmlName: "properties.isDefault",
                type: {
                    name: "Boolean"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                xmlName: "properties.parameters",
                xmlElementName: "EmailTemplateParametersContractProperties",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EmailTemplateParametersContractProperties"
                        }
                    }
                }
            } })
    }
};
const GatewayContract = {
    serializedName: "GatewayContract",
    type: {
        name: "Composite",
        className: "GatewayContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { locationData: {
                serializedName: "properties.locationData",
                xmlName: "properties.locationData",
                type: {
                    name: "Composite",
                    className: "ResourceLocationDataContract"
                }
            }, description: {
                constraints: {
                    MaxLength: 1000
                },
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            } })
    }
};
const GatewayHostnameConfigurationContract = {
    serializedName: "GatewayHostnameConfigurationContract",
    type: {
        name: "Composite",
        className: "GatewayHostnameConfigurationContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { hostname: {
                serializedName: "properties.hostname",
                xmlName: "properties.hostname",
                type: {
                    name: "String"
                }
            }, certificateId: {
                serializedName: "properties.certificateId",
                xmlName: "properties.certificateId",
                type: {
                    name: "String"
                }
            }, negotiateClientCertificate: {
                serializedName: "properties.negotiateClientCertificate",
                xmlName: "properties.negotiateClientCertificate",
                type: {
                    name: "Boolean"
                }
            }, tls10Enabled: {
                serializedName: "properties.tls10Enabled",
                xmlName: "properties.tls10Enabled",
                type: {
                    name: "Boolean"
                }
            }, tls11Enabled: {
                serializedName: "properties.tls11Enabled",
                xmlName: "properties.tls11Enabled",
                type: {
                    name: "Boolean"
                }
            }, http2Enabled: {
                serializedName: "properties.http2Enabled",
                xmlName: "properties.http2Enabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const AssociationContract = {
    serializedName: "AssociationContract",
    type: {
        name: "Composite",
        className: "AssociationContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                defaultValue: "created",
                isConstant: true,
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            } })
    }
};
const GatewayCertificateAuthorityContract = {
    serializedName: "GatewayCertificateAuthorityContract",
    type: {
        name: "Composite",
        className: "GatewayCertificateAuthorityContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { isTrusted: {
                serializedName: "properties.isTrusted",
                xmlName: "properties.isTrusted",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const GroupContract = {
    serializedName: "GroupContract",
    type: {
        name: "Composite",
        className: "GroupContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, description: {
                constraints: {
                    MaxLength: 1000
                },
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, builtIn: {
                serializedName: "properties.builtIn",
                readOnly: true,
                xmlName: "properties.builtIn",
                type: {
                    name: "Boolean"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                xmlName: "properties.type",
                type: {
                    name: "Enum",
                    allowedValues: ["custom", "system", "external"]
                }
            }, externalId: {
                serializedName: "properties.externalId",
                xmlName: "properties.externalId",
                type: {
                    name: "String"
                }
            } })
    }
};
const UserContract = {
    serializedName: "UserContract",
    type: {
        name: "Composite",
        className: "UserContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { state: {
                defaultValue: "active",
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "String"
                }
            }, note: {
                serializedName: "properties.note",
                xmlName: "properties.note",
                type: {
                    name: "String"
                }
            }, identities: {
                serializedName: "properties.identities",
                xmlName: "properties.identities",
                xmlElementName: "UserIdentityContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UserIdentityContract"
                        }
                    }
                }
            }, firstName: {
                serializedName: "properties.firstName",
                xmlName: "properties.firstName",
                type: {
                    name: "String"
                }
            }, lastName: {
                serializedName: "properties.lastName",
                xmlName: "properties.lastName",
                type: {
                    name: "String"
                }
            }, email: {
                serializedName: "properties.email",
                xmlName: "properties.email",
                type: {
                    name: "String"
                }
            }, registrationDate: {
                serializedName: "properties.registrationDate",
                xmlName: "properties.registrationDate",
                type: {
                    name: "DateTime"
                }
            }, groups: {
                serializedName: "properties.groups",
                readOnly: true,
                xmlName: "properties.groups",
                xmlElementName: "GroupContractProperties",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GroupContractProperties"
                        }
                    }
                }
            } })
    }
};
const IdentityProviderContract = {
    serializedName: "IdentityProviderContract",
    type: {
        name: "Composite",
        className: "IdentityProviderContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { typePropertiesType: {
                serializedName: "properties.type",
                xmlName: "properties.type",
                type: {
                    name: "String"
                }
            }, signinTenant: {
                serializedName: "properties.signinTenant",
                xmlName: "properties.signinTenant",
                type: {
                    name: "String"
                }
            }, allowedTenants: {
                constraints: {
                    MaxItems: 32
                },
                serializedName: "properties.allowedTenants",
                xmlName: "properties.allowedTenants",
                xmlElementName: "IdentityProviderBaseParametersAllowedTenantsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, authority: {
                serializedName: "properties.authority",
                xmlName: "properties.authority",
                type: {
                    name: "String"
                }
            }, signupPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.signupPolicyName",
                xmlName: "properties.signupPolicyName",
                type: {
                    name: "String"
                }
            }, signinPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.signinPolicyName",
                xmlName: "properties.signinPolicyName",
                type: {
                    name: "String"
                }
            }, profileEditingPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.profileEditingPolicyName",
                xmlName: "properties.profileEditingPolicyName",
                type: {
                    name: "String"
                }
            }, passwordResetPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.passwordResetPolicyName",
                xmlName: "properties.passwordResetPolicyName",
                type: {
                    name: "String"
                }
            }, clientId: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.clientId",
                xmlName: "properties.clientId",
                type: {
                    name: "String"
                }
            }, clientSecret: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.clientSecret",
                xmlName: "properties.clientSecret",
                type: {
                    name: "String"
                }
            } })
    }
};
const IdentityProviderCreateContract = {
    serializedName: "IdentityProviderCreateContract",
    type: {
        name: "Composite",
        className: "IdentityProviderCreateContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { typePropertiesType: {
                serializedName: "properties.type",
                xmlName: "properties.type",
                type: {
                    name: "String"
                }
            }, signinTenant: {
                serializedName: "properties.signinTenant",
                xmlName: "properties.signinTenant",
                type: {
                    name: "String"
                }
            }, allowedTenants: {
                constraints: {
                    MaxItems: 32
                },
                serializedName: "properties.allowedTenants",
                xmlName: "properties.allowedTenants",
                xmlElementName: "IdentityProviderBaseParametersAllowedTenantsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, authority: {
                serializedName: "properties.authority",
                xmlName: "properties.authority",
                type: {
                    name: "String"
                }
            }, signupPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.signupPolicyName",
                xmlName: "properties.signupPolicyName",
                type: {
                    name: "String"
                }
            }, signinPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.signinPolicyName",
                xmlName: "properties.signinPolicyName",
                type: {
                    name: "String"
                }
            }, profileEditingPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.profileEditingPolicyName",
                xmlName: "properties.profileEditingPolicyName",
                type: {
                    name: "String"
                }
            }, passwordResetPolicyName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.passwordResetPolicyName",
                xmlName: "properties.passwordResetPolicyName",
                type: {
                    name: "String"
                }
            }, clientId: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.clientId",
                xmlName: "properties.clientId",
                type: {
                    name: "String"
                }
            }, clientSecret: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.clientSecret",
                xmlName: "properties.clientSecret",
                type: {
                    name: "String"
                }
            } })
    }
};
const LoggerContract = {
    serializedName: "LoggerContract",
    type: {
        name: "Composite",
        className: "LoggerContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { loggerType: {
                serializedName: "properties.loggerType",
                xmlName: "properties.loggerType",
                type: {
                    name: "String"
                }
            }, description: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, credentials: {
                serializedName: "properties.credentials",
                xmlName: "properties.credentials",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, isBuffered: {
                serializedName: "properties.isBuffered",
                xmlName: "properties.isBuffered",
                type: {
                    name: "Boolean"
                }
            }, resourceId: {
                serializedName: "properties.resourceId",
                xmlName: "properties.resourceId",
                type: {
                    name: "String"
                }
            } })
    }
};
const NamedValueContract = {
    serializedName: "NamedValueContract",
    type: {
        name: "Composite",
        className: "NamedValueContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                constraints: {
                    MaxItems: 32
                },
                serializedName: "properties.tags",
                xmlName: "properties.tags",
                xmlElementName: "NamedValueEntityBaseParametersTagsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, secret: {
                serializedName: "properties.secret",
                xmlName: "properties.secret",
                type: {
                    name: "Boolean"
                }
            }, displayName: {
                constraints: {
                    Pattern: new RegExp("^[A-Za-z0-9-._]+$"),
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, value: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "properties.value",
                xmlName: "properties.value",
                type: {
                    name: "String"
                }
            }, keyVault: {
                serializedName: "properties.keyVault",
                xmlName: "properties.keyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultContractProperties"
                }
            } })
    }
};
const NamedValueCreateContract = {
    serializedName: "NamedValueCreateContract",
    type: {
        name: "Composite",
        className: "NamedValueCreateContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                constraints: {
                    MaxItems: 32
                },
                serializedName: "properties.tags",
                xmlName: "properties.tags",
                xmlElementName: "NamedValueEntityBaseParametersTagsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, secret: {
                serializedName: "properties.secret",
                xmlName: "properties.secret",
                type: {
                    name: "Boolean"
                }
            }, displayName: {
                constraints: {
                    Pattern: new RegExp("^[A-Za-z0-9-._]+$"),
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, value: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "properties.value",
                xmlName: "properties.value",
                type: {
                    name: "String"
                }
            }, keyVault: {
                serializedName: "properties.keyVault",
                xmlName: "properties.keyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultContractCreateProperties"
                }
            } })
    }
};
const NotificationContract = {
    serializedName: "NotificationContract",
    type: {
        name: "Composite",
        className: "NotificationContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { title: {
                constraints: {
                    MaxLength: 1000,
                    MinLength: 1
                },
                serializedName: "properties.title",
                xmlName: "properties.title",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, recipients: {
                serializedName: "properties.recipients",
                xmlName: "properties.recipients",
                type: {
                    name: "Composite",
                    className: "RecipientsContractProperties"
                }
            } })
    }
};
const RecipientUserContract = {
    serializedName: "RecipientUserContract",
    type: {
        name: "Composite",
        className: "RecipientUserContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { userId: {
                serializedName: "properties.userId",
                xmlName: "properties.userId",
                type: {
                    name: "String"
                }
            } })
    }
};
const RecipientEmailContract = {
    serializedName: "RecipientEmailContract",
    type: {
        name: "Composite",
        className: "RecipientEmailContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { email: {
                serializedName: "properties.email",
                xmlName: "properties.email",
                type: {
                    name: "String"
                }
            } })
    }
};
const OpenidConnectProviderContract = {
    serializedName: "OpenidConnectProviderContract",
    type: {
        name: "Composite",
        className: "OpenidConnectProviderContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { displayName: {
                constraints: {
                    MaxLength: 50
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, metadataEndpoint: {
                serializedName: "properties.metadataEndpoint",
                xmlName: "properties.metadataEndpoint",
                type: {
                    name: "String"
                }
            }, clientId: {
                serializedName: "properties.clientId",
                xmlName: "properties.clientId",
                type: {
                    name: "String"
                }
            }, clientSecret: {
                serializedName: "properties.clientSecret",
                xmlName: "properties.clientSecret",
                type: {
                    name: "String"
                }
            } })
    }
};
const PolicyDescriptionContract = {
    serializedName: "PolicyDescriptionContract",
    type: {
        name: "Composite",
        className: "PolicyDescriptionContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, scope: {
                serializedName: "properties.scope",
                readOnly: true,
                xmlName: "properties.scope",
                type: {
                    name: "Number"
                }
            } })
    }
};
const PortalRevisionContract = {
    serializedName: "PortalRevisionContract",
    type: {
        name: "Composite",
        className: "PortalRevisionContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                constraints: {
                    MaxLength: 2000
                },
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String"
                }
            }, statusDetails: {
                constraints: {
                    MaxLength: 2000
                },
                serializedName: "properties.statusDetails",
                readOnly: true,
                xmlName: "properties.statusDetails",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "String"
                }
            }, isCurrent: {
                serializedName: "properties.isCurrent",
                xmlName: "properties.isCurrent",
                type: {
                    name: "Boolean"
                }
            }, createdDateTime: {
                serializedName: "properties.createdDateTime",
                readOnly: true,
                xmlName: "properties.createdDateTime",
                type: {
                    name: "DateTime"
                }
            }, updatedDateTime: {
                serializedName: "properties.updatedDateTime",
                readOnly: true,
                xmlName: "properties.updatedDateTime",
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const PortalSettingsContract = {
    serializedName: "PortalSettingsContract",
    type: {
        name: "Composite",
        className: "PortalSettingsContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { url: {
                serializedName: "properties.url",
                xmlName: "properties.url",
                type: {
                    name: "String"
                }
            }, validationKey: {
                serializedName: "properties.validationKey",
                xmlName: "properties.validationKey",
                type: {
                    name: "String"
                }
            }, subscriptions: {
                serializedName: "properties.subscriptions",
                xmlName: "properties.subscriptions",
                type: {
                    name: "Composite",
                    className: "SubscriptionsDelegationSettingsProperties"
                }
            }, userRegistration: {
                serializedName: "properties.userRegistration",
                xmlName: "properties.userRegistration",
                type: {
                    name: "Composite",
                    className: "RegistrationDelegationSettingsProperties"
                }
            }, enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, termsOfService: {
                serializedName: "properties.termsOfService",
                xmlName: "properties.termsOfService",
                type: {
                    name: "Composite",
                    className: "TermsOfServiceProperties"
                }
            } })
    }
};
const PortalSigninSettings = {
    serializedName: "PortalSigninSettings",
    type: {
        name: "Composite",
        className: "PortalSigninSettings",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const PortalSignupSettings = {
    serializedName: "PortalSignupSettings",
    type: {
        name: "Composite",
        className: "PortalSignupSettings",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, termsOfService: {
                serializedName: "properties.termsOfService",
                xmlName: "properties.termsOfService",
                type: {
                    name: "Composite",
                    className: "TermsOfServiceProperties"
                }
            } })
    }
};
const PortalDelegationSettings = {
    serializedName: "PortalDelegationSettings",
    type: {
        name: "Composite",
        className: "PortalDelegationSettings",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { url: {
                serializedName: "properties.url",
                xmlName: "properties.url",
                type: {
                    name: "String"
                }
            }, validationKey: {
                serializedName: "properties.validationKey",
                xmlName: "properties.validationKey",
                type: {
                    name: "String"
                }
            }, subscriptions: {
                serializedName: "properties.subscriptions",
                xmlName: "properties.subscriptions",
                type: {
                    name: "Composite",
                    className: "SubscriptionsDelegationSettingsProperties"
                }
            }, userRegistration: {
                serializedName: "properties.userRegistration",
                xmlName: "properties.userRegistration",
                type: {
                    name: "Composite",
                    className: "RegistrationDelegationSettingsProperties"
                }
            } })
    }
};
const PrivateEndpointConnection = {
    serializedName: "PrivateEndpointConnection",
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                xmlName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                xmlName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateLinkResource = {
    serializedName: "PrivateLinkResource",
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                xmlName: "properties.groupId",
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                xmlName: "properties.requiredMembers",
                xmlElementName: "PrivateLinkResourcePropertiesRequiredMembersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                xmlName: "properties.requiredZoneNames",
                xmlElementName: "PrivateLinkResourcePropertiesRequiredZoneNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const SubscriptionContract = {
    serializedName: "SubscriptionContract",
    type: {
        name: "Composite",
        className: "SubscriptionContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { ownerId: {
                serializedName: "properties.ownerId",
                xmlName: "properties.ownerId",
                type: {
                    name: "String"
                }
            }, scope: {
                serializedName: "properties.scope",
                xmlName: "properties.scope",
                type: {
                    name: "String"
                }
            }, displayName: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "suspended",
                        "active",
                        "expired",
                        "submitted",
                        "rejected",
                        "cancelled"
                    ]
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                xmlName: "properties.createdDate",
                type: {
                    name: "DateTime"
                }
            }, startDate: {
                serializedName: "properties.startDate",
                xmlName: "properties.startDate",
                type: {
                    name: "DateTime"
                }
            }, expirationDate: {
                serializedName: "properties.expirationDate",
                xmlName: "properties.expirationDate",
                type: {
                    name: "DateTime"
                }
            }, endDate: {
                serializedName: "properties.endDate",
                xmlName: "properties.endDate",
                type: {
                    name: "DateTime"
                }
            }, notificationDate: {
                serializedName: "properties.notificationDate",
                xmlName: "properties.notificationDate",
                type: {
                    name: "DateTime"
                }
            }, primaryKey: {
                constraints: {
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "properties.primaryKey",
                xmlName: "properties.primaryKey",
                type: {
                    name: "String"
                }
            }, secondaryKey: {
                constraints: {
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "properties.secondaryKey",
                xmlName: "properties.secondaryKey",
                type: {
                    name: "String"
                }
            }, stateComment: {
                serializedName: "properties.stateComment",
                xmlName: "properties.stateComment",
                type: {
                    name: "String"
                }
            }, allowTracing: {
                serializedName: "properties.allowTracing",
                xmlName: "properties.allowTracing",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const TenantSettingsContract = {
    serializedName: "TenantSettingsContract",
    type: {
        name: "Composite",
        className: "TenantSettingsContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { settings: {
                serializedName: "properties.settings",
                xmlName: "properties.settings",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const AccessInformationContract = {
    serializedName: "AccessInformationContract",
    type: {
        name: "Composite",
        className: "AccessInformationContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { idPropertiesId: {
                serializedName: "properties.id",
                xmlName: "properties.id",
                type: {
                    name: "String"
                }
            }, principalId: {
                serializedName: "properties.principalId",
                xmlName: "properties.principalId",
                type: {
                    name: "String"
                }
            }, enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const OperationResultContract = {
    serializedName: "OperationResultContract",
    type: {
        name: "Composite",
        className: "OperationResultContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { idPropertiesId: {
                serializedName: "properties.id",
                xmlName: "properties.id",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: ["Started", "InProgress", "Succeeded", "Failed"]
                }
            }, started: {
                serializedName: "properties.started",
                xmlName: "properties.started",
                type: {
                    name: "DateTime"
                }
            }, updated: {
                serializedName: "properties.updated",
                xmlName: "properties.updated",
                type: {
                    name: "DateTime"
                }
            }, resultInfo: {
                serializedName: "properties.resultInfo",
                xmlName: "properties.resultInfo",
                type: {
                    name: "String"
                }
            }, error: {
                serializedName: "properties.error",
                xmlName: "properties.error",
                type: {
                    name: "Composite",
                    className: "ErrorResponseBody"
                }
            }, actionLog: {
                serializedName: "properties.actionLog",
                readOnly: true,
                xmlName: "properties.actionLog",
                xmlElementName: "OperationResultLogItemContract",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationResultLogItemContract"
                        }
                    }
                }
            } })
    }
};
const TenantConfigurationSyncStateContract = {
    serializedName: "TenantConfigurationSyncStateContract",
    type: {
        name: "Composite",
        className: "TenantConfigurationSyncStateContract",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { branch: {
                serializedName: "properties.branch",
                xmlName: "properties.branch",
                type: {
                    name: "String"
                }
            }, commitId: {
                serializedName: "properties.commitId",
                xmlName: "properties.commitId",
                type: {
                    name: "String"
                }
            }, isExport: {
                serializedName: "properties.isExport",
                xmlName: "properties.isExport",
                type: {
                    name: "Boolean"
                }
            }, isSynced: {
                serializedName: "properties.isSynced",
                xmlName: "properties.isSynced",
                type: {
                    name: "Boolean"
                }
            }, isGitEnabled: {
                serializedName: "properties.isGitEnabled",
                xmlName: "properties.isGitEnabled",
                type: {
                    name: "Boolean"
                }
            }, syncDate: {
                serializedName: "properties.syncDate",
                xmlName: "properties.syncDate",
                type: {
                    name: "DateTime"
                }
            }, configurationChangeDate: {
                serializedName: "properties.configurationChangeDate",
                xmlName: "properties.configurationChangeDate",
                type: {
                    name: "DateTime"
                }
            }, lastOperationId: {
                serializedName: "properties.lastOperationId",
                xmlName: "properties.lastOperationId",
                type: {
                    name: "String"
                }
            } })
    }
};
const OperationContractProperties = {
    serializedName: "OperationContractProperties",
    type: {
        name: "Composite",
        className: "OperationContractProperties",
        modelProperties: Object.assign(Object.assign({}, OperationEntityBaseContract.type.modelProperties), { displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "displayName",
                required: true,
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            }, method: {
                serializedName: "method",
                required: true,
                xmlName: "method",
                type: {
                    name: "String"
                }
            }, urlTemplate: {
                constraints: {
                    MaxLength: 1000,
                    MinLength: 1
                },
                serializedName: "urlTemplate",
                required: true,
                xmlName: "urlTemplate",
                type: {
                    name: "String"
                }
            } })
    }
};
const OperationUpdateContractProperties = {
    serializedName: "OperationUpdateContractProperties",
    type: {
        name: "Composite",
        className: "OperationUpdateContractProperties",
        modelProperties: Object.assign(Object.assign({}, OperationEntityBaseContract.type.modelProperties), { displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            }, method: {
                serializedName: "method",
                xmlName: "method",
                type: {
                    name: "String"
                }
            }, urlTemplate: {
                constraints: {
                    MaxLength: 1000,
                    MinLength: 1
                },
                serializedName: "urlTemplate",
                xmlName: "urlTemplate",
                type: {
                    name: "String"
                }
            } })
    }
};
const ProductContractProperties = {
    serializedName: "ProductContractProperties",
    type: {
        name: "Composite",
        className: "ProductContractProperties",
        modelProperties: Object.assign(Object.assign({}, ProductEntityBaseParameters.type.modelProperties), { displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "displayName",
                required: true,
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            } })
    }
};
const ProductTagResourceContractProperties = {
    serializedName: "ProductTagResourceContractProperties",
    type: {
        name: "Composite",
        className: "ProductTagResourceContractProperties",
        modelProperties: Object.assign(Object.assign({}, ProductEntityBaseParameters.type.modelProperties), { id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String"
                }
            }, name: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String"
                }
            } })
    }
};
const ProductUpdateProperties = {
    serializedName: "ProductUpdateProperties",
    type: {
        name: "Composite",
        className: "ProductUpdateProperties",
        modelProperties: Object.assign(Object.assign({}, ProductEntityBaseParameters.type.modelProperties), { displayName: {
                constraints: {
                    MaxLength: 300,
                    MinLength: 1
                },
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            } })
    }
};
const IssueContractProperties = {
    serializedName: "IssueContractProperties",
    type: {
        name: "Composite",
        className: "IssueContractProperties",
        modelProperties: Object.assign(Object.assign({}, IssueContractBaseProperties.type.modelProperties), { title: {
                serializedName: "title",
                required: true,
                xmlName: "title",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "description",
                required: true,
                xmlName: "description",
                type: {
                    name: "String"
                }
            }, userId: {
                serializedName: "userId",
                required: true,
                xmlName: "userId",
                type: {
                    name: "String"
                }
            } })
    }
};
const IssueUpdateContractProperties = {
    serializedName: "IssueUpdateContractProperties",
    type: {
        name: "Composite",
        className: "IssueUpdateContractProperties",
        modelProperties: Object.assign(Object.assign({}, IssueContractBaseProperties.type.modelProperties), { title: {
                serializedName: "title",
                xmlName: "title",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String"
                }
            }, userId: {
                serializedName: "userId",
                xmlName: "userId",
                type: {
                    name: "String"
                }
            } })
    }
};
const TagDescriptionContractProperties = {
    serializedName: "TagDescriptionContractProperties",
    type: {
        name: "Composite",
        className: "TagDescriptionContractProperties",
        modelProperties: Object.assign(Object.assign({}, TagDescriptionBaseProperties.type.modelProperties), { tagId: {
                serializedName: "tagId",
                xmlName: "tagId",
                type: {
                    name: "String"
                }
            }, displayName: {
                constraints: {
                    MaxLength: 160,
                    MinLength: 1
                },
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            } })
    }
};
const ApiVersionSetContractProperties = {
    serializedName: "ApiVersionSetContractProperties",
    type: {
        name: "Composite",
        className: "ApiVersionSetContractProperties",
        modelProperties: Object.assign(Object.assign({}, ApiVersionSetEntityBase.type.modelProperties), { displayName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "displayName",
                required: true,
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            }, versioningScheme: {
                serializedName: "versioningScheme",
                required: true,
                xmlName: "versioningScheme",
                type: {
                    name: "String"
                }
            } })
    }
};
const ApiVersionSetUpdateParametersProperties = {
    serializedName: "ApiVersionSetUpdateParametersProperties",
    type: {
        name: "Composite",
        className: "ApiVersionSetUpdateParametersProperties",
        modelProperties: Object.assign(Object.assign({}, ApiVersionSetEntityBase.type.modelProperties), { displayName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            }, versioningScheme: {
                serializedName: "versioningScheme",
                xmlName: "versioningScheme",
                type: {
                    name: "String"
                }
            } })
    }
};
const AuthorizationServerContractProperties = {
    serializedName: "AuthorizationServerContractProperties",
    type: {
        name: "Composite",
        className: "AuthorizationServerContractProperties",
        modelProperties: Object.assign(Object.assign({}, AuthorizationServerContractBaseProperties.type.modelProperties), { displayName: {
                constraints: {
                    MaxLength: 50,
                    MinLength: 1
                },
                serializedName: "displayName",
                required: true,
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            }, clientRegistrationEndpoint: {
                serializedName: "clientRegistrationEndpoint",
                required: true,
                xmlName: "clientRegistrationEndpoint",
                type: {
                    name: "String"
                }
            }, authorizationEndpoint: {
                serializedName: "authorizationEndpoint",
                required: true,
                xmlName: "authorizationEndpoint",
                type: {
                    name: "String"
                }
            }, grantTypes: {
                serializedName: "grantTypes",
                required: true,
                xmlName: "grantTypes",
                xmlElementName: "GrantType",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, clientId: {
                serializedName: "clientId",
                required: true,
                xmlName: "clientId",
                type: {
                    name: "String"
                }
            }, clientSecret: {
                serializedName: "clientSecret",
                xmlName: "clientSecret",
                type: {
                    name: "String"
                }
            } })
    }
};
const AuthorizationServerUpdateContractProperties = {
    serializedName: "AuthorizationServerUpdateContractProperties",
    type: {
        name: "Composite",
        className: "AuthorizationServerUpdateContractProperties",
        modelProperties: Object.assign(Object.assign({}, AuthorizationServerContractBaseProperties.type.modelProperties), { displayName: {
                constraints: {
                    MaxLength: 50,
                    MinLength: 1
                },
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            }, clientRegistrationEndpoint: {
                serializedName: "clientRegistrationEndpoint",
                xmlName: "clientRegistrationEndpoint",
                type: {
                    name: "String"
                }
            }, authorizationEndpoint: {
                serializedName: "authorizationEndpoint",
                xmlName: "authorizationEndpoint",
                type: {
                    name: "String"
                }
            }, grantTypes: {
                serializedName: "grantTypes",
                xmlName: "grantTypes",
                xmlElementName: "GrantType",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, clientId: {
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String"
                }
            }, clientSecret: {
                serializedName: "clientSecret",
                xmlName: "clientSecret",
                type: {
                    name: "String"
                }
            } })
    }
};
const BackendContractProperties = {
    serializedName: "BackendContractProperties",
    type: {
        name: "Composite",
        className: "BackendContractProperties",
        modelProperties: Object.assign(Object.assign({}, BackendBaseParameters.type.modelProperties), { url: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "url",
                required: true,
                xmlName: "url",
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "protocol",
                required: true,
                xmlName: "protocol",
                type: {
                    name: "String"
                }
            } })
    }
};
const BackendUpdateParameterProperties = {
    serializedName: "BackendUpdateParameterProperties",
    type: {
        name: "Composite",
        className: "BackendUpdateParameterProperties",
        modelProperties: Object.assign(Object.assign({}, BackendBaseParameters.type.modelProperties), { url: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 1
                },
                serializedName: "url",
                xmlName: "url",
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "protocol",
                xmlName: "protocol",
                type: {
                    name: "String"
                }
            } })
    }
};
const KeyVaultContractProperties = {
    serializedName: "KeyVaultContractProperties",
    type: {
        name: "Composite",
        className: "KeyVaultContractProperties",
        modelProperties: Object.assign(Object.assign({}, KeyVaultContractCreateProperties.type.modelProperties), { lastStatus: {
                serializedName: "lastStatus",
                xmlName: "lastStatus",
                type: {
                    name: "Composite",
                    className: "KeyVaultLastAccessStatusContractProperties"
                }
            } })
    }
};
const ApiManagementServiceProperties = {
    serializedName: "ApiManagementServiceProperties",
    type: {
        name: "Composite",
        className: "ApiManagementServiceProperties",
        modelProperties: Object.assign(Object.assign({}, ApiManagementServiceBaseProperties.type.modelProperties), { publisherEmail: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "publisherEmail",
                required: true,
                xmlName: "publisherEmail",
                type: {
                    name: "String"
                }
            }, publisherName: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "publisherName",
                required: true,
                xmlName: "publisherName",
                type: {
                    name: "String"
                }
            } })
    }
};
const ApiManagementServiceUpdateProperties = {
    serializedName: "ApiManagementServiceUpdateProperties",
    type: {
        name: "Composite",
        className: "ApiManagementServiceUpdateProperties",
        modelProperties: Object.assign(Object.assign({}, ApiManagementServiceBaseProperties.type.modelProperties), { publisherEmail: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "publisherEmail",
                xmlName: "publisherEmail",
                type: {
                    name: "String"
                }
            }, publisherName: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "publisherName",
                xmlName: "publisherName",
                type: {
                    name: "String"
                }
            } })
    }
};
const ApiManagementServiceResource = {
    serializedName: "ApiManagementServiceResource",
    type: {
        name: "Composite",
        className: "ApiManagementServiceResource",
        modelProperties: Object.assign(Object.assign({}, ApimResource.type.modelProperties), { sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "ApiManagementServiceSkuProperties"
                }
            }, identity: {
                serializedName: "identity",
                xmlName: "identity",
                type: {
                    name: "Composite",
                    className: "ApiManagementServiceIdentity"
                }
            }, systemData: {
                serializedName: "systemData",
                xmlName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, location: {
                serializedName: "location",
                required: true,
                xmlName: "location",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                xmlName: "zones",
                xmlElementName: "ApiManagementServiceResourceZonesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, notificationSenderEmail: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "properties.notificationSenderEmail",
                xmlName: "properties.notificationSenderEmail",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, targetProvisioningState: {
                serializedName: "properties.targetProvisioningState",
                readOnly: true,
                xmlName: "properties.targetProvisioningState",
                type: {
                    name: "String"
                }
            }, createdAtUtc: {
                serializedName: "properties.createdAtUtc",
                readOnly: true,
                xmlName: "properties.createdAtUtc",
                type: {
                    name: "DateTime"
                }
            }, gatewayUrl: {
                serializedName: "properties.gatewayUrl",
                readOnly: true,
                xmlName: "properties.gatewayUrl",
                type: {
                    name: "String"
                }
            }, gatewayRegionalUrl: {
                serializedName: "properties.gatewayRegionalUrl",
                readOnly: true,
                xmlName: "properties.gatewayRegionalUrl",
                type: {
                    name: "String"
                }
            }, portalUrl: {
                serializedName: "properties.portalUrl",
                readOnly: true,
                xmlName: "properties.portalUrl",
                type: {
                    name: "String"
                }
            }, managementApiUrl: {
                serializedName: "properties.managementApiUrl",
                readOnly: true,
                xmlName: "properties.managementApiUrl",
                type: {
                    name: "String"
                }
            }, scmUrl: {
                serializedName: "properties.scmUrl",
                readOnly: true,
                xmlName: "properties.scmUrl",
                type: {
                    name: "String"
                }
            }, developerPortalUrl: {
                serializedName: "properties.developerPortalUrl",
                readOnly: true,
                xmlName: "properties.developerPortalUrl",
                type: {
                    name: "String"
                }
            }, hostnameConfigurations: {
                serializedName: "properties.hostnameConfigurations",
                xmlName: "properties.hostnameConfigurations",
                xmlElementName: "HostnameConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostnameConfiguration"
                        }
                    }
                }
            }, publicIPAddresses: {
                serializedName: "properties.publicIPAddresses",
                readOnly: true,
                xmlName: "properties.publicIPAddresses",
                xmlElementName: "ApiManagementServiceBasePropertiesPublicIPAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, privateIPAddresses: {
                serializedName: "properties.privateIPAddresses",
                readOnly: true,
                xmlName: "properties.privateIPAddresses",
                xmlElementName: "ApiManagementServiceBasePropertiesPrivateIPAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, publicIpAddressId: {
                serializedName: "properties.publicIpAddressId",
                xmlName: "properties.publicIpAddressId",
                type: {
                    name: "String"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                xmlName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, virtualNetworkConfiguration: {
                serializedName: "properties.virtualNetworkConfiguration",
                xmlName: "properties.virtualNetworkConfiguration",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkConfiguration"
                }
            }, additionalLocations: {
                serializedName: "properties.additionalLocations",
                xmlName: "properties.additionalLocations",
                xmlElementName: "AdditionalLocation",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdditionalLocation"
                        }
                    }
                }
            }, customProperties: {
                serializedName: "properties.customProperties",
                xmlName: "properties.customProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, certificates: {
                serializedName: "properties.certificates",
                xmlName: "properties.certificates",
                xmlElementName: "CertificateConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CertificateConfiguration"
                        }
                    }
                }
            }, enableClientCertificate: {
                defaultValue: false,
                serializedName: "properties.enableClientCertificate",
                xmlName: "properties.enableClientCertificate",
                type: {
                    name: "Boolean"
                }
            }, disableGateway: {
                defaultValue: false,
                serializedName: "properties.disableGateway",
                xmlName: "properties.disableGateway",
                type: {
                    name: "Boolean"
                }
            }, virtualNetworkType: {
                defaultValue: "None",
                serializedName: "properties.virtualNetworkType",
                xmlName: "properties.virtualNetworkType",
                type: {
                    name: "String"
                }
            }, apiVersionConstraint: {
                serializedName: "properties.apiVersionConstraint",
                xmlName: "properties.apiVersionConstraint",
                type: {
                    name: "Composite",
                    className: "ApiVersionConstraint"
                }
            }, restore: {
                defaultValue: false,
                serializedName: "properties.restore",
                xmlName: "properties.restore",
                type: {
                    name: "Boolean"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                xmlName: "properties.privateEndpointConnections",
                xmlElementName: "RemotePrivateEndpointConnectionWrapper",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RemotePrivateEndpointConnectionWrapper"
                        }
                    }
                }
            }, platformVersion: {
                serializedName: "properties.platformVersion",
                readOnly: true,
                xmlName: "properties.platformVersion",
                type: {
                    name: "String"
                }
            }, publisherEmail: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "properties.publisherEmail",
                required: true,
                xmlName: "properties.publisherEmail",
                type: {
                    name: "String"
                }
            }, publisherName: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "properties.publisherName",
                required: true,
                xmlName: "properties.publisherName",
                type: {
                    name: "String"
                }
            } })
    }
};
const ApiManagementServiceUpdateParameters = {
    serializedName: "ApiManagementServiceUpdateParameters",
    type: {
        name: "Composite",
        className: "ApiManagementServiceUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ApimResource.type.modelProperties), { sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "ApiManagementServiceSkuProperties"
                }
            }, identity: {
                serializedName: "identity",
                xmlName: "identity",
                type: {
                    name: "Composite",
                    className: "ApiManagementServiceIdentity"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                xmlName: "zones",
                xmlElementName: "ApiManagementServiceUpdateParametersZonesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, notificationSenderEmail: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "properties.notificationSenderEmail",
                xmlName: "properties.notificationSenderEmail",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, targetProvisioningState: {
                serializedName: "properties.targetProvisioningState",
                readOnly: true,
                xmlName: "properties.targetProvisioningState",
                type: {
                    name: "String"
                }
            }, createdAtUtc: {
                serializedName: "properties.createdAtUtc",
                readOnly: true,
                xmlName: "properties.createdAtUtc",
                type: {
                    name: "DateTime"
                }
            }, gatewayUrl: {
                serializedName: "properties.gatewayUrl",
                readOnly: true,
                xmlName: "properties.gatewayUrl",
                type: {
                    name: "String"
                }
            }, gatewayRegionalUrl: {
                serializedName: "properties.gatewayRegionalUrl",
                readOnly: true,
                xmlName: "properties.gatewayRegionalUrl",
                type: {
                    name: "String"
                }
            }, portalUrl: {
                serializedName: "properties.portalUrl",
                readOnly: true,
                xmlName: "properties.portalUrl",
                type: {
                    name: "String"
                }
            }, managementApiUrl: {
                serializedName: "properties.managementApiUrl",
                readOnly: true,
                xmlName: "properties.managementApiUrl",
                type: {
                    name: "String"
                }
            }, scmUrl: {
                serializedName: "properties.scmUrl",
                readOnly: true,
                xmlName: "properties.scmUrl",
                type: {
                    name: "String"
                }
            }, developerPortalUrl: {
                serializedName: "properties.developerPortalUrl",
                readOnly: true,
                xmlName: "properties.developerPortalUrl",
                type: {
                    name: "String"
                }
            }, hostnameConfigurations: {
                serializedName: "properties.hostnameConfigurations",
                xmlName: "properties.hostnameConfigurations",
                xmlElementName: "HostnameConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostnameConfiguration"
                        }
                    }
                }
            }, publicIPAddresses: {
                serializedName: "properties.publicIPAddresses",
                readOnly: true,
                xmlName: "properties.publicIPAddresses",
                xmlElementName: "ApiManagementServiceBasePropertiesPublicIPAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, privateIPAddresses: {
                serializedName: "properties.privateIPAddresses",
                readOnly: true,
                xmlName: "properties.privateIPAddresses",
                xmlElementName: "ApiManagementServiceBasePropertiesPrivateIPAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, publicIpAddressId: {
                serializedName: "properties.publicIpAddressId",
                xmlName: "properties.publicIpAddressId",
                type: {
                    name: "String"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                xmlName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, virtualNetworkConfiguration: {
                serializedName: "properties.virtualNetworkConfiguration",
                xmlName: "properties.virtualNetworkConfiguration",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkConfiguration"
                }
            }, additionalLocations: {
                serializedName: "properties.additionalLocations",
                xmlName: "properties.additionalLocations",
                xmlElementName: "AdditionalLocation",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdditionalLocation"
                        }
                    }
                }
            }, customProperties: {
                serializedName: "properties.customProperties",
                xmlName: "properties.customProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, certificates: {
                serializedName: "properties.certificates",
                xmlName: "properties.certificates",
                xmlElementName: "CertificateConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CertificateConfiguration"
                        }
                    }
                }
            }, enableClientCertificate: {
                defaultValue: false,
                serializedName: "properties.enableClientCertificate",
                xmlName: "properties.enableClientCertificate",
                type: {
                    name: "Boolean"
                }
            }, disableGateway: {
                defaultValue: false,
                serializedName: "properties.disableGateway",
                xmlName: "properties.disableGateway",
                type: {
                    name: "Boolean"
                }
            }, virtualNetworkType: {
                defaultValue: "None",
                serializedName: "properties.virtualNetworkType",
                xmlName: "properties.virtualNetworkType",
                type: {
                    name: "String"
                }
            }, apiVersionConstraint: {
                serializedName: "properties.apiVersionConstraint",
                xmlName: "properties.apiVersionConstraint",
                type: {
                    name: "Composite",
                    className: "ApiVersionConstraint"
                }
            }, restore: {
                defaultValue: false,
                serializedName: "properties.restore",
                xmlName: "properties.restore",
                type: {
                    name: "Boolean"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                xmlName: "properties.privateEndpointConnections",
                xmlElementName: "RemotePrivateEndpointConnectionWrapper",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RemotePrivateEndpointConnectionWrapper"
                        }
                    }
                }
            }, platformVersion: {
                serializedName: "properties.platformVersion",
                readOnly: true,
                xmlName: "properties.platformVersion",
                type: {
                    name: "String"
                }
            }, publisherEmail: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "properties.publisherEmail",
                xmlName: "properties.publisherEmail",
                type: {
                    name: "String"
                }
            }, publisherName: {
                constraints: {
                    MaxLength: 100
                },
                serializedName: "properties.publisherName",
                xmlName: "properties.publisherName",
                type: {
                    name: "String"
                }
            } })
    }
};
const UserContractProperties = {
    serializedName: "UserContractProperties",
    type: {
        name: "Composite",
        className: "UserContractProperties",
        modelProperties: Object.assign(Object.assign({}, UserEntityBaseParameters.type.modelProperties), { firstName: {
                serializedName: "firstName",
                xmlName: "firstName",
                type: {
                    name: "String"
                }
            }, lastName: {
                serializedName: "lastName",
                xmlName: "lastName",
                type: {
                    name: "String"
                }
            }, email: {
                serializedName: "email",
                xmlName: "email",
                type: {
                    name: "String"
                }
            }, registrationDate: {
                serializedName: "registrationDate",
                xmlName: "registrationDate",
                type: {
                    name: "DateTime"
                }
            }, groups: {
                serializedName: "groups",
                readOnly: true,
                xmlName: "groups",
                xmlElementName: "GroupContractProperties",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GroupContractProperties"
                        }
                    }
                }
            } })
    }
};
const UserCreateParameterProperties = {
    serializedName: "UserCreateParameterProperties",
    type: {
        name: "Composite",
        className: "UserCreateParameterProperties",
        modelProperties: Object.assign(Object.assign({}, UserEntityBaseParameters.type.modelProperties), { email: {
                constraints: {
                    MaxLength: 254,
                    MinLength: 1
                },
                serializedName: "email",
                required: true,
                xmlName: "email",
                type: {
                    name: "String"
                }
            }, firstName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "firstName",
                required: true,
                xmlName: "firstName",
                type: {
                    name: "String"
                }
            }, lastName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "lastName",
                required: true,
                xmlName: "lastName",
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "password",
                xmlName: "password",
                type: {
                    name: "String"
                }
            }, appType: {
                serializedName: "appType",
                xmlName: "appType",
                type: {
                    name: "String"
                }
            }, confirmation: {
                serializedName: "confirmation",
                xmlName: "confirmation",
                type: {
                    name: "String"
                }
            } })
    }
};
const UserUpdateParametersProperties = {
    serializedName: "UserUpdateParametersProperties",
    type: {
        name: "Composite",
        className: "UserUpdateParametersProperties",
        modelProperties: Object.assign(Object.assign({}, UserEntityBaseParameters.type.modelProperties), { email: {
                constraints: {
                    MaxLength: 254,
                    MinLength: 1
                },
                serializedName: "email",
                xmlName: "email",
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "password",
                xmlName: "password",
                type: {
                    name: "String"
                }
            }, firstName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "firstName",
                xmlName: "firstName",
                type: {
                    name: "String"
                }
            }, lastName: {
                constraints: {
                    MaxLength: 100,
                    MinLength: 1
                },
                serializedName: "lastName",
                xmlName: "lastName",
                type: {
                    name: "String"
                }
            } })
    }
};
const IdentityProviderContractProperties = {
    serializedName: "IdentityProviderContractProperties",
    type: {
        name: "Composite",
        className: "IdentityProviderContractProperties",
        modelProperties: Object.assign(Object.assign({}, IdentityProviderBaseParameters.type.modelProperties), { clientId: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "clientId",
                required: true,
                xmlName: "clientId",
                type: {
                    name: "String"
                }
            }, clientSecret: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "clientSecret",
                xmlName: "clientSecret",
                type: {
                    name: "String"
                }
            } })
    }
};
const IdentityProviderCreateContractProperties = {
    serializedName: "IdentityProviderCreateContractProperties",
    type: {
        name: "Composite",
        className: "IdentityProviderCreateContractProperties",
        modelProperties: Object.assign(Object.assign({}, IdentityProviderBaseParameters.type.modelProperties), { clientId: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "clientId",
                required: true,
                xmlName: "clientId",
                type: {
                    name: "String"
                }
            }, clientSecret: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "clientSecret",
                required: true,
                xmlName: "clientSecret",
                type: {
                    name: "String"
                }
            } })
    }
};
const IdentityProviderUpdateProperties = {
    serializedName: "IdentityProviderUpdateProperties",
    type: {
        name: "Composite",
        className: "IdentityProviderUpdateProperties",
        modelProperties: Object.assign(Object.assign({}, IdentityProviderBaseParameters.type.modelProperties), { clientId: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String"
                }
            }, clientSecret: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "clientSecret",
                xmlName: "clientSecret",
                type: {
                    name: "String"
                }
            } })
    }
};
const NamedValueContractProperties = {
    serializedName: "NamedValueContractProperties",
    type: {
        name: "Composite",
        className: "NamedValueContractProperties",
        modelProperties: Object.assign(Object.assign({}, NamedValueEntityBaseParameters.type.modelProperties), { displayName: {
                constraints: {
                    Pattern: new RegExp("^[A-Za-z0-9-._]+$"),
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "displayName",
                required: true,
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            }, value: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }, keyVault: {
                serializedName: "keyVault",
                xmlName: "keyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultContractProperties"
                }
            } })
    }
};
const NamedValueCreateContractProperties = {
    serializedName: "NamedValueCreateContractProperties",
    type: {
        name: "Composite",
        className: "NamedValueCreateContractProperties",
        modelProperties: Object.assign(Object.assign({}, NamedValueEntityBaseParameters.type.modelProperties), { displayName: {
                constraints: {
                    Pattern: new RegExp("^[A-Za-z0-9-._]+$"),
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "displayName",
                required: true,
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            }, value: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }, keyVault: {
                serializedName: "keyVault",
                xmlName: "keyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultContractCreateProperties"
                }
            } })
    }
};
const NamedValueUpdateParameterProperties = {
    serializedName: "NamedValueUpdateParameterProperties",
    type: {
        name: "Composite",
        className: "NamedValueUpdateParameterProperties",
        modelProperties: Object.assign(Object.assign({}, NamedValueEntityBaseParameters.type.modelProperties), { displayName: {
                constraints: {
                    Pattern: new RegExp("^[A-Za-z0-9-._]+$"),
                    MaxLength: 256,
                    MinLength: 1
                },
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String"
                }
            }, value: {
                constraints: {
                    MaxLength: 4096,
                    MinLength: 1
                },
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }, keyVault: {
                serializedName: "keyVault",
                xmlName: "keyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultContractCreateProperties"
                }
            } })
    }
};
const ApiCreateOrUpdateProperties = {
    serializedName: "ApiCreateOrUpdateProperties",
    type: {
        name: "Composite",
        className: "ApiCreateOrUpdateProperties",
        modelProperties: Object.assign(Object.assign({}, ApiContractProperties.type.modelProperties), { value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }, format: {
                serializedName: "format",
                xmlName: "format",
                type: {
                    name: "String"
                }
            }, wsdlSelector: {
                serializedName: "wsdlSelector",
                xmlName: "wsdlSelector",
                type: {
                    name: "Composite",
                    className: "ApiCreateOrUpdatePropertiesWsdlSelector"
                }
            }, soapApiType: {
                serializedName: "apiType",
                xmlName: "apiType",
                type: {
                    name: "String"
                }
            } })
    }
};
const ApiGetEntityTagHeaders = {
    serializedName: "Api_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ApiGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiGetHeaders = {
    serializedName: "Api_getHeaders",
    type: {
        name: "Composite",
        className: "ApiGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiCreateOrUpdateHeaders = {
    serializedName: "Api_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ApiCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiUpdateHeaders = {
    serializedName: "Api_updateHeaders",
    type: {
        name: "Composite",
        className: "ApiUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiReleaseGetEntityTagHeaders = {
    serializedName: "ApiRelease_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ApiReleaseGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiReleaseGetHeaders = {
    serializedName: "ApiRelease_getHeaders",
    type: {
        name: "Composite",
        className: "ApiReleaseGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiReleaseCreateOrUpdateHeaders = {
    serializedName: "ApiRelease_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ApiReleaseCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiReleaseUpdateHeaders = {
    serializedName: "ApiRelease_updateHeaders",
    type: {
        name: "Composite",
        className: "ApiReleaseUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiOperationGetEntityTagHeaders = {
    serializedName: "ApiOperation_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ApiOperationGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiOperationGetHeaders = {
    serializedName: "ApiOperation_getHeaders",
    type: {
        name: "Composite",
        className: "ApiOperationGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiOperationCreateOrUpdateHeaders = {
    serializedName: "ApiOperation_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ApiOperationCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiOperationUpdateHeaders = {
    serializedName: "ApiOperation_updateHeaders",
    type: {
        name: "Composite",
        className: "ApiOperationUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiOperationPolicyGetEntityTagHeaders = {
    serializedName: "ApiOperationPolicy_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ApiOperationPolicyGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiOperationPolicyGetHeaders = {
    serializedName: "ApiOperationPolicy_getHeaders",
    type: {
        name: "Composite",
        className: "ApiOperationPolicyGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiOperationPolicyCreateOrUpdateHeaders = {
    serializedName: "ApiOperationPolicy_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ApiOperationPolicyCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagGetEntityStateByOperationHeaders = {
    serializedName: "Tag_getEntityStateByOperationHeaders",
    type: {
        name: "Composite",
        className: "TagGetEntityStateByOperationHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagGetByOperationHeaders = {
    serializedName: "Tag_getByOperationHeaders",
    type: {
        name: "Composite",
        className: "TagGetByOperationHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagGetEntityStateByApiHeaders = {
    serializedName: "Tag_getEntityStateByApiHeaders",
    type: {
        name: "Composite",
        className: "TagGetEntityStateByApiHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagGetByApiHeaders = {
    serializedName: "Tag_getByApiHeaders",
    type: {
        name: "Composite",
        className: "TagGetByApiHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagAssignToApiHeaders = {
    serializedName: "Tag_assignToApiHeaders",
    type: {
        name: "Composite",
        className: "TagAssignToApiHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagGetEntityStateByProductHeaders = {
    serializedName: "Tag_getEntityStateByProductHeaders",
    type: {
        name: "Composite",
        className: "TagGetEntityStateByProductHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagGetByProductHeaders = {
    serializedName: "Tag_getByProductHeaders",
    type: {
        name: "Composite",
        className: "TagGetByProductHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagGetEntityStateHeaders = {
    serializedName: "Tag_getEntityStateHeaders",
    type: {
        name: "Composite",
        className: "TagGetEntityStateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagGetHeaders = {
    serializedName: "Tag_getHeaders",
    type: {
        name: "Composite",
        className: "TagGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagCreateOrUpdateHeaders = {
    serializedName: "Tag_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "TagCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagUpdateHeaders = {
    serializedName: "Tag_updateHeaders",
    type: {
        name: "Composite",
        className: "TagUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiPolicyGetEntityTagHeaders = {
    serializedName: "ApiPolicy_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ApiPolicyGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiPolicyGetHeaders = {
    serializedName: "ApiPolicy_getHeaders",
    type: {
        name: "Composite",
        className: "ApiPolicyGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiPolicyCreateOrUpdateHeaders = {
    serializedName: "ApiPolicy_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ApiPolicyCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiSchemaGetEntityTagHeaders = {
    serializedName: "ApiSchema_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ApiSchemaGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiSchemaGetHeaders = {
    serializedName: "ApiSchema_getHeaders",
    type: {
        name: "Composite",
        className: "ApiSchemaGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiSchemaCreateOrUpdateHeaders = {
    serializedName: "ApiSchema_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ApiSchemaCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiDiagnosticGetEntityTagHeaders = {
    serializedName: "ApiDiagnostic_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ApiDiagnosticGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiDiagnosticGetHeaders = {
    serializedName: "ApiDiagnostic_getHeaders",
    type: {
        name: "Composite",
        className: "ApiDiagnosticGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiDiagnosticCreateOrUpdateHeaders = {
    serializedName: "ApiDiagnostic_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ApiDiagnosticCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiDiagnosticUpdateHeaders = {
    serializedName: "ApiDiagnostic_updateHeaders",
    type: {
        name: "Composite",
        className: "ApiDiagnosticUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiIssueGetEntityTagHeaders = {
    serializedName: "ApiIssue_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ApiIssueGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiIssueGetHeaders = {
    serializedName: "ApiIssue_getHeaders",
    type: {
        name: "Composite",
        className: "ApiIssueGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiIssueCreateOrUpdateHeaders = {
    serializedName: "ApiIssue_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ApiIssueCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiIssueUpdateHeaders = {
    serializedName: "ApiIssue_updateHeaders",
    type: {
        name: "Composite",
        className: "ApiIssueUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiIssueCommentGetEntityTagHeaders = {
    serializedName: "ApiIssueComment_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ApiIssueCommentGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiIssueCommentGetHeaders = {
    serializedName: "ApiIssueComment_getHeaders",
    type: {
        name: "Composite",
        className: "ApiIssueCommentGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiIssueCommentCreateOrUpdateHeaders = {
    serializedName: "ApiIssueComment_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ApiIssueCommentCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiIssueAttachmentGetEntityTagHeaders = {
    serializedName: "ApiIssueAttachment_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ApiIssueAttachmentGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiIssueAttachmentGetHeaders = {
    serializedName: "ApiIssueAttachment_getHeaders",
    type: {
        name: "Composite",
        className: "ApiIssueAttachmentGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiIssueAttachmentCreateOrUpdateHeaders = {
    serializedName: "ApiIssueAttachment_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ApiIssueAttachmentCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiTagDescriptionGetEntityTagHeaders = {
    serializedName: "ApiTagDescription_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ApiTagDescriptionGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiTagDescriptionGetHeaders = {
    serializedName: "ApiTagDescription_getHeaders",
    type: {
        name: "Composite",
        className: "ApiTagDescriptionGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiTagDescriptionCreateOrUpdateHeaders = {
    serializedName: "ApiTagDescription_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ApiTagDescriptionCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiVersionSetGetEntityTagHeaders = {
    serializedName: "ApiVersionSet_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ApiVersionSetGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiVersionSetGetHeaders = {
    serializedName: "ApiVersionSet_getHeaders",
    type: {
        name: "Composite",
        className: "ApiVersionSetGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiVersionSetCreateOrUpdateHeaders = {
    serializedName: "ApiVersionSet_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ApiVersionSetCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiVersionSetUpdateHeaders = {
    serializedName: "ApiVersionSet_updateHeaders",
    type: {
        name: "Composite",
        className: "ApiVersionSetUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizationServerGetEntityTagHeaders = {
    serializedName: "AuthorizationServer_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "AuthorizationServerGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizationServerGetHeaders = {
    serializedName: "AuthorizationServer_getHeaders",
    type: {
        name: "Composite",
        className: "AuthorizationServerGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizationServerCreateOrUpdateHeaders = {
    serializedName: "AuthorizationServer_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "AuthorizationServerCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizationServerUpdateHeaders = {
    serializedName: "AuthorizationServer_updateHeaders",
    type: {
        name: "Composite",
        className: "AuthorizationServerUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizationServerListSecretsHeaders = {
    serializedName: "AuthorizationServer_listSecretsHeaders",
    type: {
        name: "Composite",
        className: "AuthorizationServerListSecretsHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackendGetEntityTagHeaders = {
    serializedName: "Backend_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "BackendGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackendGetHeaders = {
    serializedName: "Backend_getHeaders",
    type: {
        name: "Composite",
        className: "BackendGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackendCreateOrUpdateHeaders = {
    serializedName: "Backend_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "BackendCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackendUpdateHeaders = {
    serializedName: "Backend_updateHeaders",
    type: {
        name: "Composite",
        className: "BackendUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheGetEntityTagHeaders = {
    serializedName: "Cache_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "CacheGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheGetHeaders = {
    serializedName: "Cache_getHeaders",
    type: {
        name: "Composite",
        className: "CacheGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheCreateOrUpdateHeaders = {
    serializedName: "Cache_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "CacheCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheUpdateHeaders = {
    serializedName: "Cache_updateHeaders",
    type: {
        name: "Composite",
        className: "CacheUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateGetEntityTagHeaders = {
    serializedName: "Certificate_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "CertificateGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateGetHeaders = {
    serializedName: "Certificate_getHeaders",
    type: {
        name: "Composite",
        className: "CertificateGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateCreateOrUpdateHeaders = {
    serializedName: "Certificate_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "CertificateCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateRefreshSecretHeaders = {
    serializedName: "Certificate_refreshSecretHeaders",
    type: {
        name: "Composite",
        className: "CertificateRefreshSecretHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContentTypeGetHeaders = {
    serializedName: "ContentType_getHeaders",
    type: {
        name: "Composite",
        className: "ContentTypeGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContentTypeCreateOrUpdateHeaders = {
    serializedName: "ContentType_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ContentTypeCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContentItemGetEntityTagHeaders = {
    serializedName: "ContentItem_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ContentItemGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContentItemGetHeaders = {
    serializedName: "ContentItem_getHeaders",
    type: {
        name: "Composite",
        className: "ContentItemGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContentItemCreateOrUpdateHeaders = {
    serializedName: "ContentItem_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ContentItemCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticGetEntityTagHeaders = {
    serializedName: "Diagnostic_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "DiagnosticGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticGetHeaders = {
    serializedName: "Diagnostic_getHeaders",
    type: {
        name: "Composite",
        className: "DiagnosticGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticCreateOrUpdateHeaders = {
    serializedName: "Diagnostic_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "DiagnosticCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticUpdateHeaders = {
    serializedName: "Diagnostic_updateHeaders",
    type: {
        name: "Composite",
        className: "DiagnosticUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EmailTemplateGetEntityTagHeaders = {
    serializedName: "EmailTemplate_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "EmailTemplateGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EmailTemplateGetHeaders = {
    serializedName: "EmailTemplate_getHeaders",
    type: {
        name: "Composite",
        className: "EmailTemplateGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EmailTemplateUpdateHeaders = {
    serializedName: "EmailTemplate_updateHeaders",
    type: {
        name: "Composite",
        className: "EmailTemplateUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayGetEntityTagHeaders = {
    serializedName: "Gateway_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "GatewayGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayGetHeaders = {
    serializedName: "Gateway_getHeaders",
    type: {
        name: "Composite",
        className: "GatewayGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayCreateOrUpdateHeaders = {
    serializedName: "Gateway_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "GatewayCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayUpdateHeaders = {
    serializedName: "Gateway_updateHeaders",
    type: {
        name: "Composite",
        className: "GatewayUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayListKeysHeaders = {
    serializedName: "Gateway_listKeysHeaders",
    type: {
        name: "Composite",
        className: "GatewayListKeysHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayHostnameConfigurationGetEntityTagHeaders = {
    serializedName: "GatewayHostnameConfiguration_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "GatewayHostnameConfigurationGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayHostnameConfigurationGetHeaders = {
    serializedName: "GatewayHostnameConfiguration_getHeaders",
    type: {
        name: "Composite",
        className: "GatewayHostnameConfigurationGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayHostnameConfigurationCreateOrUpdateHeaders = {
    serializedName: "GatewayHostnameConfiguration_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "GatewayHostnameConfigurationCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayApiGetEntityTagHeaders = {
    serializedName: "GatewayApi_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "GatewayApiGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayCertificateAuthorityGetEntityTagHeaders = {
    serializedName: "GatewayCertificateAuthority_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "GatewayCertificateAuthorityGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayCertificateAuthorityGetHeaders = {
    serializedName: "GatewayCertificateAuthority_getHeaders",
    type: {
        name: "Composite",
        className: "GatewayCertificateAuthorityGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayCertificateAuthorityCreateOrUpdateHeaders = {
    serializedName: "GatewayCertificateAuthority_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "GatewayCertificateAuthorityCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GroupGetEntityTagHeaders = {
    serializedName: "Group_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "GroupGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GroupGetHeaders = {
    serializedName: "Group_getHeaders",
    type: {
        name: "Composite",
        className: "GroupGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GroupCreateOrUpdateHeaders = {
    serializedName: "Group_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "GroupCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GroupUpdateHeaders = {
    serializedName: "Group_updateHeaders",
    type: {
        name: "Composite",
        className: "GroupUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdentityProviderGetEntityTagHeaders = {
    serializedName: "IdentityProvider_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "IdentityProviderGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdentityProviderGetHeaders = {
    serializedName: "IdentityProvider_getHeaders",
    type: {
        name: "Composite",
        className: "IdentityProviderGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdentityProviderCreateOrUpdateHeaders = {
    serializedName: "IdentityProvider_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "IdentityProviderCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdentityProviderUpdateHeaders = {
    serializedName: "IdentityProvider_updateHeaders",
    type: {
        name: "Composite",
        className: "IdentityProviderUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdentityProviderListSecretsHeaders = {
    serializedName: "IdentityProvider_listSecretsHeaders",
    type: {
        name: "Composite",
        className: "IdentityProviderListSecretsHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IssueGetHeaders = {
    serializedName: "Issue_getHeaders",
    type: {
        name: "Composite",
        className: "IssueGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoggerGetEntityTagHeaders = {
    serializedName: "Logger_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "LoggerGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoggerGetHeaders = {
    serializedName: "Logger_getHeaders",
    type: {
        name: "Composite",
        className: "LoggerGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoggerCreateOrUpdateHeaders = {
    serializedName: "Logger_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "LoggerCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoggerUpdateHeaders = {
    serializedName: "Logger_updateHeaders",
    type: {
        name: "Composite",
        className: "LoggerUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NamedValueGetEntityTagHeaders = {
    serializedName: "NamedValue_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "NamedValueGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NamedValueGetHeaders = {
    serializedName: "NamedValue_getHeaders",
    type: {
        name: "Composite",
        className: "NamedValueGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NamedValueCreateOrUpdateHeaders = {
    serializedName: "NamedValue_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "NamedValueCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NamedValueUpdateHeaders = {
    serializedName: "NamedValue_updateHeaders",
    type: {
        name: "Composite",
        className: "NamedValueUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NamedValueListValueHeaders = {
    serializedName: "NamedValue_listValueHeaders",
    type: {
        name: "Composite",
        className: "NamedValueListValueHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NamedValueRefreshSecretHeaders = {
    serializedName: "NamedValue_refreshSecretHeaders",
    type: {
        name: "Composite",
        className: "NamedValueRefreshSecretHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenIdConnectProviderGetEntityTagHeaders = {
    serializedName: "OpenIdConnectProvider_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "OpenIdConnectProviderGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenIdConnectProviderGetHeaders = {
    serializedName: "OpenIdConnectProvider_getHeaders",
    type: {
        name: "Composite",
        className: "OpenIdConnectProviderGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenIdConnectProviderCreateOrUpdateHeaders = {
    serializedName: "OpenIdConnectProvider_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "OpenIdConnectProviderCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenIdConnectProviderUpdateHeaders = {
    serializedName: "OpenIdConnectProvider_updateHeaders",
    type: {
        name: "Composite",
        className: "OpenIdConnectProviderUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenIdConnectProviderListSecretsHeaders = {
    serializedName: "OpenIdConnectProvider_listSecretsHeaders",
    type: {
        name: "Composite",
        className: "OpenIdConnectProviderListSecretsHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicyGetEntityTagHeaders = {
    serializedName: "Policy_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "PolicyGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicyGetHeaders = {
    serializedName: "Policy_getHeaders",
    type: {
        name: "Composite",
        className: "PolicyGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicyCreateOrUpdateHeaders = {
    serializedName: "Policy_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "PolicyCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PortalRevisionGetEntityTagHeaders = {
    serializedName: "PortalRevision_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "PortalRevisionGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PortalRevisionGetHeaders = {
    serializedName: "PortalRevision_getHeaders",
    type: {
        name: "Composite",
        className: "PortalRevisionGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PortalRevisionCreateOrUpdateHeaders = {
    serializedName: "PortalRevision_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "PortalRevisionCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PortalRevisionUpdateHeaders = {
    serializedName: "PortalRevision_updateHeaders",
    type: {
        name: "Composite",
        className: "PortalRevisionUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SignInSettingsGetEntityTagHeaders = {
    serializedName: "SignInSettings_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "SignInSettingsGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SignInSettingsGetHeaders = {
    serializedName: "SignInSettings_getHeaders",
    type: {
        name: "Composite",
        className: "SignInSettingsGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SignUpSettingsGetEntityTagHeaders = {
    serializedName: "SignUpSettings_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "SignUpSettingsGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SignUpSettingsGetHeaders = {
    serializedName: "SignUpSettings_getHeaders",
    type: {
        name: "Composite",
        className: "SignUpSettingsGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DelegationSettingsGetEntityTagHeaders = {
    serializedName: "DelegationSettings_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "DelegationSettingsGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DelegationSettingsGetHeaders = {
    serializedName: "DelegationSettings_getHeaders",
    type: {
        name: "Composite",
        className: "DelegationSettingsGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProductGetEntityTagHeaders = {
    serializedName: "Product_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ProductGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProductGetHeaders = {
    serializedName: "Product_getHeaders",
    type: {
        name: "Composite",
        className: "ProductGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProductCreateOrUpdateHeaders = {
    serializedName: "Product_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ProductCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProductUpdateHeaders = {
    serializedName: "Product_updateHeaders",
    type: {
        name: "Composite",
        className: "ProductUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProductPolicyGetEntityTagHeaders = {
    serializedName: "ProductPolicy_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "ProductPolicyGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProductPolicyGetHeaders = {
    serializedName: "ProductPolicy_getHeaders",
    type: {
        name: "Composite",
        className: "ProductPolicyGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProductPolicyCreateOrUpdateHeaders = {
    serializedName: "ProductPolicy_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "ProductPolicyCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TenantSettingsGetHeaders = {
    serializedName: "TenantSettings_getHeaders",
    type: {
        name: "Composite",
        className: "TenantSettingsGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubscriptionGetEntityTagHeaders = {
    serializedName: "Subscription_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "SubscriptionGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubscriptionGetHeaders = {
    serializedName: "Subscription_getHeaders",
    type: {
        name: "Composite",
        className: "SubscriptionGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubscriptionCreateOrUpdateHeaders = {
    serializedName: "Subscription_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "SubscriptionCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubscriptionUpdateHeaders = {
    serializedName: "Subscription_updateHeaders",
    type: {
        name: "Composite",
        className: "SubscriptionUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubscriptionListSecretsHeaders = {
    serializedName: "Subscription_listSecretsHeaders",
    type: {
        name: "Composite",
        className: "SubscriptionListSecretsHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TenantAccessGetEntityTagHeaders = {
    serializedName: "TenantAccess_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "TenantAccessGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TenantAccessGetHeaders = {
    serializedName: "TenantAccess_getHeaders",
    type: {
        name: "Composite",
        className: "TenantAccessGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TenantAccessCreateHeaders = {
    serializedName: "TenantAccess_createHeaders",
    type: {
        name: "Composite",
        className: "TenantAccessCreateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TenantAccessUpdateHeaders = {
    serializedName: "TenantAccess_updateHeaders",
    type: {
        name: "Composite",
        className: "TenantAccessUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TenantAccessListSecretsHeaders = {
    serializedName: "TenantAccess_listSecretsHeaders",
    type: {
        name: "Composite",
        className: "TenantAccessListSecretsHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserGetEntityTagHeaders = {
    serializedName: "User_getEntityTagHeaders",
    type: {
        name: "Composite",
        className: "UserGetEntityTagHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserGetHeaders = {
    serializedName: "User_getHeaders",
    type: {
        name: "Composite",
        className: "UserGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserCreateOrUpdateHeaders = {
    serializedName: "User_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "UserCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserUpdateHeaders = {
    serializedName: "User_updateHeaders",
    type: {
        name: "Composite",
        className: "UserUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserSubscriptionGetHeaders = {
    serializedName: "UserSubscription_getHeaders",
    type: {
        name: "Composite",
        className: "UserSubscriptionGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ApiCollection: ApiCollection,
    ApiVersionSetContractDetails: ApiVersionSetContractDetails,
    ApiEntityBaseContract: ApiEntityBaseContract,
    AuthenticationSettingsContract: AuthenticationSettingsContract,
    OAuth2AuthenticationSettingsContract: OAuth2AuthenticationSettingsContract,
    OpenIdAuthenticationSettingsContract: OpenIdAuthenticationSettingsContract,
    SubscriptionKeyParameterNamesContract: SubscriptionKeyParameterNamesContract,
    ApiContactInformation: ApiContactInformation,
    ApiLicenseInformation: ApiLicenseInformation,
    Resource: Resource,
    ErrorResponse: ErrorResponse,
    ErrorResponseBody: ErrorResponseBody,
    ErrorFieldContract: ErrorFieldContract,
    ApiCreateOrUpdateParameter: ApiCreateOrUpdateParameter,
    ApiCreateOrUpdatePropertiesWsdlSelector: ApiCreateOrUpdatePropertiesWsdlSelector,
    ApiUpdateContract: ApiUpdateContract,
    ApiRevisionCollection: ApiRevisionCollection,
    ApiRevisionContract: ApiRevisionContract,
    ApiReleaseCollection: ApiReleaseCollection,
    OperationCollection: OperationCollection,
    OperationEntityBaseContract: OperationEntityBaseContract,
    ParameterContract: ParameterContract,
    ParameterExampleContract: ParameterExampleContract,
    RequestContract: RequestContract,
    RepresentationContract: RepresentationContract,
    ResponseContract: ResponseContract,
    OperationUpdateContract: OperationUpdateContract,
    PolicyCollection: PolicyCollection,
    TagCollection: TagCollection,
    ProductCollection: ProductCollection,
    ProductEntityBaseParameters: ProductEntityBaseParameters,
    SchemaCollection: SchemaCollection,
    DiagnosticCollection: DiagnosticCollection,
    SamplingSettings: SamplingSettings,
    PipelineDiagnosticSettings: PipelineDiagnosticSettings,
    HttpMessageDiagnostic: HttpMessageDiagnostic,
    BodyDiagnosticSettings: BodyDiagnosticSettings,
    DataMasking: DataMasking,
    DataMaskingEntity: DataMaskingEntity,
    IssueCollection: IssueCollection,
    IssueContractBaseProperties: IssueContractBaseProperties,
    IssueUpdateContract: IssueUpdateContract,
    IssueCommentCollection: IssueCommentCollection,
    IssueAttachmentCollection: IssueAttachmentCollection,
    TagDescriptionCollection: TagDescriptionCollection,
    TagDescriptionBaseProperties: TagDescriptionBaseProperties,
    TagDescriptionCreateParameters: TagDescriptionCreateParameters,
    TagResourceCollection: TagResourceCollection,
    TagResourceContract: TagResourceContract,
    TagResourceContractProperties: TagResourceContractProperties,
    OperationTagResourceContractProperties: OperationTagResourceContractProperties,
    ApiExportResult: ApiExportResult,
    ApiExportResultValue: ApiExportResultValue,
    ApiVersionSetCollection: ApiVersionSetCollection,
    ApiVersionSetEntityBase: ApiVersionSetEntityBase,
    ApiVersionSetUpdateParameters: ApiVersionSetUpdateParameters,
    AuthorizationServerCollection: AuthorizationServerCollection,
    AuthorizationServerContractBaseProperties: AuthorizationServerContractBaseProperties,
    TokenBodyParameterContract: TokenBodyParameterContract,
    AuthorizationServerSecretsContract: AuthorizationServerSecretsContract,
    BackendCollection: BackendCollection,
    BackendBaseParameters: BackendBaseParameters,
    BackendProperties: BackendProperties,
    BackendServiceFabricClusterProperties: BackendServiceFabricClusterProperties,
    X509CertificateName: X509CertificateName,
    BackendCredentialsContract: BackendCredentialsContract,
    BackendAuthorizationHeaderCredentials: BackendAuthorizationHeaderCredentials,
    BackendProxyContract: BackendProxyContract,
    BackendTlsProperties: BackendTlsProperties,
    BackendUpdateParameters: BackendUpdateParameters,
    CacheCollection: CacheCollection,
    CacheUpdateParameters: CacheUpdateParameters,
    CertificateCollection: CertificateCollection,
    KeyVaultLastAccessStatusContractProperties: KeyVaultLastAccessStatusContractProperties,
    KeyVaultContractCreateProperties: KeyVaultContractCreateProperties,
    CertificateCreateOrUpdateParameters: CertificateCreateOrUpdateParameters,
    ConnectivityCheckRequest: ConnectivityCheckRequest,
    ConnectivityCheckRequestSource: ConnectivityCheckRequestSource,
    ConnectivityCheckRequestDestination: ConnectivityCheckRequestDestination,
    ConnectivityCheckRequestProtocolConfiguration: ConnectivityCheckRequestProtocolConfiguration,
    ConnectivityCheckRequestProtocolConfigurationHttpConfiguration: ConnectivityCheckRequestProtocolConfigurationHttpConfiguration,
    HttpHeader: HttpHeader,
    ConnectivityCheckResponse: ConnectivityCheckResponse,
    ConnectivityHop: ConnectivityHop,
    ConnectivityIssue: ConnectivityIssue,
    ContentTypeCollection: ContentTypeCollection,
    ContentItemCollection: ContentItemCollection,
    DeletedServicesCollection: DeletedServicesCollection,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    ResourceSkuResults: ResourceSkuResults,
    ResourceSkuResult: ResourceSkuResult,
    ResourceSku: ResourceSku,
    ResourceSkuCapacity: ResourceSkuCapacity,
    ApiManagementServiceBackupRestoreParameters: ApiManagementServiceBackupRestoreParameters,
    ApiManagementServiceBaseProperties: ApiManagementServiceBaseProperties,
    HostnameConfiguration: HostnameConfiguration,
    CertificateInformation: CertificateInformation,
    VirtualNetworkConfiguration: VirtualNetworkConfiguration,
    AdditionalLocation: AdditionalLocation,
    ApiManagementServiceSkuProperties: ApiManagementServiceSkuProperties,
    CertificateConfiguration: CertificateConfiguration,
    ApiVersionConstraint: ApiVersionConstraint,
    RemotePrivateEndpointConnectionWrapper: RemotePrivateEndpointConnectionWrapper,
    ArmIdWrapper: ArmIdWrapper,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    ApiManagementServiceIdentity: ApiManagementServiceIdentity,
    UserIdentityProperties: UserIdentityProperties,
    SystemData: SystemData,
    ApimResource: ApimResource,
    ApiManagementServiceListResult: ApiManagementServiceListResult,
    ApiManagementServiceGetSsoTokenResult: ApiManagementServiceGetSsoTokenResult,
    ApiManagementServiceCheckNameAvailabilityParameters: ApiManagementServiceCheckNameAvailabilityParameters,
    ApiManagementServiceNameAvailabilityResult: ApiManagementServiceNameAvailabilityResult,
    ApiManagementServiceGetDomainOwnershipIdentifierResult: ApiManagementServiceGetDomainOwnershipIdentifierResult,
    ApiManagementServiceApplyNetworkConfigurationParameters: ApiManagementServiceApplyNetworkConfigurationParameters,
    EmailTemplateCollection: EmailTemplateCollection,
    EmailTemplateParametersContractProperties: EmailTemplateParametersContractProperties,
    EmailTemplateUpdateParameters: EmailTemplateUpdateParameters,
    GatewayCollection: GatewayCollection,
    ResourceLocationDataContract: ResourceLocationDataContract,
    GatewayKeysContract: GatewayKeysContract,
    GatewayKeyRegenerationRequestContract: GatewayKeyRegenerationRequestContract,
    GatewayTokenRequestContract: GatewayTokenRequestContract,
    GatewayTokenContract: GatewayTokenContract,
    GatewayHostnameConfigurationCollection: GatewayHostnameConfigurationCollection,
    GatewayCertificateAuthorityCollection: GatewayCertificateAuthorityCollection,
    GroupCollection: GroupCollection,
    GroupContractProperties: GroupContractProperties,
    GroupCreateParameters: GroupCreateParameters,
    GroupUpdateParameters: GroupUpdateParameters,
    UserCollection: UserCollection,
    UserEntityBaseParameters: UserEntityBaseParameters,
    UserIdentityContract: UserIdentityContract,
    IdentityProviderList: IdentityProviderList,
    IdentityProviderBaseParameters: IdentityProviderBaseParameters,
    IdentityProviderUpdateParameters: IdentityProviderUpdateParameters,
    ClientSecretContract: ClientSecretContract,
    LoggerCollection: LoggerCollection,
    LoggerUpdateContract: LoggerUpdateContract,
    NamedValueCollection: NamedValueCollection,
    NamedValueEntityBaseParameters: NamedValueEntityBaseParameters,
    NamedValueUpdateParameters: NamedValueUpdateParameters,
    NamedValueSecretContract: NamedValueSecretContract,
    NetworkStatusContractByLocation: NetworkStatusContractByLocation,
    NetworkStatusContract: NetworkStatusContract,
    ConnectivityStatusContract: ConnectivityStatusContract,
    NotificationCollection: NotificationCollection,
    RecipientsContractProperties: RecipientsContractProperties,
    RecipientUserCollection: RecipientUserCollection,
    RecipientEmailCollection: RecipientEmailCollection,
    OpenIdConnectProviderCollection: OpenIdConnectProviderCollection,
    OpenidConnectProviderUpdateContract: OpenidConnectProviderUpdateContract,
    OutboundEnvironmentEndpointList: OutboundEnvironmentEndpointList,
    OutboundEnvironmentEndpoint: OutboundEnvironmentEndpoint,
    EndpointDependency: EndpointDependency,
    EndpointDetail: EndpointDetail,
    PolicyDescriptionCollection: PolicyDescriptionCollection,
    PortalRevisionCollection: PortalRevisionCollection,
    PortalSettingsCollection: PortalSettingsCollection,
    SubscriptionsDelegationSettingsProperties: SubscriptionsDelegationSettingsProperties,
    RegistrationDelegationSettingsProperties: RegistrationDelegationSettingsProperties,
    TermsOfServiceProperties: TermsOfServiceProperties,
    PortalSettingValidationKeyContract: PortalSettingValidationKeyContract,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateEndpoint: PrivateEndpoint,
    PrivateEndpointConnectionRequest: PrivateEndpointConnectionRequest,
    PrivateEndpointConnectionRequestProperties: PrivateEndpointConnectionRequestProperties,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    ProductUpdateParameters: ProductUpdateParameters,
    SubscriptionCollection: SubscriptionCollection,
    QuotaCounterCollection: QuotaCounterCollection,
    QuotaCounterContract: QuotaCounterContract,
    QuotaCounterValueContractProperties: QuotaCounterValueContractProperties,
    QuotaCounterValueUpdateContract: QuotaCounterValueUpdateContract,
    RegionListResult: RegionListResult,
    RegionContract: RegionContract,
    ReportCollection: ReportCollection,
    ReportRecordContract: ReportRecordContract,
    RequestReportCollection: RequestReportCollection,
    RequestReportRecordContract: RequestReportRecordContract,
    TenantSettingsCollection: TenantSettingsCollection,
    ApiManagementSkusResult: ApiManagementSkusResult,
    ApiManagementSku: ApiManagementSku,
    ApiManagementSkuCapacity: ApiManagementSkuCapacity,
    ApiManagementSkuLocationInfo: ApiManagementSkuLocationInfo,
    ApiManagementSkuZoneDetails: ApiManagementSkuZoneDetails,
    ApiManagementSkuCapabilities: ApiManagementSkuCapabilities,
    ApiManagementSkuCosts: ApiManagementSkuCosts,
    ApiManagementSkuRestrictions: ApiManagementSkuRestrictions,
    ApiManagementSkuRestrictionInfo: ApiManagementSkuRestrictionInfo,
    SubscriptionCreateParameters: SubscriptionCreateParameters,
    SubscriptionUpdateParameters: SubscriptionUpdateParameters,
    SubscriptionKeysContract: SubscriptionKeysContract,
    TagCreateUpdateParameters: TagCreateUpdateParameters,
    AccessInformationCollection: AccessInformationCollection,
    AccessInformationCreateParameters: AccessInformationCreateParameters,
    AccessInformationUpdateParameters: AccessInformationUpdateParameters,
    AccessInformationSecretsContract: AccessInformationSecretsContract,
    DeployConfigurationParameters: DeployConfigurationParameters,
    OperationResultLogItemContract: OperationResultLogItemContract,
    SaveConfigurationParameter: SaveConfigurationParameter,
    UserCreateParameters: UserCreateParameters,
    UserUpdateParameters: UserUpdateParameters,
    GenerateSsoUrlResult: GenerateSsoUrlResult,
    UserIdentityCollection: UserIdentityCollection,
    UserTokenParameters: UserTokenParameters,
    UserTokenResult: UserTokenResult,
    ApiRevisionInfoContract: ApiRevisionInfoContract,
    QuotaCounterValueContract: QuotaCounterValueContract,
    ApiContractProperties: ApiContractProperties,
    ApiContractUpdateProperties: ApiContractUpdateProperties,
    ApiTagResourceContractProperties: ApiTagResourceContractProperties,
    ApiContract: ApiContract,
    ApiReleaseContract: ApiReleaseContract,
    OperationContract: OperationContract,
    PolicyContract: PolicyContract,
    TagContract: TagContract,
    ProductContract: ProductContract,
    SchemaContract: SchemaContract,
    DiagnosticContract: DiagnosticContract,
    IssueContract: IssueContract,
    IssueCommentContract: IssueCommentContract,
    IssueAttachmentContract: IssueAttachmentContract,
    TagDescriptionContract: TagDescriptionContract,
    ApiVersionSetContract: ApiVersionSetContract,
    AuthorizationServerContract: AuthorizationServerContract,
    AuthorizationServerUpdateContract: AuthorizationServerUpdateContract,
    BackendContract: BackendContract,
    BackendReconnectContract: BackendReconnectContract,
    CacheContract: CacheContract,
    CertificateContract: CertificateContract,
    ContentTypeContract: ContentTypeContract,
    ContentItemContract: ContentItemContract,
    DeletedServiceContract: DeletedServiceContract,
    EmailTemplateContract: EmailTemplateContract,
    GatewayContract: GatewayContract,
    GatewayHostnameConfigurationContract: GatewayHostnameConfigurationContract,
    AssociationContract: AssociationContract,
    GatewayCertificateAuthorityContract: GatewayCertificateAuthorityContract,
    GroupContract: GroupContract,
    UserContract: UserContract,
    IdentityProviderContract: IdentityProviderContract,
    IdentityProviderCreateContract: IdentityProviderCreateContract,
    LoggerContract: LoggerContract,
    NamedValueContract: NamedValueContract,
    NamedValueCreateContract: NamedValueCreateContract,
    NotificationContract: NotificationContract,
    RecipientUserContract: RecipientUserContract,
    RecipientEmailContract: RecipientEmailContract,
    OpenidConnectProviderContract: OpenidConnectProviderContract,
    PolicyDescriptionContract: PolicyDescriptionContract,
    PortalRevisionContract: PortalRevisionContract,
    PortalSettingsContract: PortalSettingsContract,
    PortalSigninSettings: PortalSigninSettings,
    PortalSignupSettings: PortalSignupSettings,
    PortalDelegationSettings: PortalDelegationSettings,
    PrivateEndpointConnection: PrivateEndpointConnection,
    PrivateLinkResource: PrivateLinkResource,
    SubscriptionContract: SubscriptionContract,
    TenantSettingsContract: TenantSettingsContract,
    AccessInformationContract: AccessInformationContract,
    OperationResultContract: OperationResultContract,
    TenantConfigurationSyncStateContract: TenantConfigurationSyncStateContract,
    OperationContractProperties: OperationContractProperties,
    OperationUpdateContractProperties: OperationUpdateContractProperties,
    ProductContractProperties: ProductContractProperties,
    ProductTagResourceContractProperties: ProductTagResourceContractProperties,
    ProductUpdateProperties: ProductUpdateProperties,
    IssueContractProperties: IssueContractProperties,
    IssueUpdateContractProperties: IssueUpdateContractProperties,
    TagDescriptionContractProperties: TagDescriptionContractProperties,
    ApiVersionSetContractProperties: ApiVersionSetContractProperties,
    ApiVersionSetUpdateParametersProperties: ApiVersionSetUpdateParametersProperties,
    AuthorizationServerContractProperties: AuthorizationServerContractProperties,
    AuthorizationServerUpdateContractProperties: AuthorizationServerUpdateContractProperties,
    BackendContractProperties: BackendContractProperties,
    BackendUpdateParameterProperties: BackendUpdateParameterProperties,
    KeyVaultContractProperties: KeyVaultContractProperties,
    ApiManagementServiceProperties: ApiManagementServiceProperties,
    ApiManagementServiceUpdateProperties: ApiManagementServiceUpdateProperties,
    ApiManagementServiceResource: ApiManagementServiceResource,
    ApiManagementServiceUpdateParameters: ApiManagementServiceUpdateParameters,
    UserContractProperties: UserContractProperties,
    UserCreateParameterProperties: UserCreateParameterProperties,
    UserUpdateParametersProperties: UserUpdateParametersProperties,
    IdentityProviderContractProperties: IdentityProviderContractProperties,
    IdentityProviderCreateContractProperties: IdentityProviderCreateContractProperties,
    IdentityProviderUpdateProperties: IdentityProviderUpdateProperties,
    NamedValueContractProperties: NamedValueContractProperties,
    NamedValueCreateContractProperties: NamedValueCreateContractProperties,
    NamedValueUpdateParameterProperties: NamedValueUpdateParameterProperties,
    ApiCreateOrUpdateProperties: ApiCreateOrUpdateProperties,
    ApiGetEntityTagHeaders: ApiGetEntityTagHeaders,
    ApiGetHeaders: ApiGetHeaders,
    ApiCreateOrUpdateHeaders: ApiCreateOrUpdateHeaders,
    ApiUpdateHeaders: ApiUpdateHeaders,
    ApiReleaseGetEntityTagHeaders: ApiReleaseGetEntityTagHeaders,
    ApiReleaseGetHeaders: ApiReleaseGetHeaders,
    ApiReleaseCreateOrUpdateHeaders: ApiReleaseCreateOrUpdateHeaders,
    ApiReleaseUpdateHeaders: ApiReleaseUpdateHeaders,
    ApiOperationGetEntityTagHeaders: ApiOperationGetEntityTagHeaders,
    ApiOperationGetHeaders: ApiOperationGetHeaders,
    ApiOperationCreateOrUpdateHeaders: ApiOperationCreateOrUpdateHeaders,
    ApiOperationUpdateHeaders: ApiOperationUpdateHeaders,
    ApiOperationPolicyGetEntityTagHeaders: ApiOperationPolicyGetEntityTagHeaders,
    ApiOperationPolicyGetHeaders: ApiOperationPolicyGetHeaders,
    ApiOperationPolicyCreateOrUpdateHeaders: ApiOperationPolicyCreateOrUpdateHeaders,
    TagGetEntityStateByOperationHeaders: TagGetEntityStateByOperationHeaders,
    TagGetByOperationHeaders: TagGetByOperationHeaders,
    TagGetEntityStateByApiHeaders: TagGetEntityStateByApiHeaders,
    TagGetByApiHeaders: TagGetByApiHeaders,
    TagAssignToApiHeaders: TagAssignToApiHeaders,
    TagGetEntityStateByProductHeaders: TagGetEntityStateByProductHeaders,
    TagGetByProductHeaders: TagGetByProductHeaders,
    TagGetEntityStateHeaders: TagGetEntityStateHeaders,
    TagGetHeaders: TagGetHeaders,
    TagCreateOrUpdateHeaders: TagCreateOrUpdateHeaders,
    TagUpdateHeaders: TagUpdateHeaders,
    ApiPolicyGetEntityTagHeaders: ApiPolicyGetEntityTagHeaders,
    ApiPolicyGetHeaders: ApiPolicyGetHeaders,
    ApiPolicyCreateOrUpdateHeaders: ApiPolicyCreateOrUpdateHeaders,
    ApiSchemaGetEntityTagHeaders: ApiSchemaGetEntityTagHeaders,
    ApiSchemaGetHeaders: ApiSchemaGetHeaders,
    ApiSchemaCreateOrUpdateHeaders: ApiSchemaCreateOrUpdateHeaders,
    ApiDiagnosticGetEntityTagHeaders: ApiDiagnosticGetEntityTagHeaders,
    ApiDiagnosticGetHeaders: ApiDiagnosticGetHeaders,
    ApiDiagnosticCreateOrUpdateHeaders: ApiDiagnosticCreateOrUpdateHeaders,
    ApiDiagnosticUpdateHeaders: ApiDiagnosticUpdateHeaders,
    ApiIssueGetEntityTagHeaders: ApiIssueGetEntityTagHeaders,
    ApiIssueGetHeaders: ApiIssueGetHeaders,
    ApiIssueCreateOrUpdateHeaders: ApiIssueCreateOrUpdateHeaders,
    ApiIssueUpdateHeaders: ApiIssueUpdateHeaders,
    ApiIssueCommentGetEntityTagHeaders: ApiIssueCommentGetEntityTagHeaders,
    ApiIssueCommentGetHeaders: ApiIssueCommentGetHeaders,
    ApiIssueCommentCreateOrUpdateHeaders: ApiIssueCommentCreateOrUpdateHeaders,
    ApiIssueAttachmentGetEntityTagHeaders: ApiIssueAttachmentGetEntityTagHeaders,
    ApiIssueAttachmentGetHeaders: ApiIssueAttachmentGetHeaders,
    ApiIssueAttachmentCreateOrUpdateHeaders: ApiIssueAttachmentCreateOrUpdateHeaders,
    ApiTagDescriptionGetEntityTagHeaders: ApiTagDescriptionGetEntityTagHeaders,
    ApiTagDescriptionGetHeaders: ApiTagDescriptionGetHeaders,
    ApiTagDescriptionCreateOrUpdateHeaders: ApiTagDescriptionCreateOrUpdateHeaders,
    ApiVersionSetGetEntityTagHeaders: ApiVersionSetGetEntityTagHeaders,
    ApiVersionSetGetHeaders: ApiVersionSetGetHeaders,
    ApiVersionSetCreateOrUpdateHeaders: ApiVersionSetCreateOrUpdateHeaders,
    ApiVersionSetUpdateHeaders: ApiVersionSetUpdateHeaders,
    AuthorizationServerGetEntityTagHeaders: AuthorizationServerGetEntityTagHeaders,
    AuthorizationServerGetHeaders: AuthorizationServerGetHeaders,
    AuthorizationServerCreateOrUpdateHeaders: AuthorizationServerCreateOrUpdateHeaders,
    AuthorizationServerUpdateHeaders: AuthorizationServerUpdateHeaders,
    AuthorizationServerListSecretsHeaders: AuthorizationServerListSecretsHeaders,
    BackendGetEntityTagHeaders: BackendGetEntityTagHeaders,
    BackendGetHeaders: BackendGetHeaders,
    BackendCreateOrUpdateHeaders: BackendCreateOrUpdateHeaders,
    BackendUpdateHeaders: BackendUpdateHeaders,
    CacheGetEntityTagHeaders: CacheGetEntityTagHeaders,
    CacheGetHeaders: CacheGetHeaders,
    CacheCreateOrUpdateHeaders: CacheCreateOrUpdateHeaders,
    CacheUpdateHeaders: CacheUpdateHeaders,
    CertificateGetEntityTagHeaders: CertificateGetEntityTagHeaders,
    CertificateGetHeaders: CertificateGetHeaders,
    CertificateCreateOrUpdateHeaders: CertificateCreateOrUpdateHeaders,
    CertificateRefreshSecretHeaders: CertificateRefreshSecretHeaders,
    ContentTypeGetHeaders: ContentTypeGetHeaders,
    ContentTypeCreateOrUpdateHeaders: ContentTypeCreateOrUpdateHeaders,
    ContentItemGetEntityTagHeaders: ContentItemGetEntityTagHeaders,
    ContentItemGetHeaders: ContentItemGetHeaders,
    ContentItemCreateOrUpdateHeaders: ContentItemCreateOrUpdateHeaders,
    DiagnosticGetEntityTagHeaders: DiagnosticGetEntityTagHeaders,
    DiagnosticGetHeaders: DiagnosticGetHeaders,
    DiagnosticCreateOrUpdateHeaders: DiagnosticCreateOrUpdateHeaders,
    DiagnosticUpdateHeaders: DiagnosticUpdateHeaders,
    EmailTemplateGetEntityTagHeaders: EmailTemplateGetEntityTagHeaders,
    EmailTemplateGetHeaders: EmailTemplateGetHeaders,
    EmailTemplateUpdateHeaders: EmailTemplateUpdateHeaders,
    GatewayGetEntityTagHeaders: GatewayGetEntityTagHeaders,
    GatewayGetHeaders: GatewayGetHeaders,
    GatewayCreateOrUpdateHeaders: GatewayCreateOrUpdateHeaders,
    GatewayUpdateHeaders: GatewayUpdateHeaders,
    GatewayListKeysHeaders: GatewayListKeysHeaders,
    GatewayHostnameConfigurationGetEntityTagHeaders: GatewayHostnameConfigurationGetEntityTagHeaders,
    GatewayHostnameConfigurationGetHeaders: GatewayHostnameConfigurationGetHeaders,
    GatewayHostnameConfigurationCreateOrUpdateHeaders: GatewayHostnameConfigurationCreateOrUpdateHeaders,
    GatewayApiGetEntityTagHeaders: GatewayApiGetEntityTagHeaders,
    GatewayCertificateAuthorityGetEntityTagHeaders: GatewayCertificateAuthorityGetEntityTagHeaders,
    GatewayCertificateAuthorityGetHeaders: GatewayCertificateAuthorityGetHeaders,
    GatewayCertificateAuthorityCreateOrUpdateHeaders: GatewayCertificateAuthorityCreateOrUpdateHeaders,
    GroupGetEntityTagHeaders: GroupGetEntityTagHeaders,
    GroupGetHeaders: GroupGetHeaders,
    GroupCreateOrUpdateHeaders: GroupCreateOrUpdateHeaders,
    GroupUpdateHeaders: GroupUpdateHeaders,
    IdentityProviderGetEntityTagHeaders: IdentityProviderGetEntityTagHeaders,
    IdentityProviderGetHeaders: IdentityProviderGetHeaders,
    IdentityProviderCreateOrUpdateHeaders: IdentityProviderCreateOrUpdateHeaders,
    IdentityProviderUpdateHeaders: IdentityProviderUpdateHeaders,
    IdentityProviderListSecretsHeaders: IdentityProviderListSecretsHeaders,
    IssueGetHeaders: IssueGetHeaders,
    LoggerGetEntityTagHeaders: LoggerGetEntityTagHeaders,
    LoggerGetHeaders: LoggerGetHeaders,
    LoggerCreateOrUpdateHeaders: LoggerCreateOrUpdateHeaders,
    LoggerUpdateHeaders: LoggerUpdateHeaders,
    NamedValueGetEntityTagHeaders: NamedValueGetEntityTagHeaders,
    NamedValueGetHeaders: NamedValueGetHeaders,
    NamedValueCreateOrUpdateHeaders: NamedValueCreateOrUpdateHeaders,
    NamedValueUpdateHeaders: NamedValueUpdateHeaders,
    NamedValueListValueHeaders: NamedValueListValueHeaders,
    NamedValueRefreshSecretHeaders: NamedValueRefreshSecretHeaders,
    OpenIdConnectProviderGetEntityTagHeaders: OpenIdConnectProviderGetEntityTagHeaders,
    OpenIdConnectProviderGetHeaders: OpenIdConnectProviderGetHeaders,
    OpenIdConnectProviderCreateOrUpdateHeaders: OpenIdConnectProviderCreateOrUpdateHeaders,
    OpenIdConnectProviderUpdateHeaders: OpenIdConnectProviderUpdateHeaders,
    OpenIdConnectProviderListSecretsHeaders: OpenIdConnectProviderListSecretsHeaders,
    PolicyGetEntityTagHeaders: PolicyGetEntityTagHeaders,
    PolicyGetHeaders: PolicyGetHeaders,
    PolicyCreateOrUpdateHeaders: PolicyCreateOrUpdateHeaders,
    PortalRevisionGetEntityTagHeaders: PortalRevisionGetEntityTagHeaders,
    PortalRevisionGetHeaders: PortalRevisionGetHeaders,
    PortalRevisionCreateOrUpdateHeaders: PortalRevisionCreateOrUpdateHeaders,
    PortalRevisionUpdateHeaders: PortalRevisionUpdateHeaders,
    SignInSettingsGetEntityTagHeaders: SignInSettingsGetEntityTagHeaders,
    SignInSettingsGetHeaders: SignInSettingsGetHeaders,
    SignUpSettingsGetEntityTagHeaders: SignUpSettingsGetEntityTagHeaders,
    SignUpSettingsGetHeaders: SignUpSettingsGetHeaders,
    DelegationSettingsGetEntityTagHeaders: DelegationSettingsGetEntityTagHeaders,
    DelegationSettingsGetHeaders: DelegationSettingsGetHeaders,
    ProductGetEntityTagHeaders: ProductGetEntityTagHeaders,
    ProductGetHeaders: ProductGetHeaders,
    ProductCreateOrUpdateHeaders: ProductCreateOrUpdateHeaders,
    ProductUpdateHeaders: ProductUpdateHeaders,
    ProductPolicyGetEntityTagHeaders: ProductPolicyGetEntityTagHeaders,
    ProductPolicyGetHeaders: ProductPolicyGetHeaders,
    ProductPolicyCreateOrUpdateHeaders: ProductPolicyCreateOrUpdateHeaders,
    TenantSettingsGetHeaders: TenantSettingsGetHeaders,
    SubscriptionGetEntityTagHeaders: SubscriptionGetEntityTagHeaders,
    SubscriptionGetHeaders: SubscriptionGetHeaders,
    SubscriptionCreateOrUpdateHeaders: SubscriptionCreateOrUpdateHeaders,
    SubscriptionUpdateHeaders: SubscriptionUpdateHeaders,
    SubscriptionListSecretsHeaders: SubscriptionListSecretsHeaders,
    TenantAccessGetEntityTagHeaders: TenantAccessGetEntityTagHeaders,
    TenantAccessGetHeaders: TenantAccessGetHeaders,
    TenantAccessCreateHeaders: TenantAccessCreateHeaders,
    TenantAccessUpdateHeaders: TenantAccessUpdateHeaders,
    TenantAccessListSecretsHeaders: TenantAccessListSecretsHeaders,
    UserGetEntityTagHeaders: UserGetEntityTagHeaders,
    UserGetHeaders: UserGetHeaders,
    UserCreateOrUpdateHeaders: UserCreateOrUpdateHeaders,
    UserUpdateHeaders: UserUpdateHeaders,
    UserSubscriptionGetHeaders: UserSubscriptionGetHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        xmlName: "$host",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        xmlName: "resourceGroupName",
        type: {
            name: "String"
        }
    }
};
const serviceName = {
    parameterPath: "serviceName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?$"),
            MaxLength: 50,
            MinLength: 1
        },
        serializedName: "serviceName",
        required: true,
        xmlName: "serviceName",
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        xmlName: "$filter",
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        constraints: {
            InclusiveMinimum: 1
        },
        serializedName: "$top",
        xmlName: "$top",
        type: {
            name: "Number"
        }
    }
};
const skip = {
    parameterPath: ["options", "skip"],
    mapper: {
        constraints: {
            InclusiveMinimum: 0
        },
        serializedName: "$skip",
        xmlName: "$skip",
        type: {
            name: "Number"
        }
    }
};
const tags = {
    parameterPath: ["options", "tags"],
    mapper: {
        serializedName: "tags",
        xmlName: "tags",
        type: {
            name: "String"
        }
    }
};
const expandApiVersionSet = {
    parameterPath: ["options", "expandApiVersionSet"],
    mapper: {
        serializedName: "expandApiVersionSet",
        xmlName: "expandApiVersionSet",
        type: {
            name: "Boolean"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-08-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        xmlName: "subscriptionId",
        type: {
            name: "String"
        }
    }
};
const apiId = {
    parameterPath: "apiId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 256,
            MinLength: 1
        },
        serializedName: "apiId",
        required: true,
        xmlName: "apiId",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: ApiCreateOrUpdateParameter
};
const ifMatch = {
    parameterPath: ["options", "ifMatch"],
    mapper: {
        serializedName: "If-Match",
        xmlName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: ApiUpdateContract
};
const ifMatch1 = {
    parameterPath: "ifMatch",
    mapper: {
        serializedName: "If-Match",
        required: true,
        xmlName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const deleteRevisions = {
    parameterPath: ["options", "deleteRevisions"],
    mapper: {
        serializedName: "deleteRevisions",
        xmlName: "deleteRevisions",
        type: {
            name: "Boolean"
        }
    }
};
const includeNotTaggedApis = {
    parameterPath: ["options", "includeNotTaggedApis"],
    mapper: {
        serializedName: "includeNotTaggedApis",
        xmlName: "includeNotTaggedApis",
        type: {
            name: "Boolean"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        xmlName: "nextLink",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiId1 = {
    parameterPath: "apiId",
    mapper: {
        constraints: {
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "apiId",
        required: true,
        xmlName: "apiId",
        type: {
            name: "String"
        }
    }
};
const releaseId = {
    parameterPath: "releaseId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "releaseId",
        required: true,
        xmlName: "releaseId",
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: ApiReleaseContract
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        constraints: {
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "operationId",
        required: true,
        xmlName: "operationId",
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: OperationContract
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: OperationUpdateContract
};
const policyId = {
    parameterPath: "policyId",
    mapper: {
        serializedName: "policyId",
        required: true,
        xmlName: "policyId",
        type: {
            name: "String"
        }
    }
};
const format = {
    parameterPath: ["options", "format"],
    mapper: {
        defaultValue: "xml",
        serializedName: "format",
        xmlName: "format",
        type: {
            name: "String"
        }
    }
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: PolicyContract
};
const tagId = {
    parameterPath: "tagId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "tagId",
        required: true,
        xmlName: "tagId",
        type: {
            name: "String"
        }
    }
};
const productId = {
    parameterPath: "productId",
    mapper: {
        constraints: {
            MaxLength: 256,
            MinLength: 1
        },
        serializedName: "productId",
        required: true,
        xmlName: "productId",
        type: {
            name: "String"
        }
    }
};
const scope = {
    parameterPath: ["options", "scope"],
    mapper: {
        serializedName: "scope",
        xmlName: "scope",
        type: {
            name: "String"
        }
    }
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: TagCreateUpdateParameters
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json, application/vnd.ms-azure-apim.policy+xml, application/vnd.ms-azure-apim.policy.raw+xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const schemaId = {
    parameterPath: "schemaId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "schemaId",
        required: true,
        xmlName: "schemaId",
        type: {
            name: "String"
        }
    }
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: SchemaContract
};
const force = {
    parameterPath: ["options", "force"],
    mapper: {
        serializedName: "force",
        xmlName: "force",
        type: {
            name: "Boolean"
        }
    }
};
const diagnosticId = {
    parameterPath: "diagnosticId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "diagnosticId",
        required: true,
        xmlName: "diagnosticId",
        type: {
            name: "String"
        }
    }
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: DiagnosticContract
};
const expandCommentsAttachments = {
    parameterPath: ["options", "expandCommentsAttachments"],
    mapper: {
        serializedName: "expandCommentsAttachments",
        xmlName: "expandCommentsAttachments",
        type: {
            name: "Boolean"
        }
    }
};
const issueId = {
    parameterPath: "issueId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 256,
            MinLength: 1
        },
        serializedName: "issueId",
        required: true,
        xmlName: "issueId",
        type: {
            name: "String"
        }
    }
};
const parameters9 = {
    parameterPath: "parameters",
    mapper: IssueContract
};
const parameters10 = {
    parameterPath: "parameters",
    mapper: IssueUpdateContract
};
const commentId = {
    parameterPath: "commentId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 256,
            MinLength: 1
        },
        serializedName: "commentId",
        required: true,
        xmlName: "commentId",
        type: {
            name: "String"
        }
    }
};
const parameters11 = {
    parameterPath: "parameters",
    mapper: IssueCommentContract
};
const attachmentId = {
    parameterPath: "attachmentId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 256,
            MinLength: 1
        },
        serializedName: "attachmentId",
        required: true,
        xmlName: "attachmentId",
        type: {
            name: "String"
        }
    }
};
const parameters12 = {
    parameterPath: "parameters",
    mapper: IssueAttachmentContract
};
const tagDescriptionId = {
    parameterPath: "tagDescriptionId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "tagDescriptionId",
        required: true,
        xmlName: "tagDescriptionId",
        type: {
            name: "String"
        }
    }
};
const parameters13 = {
    parameterPath: "parameters",
    mapper: TagDescriptionCreateParameters
};
const includeNotTaggedOperations = {
    parameterPath: ["options", "includeNotTaggedOperations"],
    mapper: {
        serializedName: "includeNotTaggedOperations",
        xmlName: "includeNotTaggedOperations",
        type: {
            name: "Boolean"
        }
    }
};
const format1 = {
    parameterPath: "format",
    mapper: {
        serializedName: "format",
        required: true,
        xmlName: "format",
        type: {
            name: "String"
        }
    }
};
const exportParam = {
    parameterPath: "exportParam",
    mapper: {
        serializedName: "export",
        required: true,
        xmlName: "export",
        type: {
            name: "String"
        }
    }
};
const versionSetId = {
    parameterPath: "versionSetId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "versionSetId",
        required: true,
        xmlName: "versionSetId",
        type: {
            name: "String"
        }
    }
};
const parameters14 = {
    parameterPath: "parameters",
    mapper: ApiVersionSetContract
};
const parameters15 = {
    parameterPath: "parameters",
    mapper: ApiVersionSetUpdateParameters
};
const authsid = {
    parameterPath: "authsid",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "authsid",
        required: true,
        xmlName: "authsid",
        type: {
            name: "String"
        }
    }
};
const parameters16 = {
    parameterPath: "parameters",
    mapper: AuthorizationServerContract
};
const parameters17 = {
    parameterPath: "parameters",
    mapper: AuthorizationServerUpdateContract
};
const backendId = {
    parameterPath: "backendId",
    mapper: {
        constraints: {
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "backendId",
        required: true,
        xmlName: "backendId",
        type: {
            name: "String"
        }
    }
};
const parameters18 = {
    parameterPath: "parameters",
    mapper: BackendContract
};
const parameters19 = {
    parameterPath: "parameters",
    mapper: BackendUpdateParameters
};
const parameters20 = {
    parameterPath: ["options", "parameters"],
    mapper: BackendReconnectContract
};
const cacheId = {
    parameterPath: "cacheId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "cacheId",
        required: true,
        xmlName: "cacheId",
        type: {
            name: "String"
        }
    }
};
const parameters21 = {
    parameterPath: "parameters",
    mapper: CacheContract
};
const parameters22 = {
    parameterPath: "parameters",
    mapper: CacheUpdateParameters
};
const isKeyVaultRefreshFailed = {
    parameterPath: ["options", "isKeyVaultRefreshFailed"],
    mapper: {
        serializedName: "isKeyVaultRefreshFailed",
        xmlName: "isKeyVaultRefreshFailed",
        type: {
            name: "Boolean"
        }
    }
};
const certificateId = {
    parameterPath: "certificateId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "certificateId",
        required: true,
        xmlName: "certificateId",
        type: {
            name: "String"
        }
    }
};
const parameters23 = {
    parameterPath: "parameters",
    mapper: CertificateCreateOrUpdateParameters
};
const connectivityCheckRequestParams = {
    parameterPath: "connectivityCheckRequestParams",
    mapper: ConnectivityCheckRequest
};
const contentTypeId = {
    parameterPath: "contentTypeId",
    mapper: {
        constraints: {
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "contentTypeId",
        required: true,
        xmlName: "contentTypeId",
        type: {
            name: "String"
        }
    }
};
const contentItemId = {
    parameterPath: "contentItemId",
    mapper: {
        constraints: {
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "contentItemId",
        required: true,
        xmlName: "contentItemId",
        type: {
            name: "String"
        }
    }
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        xmlName: "location",
        type: {
            name: "String"
        }
    }
};
const parameters24 = {
    parameterPath: "parameters",
    mapper: ApiManagementServiceBackupRestoreParameters
};
const parameters25 = {
    parameterPath: "parameters",
    mapper: ApiManagementServiceResource
};
const parameters26 = {
    parameterPath: "parameters",
    mapper: ApiManagementServiceUpdateParameters
};
const parameters27 = {
    parameterPath: "parameters",
    mapper: ApiManagementServiceCheckNameAvailabilityParameters
};
const parameters28 = {
    parameterPath: ["options", "parameters"],
    mapper: ApiManagementServiceApplyNetworkConfigurationParameters
};
const templateName = {
    parameterPath: "templateName",
    mapper: {
        serializedName: "templateName",
        required: true,
        xmlName: "templateName",
        type: {
            name: "String"
        }
    }
};
const parameters29 = {
    parameterPath: "parameters",
    mapper: EmailTemplateUpdateParameters
};
const gatewayId = {
    parameterPath: "gatewayId",
    mapper: {
        constraints: {
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "gatewayId",
        required: true,
        xmlName: "gatewayId",
        type: {
            name: "String"
        }
    }
};
const parameters30 = {
    parameterPath: "parameters",
    mapper: GatewayContract
};
const parameters31 = {
    parameterPath: "parameters",
    mapper: GatewayKeyRegenerationRequestContract
};
const parameters32 = {
    parameterPath: "parameters",
    mapper: GatewayTokenRequestContract
};
const hcId = {
    parameterPath: "hcId",
    mapper: {
        constraints: {
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "hcId",
        required: true,
        xmlName: "hcId",
        type: {
            name: "String"
        }
    }
};
const parameters33 = {
    parameterPath: "parameters",
    mapper: GatewayHostnameConfigurationContract
};
const parameters34 = {
    parameterPath: ["options", "parameters"],
    mapper: AssociationContract
};
const parameters35 = {
    parameterPath: "parameters",
    mapper: GatewayCertificateAuthorityContract
};
const groupId = {
    parameterPath: "groupId",
    mapper: {
        constraints: {
            MaxLength: 256,
            MinLength: 1
        },
        serializedName: "groupId",
        required: true,
        xmlName: "groupId",
        type: {
            name: "String"
        }
    }
};
const parameters36 = {
    parameterPath: "parameters",
    mapper: GroupCreateParameters
};
const parameters37 = {
    parameterPath: "parameters",
    mapper: GroupUpdateParameters
};
const userId = {
    parameterPath: "userId",
    mapper: {
        constraints: {
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "userId",
        required: true,
        xmlName: "userId",
        type: {
            name: "String"
        }
    }
};
const identityProviderName = {
    parameterPath: "identityProviderName",
    mapper: {
        serializedName: "identityProviderName",
        required: true,
        xmlName: "identityProviderName",
        type: {
            name: "String"
        }
    }
};
const parameters38 = {
    parameterPath: "parameters",
    mapper: IdentityProviderCreateContract
};
const parameters39 = {
    parameterPath: "parameters",
    mapper: IdentityProviderUpdateParameters
};
const loggerId = {
    parameterPath: "loggerId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 256
        },
        serializedName: "loggerId",
        required: true,
        xmlName: "loggerId",
        type: {
            name: "String"
        }
    }
};
const parameters40 = {
    parameterPath: "parameters",
    mapper: LoggerContract
};
const parameters41 = {
    parameterPath: "parameters",
    mapper: LoggerUpdateContract
};
const namedValueId = {
    parameterPath: "namedValueId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 256
        },
        serializedName: "namedValueId",
        required: true,
        xmlName: "namedValueId",
        type: {
            name: "String"
        }
    }
};
const parameters42 = {
    parameterPath: "parameters",
    mapper: NamedValueCreateContract
};
const parameters43 = {
    parameterPath: "parameters",
    mapper: NamedValueUpdateParameters
};
const locationName = {
    parameterPath: "locationName",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "locationName",
        required: true,
        xmlName: "locationName",
        type: {
            name: "String"
        }
    }
};
const notificationName = {
    parameterPath: "notificationName",
    mapper: {
        serializedName: "notificationName",
        required: true,
        xmlName: "notificationName",
        type: {
            name: "String"
        }
    }
};
const email = {
    parameterPath: "email",
    mapper: {
        serializedName: "email",
        required: true,
        xmlName: "email",
        type: {
            name: "String"
        }
    }
};
const opid = {
    parameterPath: "opid",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 256
        },
        serializedName: "opid",
        required: true,
        xmlName: "opid",
        type: {
            name: "String"
        }
    }
};
const parameters44 = {
    parameterPath: "parameters",
    mapper: OpenidConnectProviderContract
};
const parameters45 = {
    parameterPath: "parameters",
    mapper: OpenidConnectProviderUpdateContract
};
const scope1 = {
    parameterPath: ["options", "scope"],
    mapper: {
        serializedName: "scope",
        xmlName: "scope",
        type: {
            name: "Enum",
            allowedValues: ["Tenant", "Product", "Api", "Operation", "All"]
        }
    }
};
const portalRevisionId = {
    parameterPath: "portalRevisionId",
    mapper: {
        constraints: {
            MaxLength: 256,
            MinLength: 1
        },
        serializedName: "portalRevisionId",
        required: true,
        xmlName: "portalRevisionId",
        type: {
            name: "String"
        }
    }
};
const parameters46 = {
    parameterPath: "parameters",
    mapper: PortalRevisionContract
};
const parameters47 = {
    parameterPath: "parameters",
    mapper: PortalSigninSettings
};
const parameters48 = {
    parameterPath: "parameters",
    mapper: PortalSignupSettings
};
const parameters49 = {
    parameterPath: "parameters",
    mapper: PortalDelegationSettings
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        xmlName: "privateEndpointConnectionName",
        type: {
            name: "String"
        }
    }
};
const privateEndpointConnectionRequest = {
    parameterPath: "privateEndpointConnectionRequest",
    mapper: PrivateEndpointConnectionRequest
};
const privateLinkSubResourceName = {
    parameterPath: "privateLinkSubResourceName",
    mapper: {
        serializedName: "privateLinkSubResourceName",
        required: true,
        xmlName: "privateLinkSubResourceName",
        type: {
            name: "String"
        }
    }
};
const expandGroups = {
    parameterPath: ["options", "expandGroups"],
    mapper: {
        serializedName: "expandGroups",
        xmlName: "expandGroups",
        type: {
            name: "Boolean"
        }
    }
};
const parameters50 = {
    parameterPath: "parameters",
    mapper: ProductContract
};
const parameters51 = {
    parameterPath: "parameters",
    mapper: ProductUpdateParameters
};
const deleteSubscriptions = {
    parameterPath: ["options", "deleteSubscriptions"],
    mapper: {
        serializedName: "deleteSubscriptions",
        xmlName: "deleteSubscriptions",
        type: {
            name: "Boolean"
        }
    }
};
const includeNotTaggedProducts = {
    parameterPath: ["options", "includeNotTaggedProducts"],
    mapper: {
        serializedName: "includeNotTaggedProducts",
        xmlName: "includeNotTaggedProducts",
        type: {
            name: "Boolean"
        }
    }
};
const quotaCounterKey = {
    parameterPath: "quotaCounterKey",
    mapper: {
        serializedName: "quotaCounterKey",
        required: true,
        xmlName: "quotaCounterKey",
        type: {
            name: "String"
        }
    }
};
const parameters52 = {
    parameterPath: "parameters",
    mapper: QuotaCounterValueUpdateContract
};
const quotaPeriodKey = {
    parameterPath: "quotaPeriodKey",
    mapper: {
        serializedName: "quotaPeriodKey",
        required: true,
        xmlName: "quotaPeriodKey",
        type: {
            name: "String"
        }
    }
};
const filter1 = {
    parameterPath: "filter",
    mapper: {
        serializedName: "$filter",
        required: true,
        xmlName: "$filter",
        type: {
            name: "String"
        }
    }
};
const orderby = {
    parameterPath: ["options", "orderby"],
    mapper: {
        serializedName: "$orderby",
        xmlName: "$orderby",
        type: {
            name: "String"
        }
    }
};
const interval = {
    parameterPath: "interval",
    mapper: {
        serializedName: "interval",
        required: true,
        xmlName: "interval",
        type: {
            name: "TimeSpan"
        }
    }
};
const settingsType = {
    parameterPath: "settingsType",
    mapper: {
        serializedName: "settingsType",
        required: true,
        xmlName: "settingsType",
        type: {
            name: "String"
        }
    }
};
const sid = {
    parameterPath: "sid",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[^*#&+:<>?]+$"),
            MaxLength: 256
        },
        serializedName: "sid",
        required: true,
        xmlName: "sid",
        type: {
            name: "String"
        }
    }
};
const parameters53 = {
    parameterPath: "parameters",
    mapper: SubscriptionCreateParameters
};
const notify = {
    parameterPath: ["options", "notify"],
    mapper: {
        serializedName: "notify",
        xmlName: "notify",
        type: {
            name: "Boolean"
        }
    }
};
const appType = {
    parameterPath: ["options", "appType"],
    mapper: {
        serializedName: "appType",
        xmlName: "appType",
        type: {
            name: "String"
        }
    }
};
const parameters54 = {
    parameterPath: "parameters",
    mapper: SubscriptionUpdateParameters
};
const accessName = {
    parameterPath: "accessName",
    mapper: {
        serializedName: "accessName",
        required: true,
        xmlName: "accessName",
        type: {
            name: "String"
        }
    }
};
const parameters55 = {
    parameterPath: "parameters",
    mapper: AccessInformationCreateParameters
};
const parameters56 = {
    parameterPath: "parameters",
    mapper: AccessInformationUpdateParameters
};
const parameters57 = {
    parameterPath: "parameters",
    mapper: DeployConfigurationParameters
};
const configurationName = {
    parameterPath: "configurationName",
    mapper: {
        serializedName: "configurationName",
        required: true,
        xmlName: "configurationName",
        type: {
            name: "String"
        }
    }
};
const parameters58 = {
    parameterPath: "parameters",
    mapper: SaveConfigurationParameter
};
const parameters59 = {
    parameterPath: "parameters",
    mapper: UserCreateParameters
};
const parameters60 = {
    parameterPath: "parameters",
    mapper: UserUpdateParameters
};
const parameters61 = {
    parameterPath: "parameters",
    mapper: UserTokenParameters
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Api operations. */
class ApiImpl {
    /**
     * Initialize a new instance of the class Api class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all APIs of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of apis associated with tags.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByTags(resourceGroupName, serviceName, options) {
        const iter = this.listByTagsPagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByTagsPagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByTagsPagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTagsPagingPage_1() {
            let result = yield tslib.__await(this._listByTags(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByTagsNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByTagsPagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTagsPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByTagsPagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all APIs of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$G);
    }
    /**
     * Gets the entity state (Etag) version of the API specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, options }, getEntityTagOperationSpec$B);
    }
    /**
     * Gets the details of the API specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, options }, getOperationSpec$J);
    }
    /**
     * Creates new or updates existing specified API of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param parameters Create or update parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serviceName, apiId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, apiId, parameters, options }, createOrUpdateOperationSpec$J);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates new or updates existing specified API of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param parameters Create or update parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serviceName, apiId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serviceName, apiId, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the specified API of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters API Update Contract parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, apiId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, ifMatch, parameters, options }, updateOperationSpec$s);
    }
    /**
     * Deletes the specified API of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, apiId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, ifMatch, options }, deleteOperationSpec$F);
    }
    /**
     * Lists a collection of apis associated with tags.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByTags(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByTagsOperationSpec$2);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$z);
    }
    /**
     * ListByTagsNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByTags method.
     * @param options The options parameters.
     */
    _listByTagsNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByTagsNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$1a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        tags,
        expandApiVersionSet,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1a
};
const getEntityTagOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ApiGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId
    ],
    headerParameters: [accept],
    serializer: serializer$1a
};
const getOperationSpec$J = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiContract,
            headersMapper: ApiGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId
    ],
    headerParameters: [accept],
    serializer: serializer$1a
};
const createOrUpdateOperationSpec$J = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApiContract,
            headersMapper: ApiCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: ApiContract,
            headersMapper: ApiCreateOrUpdateHeaders
        },
        202: {
            bodyMapper: ApiContract,
            headersMapper: ApiCreateOrUpdateHeaders
        },
        204: {
            bodyMapper: ApiContract,
            headersMapper: ApiCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$1a
};
const updateOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ApiContract,
            headersMapper: ApiUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$1a
};
const deleteOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, deleteRevisions],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$1a
};
const listByTagsOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apisByTags",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagResourceCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        includeNotTaggedApis
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1a
};
const listByServiceNextOperationSpec$z = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        tags,
        expandApiVersionSet,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1a
};
const listByTagsNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagResourceCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        includeNotTaggedApis
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiRevision operations. */
class ApiRevisionImpl {
    /**
     * Initialize a new instance of the class ApiRevision class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all revisions of an API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, apiId, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, apiId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, apiId, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, apiId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, apiId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, apiId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all revisions of an API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, options }, listByServiceOperationSpec$F);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, apiId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, nextLink, options }, listByServiceNextOperationSpec$y);
    }
}
// Operation Specifications
const serializer$19 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/revisions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiRevisionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1
    ],
    headerParameters: [accept],
    serializer: serializer$19
};
const listByServiceNextOperationSpec$y = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiRevisionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        apiId1
    ],
    headerParameters: [accept],
    serializer: serializer$19
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiRelease operations. */
class ApiReleaseImpl {
    /**
     * Initialize a new instance of the class ApiRelease class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all releases of an API. An API release is created when making an API Revision current.
     * Releases are also used to rollback to previous revisions. Results will be paged and can be
     * constrained by the $top and $skip parameters.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, apiId, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, apiId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, apiId, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, apiId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, apiId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, apiId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all releases of an API. An API release is created when making an API Revision current.
     * Releases are also used to rollback to previous revisions. Results will be paged and can be
     * constrained by the $top and $skip parameters.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, options }, listByServiceOperationSpec$E);
    }
    /**
     * Returns the etag of an API release.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management
     *                  service instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, apiId, releaseId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, releaseId, options }, getEntityTagOperationSpec$A);
    }
    /**
     * Returns the details of an API release.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management
     *                  service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, apiId, releaseId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, releaseId, options }, getOperationSpec$I);
    }
    /**
     * Creates a new Release for the API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management
     *                  service instance.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, apiId, releaseId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, releaseId, parameters, options }, createOrUpdateOperationSpec$I);
    }
    /**
     * Updates the details of the release of the API specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management
     *                  service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters API Release Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, apiId, releaseId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            releaseId,
            ifMatch,
            parameters,
            options
        }, updateOperationSpec$r);
    }
    /**
     * Deletes the specified release in the API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param releaseId Release identifier within an API. Must be unique in the current API Management
     *                  service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, apiId, releaseId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, releaseId, ifMatch, options }, deleteOperationSpec$E);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, apiId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, nextLink, options }, listByServiceNextOperationSpec$x);
    }
}
// Operation Specifications
const serializer$18 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/releases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiReleaseCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1
    ],
    headerParameters: [accept],
    serializer: serializer$18
};
const getEntityTagOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/releases/{releaseId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ApiReleaseGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        releaseId
    ],
    headerParameters: [accept],
    serializer: serializer$18
};
const getOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/releases/{releaseId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiReleaseContract,
            headersMapper: ApiReleaseGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        releaseId
    ],
    headerParameters: [accept],
    serializer: serializer$18
};
const createOrUpdateOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/releases/{releaseId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApiReleaseContract,
            headersMapper: ApiReleaseCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: ApiReleaseContract,
            headersMapper: ApiReleaseCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        releaseId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$18
};
const updateOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/releases/{releaseId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ApiReleaseContract,
            headersMapper: ApiReleaseUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        releaseId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$18
};
const deleteOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/releases/{releaseId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        releaseId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$18
};
const listByServiceNextOperationSpec$x = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiReleaseCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        apiId1
    ],
    headerParameters: [accept],
    serializer: serializer$18
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiOperation operations. */
class ApiOperationImpl {
    /**
     * Initialize a new instance of the class ApiOperation class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of the operations for the specified API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    listByApi(resourceGroupName, serviceName, apiId, options) {
        const iter = this.listByApiPagingAll(resourceGroupName, serviceName, apiId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByApiPagingPage(resourceGroupName, serviceName, apiId, options);
            }
        };
    }
    listByApiPagingPage(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByApiPagingPage_1() {
            let result = yield tslib.__await(this._listByApi(resourceGroupName, serviceName, apiId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByApiNext(resourceGroupName, serviceName, apiId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByApiPagingAll(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByApiPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByApiPagingPage(resourceGroupName, serviceName, apiId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of the operations for the specified API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    _listByApi(resourceGroupName, serviceName, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, options }, listByApiOperationSpec$4);
    }
    /**
     * Gets the entity state (Etag) version of the API operation specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, apiId, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, operationId, options }, getEntityTagOperationSpec$z);
    }
    /**
     * Gets the details of the API Operation specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, apiId, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, operationId, options }, getOperationSpec$H);
    }
    /**
     * Creates a new operation in the API or updates an existing one.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, apiId, operationId, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            operationId,
            parameters,
            options
        }, createOrUpdateOperationSpec$H);
    }
    /**
     * Updates the details of the operation in the API specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters API Operation Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, apiId, operationId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            operationId,
            ifMatch,
            parameters,
            options
        }, updateOperationSpec$q);
    }
    /**
     * Deletes the specified operation in the API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, apiId, operationId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, operationId, ifMatch, options }, deleteOperationSpec$D);
    }
    /**
     * ListByApiNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param nextLink The nextLink from the previous successful call to the ListByApi method.
     * @param options The options parameters.
     */
    _listByApiNext(resourceGroupName, serviceName, apiId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, nextLink, options }, listByApiNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$17 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByApiOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        tags,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId
    ],
    headerParameters: [accept],
    serializer: serializer$17
};
const getEntityTagOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ApiOperationGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$17
};
const getOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationContract,
            headersMapper: ApiOperationGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$17
};
const createOrUpdateOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: OperationContract,
            headersMapper: ApiOperationCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: OperationContract,
            headersMapper: ApiOperationCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$17
};
const updateOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: OperationContract,
            headersMapper: ApiOperationUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$17
};
const deleteOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$17
};
const listByApiNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        tags,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$17
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ApiOperationPolicy operations. */
class ApiOperationPolicyImpl {
    /**
     * Initialize a new instance of the class ApiOperationPolicy class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the list of policy configuration at the API Operation level.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param options The options parameters.
     */
    listByOperation(resourceGroupName, serviceName, apiId, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, operationId, options }, listByOperationOperationSpec$2);
    }
    /**
     * Gets the entity state (Etag) version of the API operation policy specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param policyId The identifier of the Policy.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, apiId, operationId, policyId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, operationId, policyId, options }, getEntityTagOperationSpec$y);
    }
    /**
     * Get the policy configuration at the API Operation level.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param policyId The identifier of the Policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, apiId, operationId, policyId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, operationId, policyId, options }, getOperationSpec$G);
    }
    /**
     * Creates or updates policy configuration for the API Operation level.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param policyId The identifier of the Policy.
     * @param parameters The policy contents to apply.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, apiId, operationId, policyId, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            operationId,
            policyId,
            parameters,
            options
        }, createOrUpdateOperationSpec$G);
    }
    /**
     * Deletes the policy configuration at the Api Operation.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param policyId The identifier of the Policy.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, apiId, operationId, policyId, ifMatch, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            operationId,
            policyId,
            ifMatch,
            options
        }, deleteOperationSpec$C);
    }
}
// Operation Specifications
const serializer$16 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByOperationOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}/policies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$16
};
const getEntityTagOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}/policies/{policyId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ApiOperationPolicyGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId,
        policyId
    ],
    headerParameters: [accept],
    serializer: serializer$16
};
const getOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}/policies/{policyId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyContract,
            headersMapper: ApiOperationPolicyGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, format],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId,
        policyId
    ],
    headerParameters: [accept],
    serializer: serializer$16
};
const createOrUpdateOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}/policies/{policyId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PolicyContract,
            headersMapper: ApiOperationPolicyCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: PolicyContract,
            headersMapper: ApiOperationPolicyCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId,
        policyId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$16
};
const deleteOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}/policies/{policyId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId,
        policyId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$16
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Tag operations. */
class TagImpl {
    /**
     * Initialize a new instance of the class Tag class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Tags associated with the Operation.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param options The options parameters.
     */
    listByOperation(resourceGroupName, serviceName, apiId, operationId, options) {
        const iter = this.listByOperationPagingAll(resourceGroupName, serviceName, apiId, operationId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByOperationPagingPage(resourceGroupName, serviceName, apiId, operationId, options);
            }
        };
    }
    listByOperationPagingPage(resourceGroupName, serviceName, apiId, operationId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByOperationPagingPage_1() {
            let result = yield tslib.__await(this._listByOperation(resourceGroupName, serviceName, apiId, operationId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByOperationNext(resourceGroupName, serviceName, apiId, operationId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByOperationPagingAll(resourceGroupName, serviceName, apiId, operationId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByOperationPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByOperationPagingPage(resourceGroupName, serviceName, apiId, operationId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all Tags associated with the API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    listByApi(resourceGroupName, serviceName, apiId, options) {
        const iter = this.listByApiPagingAll(resourceGroupName, serviceName, apiId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByApiPagingPage(resourceGroupName, serviceName, apiId, options);
            }
        };
    }
    listByApiPagingPage(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByApiPagingPage_1() {
            let result = yield tslib.__await(this._listByApi(resourceGroupName, serviceName, apiId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByApiNext(resourceGroupName, serviceName, apiId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByApiPagingAll(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByApiPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByApiPagingPage(resourceGroupName, serviceName, apiId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all Tags associated with the Product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    listByProduct(resourceGroupName, serviceName, productId, options) {
        const iter = this.listByProductPagingAll(resourceGroupName, serviceName, productId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByProductPagingPage(resourceGroupName, serviceName, productId, options);
            }
        };
    }
    listByProductPagingPage(resourceGroupName, serviceName, productId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProductPagingPage_1() {
            let result = yield tslib.__await(this._listByProduct(resourceGroupName, serviceName, productId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByProductNext(resourceGroupName, serviceName, productId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByProductPagingAll(resourceGroupName, serviceName, productId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProductPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByProductPagingPage(resourceGroupName, serviceName, productId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Lists a collection of tags defined within a service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Lists all Tags associated with the Operation.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param options The options parameters.
     */
    _listByOperation(resourceGroupName, serviceName, apiId, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, operationId, options }, listByOperationOperationSpec$1);
    }
    /**
     * Gets the entity state version of the tag specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    getEntityStateByOperation(resourceGroupName, serviceName, apiId, operationId, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, operationId, tagId, options }, getEntityStateByOperationOperationSpec);
    }
    /**
     * Get tag associated with the Operation.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    getByOperation(resourceGroupName, serviceName, apiId, operationId, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, operationId, tagId, options }, getByOperationOperationSpec);
    }
    /**
     * Assign tag to the Operation.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    assignToOperation(resourceGroupName, serviceName, apiId, operationId, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, operationId, tagId, options }, assignToOperationOperationSpec);
    }
    /**
     * Detach the tag from the Operation.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    detachFromOperation(resourceGroupName, serviceName, apiId, operationId, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, operationId, tagId, options }, detachFromOperationOperationSpec);
    }
    /**
     * Lists all Tags associated with the API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    _listByApi(resourceGroupName, serviceName, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, options }, listByApiOperationSpec$3);
    }
    /**
     * Gets the entity state version of the tag specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    getEntityStateByApi(resourceGroupName, serviceName, apiId, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, tagId, options }, getEntityStateByApiOperationSpec);
    }
    /**
     * Get tag associated with the API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    getByApi(resourceGroupName, serviceName, apiId, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, tagId, options }, getByApiOperationSpec);
    }
    /**
     * Assign tag to the Api.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    assignToApi(resourceGroupName, serviceName, apiId, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, tagId, options }, assignToApiOperationSpec);
    }
    /**
     * Detach the tag from the Api.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    detachFromApi(resourceGroupName, serviceName, apiId, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, tagId, options }, detachFromApiOperationSpec);
    }
    /**
     * Lists all Tags associated with the Product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _listByProduct(resourceGroupName, serviceName, productId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, options }, listByProductOperationSpec$4);
    }
    /**
     * Gets the entity state version of the tag specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    getEntityStateByProduct(resourceGroupName, serviceName, productId, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, tagId, options }, getEntityStateByProductOperationSpec);
    }
    /**
     * Get tag associated with the Product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    getByProduct(resourceGroupName, serviceName, productId, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, tagId, options }, getByProductOperationSpec);
    }
    /**
     * Assign tag to the Product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    assignToProduct(resourceGroupName, serviceName, productId, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, tagId, options }, assignToProductOperationSpec);
    }
    /**
     * Detach the tag from the Product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    detachFromProduct(resourceGroupName, serviceName, productId, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, tagId, options }, detachFromProductOperationSpec);
    }
    /**
     * Lists a collection of tags defined within a service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$D);
    }
    /**
     * Gets the entity state version of the tag specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    getEntityState(resourceGroupName, serviceName, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, tagId, options }, getEntityStateOperationSpec);
    }
    /**
     * Gets the details of the tag specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, tagId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, tagId, options }, getOperationSpec$F);
    }
    /**
     * Creates a tag.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, tagId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, tagId, parameters, options }, createOrUpdateOperationSpec$F);
    }
    /**
     * Updates the details of the tag specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, tagId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, tagId, ifMatch, parameters, options }, updateOperationSpec$p);
    }
    /**
     * Deletes specific tag of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param tagId Tag identifier. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, tagId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, tagId, ifMatch, options }, deleteOperationSpec$B);
    }
    /**
     * ListByOperationNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param operationId Operation identifier within an API. Must be unique in the current API Management
     *                    service instance.
     * @param nextLink The nextLink from the previous successful call to the ListByOperation method.
     * @param options The options parameters.
     */
    _listByOperationNext(resourceGroupName, serviceName, apiId, operationId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, operationId, nextLink, options }, listByOperationNextOperationSpec$1);
    }
    /**
     * ListByApiNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param nextLink The nextLink from the previous successful call to the ListByApi method.
     * @param options The options parameters.
     */
    _listByApiNext(resourceGroupName, serviceName, apiId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, nextLink, options }, listByApiNextOperationSpec$2);
    }
    /**
     * ListByProductNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the ListByProduct method.
     * @param options The options parameters.
     */
    _listByProductNext(resourceGroupName, serviceName, productId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, nextLink, options }, listByProductNextOperationSpec$3);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$w);
    }
}
// Operation Specifications
const serializer$15 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByOperationOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}/tags",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const getEntityStateByOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}/tags/{tagId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: TagGetEntityStateByOperationHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId,
        tagId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const getByOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}/tags/{tagId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagContract,
            headersMapper: TagGetByOperationHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId,
        tagId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const assignToOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}/tags/{tagId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: TagContract
        },
        201: {
            bodyMapper: TagContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId,
        tagId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const detachFromOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operations/{operationId}/tags/{tagId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        operationId,
        tagId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const listByApiOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/tags",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const getEntityStateByApiOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/tags/{tagId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: TagGetEntityStateByApiHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        tagId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const getByApiOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/tags/{tagId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagContract,
            headersMapper: TagGetByApiHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        tagId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const assignToApiOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/tags/{tagId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: TagContract,
            headersMapper: TagAssignToApiHeaders
        },
        201: {
            bodyMapper: TagContract,
            headersMapper: TagAssignToApiHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        tagId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const detachFromApiOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/tags/{tagId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        tagId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const listByProductOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/tags",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const getEntityStateByProductOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/tags/{tagId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: TagGetEntityStateByProductHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        tagId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const getByProductOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/tags/{tagId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagContract,
            headersMapper: TagGetByProductHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        tagId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const assignToProductOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/tags/{tagId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: TagContract
        },
        201: {
            bodyMapper: TagContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        tagId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const detachFromProductOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/tags/{tagId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        tagId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const listByServiceOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tags",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        scope
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const getEntityStateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tags/{tagId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: TagGetEntityStateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        tagId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const getOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tags/{tagId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagContract,
            headersMapper: TagGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        tagId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const createOrUpdateOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tags/{tagId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: TagContract,
            headersMapper: TagCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: TagContract,
            headersMapper: TagCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        tagId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$15
};
const updateOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tags/{tagId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: TagContract,
            headersMapper: TagUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        tagId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$15
};
const deleteOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tags/{tagId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        tagId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$15
};
const listByOperationNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        nextLink,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const listByApiNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const listByProductNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const listByServiceNextOperationSpec$w = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        scope
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$15
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiProduct operations. */
class ApiProductImpl {
    /**
     * Initialize a new instance of the class ApiProduct class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Products, which the API is part of.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    listByApis(resourceGroupName, serviceName, apiId, options) {
        const iter = this.listByApisPagingAll(resourceGroupName, serviceName, apiId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByApisPagingPage(resourceGroupName, serviceName, apiId, options);
            }
        };
    }
    listByApisPagingPage(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByApisPagingPage_1() {
            let result = yield tslib.__await(this._listByApis(resourceGroupName, serviceName, apiId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByApisNext(resourceGroupName, serviceName, apiId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByApisPagingAll(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByApisPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByApisPagingPage(resourceGroupName, serviceName, apiId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all Products, which the API is part of.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _listByApis(resourceGroupName, serviceName, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, options }, listByApisOperationSpec);
    }
    /**
     * ListByApisNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the ListByApis method.
     * @param options The options parameters.
     */
    _listByApisNext(resourceGroupName, serviceName, apiId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, nextLink, options }, listByApisNextOperationSpec);
    }
}
// Operation Specifications
const serializer$14 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByApisOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/products",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProductCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1
    ],
    headerParameters: [accept],
    serializer: serializer$14
};
const listByApisNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProductCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        apiId1
    ],
    headerParameters: [accept],
    serializer: serializer$14
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ApiPolicy operations. */
class ApiPolicyImpl {
    /**
     * Initialize a new instance of the class ApiPolicy class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the policy configuration at the API level.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    listByApi(resourceGroupName, serviceName, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, options }, listByApiOperationSpec$2);
    }
    /**
     * Gets the entity state (Etag) version of the API policy specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param policyId The identifier of the Policy.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, apiId, policyId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, policyId, options }, getEntityTagOperationSpec$x);
    }
    /**
     * Get the policy configuration at the API level.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param policyId The identifier of the Policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, apiId, policyId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, policyId, options }, getOperationSpec$E);
    }
    /**
     * Creates or updates policy configuration for the API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param policyId The identifier of the Policy.
     * @param parameters The policy contents to apply.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, apiId, policyId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, policyId, parameters, options }, createOrUpdateOperationSpec$E);
    }
    /**
     * Deletes the policy configuration at the Api.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param policyId The identifier of the Policy.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, apiId, policyId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, policyId, ifMatch, options }, deleteOperationSpec$A);
    }
}
// Operation Specifications
const xmlSerializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ true);
const serializer$13 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByApiOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/policies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId
    ],
    headerParameters: [accept],
    serializer: serializer$13
};
const getEntityTagOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/policies/{policyId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ApiPolicyGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        policyId
    ],
    headerParameters: [accept],
    serializer: serializer$13
};
const getOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/policies/{policyId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyContract,
            headersMapper: ApiPolicyGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, format],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        policyId
    ],
    headerParameters: [accept1],
    isXML: true,
    serializer: xmlSerializer
};
const createOrUpdateOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/policies/{policyId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PolicyContract,
            headersMapper: ApiPolicyCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: PolicyContract,
            headersMapper: ApiPolicyCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        policyId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$13
};
const deleteOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/policies/{policyId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        policyId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$13
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiSchema operations. */
class ApiSchemaImpl {
    /**
     * Initialize a new instance of the class ApiSchema class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the schema configuration at the API level.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    listByApi(resourceGroupName, serviceName, apiId, options) {
        const iter = this.listByApiPagingAll(resourceGroupName, serviceName, apiId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByApiPagingPage(resourceGroupName, serviceName, apiId, options);
            }
        };
    }
    listByApiPagingPage(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByApiPagingPage_1() {
            let result = yield tslib.__await(this._listByApi(resourceGroupName, serviceName, apiId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByApiNext(resourceGroupName, serviceName, apiId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByApiPagingAll(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByApiPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByApiPagingPage(resourceGroupName, serviceName, apiId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the schema configuration at the API level.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    _listByApi(resourceGroupName, serviceName, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, options }, listByApiOperationSpec$1);
    }
    /**
     * Gets the entity state (Etag) version of the schema specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param schemaId Schema identifier within an API. Must be unique in the current API Management
     *                 service instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, apiId, schemaId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, schemaId, options }, getEntityTagOperationSpec$w);
    }
    /**
     * Get the schema configuration at the API level.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param schemaId Schema identifier within an API. Must be unique in the current API Management
     *                 service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, apiId, schemaId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, schemaId, options }, getOperationSpec$D);
    }
    /**
     * Creates or updates schema configuration for the API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param schemaId Schema identifier within an API. Must be unique in the current API Management
     *                 service instance.
     * @param parameters The schema contents to apply.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serviceName, apiId, schemaId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, apiId, schemaId, parameters, options }, createOrUpdateOperationSpec$D);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates schema configuration for the API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param schemaId Schema identifier within an API. Must be unique in the current API Management
     *                 service instance.
     * @param parameters The schema contents to apply.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serviceName, apiId, schemaId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serviceName, apiId, schemaId, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the schema configuration at the Api.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param schemaId Schema identifier within an API. Must be unique in the current API Management
     *                 service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, apiId, schemaId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, schemaId, ifMatch, options }, deleteOperationSpec$z);
    }
    /**
     * ListByApiNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param nextLink The nextLink from the previous successful call to the ListByApi method.
     * @param options The options parameters.
     */
    _listByApiNext(resourceGroupName, serviceName, apiId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, nextLink, options }, listByApiNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$12 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByApiOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/schemas",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SchemaCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId
    ],
    headerParameters: [accept],
    serializer: serializer$12
};
const getEntityTagOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/schemas/{schemaId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ApiSchemaGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        schemaId
    ],
    headerParameters: [accept],
    serializer: serializer$12
};
const getOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/schemas/{schemaId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SchemaContract,
            headersMapper: ApiSchemaGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        schemaId
    ],
    headerParameters: [accept],
    serializer: serializer$12
};
const createOrUpdateOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/schemas/{schemaId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SchemaContract,
            headersMapper: ApiSchemaCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: SchemaContract,
            headersMapper: ApiSchemaCreateOrUpdateHeaders
        },
        202: {
            bodyMapper: SchemaContract,
            headersMapper: ApiSchemaCreateOrUpdateHeaders
        },
        204: {
            bodyMapper: SchemaContract,
            headersMapper: ApiSchemaCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        schemaId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$12
};
const deleteOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/schemas/{schemaId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, force],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        schemaId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$12
};
const listByApiNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SchemaCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$12
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiDiagnostic operations. */
class ApiDiagnosticImpl {
    /**
     * Initialize a new instance of the class ApiDiagnostic class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all diagnostics of an API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, apiId, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, apiId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, apiId, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, apiId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, apiId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, apiId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all diagnostics of an API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, options }, listByServiceOperationSpec$C);
    }
    /**
     * Gets the entity state (Etag) version of the Diagnostic for an API specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param diagnosticId Diagnostic identifier. Must be unique in the current API Management service
     *                     instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, apiId, diagnosticId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, diagnosticId, options }, getEntityTagOperationSpec$v);
    }
    /**
     * Gets the details of the Diagnostic for an API specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param diagnosticId Diagnostic identifier. Must be unique in the current API Management service
     *                     instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, apiId, diagnosticId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, diagnosticId, options }, getOperationSpec$C);
    }
    /**
     * Creates a new Diagnostic for an API or updates an existing one.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param diagnosticId Diagnostic identifier. Must be unique in the current API Management service
     *                     instance.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, apiId, diagnosticId, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            diagnosticId,
            parameters,
            options
        }, createOrUpdateOperationSpec$C);
    }
    /**
     * Updates the details of the Diagnostic for an API specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param diagnosticId Diagnostic identifier. Must be unique in the current API Management service
     *                     instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Diagnostic Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, apiId, diagnosticId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            diagnosticId,
            ifMatch,
            parameters,
            options
        }, updateOperationSpec$o);
    }
    /**
     * Deletes the specified Diagnostic from an API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param diagnosticId Diagnostic identifier. Must be unique in the current API Management service
     *                     instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, apiId, diagnosticId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, diagnosticId, ifMatch, options }, deleteOperationSpec$y);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, apiId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, nextLink, options }, listByServiceNextOperationSpec$v);
    }
}
// Operation Specifications
const serializer$11 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/diagnostics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const getEntityTagOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/diagnostics/{diagnosticId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ApiDiagnosticGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        diagnosticId
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const getOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/diagnostics/{diagnosticId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticContract,
            headersMapper: ApiDiagnosticGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        diagnosticId
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const createOrUpdateOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/diagnostics/{diagnosticId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DiagnosticContract,
            headersMapper: ApiDiagnosticCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: DiagnosticContract,
            headersMapper: ApiDiagnosticCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        diagnosticId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$11
};
const updateOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/diagnostics/{diagnosticId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DiagnosticContract,
            headersMapper: ApiDiagnosticUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        diagnosticId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$11
};
const deleteOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/diagnostics/{diagnosticId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        diagnosticId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$11
};
const listByServiceNextOperationSpec$v = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        apiId1
    ],
    headerParameters: [accept],
    serializer: serializer$11
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiIssue operations. */
class ApiIssueImpl {
    /**
     * Initialize a new instance of the class ApiIssue class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all issues associated with the specified API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, apiId, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, apiId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, apiId, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, apiId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, apiId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, apiId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all issues associated with the specified API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, options }, listByServiceOperationSpec$B);
    }
    /**
     * Gets the entity state (Etag) version of the Issue for an API specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, apiId, issueId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, issueId, options }, getEntityTagOperationSpec$u);
    }
    /**
     * Gets the details of the Issue for an API specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, apiId, issueId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, issueId, options }, getOperationSpec$B);
    }
    /**
     * Creates a new Issue for an API or updates an existing one.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, apiId, issueId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, issueId, parameters, options }, createOrUpdateOperationSpec$B);
    }
    /**
     * Updates an existing issue for an API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, apiId, issueId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            issueId,
            ifMatch,
            parameters,
            options
        }, updateOperationSpec$n);
    }
    /**
     * Deletes the specified Issue from an API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, apiId, issueId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, issueId, ifMatch, options }, deleteOperationSpec$x);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, apiId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, nextLink, options }, listByServiceNextOperationSpec$u);
    }
}
// Operation Specifications
const serializer$10 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IssueCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        expandCommentsAttachments
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const getEntityTagOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ApiIssueGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const getOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IssueContract,
            headersMapper: ApiIssueGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        expandCommentsAttachments
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const createOrUpdateOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IssueContract,
            headersMapper: ApiIssueCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: IssueContract,
            headersMapper: ApiIssueCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$10
};
const updateOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: IssueContract,
            headersMapper: ApiIssueUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$10
};
const deleteOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$10
};
const listByServiceNextOperationSpec$u = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IssueCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        expandCommentsAttachments
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        apiId1
    ],
    headerParameters: [accept],
    serializer: serializer$10
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiIssueComment operations. */
class ApiIssueCommentImpl {
    /**
     * Initialize a new instance of the class ApiIssueComment class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all comments for the Issue associated with the specified API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, apiId, issueId, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, apiId, issueId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, apiId, issueId, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, apiId, issueId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, apiId, issueId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, apiId, issueId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, apiId, issueId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, apiId, issueId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all comments for the Issue associated with the specified API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, apiId, issueId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, issueId, options }, listByServiceOperationSpec$A);
    }
    /**
     * Gets the entity state (Etag) version of the issue Comment for an API specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param commentId Comment identifier within an Issue. Must be unique in the current Issue.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, apiId, issueId, commentId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, issueId, commentId, options }, getEntityTagOperationSpec$t);
    }
    /**
     * Gets the details of the issue Comment for an API specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param commentId Comment identifier within an Issue. Must be unique in the current Issue.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, apiId, issueId, commentId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, issueId, commentId, options }, getOperationSpec$A);
    }
    /**
     * Creates a new Comment for the Issue in an API or updates an existing one.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param commentId Comment identifier within an Issue. Must be unique in the current Issue.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, apiId, issueId, commentId, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            issueId,
            commentId,
            parameters,
            options
        }, createOrUpdateOperationSpec$A);
    }
    /**
     * Deletes the specified comment from an Issue.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param commentId Comment identifier within an Issue. Must be unique in the current Issue.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, apiId, issueId, commentId, ifMatch, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            issueId,
            commentId,
            ifMatch,
            options
        }, deleteOperationSpec$w);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, apiId, issueId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, issueId, nextLink, options }, listByServiceNextOperationSpec$t);
    }
}
// Operation Specifications
const serializer$$ = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}/comments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IssueCommentCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId
    ],
    headerParameters: [accept],
    serializer: serializer$$
};
const getEntityTagOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}/comments/{commentId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ApiIssueCommentGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId,
        commentId
    ],
    headerParameters: [accept],
    serializer: serializer$$
};
const getOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}/comments/{commentId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IssueCommentContract,
            headersMapper: ApiIssueCommentGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId,
        commentId
    ],
    headerParameters: [accept],
    serializer: serializer$$
};
const createOrUpdateOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}/comments/{commentId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IssueCommentContract,
            headersMapper: ApiIssueCommentCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: IssueCommentContract,
            headersMapper: ApiIssueCommentCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId,
        commentId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$$
};
const deleteOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}/comments/{commentId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId,
        commentId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$$
};
const listByServiceNextOperationSpec$t = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IssueCommentCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        apiId1,
        issueId
    ],
    headerParameters: [accept],
    serializer: serializer$$
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiIssueAttachment operations. */
class ApiIssueAttachmentImpl {
    /**
     * Initialize a new instance of the class ApiIssueAttachment class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all attachments for the Issue associated with the specified API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, apiId, issueId, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, apiId, issueId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, apiId, issueId, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, apiId, issueId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, apiId, issueId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, apiId, issueId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, apiId, issueId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, apiId, issueId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all attachments for the Issue associated with the specified API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, apiId, issueId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, issueId, options }, listByServiceOperationSpec$z);
    }
    /**
     * Gets the entity state (Etag) version of the issue Attachment for an API specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param attachmentId Attachment identifier within an Issue. Must be unique in the current Issue.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, apiId, issueId, attachmentId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, issueId, attachmentId, options }, getEntityTagOperationSpec$s);
    }
    /**
     * Gets the details of the issue Attachment for an API specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param attachmentId Attachment identifier within an Issue. Must be unique in the current Issue.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, apiId, issueId, attachmentId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, issueId, attachmentId, options }, getOperationSpec$z);
    }
    /**
     * Creates a new Attachment for the Issue in an API or updates an existing one.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param attachmentId Attachment identifier within an Issue. Must be unique in the current Issue.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, apiId, issueId, attachmentId, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            issueId,
            attachmentId,
            parameters,
            options
        }, createOrUpdateOperationSpec$z);
    }
    /**
     * Deletes the specified comment from an Issue.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param attachmentId Attachment identifier within an Issue. Must be unique in the current Issue.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, apiId, issueId, attachmentId, ifMatch, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            issueId,
            attachmentId,
            ifMatch,
            options
        }, deleteOperationSpec$v);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, apiId, issueId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, issueId, nextLink, options }, listByServiceNextOperationSpec$s);
    }
}
// Operation Specifications
const serializer$_ = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}/attachments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IssueAttachmentCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId
    ],
    headerParameters: [accept],
    serializer: serializer$_
};
const getEntityTagOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}/attachments/{attachmentId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ApiIssueAttachmentGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId,
        attachmentId
    ],
    headerParameters: [accept],
    serializer: serializer$_
};
const getOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}/attachments/{attachmentId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IssueAttachmentContract,
            headersMapper: ApiIssueAttachmentGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId,
        attachmentId
    ],
    headerParameters: [accept],
    serializer: serializer$_
};
const createOrUpdateOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}/attachments/{attachmentId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IssueAttachmentContract,
            headersMapper: ApiIssueAttachmentCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: IssueAttachmentContract,
            headersMapper: ApiIssueAttachmentCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId,
        attachmentId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$_
};
const deleteOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/issues/{issueId}/attachments/{attachmentId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        issueId,
        attachmentId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$_
};
const listByServiceNextOperationSpec$s = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IssueAttachmentCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        apiId1,
        issueId
    ],
    headerParameters: [accept],
    serializer: serializer$_
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiTagDescription operations. */
class ApiTagDescriptionImpl {
    /**
     * Initialize a new instance of the class ApiTagDescription class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Tags descriptions in scope of API. Model similar to swagger - tagDescription is defined on
     * API level but tag may be assigned to the Operations
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, apiId, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, apiId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, apiId, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, apiId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, apiId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, apiId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all Tags descriptions in scope of API. Model similar to swagger - tagDescription is defined on
     * API level but tag may be assigned to the Operations
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, options }, listByServiceOperationSpec$y);
    }
    /**
     * Gets the entity state version of the tag specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param tagDescriptionId Tag description identifier. Used when creating tagDescription for API/Tag
     *                         association. Based on API and Tag names.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, apiId, tagDescriptionId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, tagDescriptionId, options }, getEntityTagOperationSpec$r);
    }
    /**
     * Get Tag description in scope of API
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param tagDescriptionId Tag description identifier. Used when creating tagDescription for API/Tag
     *                         association. Based on API and Tag names.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, apiId, tagDescriptionId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, tagDescriptionId, options }, getOperationSpec$y);
    }
    /**
     * Create/Update tag description in scope of the Api.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param tagDescriptionId Tag description identifier. Used when creating tagDescription for API/Tag
     *                         association. Based on API and Tag names.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, apiId, tagDescriptionId, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            tagDescriptionId,
            parameters,
            options
        }, createOrUpdateOperationSpec$y);
    }
    /**
     * Delete tag description for the Api.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param tagDescriptionId Tag description identifier. Used when creating tagDescription for API/Tag
     *                         association. Based on API and Tag names.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, apiId, tagDescriptionId, ifMatch, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            apiId,
            tagDescriptionId,
            ifMatch,
            options
        }, deleteOperationSpec$u);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, apiId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, nextLink, options }, listByServiceNextOperationSpec$r);
    }
}
// Operation Specifications
const serializer$Z = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/tagDescriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagDescriptionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};
const getEntityTagOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/tagDescriptions/{tagDescriptionId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ApiTagDescriptionGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        tagDescriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};
const getOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/tagDescriptions/{tagDescriptionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagDescriptionContract,
            headersMapper: ApiTagDescriptionGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        tagDescriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};
const createOrUpdateOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/tagDescriptions/{tagDescriptionId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: TagDescriptionContract,
            headersMapper: ApiTagDescriptionCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: TagDescriptionContract,
            headersMapper: ApiTagDescriptionCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        tagDescriptionId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$Z
};
const deleteOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/tagDescriptions/{tagDescriptionId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        tagDescriptionId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$Z
};
const listByServiceNextOperationSpec$r = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagDescriptionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing OperationOperations operations. */
class OperationOperationsImpl {
    /**
     * Initialize a new instance of the class OperationOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of operations associated with tags.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    listByTags(resourceGroupName, serviceName, apiId, options) {
        const iter = this.listByTagsPagingAll(resourceGroupName, serviceName, apiId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByTagsPagingPage(resourceGroupName, serviceName, apiId, options);
            }
        };
    }
    listByTagsPagingPage(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTagsPagingPage_1() {
            let result = yield tslib.__await(this._listByTags(resourceGroupName, serviceName, apiId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByTagsNext(resourceGroupName, serviceName, apiId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByTagsPagingAll(resourceGroupName, serviceName, apiId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTagsPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByTagsPagingPage(resourceGroupName, serviceName, apiId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of operations associated with tags.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    _listByTags(resourceGroupName, serviceName, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, options }, listByTagsOperationSpec$1);
    }
    /**
     * ListByTagsNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param nextLink The nextLink from the previous successful call to the ListByTags method.
     * @param options The options parameters.
     */
    _listByTagsNext(resourceGroupName, serviceName, apiId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, nextLink, options }, listByTagsNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$Y = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByTagsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}/operationsByTags",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagResourceCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        includeNotTaggedOperations
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId
    ],
    headerParameters: [accept],
    serializer: serializer$Y
};
const listByTagsNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagResourceCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        includeNotTaggedOperations
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$Y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ApiExport operations. */
class ApiExportImpl {
    /**
     * Initialize a new instance of the class ApiExport class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the details of the API specified by its identifier in the format specified to the Storage Blob
     * with SAS Key valid for 5 minutes.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param format Format in which to export the Api Details to the Storage Blob with Sas Key valid for 5
     *               minutes.
     * @param exportParam Query parameter required to export the API details.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, apiId, format, exportParam, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, apiId, format, exportParam, options }, getOperationSpec$x);
    }
}
// Operation Specifications
const serializer$X = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apis/{apiId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiExportResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        format1,
        exportParam
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId
    ],
    headerParameters: [accept],
    serializer: serializer$X
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiVersionSet operations. */
class ApiVersionSetImpl {
    /**
     * Initialize a new instance of the class ApiVersionSet class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of API Version Sets in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of API Version Sets in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$x);
    }
    /**
     * Gets the entity state (Etag) version of the Api Version Set specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param versionSetId Api Version Set identifier. Must be unique in the current API Management service
     *                     instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, versionSetId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, versionSetId, options }, getEntityTagOperationSpec$q);
    }
    /**
     * Gets the details of the Api Version Set specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param versionSetId Api Version Set identifier. Must be unique in the current API Management service
     *                     instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, versionSetId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, versionSetId, options }, getOperationSpec$w);
    }
    /**
     * Creates or Updates a Api Version Set.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param versionSetId Api Version Set identifier. Must be unique in the current API Management service
     *                     instance.
     * @param parameters Create or update parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, versionSetId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, versionSetId, parameters, options }, createOrUpdateOperationSpec$x);
    }
    /**
     * Updates the details of the Api VersionSet specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param versionSetId Api Version Set identifier. Must be unique in the current API Management service
     *                     instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, versionSetId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            versionSetId,
            ifMatch,
            parameters,
            options
        }, updateOperationSpec$m);
    }
    /**
     * Deletes specific Api Version Set.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param versionSetId Api Version Set identifier. Must be unique in the current API Management service
     *                     instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, versionSetId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, versionSetId, ifMatch, options }, deleteOperationSpec$t);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$q);
    }
}
// Operation Specifications
const serializer$W = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apiVersionSets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiVersionSetCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$W
};
const getEntityTagOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apiVersionSets/{versionSetId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ApiVersionSetGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        versionSetId
    ],
    headerParameters: [accept],
    serializer: serializer$W
};
const getOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apiVersionSets/{versionSetId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiVersionSetContract,
            headersMapper: ApiVersionSetGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        versionSetId
    ],
    headerParameters: [accept],
    serializer: serializer$W
};
const createOrUpdateOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apiVersionSets/{versionSetId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApiVersionSetContract,
            headersMapper: ApiVersionSetCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: ApiVersionSetContract,
            headersMapper: ApiVersionSetCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters14,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        versionSetId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$W
};
const updateOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apiVersionSets/{versionSetId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ApiVersionSetContract,
            headersMapper: ApiVersionSetUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters15,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        versionSetId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$W
};
const deleteOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/apiVersionSets/{versionSetId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        versionSetId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$W
};
const listByServiceNextOperationSpec$q = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiVersionSetCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$W
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AuthorizationServer operations. */
class AuthorizationServerImpl {
    /**
     * Initialize a new instance of the class AuthorizationServer class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of authorization servers defined within a service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of authorization servers defined within a service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$w);
    }
    /**
     * Gets the entity state (Etag) version of the authorizationServer specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param authsid Identifier of the authorization server.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, authsid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, authsid, options }, getEntityTagOperationSpec$p);
    }
    /**
     * Gets the details of the authorization server specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param authsid Identifier of the authorization server.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, authsid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, authsid, options }, getOperationSpec$v);
    }
    /**
     * Creates new authorization server or updates an existing authorization server.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param authsid Identifier of the authorization server.
     * @param parameters Create or update parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, authsid, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, authsid, parameters, options }, createOrUpdateOperationSpec$w);
    }
    /**
     * Updates the details of the authorization server specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param authsid Identifier of the authorization server.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters OAuth2 Server settings Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, authsid, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, authsid, ifMatch, parameters, options }, updateOperationSpec$l);
    }
    /**
     * Deletes specific authorization server instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param authsid Identifier of the authorization server.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, authsid, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, authsid, ifMatch, options }, deleteOperationSpec$s);
    }
    /**
     * Gets the client secret details of the authorization server.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param authsid Identifier of the authorization server.
     * @param options The options parameters.
     */
    listSecrets(resourceGroupName, serviceName, authsid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, authsid, options }, listSecretsOperationSpec$5);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$p);
    }
}
// Operation Specifications
const serializer$V = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/authorizationServers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AuthorizationServerCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const getEntityTagOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/authorizationServers/{authsid}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: AuthorizationServerGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        authsid
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const getOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/authorizationServers/{authsid}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AuthorizationServerContract,
            headersMapper: AuthorizationServerGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        authsid
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const createOrUpdateOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/authorizationServers/{authsid}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AuthorizationServerContract,
            headersMapper: AuthorizationServerCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: AuthorizationServerContract,
            headersMapper: AuthorizationServerCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters16,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        authsid
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$V
};
const updateOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/authorizationServers/{authsid}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AuthorizationServerContract,
            headersMapper: AuthorizationServerUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters17,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        authsid
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$V
};
const deleteOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/authorizationServers/{authsid}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        authsid
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$V
};
const listSecretsOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/authorizationServers/{authsid}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AuthorizationServerSecretsContract,
            headersMapper: AuthorizationServerListSecretsHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        authsid
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const listByServiceNextOperationSpec$p = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AuthorizationServerCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$V
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Backend operations. */
class BackendImpl {
    /**
     * Initialize a new instance of the class Backend class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of backends in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of backends in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$v);
    }
    /**
     * Gets the entity state (Etag) version of the backend specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param backendId Identifier of the Backend entity. Must be unique in the current API Management
     *                  service instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, backendId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, backendId, options }, getEntityTagOperationSpec$o);
    }
    /**
     * Gets the details of the backend specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param backendId Identifier of the Backend entity. Must be unique in the current API Management
     *                  service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, backendId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, backendId, options }, getOperationSpec$u);
    }
    /**
     * Creates or Updates a backend.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param backendId Identifier of the Backend entity. Must be unique in the current API Management
     *                  service instance.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, backendId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, backendId, parameters, options }, createOrUpdateOperationSpec$v);
    }
    /**
     * Updates an existing backend.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param backendId Identifier of the Backend entity. Must be unique in the current API Management
     *                  service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, backendId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            backendId,
            ifMatch,
            parameters,
            options
        }, updateOperationSpec$k);
    }
    /**
     * Deletes the specified backend.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param backendId Identifier of the Backend entity. Must be unique in the current API Management
     *                  service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, backendId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, backendId, ifMatch, options }, deleteOperationSpec$r);
    }
    /**
     * Notifies the APIM proxy to create a new connection to the backend after the specified timeout. If no
     * timeout was specified, timeout of 2 minutes is used.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param backendId Identifier of the Backend entity. Must be unique in the current API Management
     *                  service instance.
     * @param options The options parameters.
     */
    reconnect(resourceGroupName, serviceName, backendId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, backendId, options }, reconnectOperationSpec);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$o);
    }
}
// Operation Specifications
const serializer$U = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/backends",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackendCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$U
};
const getEntityTagOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/backends/{backendId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: BackendGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        backendId
    ],
    headerParameters: [accept],
    serializer: serializer$U
};
const getOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/backends/{backendId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackendContract,
            headersMapper: BackendGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        backendId
    ],
    headerParameters: [accept],
    serializer: serializer$U
};
const createOrUpdateOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/backends/{backendId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BackendContract,
            headersMapper: BackendCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: BackendContract,
            headersMapper: BackendCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters18,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        backendId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$U
};
const updateOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/backends/{backendId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: BackendContract,
            headersMapper: BackendUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters19,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        backendId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$U
};
const deleteOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/backends/{backendId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        backendId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$U
};
const reconnectOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/backends/{backendId}/reconnect",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters20,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        backendId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const listByServiceNextOperationSpec$o = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackendCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$U
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Cache operations. */
class CacheImpl {
    /**
     * Initialize a new instance of the class Cache class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of all external Caches in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of all external Caches in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$u);
    }
    /**
     * Gets the entity state (Etag) version of the Cache specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param cacheId Identifier of the Cache entity. Cache identifier (should be either 'default' or valid
     *                Azure region identifier).
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, cacheId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, cacheId, options }, getEntityTagOperationSpec$n);
    }
    /**
     * Gets the details of the Cache specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param cacheId Identifier of the Cache entity. Cache identifier (should be either 'default' or valid
     *                Azure region identifier).
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, cacheId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, cacheId, options }, getOperationSpec$t);
    }
    /**
     * Creates or updates an External Cache to be used in Api Management instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param cacheId Identifier of the Cache entity. Cache identifier (should be either 'default' or valid
     *                Azure region identifier).
     * @param parameters Create or Update parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, cacheId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, cacheId, parameters, options }, createOrUpdateOperationSpec$u);
    }
    /**
     * Updates the details of the cache specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param cacheId Identifier of the Cache entity. Cache identifier (should be either 'default' or valid
     *                Azure region identifier).
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, cacheId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, cacheId, ifMatch, parameters, options }, updateOperationSpec$j);
    }
    /**
     * Deletes specific Cache.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param cacheId Identifier of the Cache entity. Cache identifier (should be either 'default' or valid
     *                Azure region identifier).
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, cacheId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, cacheId, ifMatch, options }, deleteOperationSpec$q);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$n);
    }
}
// Operation Specifications
const serializer$T = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/caches",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CacheCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [top, skip, apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$T
};
const getEntityTagOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/caches/{cacheId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: CacheGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        cacheId
    ],
    headerParameters: [accept],
    serializer: serializer$T
};
const getOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/caches/{cacheId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CacheContract,
            headersMapper: CacheGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        cacheId
    ],
    headerParameters: [accept],
    serializer: serializer$T
};
const createOrUpdateOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/caches/{cacheId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CacheContract,
            headersMapper: CacheCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: CacheContract,
            headersMapper: CacheCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters21,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        cacheId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$T
};
const updateOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/caches/{cacheId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: CacheContract,
            headersMapper: CacheUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters22,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        cacheId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$T
};
const deleteOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/caches/{cacheId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        cacheId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$T
};
const listByServiceNextOperationSpec$n = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CacheCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [top, skip, apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$T
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Certificate operations. */
class CertificateImpl {
    /**
     * Initialize a new instance of the class Certificate class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of all certificates in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of all certificates in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$t);
    }
    /**
     * Gets the entity state (Etag) version of the certificate specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param certificateId Identifier of the certificate entity. Must be unique in the current API
     *                      Management service instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, certificateId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, certificateId, options }, getEntityTagOperationSpec$m);
    }
    /**
     * Gets the details of the certificate specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param certificateId Identifier of the certificate entity. Must be unique in the current API
     *                      Management service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, certificateId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, certificateId, options }, getOperationSpec$s);
    }
    /**
     * Creates or updates the certificate being used for authentication with the backend.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param certificateId Identifier of the certificate entity. Must be unique in the current API
     *                      Management service instance.
     * @param parameters Create or Update parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, certificateId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, certificateId, parameters, options }, createOrUpdateOperationSpec$t);
    }
    /**
     * Deletes specific certificate.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param certificateId Identifier of the certificate entity. Must be unique in the current API
     *                      Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, certificateId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, certificateId, ifMatch, options }, deleteOperationSpec$p);
    }
    /**
     * From KeyVault, Refresh the certificate being used for authentication with the backend.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param certificateId Identifier of the certificate entity. Must be unique in the current API
     *                      Management service instance.
     * @param options The options parameters.
     */
    refreshSecret(resourceGroupName, serviceName, certificateId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, certificateId, options }, refreshSecretOperationSpec$1);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$m);
    }
}
// Operation Specifications
const serializer$S = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/certificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        isKeyVaultRefreshFailed
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$S
};
const getEntityTagOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/certificates/{certificateId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: CertificateGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        certificateId
    ],
    headerParameters: [accept],
    serializer: serializer$S
};
const getOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/certificates/{certificateId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateContract,
            headersMapper: CertificateGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        certificateId
    ],
    headerParameters: [accept],
    serializer: serializer$S
};
const createOrUpdateOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/certificates/{certificateId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CertificateContract,
            headersMapper: CertificateCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: CertificateContract,
            headersMapper: CertificateCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters23,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        certificateId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$S
};
const deleteOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/certificates/{certificateId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        certificateId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$S
};
const refreshSecretOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/certificates/{certificateId}/refreshSecret",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CertificateContract,
            headersMapper: CertificateRefreshSecretHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        certificateId
    ],
    headerParameters: [accept],
    serializer: serializer$S
};
const listByServiceNextOperationSpec$m = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        isKeyVaultRefreshFailed
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$S
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ContentType operations. */
class ContentTypeImpl {
    /**
     * Initialize a new instance of the class ContentType class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the developer portal's content types. Content types describe content items' properties,
     * validation rules, and constraints.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the developer portal's content types. Content types describe content items' properties,
     * validation rules, and constraints.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$s);
    }
    /**
     * Gets the details of the developer portal's content type. Content types describe content items'
     * properties, validation rules, and constraints.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param contentTypeId Content type identifier.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, contentTypeId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, contentTypeId, options }, getOperationSpec$r);
    }
    /**
     * Creates or updates the developer portal's content type. Content types describe content items'
     * properties, validation rules, and constraints. Custom content types' identifiers need to start with
     * the `c-` prefix. Built-in content types can't be modified.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param contentTypeId Content type identifier.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, contentTypeId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, contentTypeId, options }, createOrUpdateOperationSpec$s);
    }
    /**
     * Removes the specified developer portal's content type. Content types describe content items'
     * properties, validation rules, and constraints. Built-in content types (with identifiers starting
     * with the `c-` prefix) can't be removed.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param contentTypeId Content type identifier.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, contentTypeId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, contentTypeId, ifMatch, options }, deleteOperationSpec$o);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$l);
    }
}
// Operation Specifications
const serializer$R = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/contentTypes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContentTypeCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const getOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/contentTypes/{contentTypeId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContentTypeContract,
            headersMapper: ContentTypeGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        contentTypeId
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const createOrUpdateOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/contentTypes/{contentTypeId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ContentTypeContract,
            headersMapper: ContentTypeCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: ContentTypeContract,
            headersMapper: ContentTypeCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        contentTypeId
    ],
    headerParameters: [accept, ifMatch],
    serializer: serializer$R
};
const deleteOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/contentTypes/{contentTypeId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        contentTypeId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$R
};
const listByServiceNextOperationSpec$l = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContentTypeCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$R
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ContentItem operations. */
class ContentItemImpl {
    /**
     * Initialize a new instance of the class ContentItem class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists developer portal's content items specified by the provided content type.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param contentTypeId Content type identifier.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, contentTypeId, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, contentTypeId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, contentTypeId, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, contentTypeId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, contentTypeId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, contentTypeId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, contentTypeId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, contentTypeId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists developer portal's content items specified by the provided content type.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param contentTypeId Content type identifier.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, contentTypeId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, contentTypeId, options }, listByServiceOperationSpec$r);
    }
    /**
     * Returns the entity state (ETag) version of the developer portal's content item specified by its
     * identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param contentTypeId Content type identifier.
     * @param contentItemId Content item identifier.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, contentTypeId, contentItemId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, contentTypeId, contentItemId, options }, getEntityTagOperationSpec$l);
    }
    /**
     * Returns the developer portal's content item specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param contentTypeId Content type identifier.
     * @param contentItemId Content item identifier.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, contentTypeId, contentItemId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, contentTypeId, contentItemId, options }, getOperationSpec$q);
    }
    /**
     * Creates a new developer portal's content item specified by the provided content type.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param contentTypeId Content type identifier.
     * @param contentItemId Content item identifier.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, contentTypeId, contentItemId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, contentTypeId, contentItemId, options }, createOrUpdateOperationSpec$r);
    }
    /**
     * Removes the specified developer portal's content item.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param contentTypeId Content type identifier.
     * @param contentItemId Content item identifier.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, contentTypeId, contentItemId, ifMatch, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            contentTypeId,
            contentItemId,
            ifMatch,
            options
        }, deleteOperationSpec$n);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param contentTypeId Content type identifier.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, contentTypeId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, contentTypeId, nextLink, options }, listByServiceNextOperationSpec$k);
    }
}
// Operation Specifications
const serializer$Q = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/contentTypes/{contentTypeId}/contentItems",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContentItemCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        contentTypeId
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};
const getEntityTagOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/contentTypes/{contentTypeId}/contentItems/{contentItemId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ContentItemGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        contentTypeId,
        contentItemId
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};
const getOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/contentTypes/{contentTypeId}/contentItems/{contentItemId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContentItemContract,
            headersMapper: ContentItemGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        contentTypeId,
        contentItemId
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};
const createOrUpdateOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/contentTypes/{contentTypeId}/contentItems/{contentItemId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ContentItemContract,
            headersMapper: ContentItemCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: ContentItemContract,
            headersMapper: ContentItemCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        contentTypeId,
        contentItemId
    ],
    headerParameters: [accept, ifMatch],
    serializer: serializer$Q
};
const deleteOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/contentTypes/{contentTypeId}/contentItems/{contentItemId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        contentTypeId,
        contentItemId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$Q
};
const listByServiceNextOperationSpec$k = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContentItemCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        contentTypeId
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DeletedServices operations. */
class DeletedServicesImpl {
    /**
     * Initialize a new instance of the class DeletedServices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all soft-deleted services available for undelete for the given subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all soft-deleted services available for undelete for the given subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * Get soft-deleted Api Management Service by name.
     * @param serviceName The name of the API Management service.
     * @param location The location of the deleted API Management service.
     * @param options The options parameters.
     */
    getByName(serviceName, location, options) {
        return this.client.sendOperationRequest({ serviceName, location, options }, getByNameOperationSpec$1);
    }
    /**
     * Purges Api Management Service (deletes it with no option to undelete).
     * @param serviceName The name of the API Management service.
     * @param location The location of the deleted API Management service.
     * @param options The options parameters.
     */
    beginPurge(serviceName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { serviceName, location, options }, purgeOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Purges Api Management Service (deletes it with no option to undelete).
     * @param serviceName The name of the API Management service.
     * @param location The location of the deleted API Management service.
     * @param options The options parameters.
     */
    beginPurgeAndWait(serviceName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPurge(serviceName, location, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$P = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ApiManagement/deletedservices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedServicesCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$P
};
const getByNameOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ApiManagement/locations/{location}/deletedservices/{serviceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedServiceContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        serviceName,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$P
};
const purgeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ApiManagement/locations/{location}/deletedservices/{serviceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        serviceName,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$P
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedServicesCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$P
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiManagementOperations operations. */
class ApiManagementOperationsImpl {
    /**
     * Initialize a new instance of the class ApiManagementOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available REST API operations of the Microsoft.ApiManagement provider.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available REST API operations of the Microsoft.ApiManagement provider.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$8);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$O = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/providers/Microsoft.ApiManagement/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$O
};
const listNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$O
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiManagementServiceSkus operations. */
class ApiManagementServiceSkusImpl {
    /**
     * Initialize a new instance of the class ApiManagementServiceSkus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all available SKU for a given API Management service
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listAvailableServiceSkus(resourceGroupName, serviceName, options) {
        const iter = this.listAvailableServiceSkusPagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAvailableServiceSkusPagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listAvailableServiceSkusPagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAvailableServiceSkusPagingPage_1() {
            let result = yield tslib.__await(this._listAvailableServiceSkus(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAvailableServiceSkusNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAvailableServiceSkusPagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAvailableServiceSkusPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAvailableServiceSkusPagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all available SKU for a given API Management service
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listAvailableServiceSkus(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listAvailableServiceSkusOperationSpec);
    }
    /**
     * ListAvailableServiceSkusNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListAvailableServiceSkus
     *                 method.
     * @param options The options parameters.
     */
    _listAvailableServiceSkusNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listAvailableServiceSkusNextOperationSpec);
    }
}
// Operation Specifications
const serializer$N = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listAvailableServiceSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceSkuResults
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$N
};
const listAvailableServiceSkusNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceSkuResults
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$N
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiManagementService operations. */
class ApiManagementServiceImpl {
    /**
     * Initialize a new instance of the class ApiManagementService class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all API Management services within a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all API Management services within an Azure subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Restores a backup of an API Management service created using the ApiManagementService_Backup
     * operation on the current service. This is a long running operation and could take several minutes to
     * complete.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param parameters Parameters supplied to the Restore API Management service from backup operation.
     * @param options The options parameters.
     */
    beginRestore(resourceGroupName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, parameters, options }, restoreOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Restores a backup of an API Management service created using the ApiManagementService_Backup
     * operation on the current service. This is a long running operation and could take several minutes to
     * complete.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param parameters Parameters supplied to the Restore API Management service from backup operation.
     * @param options The options parameters.
     */
    beginRestoreAndWait(resourceGroupName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestore(resourceGroupName, serviceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Creates a backup of the API Management service to the given Azure Storage Account. This is long
     * running operation and could take several minutes to complete.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param parameters Parameters supplied to the ApiManagementService_Backup operation.
     * @param options The options parameters.
     */
    beginBackup(resourceGroupName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, parameters, options }, backupOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a backup of the API Management service to the given Azure Storage Account. This is long
     * running operation and could take several minutes to complete.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param parameters Parameters supplied to the ApiManagementService_Backup operation.
     * @param options The options parameters.
     */
    beginBackupAndWait(resourceGroupName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginBackup(resourceGroupName, serviceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Creates or updates an API Management service. This is long running operation and could take several
     * minutes to complete.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param parameters Parameters supplied to the CreateOrUpdate API Management service operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, parameters, options }, createOrUpdateOperationSpec$q);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an API Management service. This is long running operation and could take several
     * minutes to complete.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param parameters Parameters supplied to the CreateOrUpdate API Management service operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serviceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing API Management service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param parameters Parameters supplied to the CreateOrUpdate API Management service operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, parameters, options }, updateOperationSpec$i);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an existing API Management service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param parameters Parameters supplied to the CreateOrUpdate API Management service operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, serviceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets an API Management service resource description.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, getOperationSpec$p);
    }
    /**
     * Deletes an existing API Management service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, options }, deleteOperationSpec$m);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing API Management service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serviceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List all API Management services within a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Lists all API Management services within an Azure subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$7);
    }
    /**
     * Gets the Single-Sign-On token for the API Management Service which is valid for 5 Minutes.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    getSsoToken(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, getSsoTokenOperationSpec);
    }
    /**
     * Checks availability and correctness of a name for an API Management service.
     * @param parameters Parameters supplied to the CheckNameAvailability operation.
     * @param options The options parameters.
     */
    checkNameAvailability(parameters, options) {
        return this.client.sendOperationRequest({ parameters, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * Get the custom domain ownership identifier for an API Management service.
     * @param options The options parameters.
     */
    getDomainOwnershipIdentifier(options) {
        return this.client.sendOperationRequest({ options }, getDomainOwnershipIdentifierOperationSpec);
    }
    /**
     * Updates the Microsoft.ApiManagement resource running in the Virtual network to pick the updated DNS
     * changes.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    beginApplyNetworkConfigurationUpdates(resourceGroupName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, options }, applyNetworkConfigurationUpdatesOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the Microsoft.ApiManagement resource running in the Virtual network to pick the updated DNS
     * changes.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    beginApplyNetworkConfigurationUpdatesAndWait(resourceGroupName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginApplyNetworkConfigurationUpdates(resourceGroupName, serviceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$M = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const restoreOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/restore",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ApiManagementServiceResource
        },
        201: {
            bodyMapper: ApiManagementServiceResource
        },
        202: {
            bodyMapper: ApiManagementServiceResource
        },
        204: {
            bodyMapper: ApiManagementServiceResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters24,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$M
};
const backupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/backup",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ApiManagementServiceResource
        },
        201: {
            bodyMapper: ApiManagementServiceResource
        },
        202: {
            bodyMapper: ApiManagementServiceResource
        },
        204: {
            bodyMapper: ApiManagementServiceResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters24,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$M
};
const createOrUpdateOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApiManagementServiceResource
        },
        201: {
            bodyMapper: ApiManagementServiceResource
        },
        202: {
            bodyMapper: ApiManagementServiceResource
        },
        204: {
            bodyMapper: ApiManagementServiceResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters25,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$M
};
const updateOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ApiManagementServiceResource
        },
        201: {
            bodyMapper: ApiManagementServiceResource
        },
        202: {
            bodyMapper: ApiManagementServiceResource
        },
        204: {
            bodyMapper: ApiManagementServiceResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters26,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$M
};
const getOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiManagementServiceResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const deleteOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiManagementServiceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ApiManagement/service",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiManagementServiceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$M
};
const getSsoTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/getssotoken",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ApiManagementServiceGetSsoTokenResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ApiManagement/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ApiManagementServiceNameAvailabilityResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters27,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$M
};
const getDomainOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ApiManagement/getDomainOwnershipIdentifier",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ApiManagementServiceGetDomainOwnershipIdentifierResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$M
};
const applyNetworkConfigurationUpdatesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/applynetworkconfigurationupdates",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ApiManagementServiceResource
        },
        201: {
            bodyMapper: ApiManagementServiceResource
        },
        202: {
            bodyMapper: ApiManagementServiceResource
        },
        204: {
            bodyMapper: ApiManagementServiceResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters28,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$M
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiManagementServiceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiManagementServiceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$M
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Diagnostic operations. */
class DiagnosticImpl {
    /**
     * Initialize a new instance of the class Diagnostic class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all diagnostics of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all diagnostics of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$q);
    }
    /**
     * Gets the entity state (Etag) version of the Diagnostic specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param diagnosticId Diagnostic identifier. Must be unique in the current API Management service
     *                     instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, diagnosticId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, diagnosticId, options }, getEntityTagOperationSpec$k);
    }
    /**
     * Gets the details of the Diagnostic specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param diagnosticId Diagnostic identifier. Must be unique in the current API Management service
     *                     instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, diagnosticId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, diagnosticId, options }, getOperationSpec$o);
    }
    /**
     * Creates a new Diagnostic or updates an existing one.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param diagnosticId Diagnostic identifier. Must be unique in the current API Management service
     *                     instance.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, diagnosticId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, diagnosticId, parameters, options }, createOrUpdateOperationSpec$p);
    }
    /**
     * Updates the details of the Diagnostic specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param diagnosticId Diagnostic identifier. Must be unique in the current API Management service
     *                     instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Diagnostic Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, diagnosticId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            diagnosticId,
            ifMatch,
            parameters,
            options
        }, updateOperationSpec$h);
    }
    /**
     * Deletes the specified Diagnostic.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param diagnosticId Diagnostic identifier. Must be unique in the current API Management service
     *                     instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, diagnosticId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, diagnosticId, ifMatch, options }, deleteOperationSpec$l);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$j);
    }
}
// Operation Specifications
const serializer$L = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/diagnostics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const getEntityTagOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/diagnostics/{diagnosticId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: DiagnosticGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        diagnosticId
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const getOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/diagnostics/{diagnosticId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticContract,
            headersMapper: DiagnosticGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        diagnosticId
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const createOrUpdateOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/diagnostics/{diagnosticId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DiagnosticContract,
            headersMapper: DiagnosticCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: DiagnosticContract,
            headersMapper: DiagnosticCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        diagnosticId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$L
};
const updateOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/diagnostics/{diagnosticId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DiagnosticContract,
            headersMapper: DiagnosticUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        diagnosticId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$L
};
const deleteOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/diagnostics/{diagnosticId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        diagnosticId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$L
};
const listByServiceNextOperationSpec$j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$L
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing EmailTemplate operations. */
class EmailTemplateImpl {
    /**
     * Initialize a new instance of the class EmailTemplate class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all email templates
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all email templates
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$p);
    }
    /**
     * Gets the entity state (Etag) version of the email template specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param templateName Email Template Name Identifier.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, templateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, templateName, options }, getEntityTagOperationSpec$j);
    }
    /**
     * Gets the details of the email template specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param templateName Email Template Name Identifier.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, templateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, templateName, options }, getOperationSpec$n);
    }
    /**
     * Updates an Email Template.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param templateName Email Template Name Identifier.
     * @param parameters Email Template update parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, templateName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, templateName, parameters, options }, createOrUpdateOperationSpec$o);
    }
    /**
     * Updates API Management email template
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param templateName Email Template Name Identifier.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, templateName, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            templateName,
            ifMatch,
            parameters,
            options
        }, updateOperationSpec$g);
    }
    /**
     * Reset the Email Template to default template provided by the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param templateName Email Template Name Identifier.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, templateName, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, templateName, ifMatch, options }, deleteOperationSpec$k);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$i);
    }
}
// Operation Specifications
const serializer$K = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/templates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EmailTemplateCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const getEntityTagOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/templates/{templateName}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: EmailTemplateGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        templateName
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const getOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/templates/{templateName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EmailTemplateContract,
            headersMapper: EmailTemplateGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        templateName
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const createOrUpdateOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/templates/{templateName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: EmailTemplateContract
        },
        201: {
            bodyMapper: EmailTemplateContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters29,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        templateName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$K
};
const updateOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/templates/{templateName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: EmailTemplateContract,
            headersMapper: EmailTemplateUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters29,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        templateName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$K
};
const deleteOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/templates/{templateName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        templateName
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$K
};
const listByServiceNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EmailTemplateCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$K
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Gateway operations. */
class GatewayImpl {
    /**
     * Initialize a new instance of the class Gateway class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of gateways registered with service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of gateways registered with service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$o);
    }
    /**
     * Gets the entity state (Etag) version of the Gateway specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, gatewayId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, options }, getEntityTagOperationSpec$i);
    }
    /**
     * Gets the details of the Gateway specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, gatewayId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, options }, getOperationSpec$m);
    }
    /**
     * Creates or updates a Gateway to be used in Api Management instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param parameters Gateway details.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, gatewayId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, parameters, options }, createOrUpdateOperationSpec$n);
    }
    /**
     * Updates the details of the gateway specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Gateway details.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, gatewayId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            gatewayId,
            ifMatch,
            parameters,
            options
        }, updateOperationSpec$f);
    }
    /**
     * Deletes specific Gateway.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, gatewayId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, ifMatch, options }, deleteOperationSpec$j);
    }
    /**
     * Retrieves gateway keys.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param options The options parameters.
     */
    listKeys(resourceGroupName, serviceName, gatewayId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, options }, listKeysOperationSpec);
    }
    /**
     * Regenerates specified gateway key invalidating any tokens created with it.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param parameters Gateway key regeneration request contract properties.
     * @param options The options parameters.
     */
    regenerateKey(resourceGroupName, serviceName, gatewayId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, parameters, options }, regenerateKeyOperationSpec);
    }
    /**
     * Gets the Shared Access Authorization Token for the gateway.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param parameters Gateway token request contract properties.
     * @param options The options parameters.
     */
    generateToken(resourceGroupName, serviceName, gatewayId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, parameters, options }, generateTokenOperationSpec);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$h);
    }
}
// Operation Specifications
const serializer$J = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GatewayCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const getEntityTagOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: GatewayGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const getOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GatewayContract,
            headersMapper: GatewayGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const createOrUpdateOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GatewayContract,
            headersMapper: GatewayCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: GatewayContract,
            headersMapper: GatewayCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters30,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$J
};
const updateOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: GatewayContract,
            headersMapper: GatewayUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters30,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$J
};
const deleteOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$J
};
const listKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GatewayKeysContract,
            headersMapper: GatewayListKeysHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const regenerateKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/regenerateKey",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters31,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const generateTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/generateToken",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GatewayTokenContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters32,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const listByServiceNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GatewayCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$J
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GatewayHostnameConfiguration operations. */
class GatewayHostnameConfigurationImpl {
    /**
     * Initialize a new instance of the class GatewayHostnameConfiguration class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the collection of hostname configurations for the specified gateway.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, gatewayId, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, gatewayId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, gatewayId, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, gatewayId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, gatewayId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, gatewayId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, gatewayId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, gatewayId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the collection of hostname configurations for the specified gateway.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, gatewayId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, options }, listByServiceOperationSpec$n);
    }
    /**
     * Checks that hostname configuration entity specified by identifier exists for specified Gateway
     * entity.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param hcId Gateway hostname configuration identifier. Must be unique in the scope of parent Gateway
     *             entity.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, gatewayId, hcId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, hcId, options }, getEntityTagOperationSpec$h);
    }
    /**
     * Get details of a hostname configuration
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param hcId Gateway hostname configuration identifier. Must be unique in the scope of parent Gateway
     *             entity.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, gatewayId, hcId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, hcId, options }, getOperationSpec$l);
    }
    /**
     * Creates of updates hostname configuration for a Gateway.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param hcId Gateway hostname configuration identifier. Must be unique in the scope of parent Gateway
     *             entity.
     * @param parameters Gateway hostname configuration details.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, gatewayId, hcId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, hcId, parameters, options }, createOrUpdateOperationSpec$m);
    }
    /**
     * Deletes the specified hostname configuration from the specified Gateway.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param hcId Gateway hostname configuration identifier. Must be unique in the scope of parent Gateway
     *             entity.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, gatewayId, hcId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, hcId, ifMatch, options }, deleteOperationSpec$i);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, gatewayId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, nextLink, options }, listByServiceNextOperationSpec$g);
    }
}
// Operation Specifications
const serializer$I = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/hostnameConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GatewayHostnameConfigurationCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const getEntityTagOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/hostnameConfigurations/{hcId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: GatewayHostnameConfigurationGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId,
        hcId
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const getOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/hostnameConfigurations/{hcId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GatewayHostnameConfigurationContract,
            headersMapper: GatewayHostnameConfigurationGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId,
        hcId
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const createOrUpdateOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/hostnameConfigurations/{hcId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GatewayHostnameConfigurationContract,
            headersMapper: GatewayHostnameConfigurationCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: GatewayHostnameConfigurationContract,
            headersMapper: GatewayHostnameConfigurationCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters33,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId,
        hcId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$I
};
const deleteOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/hostnameConfigurations/{hcId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId,
        hcId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$I
};
const listByServiceNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GatewayHostnameConfigurationCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$I
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GatewayApi operations. */
class GatewayApiImpl {
    /**
     * Initialize a new instance of the class GatewayApi class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of the APIs associated with a gateway.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, gatewayId, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, gatewayId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, gatewayId, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, gatewayId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, gatewayId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, gatewayId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, gatewayId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, gatewayId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of the APIs associated with a gateway.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, gatewayId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, options }, listByServiceOperationSpec$m);
    }
    /**
     * Checks that API entity specified by identifier is associated with the Gateway entity.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, gatewayId, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, apiId, options }, getEntityTagOperationSpec$g);
    }
    /**
     * Adds an API to the specified Gateway.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, gatewayId, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, apiId, options }, createOrUpdateOperationSpec$l);
    }
    /**
     * Deletes the specified API from the specified Gateway.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param apiId API identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, gatewayId, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, apiId, options }, deleteOperationSpec$h);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, gatewayId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, nextLink, options }, listByServiceNextOperationSpec$f);
    }
}
// Operation Specifications
const serializer$H = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/apis",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$H
};
const getEntityTagOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/apis/{apiId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: GatewayApiGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$H
};
const createOrUpdateOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/apis/{apiId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApiContract
        },
        201: {
            bodyMapper: ApiContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters34,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        gatewayId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$H
};
const deleteOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/apis/{apiId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId1,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$H
};
const listByServiceNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$H
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GatewayCertificateAuthority operations. */
class GatewayCertificateAuthorityImpl {
    /**
     * Initialize a new instance of the class GatewayCertificateAuthority class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the collection of Certificate Authorities for the specified Gateway entity.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, gatewayId, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, gatewayId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, gatewayId, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, gatewayId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, gatewayId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, gatewayId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, gatewayId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, gatewayId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the collection of Certificate Authorities for the specified Gateway entity.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, gatewayId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, options }, listByServiceOperationSpec$l);
    }
    /**
     * Checks if Certificate entity is assigned to Gateway entity as Certificate Authority.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param certificateId Identifier of the certificate entity. Must be unique in the current API
     *                      Management service instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, gatewayId, certificateId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, certificateId, options }, getEntityTagOperationSpec$f);
    }
    /**
     * Get assigned Gateway Certificate Authority details.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param certificateId Identifier of the certificate entity. Must be unique in the current API
     *                      Management service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, gatewayId, certificateId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, certificateId, options }, getOperationSpec$k);
    }
    /**
     * Assign Certificate entity to Gateway entity as Certificate Authority.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param certificateId Identifier of the certificate entity. Must be unique in the current API
     *                      Management service instance.
     * @param parameters Gateway certificate authority details.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, gatewayId, certificateId, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            gatewayId,
            certificateId,
            parameters,
            options
        }, createOrUpdateOperationSpec$k);
    }
    /**
     * Remove relationship between Certificate Authority and Gateway entity.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param certificateId Identifier of the certificate entity. Must be unique in the current API
     *                      Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, gatewayId, certificateId, ifMatch, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            gatewayId,
            certificateId,
            ifMatch,
            options
        }, deleteOperationSpec$g);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param gatewayId Gateway entity identifier. Must be unique in the current API Management service
     *                  instance. Must not have value 'managed'
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, gatewayId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, gatewayId, nextLink, options }, listByServiceNextOperationSpec$e);
    }
}
// Operation Specifications
const serializer$G = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/certificateAuthorities",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GatewayCertificateAuthorityCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const getEntityTagOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/certificateAuthorities/{certificateId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: GatewayCertificateAuthorityGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        certificateId,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const getOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/certificateAuthorities/{certificateId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GatewayCertificateAuthorityContract,
            headersMapper: GatewayCertificateAuthorityGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        certificateId,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const createOrUpdateOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/certificateAuthorities/{certificateId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GatewayCertificateAuthorityContract,
            headersMapper: GatewayCertificateAuthorityCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: GatewayCertificateAuthorityContract,
            headersMapper: GatewayCertificateAuthorityCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters35,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        certificateId,
        gatewayId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$G
};
const deleteOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/gateways/{gatewayId}/certificateAuthorities/{certificateId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        certificateId,
        gatewayId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$G
};
const listByServiceNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GatewayCertificateAuthorityCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$G
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Group operations. */
class GroupImpl {
    /**
     * Initialize a new instance of the class Group class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of groups defined within a service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of groups defined within a service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$k);
    }
    /**
     * Gets the entity state (Etag) version of the group specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, groupId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, groupId, options }, getEntityTagOperationSpec$e);
    }
    /**
     * Gets the details of the group specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, groupId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, groupId, options }, getOperationSpec$j);
    }
    /**
     * Creates or Updates a group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, groupId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, groupId, parameters, options }, createOrUpdateOperationSpec$j);
    }
    /**
     * Updates the details of the group specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, groupId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, groupId, ifMatch, parameters, options }, updateOperationSpec$e);
    }
    /**
     * Deletes specific group of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, groupId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, groupId, ifMatch, options }, deleteOperationSpec$f);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$d);
    }
}
// Operation Specifications
const serializer$F = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/groups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GroupCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const getEntityTagOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/groups/{groupId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: GroupGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        groupId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const getOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/groups/{groupId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GroupContract,
            headersMapper: GroupGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        groupId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const createOrUpdateOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/groups/{groupId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GroupContract,
            headersMapper: GroupCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: GroupContract,
            headersMapper: GroupCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters36,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        groupId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$F
};
const updateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/groups/{groupId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: GroupContract,
            headersMapper: GroupUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters37,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        groupId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$F
};
const deleteOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/groups/{groupId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        groupId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$F
};
const listByServiceNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GroupCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$F
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GroupUser operations. */
class GroupUserImpl {
    /**
     * Initialize a new instance of the class GroupUser class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of user entities associated with the group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    list(resourceGroupName, serviceName, groupId, options) {
        const iter = this.listPagingAll(resourceGroupName, serviceName, groupId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, serviceName, groupId, options);
            }
        };
    }
    listPagingPage(resourceGroupName, serviceName, groupId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, serviceName, groupId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, serviceName, groupId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, serviceName, groupId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, serviceName, groupId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of user entities associated with the group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _list(resourceGroupName, serviceName, groupId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, groupId, options }, listOperationSpec$6);
    }
    /**
     * Checks that user entity specified by identifier is associated with the group entity.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    checkEntityExists(resourceGroupName, serviceName, groupId, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, groupId, userId, options }, checkEntityExistsOperationSpec$4);
    }
    /**
     * Add existing user to existing group
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    create(resourceGroupName, serviceName, groupId, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, groupId, userId, options }, createOperationSpec$1);
    }
    /**
     * Remove existing user from existing group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, groupId, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, groupId, userId, options }, deleteOperationSpec$e);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, serviceName, groupId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, groupId, nextLink, options }, listNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$E = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/groups/{groupId}/users",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UserCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        groupId
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const checkEntityExistsOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/groups/{groupId}/users/{userId}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        groupId,
        userId
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const createOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/groups/{groupId}/users/{userId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: UserContract
        },
        201: {
            bodyMapper: UserContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        groupId,
        userId
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const deleteOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/groups/{groupId}/users/{userId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        groupId,
        userId
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UserCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        groupId
    ],
    headerParameters: [accept],
    serializer: serializer$E
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IdentityProvider operations. */
class IdentityProviderImpl {
    /**
     * Initialize a new instance of the class IdentityProvider class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of Identity Provider configured in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of Identity Provider configured in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$j);
    }
    /**
     * Gets the entity state (Etag) version of the identityProvider specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param identityProviderName Identity Provider Type identifier.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, identityProviderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, identityProviderName, options }, getEntityTagOperationSpec$d);
    }
    /**
     * Gets the configuration details of the identity Provider configured in specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param identityProviderName Identity Provider Type identifier.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, identityProviderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, identityProviderName, options }, getOperationSpec$i);
    }
    /**
     * Creates or Updates the IdentityProvider configuration.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param identityProviderName Identity Provider Type identifier.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, identityProviderName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            identityProviderName,
            parameters,
            options
        }, createOrUpdateOperationSpec$i);
    }
    /**
     * Updates an existing IdentityProvider configuration.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param identityProviderName Identity Provider Type identifier.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, identityProviderName, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            identityProviderName,
            ifMatch,
            parameters,
            options
        }, updateOperationSpec$d);
    }
    /**
     * Deletes the specified identity provider configuration.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param identityProviderName Identity Provider Type identifier.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, identityProviderName, ifMatch, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            identityProviderName,
            ifMatch,
            options
        }, deleteOperationSpec$d);
    }
    /**
     * Gets the client secret details of the Identity Provider.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param identityProviderName Identity Provider Type identifier.
     * @param options The options parameters.
     */
    listSecrets(resourceGroupName, serviceName, identityProviderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, identityProviderName, options }, listSecretsOperationSpec$4);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$c);
    }
}
// Operation Specifications
const serializer$D = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/identityProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IdentityProviderList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const getEntityTagOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/identityProviders/{identityProviderName}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: IdentityProviderGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        identityProviderName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const getOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/identityProviders/{identityProviderName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IdentityProviderContract,
            headersMapper: IdentityProviderGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        identityProviderName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const createOrUpdateOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/identityProviders/{identityProviderName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IdentityProviderContract,
            headersMapper: IdentityProviderCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: IdentityProviderContract,
            headersMapper: IdentityProviderCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters38,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        identityProviderName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$D
};
const updateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/identityProviders/{identityProviderName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: IdentityProviderContract,
            headersMapper: IdentityProviderUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters39,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        identityProviderName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$D
};
const deleteOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/identityProviders/{identityProviderName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        identityProviderName
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$D
};
const listSecretsOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/identityProviders/{identityProviderName}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ClientSecretContract,
            headersMapper: IdentityProviderListSecretsHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        identityProviderName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const listByServiceNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IdentityProviderList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$D
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Issue operations. */
class IssueImpl {
    /**
     * Initialize a new instance of the class Issue class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of issues in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of issues in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$i);
    }
    /**
     * Gets API Management issue details
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param issueId Issue identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, issueId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, issueId, options }, getOperationSpec$h);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$b);
    }
}
// Operation Specifications
const serializer$C = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/issues",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IssueCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const getOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/issues/{issueId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IssueContract,
            headersMapper: IssueGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        issueId
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const listByServiceNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IssueCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$C
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Logger operations. */
class LoggerImpl {
    /**
     * Initialize a new instance of the class Logger class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of loggers in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of loggers in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$h);
    }
    /**
     * Gets the entity state (Etag) version of the logger specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param loggerId Logger identifier. Must be unique in the API Management service instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, loggerId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, loggerId, options }, getEntityTagOperationSpec$c);
    }
    /**
     * Gets the details of the logger specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param loggerId Logger identifier. Must be unique in the API Management service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, loggerId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, loggerId, options }, getOperationSpec$g);
    }
    /**
     * Creates or Updates a logger.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param loggerId Logger identifier. Must be unique in the API Management service instance.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, loggerId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, loggerId, parameters, options }, createOrUpdateOperationSpec$h);
    }
    /**
     * Updates an existing logger.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param loggerId Logger identifier. Must be unique in the API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, loggerId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            loggerId,
            ifMatch,
            parameters,
            options
        }, updateOperationSpec$c);
    }
    /**
     * Deletes the specified logger.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param loggerId Logger identifier. Must be unique in the API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, loggerId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, loggerId, ifMatch, options }, deleteOperationSpec$c);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$B = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/loggers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoggerCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const getEntityTagOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/loggers/{loggerId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: LoggerGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        loggerId
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const getOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/loggers/{loggerId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoggerContract,
            headersMapper: LoggerGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        loggerId
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const createOrUpdateOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/loggers/{loggerId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LoggerContract,
            headersMapper: LoggerCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: LoggerContract,
            headersMapper: LoggerCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters40,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        loggerId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$B
};
const updateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/loggers/{loggerId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: LoggerContract,
            headersMapper: LoggerUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters41,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        loggerId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$B
};
const deleteOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/loggers/{loggerId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        loggerId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$B
};
const listByServiceNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoggerCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$B
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NamedValue operations. */
class NamedValueImpl {
    /**
     * Initialize a new instance of the class NamedValue class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of named values defined within a service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of named values defined within a service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$g);
    }
    /**
     * Gets the entity state (Etag) version of the named value specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param namedValueId Identifier of the NamedValue.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, namedValueId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, namedValueId, options }, getEntityTagOperationSpec$b);
    }
    /**
     * Gets the details of the named value specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param namedValueId Identifier of the NamedValue.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, namedValueId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, namedValueId, options }, getOperationSpec$f);
    }
    /**
     * Creates or updates named value.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param namedValueId Identifier of the NamedValue.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serviceName, namedValueId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, namedValueId, parameters, options }, createOrUpdateOperationSpec$g);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates named value.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param namedValueId Identifier of the NamedValue.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serviceName, namedValueId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serviceName, namedValueId, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the specific named value.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param namedValueId Identifier of the NamedValue.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, serviceName, namedValueId, ifMatch, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serviceName,
                namedValueId,
                ifMatch,
                parameters,
                options
            }, updateOperationSpec$b);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the specific named value.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param namedValueId Identifier of the NamedValue.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, serviceName, namedValueId, ifMatch, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, serviceName, namedValueId, ifMatch, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes specific named value from the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param namedValueId Identifier of the NamedValue.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, namedValueId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, namedValueId, ifMatch, options }, deleteOperationSpec$b);
    }
    /**
     * Gets the secret of the named value specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param namedValueId Identifier of the NamedValue.
     * @param options The options parameters.
     */
    listValue(resourceGroupName, serviceName, namedValueId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, namedValueId, options }, listValueOperationSpec);
    }
    /**
     * Refresh the secret of the named value specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param namedValueId Identifier of the NamedValue.
     * @param options The options parameters.
     */
    beginRefreshSecret(resourceGroupName, serviceName, namedValueId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, namedValueId, options }, refreshSecretOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Refresh the secret of the named value specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param namedValueId Identifier of the NamedValue.
     * @param options The options parameters.
     */
    beginRefreshSecretAndWait(resourceGroupName, serviceName, namedValueId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRefreshSecret(resourceGroupName, serviceName, namedValueId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$A = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/namedValues",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NamedValueCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        isKeyVaultRefreshFailed
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const getEntityTagOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/namedValues/{namedValueId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: NamedValueGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        namedValueId
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const getOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/namedValues/{namedValueId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NamedValueContract,
            headersMapper: NamedValueGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        namedValueId
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const createOrUpdateOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/namedValues/{namedValueId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NamedValueContract,
            headersMapper: NamedValueCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: NamedValueContract,
            headersMapper: NamedValueCreateOrUpdateHeaders
        },
        202: {
            bodyMapper: NamedValueContract,
            headersMapper: NamedValueCreateOrUpdateHeaders
        },
        204: {
            bodyMapper: NamedValueContract,
            headersMapper: NamedValueCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters42,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        namedValueId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$A
};
const updateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/namedValues/{namedValueId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NamedValueContract,
            headersMapper: NamedValueUpdateHeaders
        },
        201: {
            bodyMapper: NamedValueContract,
            headersMapper: NamedValueUpdateHeaders
        },
        202: {
            bodyMapper: NamedValueContract,
            headersMapper: NamedValueUpdateHeaders
        },
        204: {
            bodyMapper: NamedValueContract,
            headersMapper: NamedValueUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters43,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        namedValueId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$A
};
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/namedValues/{namedValueId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        namedValueId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$A
};
const listValueOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/namedValues/{namedValueId}/listValue",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NamedValueSecretContract,
            headersMapper: NamedValueListValueHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        namedValueId
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const refreshSecretOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/namedValues/{namedValueId}/refreshSecret",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NamedValueContract,
            headersMapper: NamedValueRefreshSecretHeaders
        },
        201: {
            bodyMapper: NamedValueContract,
            headersMapper: NamedValueRefreshSecretHeaders
        },
        202: {
            bodyMapper: NamedValueContract,
            headersMapper: NamedValueRefreshSecretHeaders
        },
        204: {
            bodyMapper: NamedValueContract,
            headersMapper: NamedValueRefreshSecretHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        namedValueId
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listByServiceNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NamedValueCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        isKeyVaultRefreshFailed
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$A
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing NetworkStatus operations. */
class NetworkStatusImpl {
    /**
     * Initialize a new instance of the class NetworkStatus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the Connectivity Status to the external resources on which the Api Management service depends
     * from inside the Cloud Service. This also returns the DNS Servers as visible to the CloudService.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$f);
    }
    /**
     * Gets the Connectivity Status to the external resources on which the Api Management service depends
     * from inside the Cloud Service. This also returns the DNS Servers as visible to the CloudService.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param locationName Location in which the API Management service is deployed. This is one of the
     *                     Azure Regions like West US, East US, South Central US.
     * @param options The options parameters.
     */
    listByLocation(resourceGroupName, serviceName, locationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, locationName, options }, listByLocationOperationSpec);
    }
}
// Operation Specifications
const serializer$z = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/networkstatus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkStatusContractByLocation"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const listByLocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/locations/{locationName}/networkstatus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkStatusContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Notification operations. */
class NotificationImpl {
    /**
     * Initialize a new instance of the class Notification class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of properties defined within a service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of properties defined within a service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$e);
    }
    /**
     * Gets the details of the Notification specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param notificationName Notification Name Identifier.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, notificationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, notificationName, options }, getOperationSpec$e);
    }
    /**
     * Create or Update API Management publisher notification.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param notificationName Notification Name Identifier.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, notificationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, notificationName, options }, createOrUpdateOperationSpec$f);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$y = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/notifications",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NotificationCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [top, skip, apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/notifications/{notificationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NotificationContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        notificationName
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const createOrUpdateOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/notifications/{notificationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NotificationContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        notificationName
    ],
    headerParameters: [accept, ifMatch],
    serializer: serializer$y
};
const listByServiceNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NotificationCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [top, skip, apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing NotificationRecipientUser operations. */
class NotificationRecipientUserImpl {
    /**
     * Initialize a new instance of the class NotificationRecipientUser class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the list of the Notification Recipient User subscribed to the notification.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param notificationName Notification Name Identifier.
     * @param options The options parameters.
     */
    listByNotification(resourceGroupName, serviceName, notificationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, notificationName, options }, listByNotificationOperationSpec$1);
    }
    /**
     * Determine if the Notification Recipient User is subscribed to the notification.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param notificationName Notification Name Identifier.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    checkEntityExists(resourceGroupName, serviceName, notificationName, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, notificationName, userId, options }, checkEntityExistsOperationSpec$3);
    }
    /**
     * Adds the API Management User to the list of Recipients for the Notification.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param notificationName Notification Name Identifier.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, notificationName, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, notificationName, userId, options }, createOrUpdateOperationSpec$e);
    }
    /**
     * Removes the API Management user from the list of Notification.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param notificationName Notification Name Identifier.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, notificationName, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, notificationName, userId, options }, deleteOperationSpec$a);
    }
}
// Operation Specifications
const serializer$x = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByNotificationOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/notifications/{notificationName}/recipientUsers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecipientUserCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        notificationName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const checkEntityExistsOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/notifications/{notificationName}/recipientUsers/{userId}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId,
        notificationName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const createOrUpdateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/notifications/{notificationName}/recipientUsers/{userId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RecipientUserContract
        },
        201: {
            bodyMapper: RecipientUserContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId,
        notificationName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/notifications/{notificationName}/recipientUsers/{userId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId,
        notificationName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing NotificationRecipientEmail operations. */
class NotificationRecipientEmailImpl {
    /**
     * Initialize a new instance of the class NotificationRecipientEmail class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the list of the Notification Recipient Emails subscribed to a notification.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param notificationName Notification Name Identifier.
     * @param options The options parameters.
     */
    listByNotification(resourceGroupName, serviceName, notificationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, notificationName, options }, listByNotificationOperationSpec);
    }
    /**
     * Determine if Notification Recipient Email subscribed to the notification.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param notificationName Notification Name Identifier.
     * @param email Email identifier.
     * @param options The options parameters.
     */
    checkEntityExists(resourceGroupName, serviceName, notificationName, email, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, notificationName, email, options }, checkEntityExistsOperationSpec$2);
    }
    /**
     * Adds the Email address to the list of Recipients for the Notification.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param notificationName Notification Name Identifier.
     * @param email Email identifier.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, notificationName, email, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, notificationName, email, options }, createOrUpdateOperationSpec$d);
    }
    /**
     * Removes the email from the list of Notification.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param notificationName Notification Name Identifier.
     * @param email Email identifier.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, notificationName, email, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, notificationName, email, options }, deleteOperationSpec$9);
    }
}
// Operation Specifications
const serializer$w = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByNotificationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/notifications/{notificationName}/recipientEmails",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecipientEmailCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        notificationName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const checkEntityExistsOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/notifications/{notificationName}/recipientEmails/{email}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        notificationName,
        email
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const createOrUpdateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/notifications/{notificationName}/recipientEmails/{email}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RecipientEmailContract
        },
        201: {
            bodyMapper: RecipientEmailContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        notificationName,
        email
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/notifications/{notificationName}/recipientEmails/{email}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        notificationName,
        email
    ],
    headerParameters: [accept],
    serializer: serializer$w
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing OpenIdConnectProvider operations. */
class OpenIdConnectProviderImpl {
    /**
     * Initialize a new instance of the class OpenIdConnectProvider class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists of all the OpenId Connect Providers.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists of all the OpenId Connect Providers.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$d);
    }
    /**
     * Gets the entity state (Etag) version of the openIdConnectProvider specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param opid Identifier of the OpenID Connect Provider.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, opid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, opid, options }, getEntityTagOperationSpec$a);
    }
    /**
     * Gets specific OpenID Connect Provider without secrets.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param opid Identifier of the OpenID Connect Provider.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, opid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, opid, options }, getOperationSpec$d);
    }
    /**
     * Creates or updates the OpenID Connect Provider.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param opid Identifier of the OpenID Connect Provider.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, opid, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, opid, parameters, options }, createOrUpdateOperationSpec$c);
    }
    /**
     * Updates the specific OpenID Connect Provider.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param opid Identifier of the OpenID Connect Provider.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, opid, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, opid, ifMatch, parameters, options }, updateOperationSpec$a);
    }
    /**
     * Deletes specific OpenID Connect Provider of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param opid Identifier of the OpenID Connect Provider.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, opid, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, opid, ifMatch, options }, deleteOperationSpec$8);
    }
    /**
     * Gets the client secret details of the OpenID Connect Provider.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param opid Identifier of the OpenID Connect Provider.
     * @param options The options parameters.
     */
    listSecrets(resourceGroupName, serviceName, opid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, opid, options }, listSecretsOperationSpec$3);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$v = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/openidConnectProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OpenIdConnectProviderCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const getEntityTagOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/openidConnectProviders/{opid}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: OpenIdConnectProviderGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        opid
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/openidConnectProviders/{opid}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OpenidConnectProviderContract,
            headersMapper: OpenIdConnectProviderGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        opid
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const createOrUpdateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/openidConnectProviders/{opid}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: OpenidConnectProviderContract,
            headersMapper: OpenIdConnectProviderCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: OpenidConnectProviderContract,
            headersMapper: OpenIdConnectProviderCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters44,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        opid
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$v
};
const updateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/openidConnectProviders/{opid}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: OpenidConnectProviderContract,
            headersMapper: OpenIdConnectProviderUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters45,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        opid
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$v
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/openidConnectProviders/{opid}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        opid
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$v
};
const listSecretsOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/openidConnectProviders/{opid}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ClientSecretContract,
            headersMapper: OpenIdConnectProviderListSecretsHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        opid
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const listByServiceNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OpenIdConnectProviderCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$v
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing OutboundNetworkDependenciesEndpoints operations. */
class OutboundNetworkDependenciesEndpointsImpl {
    /**
     * Initialize a new instance of the class OutboundNetworkDependenciesEndpoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the network endpoints of all outbound dependencies of a ApiManagement service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$c);
    }
}
// Operation Specifications
const serializer$u = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/outboundNetworkDependenciesEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundEnvironmentEndpointList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$u
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Policy operations. */
class PolicyImpl {
    /**
     * Initialize a new instance of the class Policy class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the Global Policy definitions of the Api Management service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$b);
    }
    /**
     * Gets the entity state (Etag) version of the Global policy definition in the Api Management service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param policyId The identifier of the Policy.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, policyId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, policyId, options }, getEntityTagOperationSpec$9);
    }
    /**
     * Get the Global policy definition of the Api Management service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param policyId The identifier of the Policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, policyId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, policyId, options }, getOperationSpec$c);
    }
    /**
     * Creates or updates the global policy configuration of the Api Management service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param policyId The identifier of the Policy.
     * @param parameters The policy contents to apply.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, policyId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, policyId, parameters, options }, createOrUpdateOperationSpec$b);
    }
    /**
     * Deletes the global policy configuration of the Api Management Service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param policyId The identifier of the Policy.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, policyId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, policyId, ifMatch, options }, deleteOperationSpec$7);
    }
}
// Operation Specifications
const serializer$t = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/policies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const getEntityTagOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/policies/{policyId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: PolicyGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        policyId
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/policies/{policyId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyContract,
            headersMapper: PolicyGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, format],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        policyId
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const createOrUpdateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/policies/{policyId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PolicyContract,
            headersMapper: PolicyCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: PolicyContract,
            headersMapper: PolicyCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        policyId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$t
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/policies/{policyId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        policyId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$t
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PolicyDescription operations. */
class PolicyDescriptionImpl {
    /**
     * Initialize a new instance of the class PolicyDescription class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all policy descriptions.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$a);
    }
}
// Operation Specifications
const serializer$s = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/policyDescriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyDescriptionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, scope1],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$s
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PortalRevision operations. */
class PortalRevisionImpl {
    /**
     * Initialize a new instance of the class PortalRevision class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists developer portal's revisions.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists developer portal's revisions.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$9);
    }
    /**
     * Gets the developer portal revision specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param portalRevisionId Portal revision identifier. Must be unique in the current API Management
     *                         service instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, portalRevisionId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, portalRevisionId, options }, getEntityTagOperationSpec$8);
    }
    /**
     * Gets the developer portal's revision specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param portalRevisionId Portal revision identifier. Must be unique in the current API Management
     *                         service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, portalRevisionId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, portalRevisionId, options }, getOperationSpec$b);
    }
    /**
     * Creates a new developer portal's revision by running the portal's publishing. The `isCurrent`
     * property indicates if the revision is publicly accessible.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param portalRevisionId Portal revision identifier. Must be unique in the current API Management
     *                         service instance.
     * @param parameters Portal Revision's contract details.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serviceName, portalRevisionId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, portalRevisionId, parameters, options }, createOrUpdateOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new developer portal's revision by running the portal's publishing. The `isCurrent`
     * property indicates if the revision is publicly accessible.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param portalRevisionId Portal revision identifier. Must be unique in the current API Management
     *                         service instance.
     * @param parameters Portal Revision's contract details.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serviceName, portalRevisionId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serviceName, portalRevisionId, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the description of specified portal revision or makes it current.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param portalRevisionId Portal revision identifier. Must be unique in the current API Management
     *                         service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Portal Revision's contract details.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, serviceName, portalRevisionId, ifMatch, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serviceName,
                portalRevisionId,
                ifMatch,
                parameters,
                options
            }, updateOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the description of specified portal revision or makes it current.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param portalRevisionId Portal revision identifier. Must be unique in the current API Management
     *                         service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Portal Revision's contract details.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, serviceName, portalRevisionId, ifMatch, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, serviceName, portalRevisionId, ifMatch, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$r = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalRevisions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PortalRevisionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const getEntityTagOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalRevisions/{portalRevisionId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: PortalRevisionGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        portalRevisionId
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalRevisions/{portalRevisionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PortalRevisionContract,
            headersMapper: PortalRevisionGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        portalRevisionId
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalRevisions/{portalRevisionId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PortalRevisionContract,
            headersMapper: PortalRevisionCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: PortalRevisionContract,
            headersMapper: PortalRevisionCreateOrUpdateHeaders
        },
        202: {
            bodyMapper: PortalRevisionContract,
            headersMapper: PortalRevisionCreateOrUpdateHeaders
        },
        204: {
            bodyMapper: PortalRevisionContract,
            headersMapper: PortalRevisionCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters46,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        portalRevisionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r
};
const updateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalRevisions/{portalRevisionId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PortalRevisionContract,
            headersMapper: PortalRevisionUpdateHeaders
        },
        201: {
            bodyMapper: PortalRevisionContract,
            headersMapper: PortalRevisionUpdateHeaders
        },
        202: {
            bodyMapper: PortalRevisionContract,
            headersMapper: PortalRevisionUpdateHeaders
        },
        204: {
            bodyMapper: PortalRevisionContract,
            headersMapper: PortalRevisionUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters46,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        portalRevisionId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$r
};
const listByServiceNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PortalRevisionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$r
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PortalSettings operations. */
class PortalSettingsImpl {
    /**
     * Initialize a new instance of the class PortalSettings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of portalsettings defined within a service instance..
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$8);
    }
}
// Operation Specifications
const serializer$q = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PortalSettingsCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SignInSettings operations. */
class SignInSettingsImpl {
    /**
     * Initialize a new instance of the class SignInSettings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the entity state (Etag) version of the SignInSettings.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, getEntityTagOperationSpec$7);
    }
    /**
     * Get Sign In Settings for the Portal
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, getOperationSpec$a);
    }
    /**
     * Update Sign-In settings.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update Sign-In settings.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, ifMatch, parameters, options }, updateOperationSpec$8);
    }
    /**
     * Create or Update Sign-In settings.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param parameters Create or update parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, parameters, options }, createOrUpdateOperationSpec$9);
    }
}
// Operation Specifications
const serializer$p = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getEntityTagOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings/signin",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: SignInSettingsGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings/signin",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PortalSigninSettings,
            headersMapper: SignInSettingsGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const updateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings/signin",
    httpMethod: "PATCH",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters47,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$p
};
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings/signin",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PortalSigninSettings
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters47,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SignUpSettings operations. */
class SignUpSettingsImpl {
    /**
     * Initialize a new instance of the class SignUpSettings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the entity state (Etag) version of the SignUpSettings.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, getEntityTagOperationSpec$6);
    }
    /**
     * Get Sign Up Settings for the Portal
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, getOperationSpec$9);
    }
    /**
     * Update Sign-Up settings.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update Sign-Up settings.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, ifMatch, parameters, options }, updateOperationSpec$7);
    }
    /**
     * Create or Update Sign-Up settings.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param parameters Create or update parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, parameters, options }, createOrUpdateOperationSpec$8);
    }
}
// Operation Specifications
const serializer$o = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getEntityTagOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings/signup",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: SignUpSettingsGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings/signup",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PortalSignupSettings,
            headersMapper: SignUpSettingsGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const updateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings/signup",
    httpMethod: "PATCH",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters48,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$o
};
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings/signup",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PortalSignupSettings
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters48,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing DelegationSettings operations. */
class DelegationSettingsImpl {
    /**
     * Initialize a new instance of the class DelegationSettings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the entity state (Etag) version of the DelegationSettings.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, getEntityTagOperationSpec$5);
    }
    /**
     * Get Delegation Settings for the Portal.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, getOperationSpec$8);
    }
    /**
     * Update Delegation settings.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update Delegation settings.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, ifMatch, parameters, options }, updateOperationSpec$6);
    }
    /**
     * Create or Update Delegation settings.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param parameters Create or update parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, parameters, options }, createOrUpdateOperationSpec$7);
    }
    /**
     * Gets the secret validation key of the DelegationSettings.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listSecrets(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listSecretsOperationSpec$2);
    }
}
// Operation Specifications
const serializer$n = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getEntityTagOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings/delegation",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: DelegationSettingsGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings/delegation",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PortalDelegationSettings,
            headersMapper: DelegationSettingsGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings/delegation",
    httpMethod: "PATCH",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters49,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$n
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings/delegation",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PortalDelegationSettings
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters49,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$n
};
const listSecretsOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/portalsettings/delegation/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PortalSettingValidationKeyContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnectionOperations operations. */
class PrivateEndpointConnectionOperationsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnectionOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all private endpoint connections of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all private endpoint connections of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$7);
    }
    /**
     * Gets the details of the Private Endpoint Connection specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param options The options parameters.
     */
    getByName(resourceGroupName, serviceName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            privateEndpointConnectionName,
            options
        }, getByNameOperationSpec);
    }
    /**
     * Creates a new Private Endpoint Connection or updates an existing one.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param privateEndpointConnectionRequest A request to approve or reject a private endpoint connection
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serviceName, privateEndpointConnectionName, privateEndpointConnectionRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serviceName,
                privateEndpointConnectionName,
                privateEndpointConnectionRequest,
                options
            }, createOrUpdateOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new Private Endpoint Connection or updates an existing one.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param privateEndpointConnectionRequest A request to approve or reject a private endpoint connection
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serviceName, privateEndpointConnectionName, privateEndpointConnectionRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serviceName, privateEndpointConnectionName, privateEndpointConnectionRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the specified Private Endpoint Connection.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serviceName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serviceName,
                privateEndpointConnectionName,
                options
            }, deleteOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified Private Endpoint Connection.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serviceName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serviceName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Gets the private link resources
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listPrivateLinkResources(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listPrivateLinkResourcesOperationSpec);
    }
    /**
     * Description for Gets the private link resources
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param privateLinkSubResourceName Name of the private link resource.
     * @param options The options parameters.
     */
    getPrivateLinkResource(resourceGroupName, serviceName, privateLinkSubResourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, privateLinkSubResourceName, options }, getPrivateLinkResourceOperationSpec);
    }
}
// Operation Specifications
const serializer$m = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getByNameOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        201: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: privateEndpointConnectionRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listPrivateLinkResourcesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getPrivateLinkResourceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/privateLinkResources/{privateLinkSubResourceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        privateLinkSubResourceName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Product operations. */
class ProductImpl {
    /**
     * Initialize a new instance of the class Product class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of products in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of products associated with tags.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByTags(resourceGroupName, serviceName, options) {
        const iter = this.listByTagsPagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByTagsPagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByTagsPagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTagsPagingPage_1() {
            let result = yield tslib.__await(this._listByTags(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByTagsNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByTagsPagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTagsPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByTagsPagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists a collection of products in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$6);
    }
    /**
     * Gets the entity state (Etag) version of the product specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, productId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, options }, getEntityTagOperationSpec$4);
    }
    /**
     * Gets the details of the product specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, productId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, options }, getOperationSpec$7);
    }
    /**
     * Creates or Updates a product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param parameters Create or update parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, productId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, parameters, options }, createOrUpdateOperationSpec$5);
    }
    /**
     * Update existing product details.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, productId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            productId,
            ifMatch,
            parameters,
            options
        }, updateOperationSpec$5);
    }
    /**
     * Delete product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, productId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, ifMatch, options }, deleteOperationSpec$5);
    }
    /**
     * Lists a collection of products associated with tags.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByTags(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByTagsOperationSpec);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$5);
    }
    /**
     * ListByTagsNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByTags method.
     * @param options The options parameters.
     */
    _listByTagsNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByTagsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$l = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProductCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        tags,
        apiVersion,
        expandGroups
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const getEntityTagOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ProductGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProductContract,
            headersMapper: ProductGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ProductContract,
            headersMapper: ProductCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: ProductContract,
            headersMapper: ProductCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters50,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        productId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$l
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ProductContract,
            headersMapper: ProductUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters51,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        productId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$l
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, deleteSubscriptions],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        productId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$l
};
const listByTagsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/productsByTags",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagResourceCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        includeNotTaggedProducts
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listByServiceNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProductCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        tags,
        apiVersion,
        expandGroups
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listByTagsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagResourceCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        includeNotTaggedProducts
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ProductApi operations. */
class ProductApiImpl {
    /**
     * Initialize a new instance of the class ProductApi class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of the APIs associated with a product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    listByProduct(resourceGroupName, serviceName, productId, options) {
        const iter = this.listByProductPagingAll(resourceGroupName, serviceName, productId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByProductPagingPage(resourceGroupName, serviceName, productId, options);
            }
        };
    }
    listByProductPagingPage(resourceGroupName, serviceName, productId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProductPagingPage_1() {
            let result = yield tslib.__await(this._listByProduct(resourceGroupName, serviceName, productId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByProductNext(resourceGroupName, serviceName, productId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByProductPagingAll(resourceGroupName, serviceName, productId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProductPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByProductPagingPage(resourceGroupName, serviceName, productId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of the APIs associated with a product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _listByProduct(resourceGroupName, serviceName, productId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, options }, listByProductOperationSpec$3);
    }
    /**
     * Checks that API entity specified by identifier is associated with the Product entity.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    checkEntityExists(resourceGroupName, serviceName, productId, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, apiId, options }, checkEntityExistsOperationSpec$1);
    }
    /**
     * Adds an API to the specified product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, productId, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, apiId, options }, createOrUpdateOperationSpec$4);
    }
    /**
     * Deletes the specified API from the specified product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param apiId API revision identifier. Must be unique in the current API Management service instance.
     *              Non-current revision has ;rev=n as a suffix where n is the revision number.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, productId, apiId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, apiId, options }, deleteOperationSpec$4);
    }
    /**
     * ListByProductNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the ListByProduct method.
     * @param options The options parameters.
     */
    _listByProductNext(resourceGroupName, serviceName, productId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, nextLink, options }, listByProductNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByProductOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/apis",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const checkEntityExistsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/apis/{apiId}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/apis/{apiId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApiContract
        },
        201: {
            bodyMapper: ApiContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/apis/{apiId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        apiId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listByProductNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ProductGroup operations. */
class ProductGroupImpl {
    /**
     * Initialize a new instance of the class ProductGroup class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the collection of developer groups associated with the specified product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    listByProduct(resourceGroupName, serviceName, productId, options) {
        const iter = this.listByProductPagingAll(resourceGroupName, serviceName, productId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByProductPagingPage(resourceGroupName, serviceName, productId, options);
            }
        };
    }
    listByProductPagingPage(resourceGroupName, serviceName, productId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProductPagingPage_1() {
            let result = yield tslib.__await(this._listByProduct(resourceGroupName, serviceName, productId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByProductNext(resourceGroupName, serviceName, productId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByProductPagingAll(resourceGroupName, serviceName, productId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProductPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByProductPagingPage(resourceGroupName, serviceName, productId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the collection of developer groups associated with the specified product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _listByProduct(resourceGroupName, serviceName, productId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, options }, listByProductOperationSpec$2);
    }
    /**
     * Checks that Group entity specified by identifier is associated with the Product entity.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    checkEntityExists(resourceGroupName, serviceName, productId, groupId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, groupId, options }, checkEntityExistsOperationSpec);
    }
    /**
     * Adds the association between the specified developer group with the specified product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, productId, groupId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, groupId, options }, createOrUpdateOperationSpec$3);
    }
    /**
     * Deletes the association between the specified group and product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param groupId Group identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, productId, groupId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, groupId, options }, deleteOperationSpec$3);
    }
    /**
     * ListByProductNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the ListByProduct method.
     * @param options The options parameters.
     */
    _listByProductNext(resourceGroupName, serviceName, productId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, nextLink, options }, listByProductNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByProductOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/groups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GroupCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const checkEntityExistsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/groups/{groupId}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        productId,
        groupId
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/groups/{groupId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GroupContract
        },
        201: {
            bodyMapper: GroupContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        productId,
        groupId
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/groups/{groupId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        productId,
        groupId
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listByProductNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GroupCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ProductSubscriptions operations. */
class ProductSubscriptionsImpl {
    /**
     * Initialize a new instance of the class ProductSubscriptions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the collection of subscriptions to the specified product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    list(resourceGroupName, serviceName, productId, options) {
        const iter = this.listPagingAll(resourceGroupName, serviceName, productId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, serviceName, productId, options);
            }
        };
    }
    listPagingPage(resourceGroupName, serviceName, productId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, serviceName, productId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, serviceName, productId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, serviceName, productId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, serviceName, productId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the collection of subscriptions to the specified product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _list(resourceGroupName, serviceName, productId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, options }, listOperationSpec$5);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, serviceName, productId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/subscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ProductPolicy operations. */
class ProductPolicyImpl {
    /**
     * Initialize a new instance of the class ProductPolicy class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the policy configuration at the Product level.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    listByProduct(resourceGroupName, serviceName, productId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, options }, listByProductOperationSpec$1);
    }
    /**
     * Get the ETag of the policy configuration at the Product level.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param policyId The identifier of the Policy.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, productId, policyId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, policyId, options }, getEntityTagOperationSpec$3);
    }
    /**
     * Get the policy configuration at the Product level.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param policyId The identifier of the Policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, productId, policyId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, policyId, options }, getOperationSpec$6);
    }
    /**
     * Creates or updates policy configuration for the Product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param policyId The identifier of the Policy.
     * @param parameters The policy contents to apply.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, productId, policyId, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            productId,
            policyId,
            parameters,
            options
        }, createOrUpdateOperationSpec$2);
    }
    /**
     * Deletes the policy configuration at the Product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param productId Product identifier. Must be unique in the current API Management service instance.
     * @param policyId The identifier of the Policy.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, productId, policyId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, productId, policyId, ifMatch, options }, deleteOperationSpec$2);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByProductOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/policies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getEntityTagOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/policies/{policyId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ProductPolicyGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        policyId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/policies/{policyId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyContract,
            headersMapper: ProductPolicyGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, format],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        policyId,
        productId
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/policies/{policyId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PolicyContract,
            headersMapper: ProductPolicyCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: PolicyContract,
            headersMapper: ProductPolicyCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        policyId,
        productId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$h
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/products/{productId}/policies/{policyId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        policyId,
        productId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing QuotaByCounterKeys operations. */
class QuotaByCounterKeysImpl {
    /**
     * Initialize a new instance of the class QuotaByCounterKeys class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of current quota counter periods associated with the counter-key configured in
     * the policy on the specified service instance. The api does not support paging yet.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param quotaCounterKey Quota counter key identifier.This is the result of expression defined in
     *                        counter-key attribute of the quota-by-key policy.For Example, if you specify counter-key="boo" in
     *                        the policy, then it’s accessible by "boo" counter key. But if it’s defined as
     *                        counter-key="@("b"+"a")" then it will be accessible by "ba" key
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, quotaCounterKey, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, quotaCounterKey, options }, listByServiceOperationSpec$5);
    }
    /**
     * Updates all the quota counter values specified with the existing quota counter key to a value in the
     * specified service instance. This should be used for reset of the quota counter values.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param quotaCounterKey Quota counter key identifier.This is the result of expression defined in
     *                        counter-key attribute of the quota-by-key policy.For Example, if you specify counter-key="boo" in
     *                        the policy, then it’s accessible by "boo" counter key. But if it’s defined as
     *                        counter-key="@("b"+"a")" then it will be accessible by "ba" key
     * @param parameters The value of the quota counter to be applied to all quota counter periods.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, quotaCounterKey, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, quotaCounterKey, parameters, options }, updateOperationSpec$4);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/quotas/{quotaCounterKey}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: QuotaCounterCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        quotaCounterKey
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/quotas/{quotaCounterKey}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: QuotaCounterCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters52,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        quotaCounterKey
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing QuotaByPeriodKeys operations. */
class QuotaByPeriodKeysImpl {
    /**
     * Initialize a new instance of the class QuotaByPeriodKeys class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the value of the quota counter associated with the counter-key in the policy for the specific
     * period in service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param quotaCounterKey Quota counter key identifier.This is the result of expression defined in
     *                        counter-key attribute of the quota-by-key policy.For Example, if you specify counter-key="boo" in
     *                        the policy, then it’s accessible by "boo" counter key. But if it’s defined as
     *                        counter-key="@("b"+"a")" then it will be accessible by "ba" key
     * @param quotaPeriodKey Quota period key identifier.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, quotaCounterKey, quotaPeriodKey, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            quotaCounterKey,
            quotaPeriodKey,
            options
        }, getOperationSpec$5);
    }
    /**
     * Updates an existing quota counter value in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param quotaCounterKey Quota counter key identifier.This is the result of expression defined in
     *                        counter-key attribute of the quota-by-key policy.For Example, if you specify counter-key="boo" in
     *                        the policy, then it’s accessible by "boo" counter key. But if it’s defined as
     *                        counter-key="@("b"+"a")" then it will be accessible by "ba" key
     * @param quotaPeriodKey Quota period key identifier.
     * @param parameters The value of the Quota counter to be applied on the specified period.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, quotaCounterKey, quotaPeriodKey, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            quotaCounterKey,
            quotaPeriodKey,
            parameters,
            options
        }, updateOperationSpec$3);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/quotas/{quotaCounterKey}/periods/{quotaPeriodKey}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: QuotaCounterContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        quotaCounterKey,
        quotaPeriodKey
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/quotas/{quotaCounterKey}/periods/{quotaPeriodKey}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: QuotaCounterContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters52,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        quotaCounterKey,
        quotaPeriodKey
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Region operations. */
class RegionImpl {
    /**
     * Initialize a new instance of the class Region class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all azure regions in which the service exists.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all azure regions in which the service exists.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$4);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/regions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listByServiceNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Reports operations. */
class ReportsImpl {
    /**
     * Initialize a new instance of the class Reports class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists report records by API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter The filter to apply on the operation.
     * @param options The options parameters.
     */
    listByApi(resourceGroupName, serviceName, filter, options) {
        const iter = this.listByApiPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByApiPagingPage(resourceGroupName, serviceName, filter, options);
            }
        };
    }
    listByApiPagingPage(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByApiPagingPage_1() {
            let result = yield tslib.__await(this._listByApi(resourceGroupName, serviceName, filter, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByApiNext(resourceGroupName, serviceName, filter, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByApiPagingAll(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByApiPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByApiPagingPage(resourceGroupName, serviceName, filter, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists report records by User.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| userId | select, filter | eq |
     *               | </br>| apiRegion | filter | eq |     | </br>| productId | filter | eq |     | </br>|
     *               subscriptionId | filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | filter
     *               | eq |     | </br>| callCountSuccess | select, orderBy |     |     | </br>| callCountBlocked |
     *               select, orderBy |     |     | </br>| callCountFailed | select, orderBy |     |     | </br>|
     *               callCountOther | select, orderBy |     |     | </br>| callCountTotal | select, orderBy |     |     |
     *               </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>|
     *               cacheMissCount | select |     |     | </br>| apiTimeAvg | select, orderBy |     |     | </br>|
     *               apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg |
     *               select |     |     | </br>| serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |
     *                 |     | </br>
     * @param options The options parameters.
     */
    listByUser(resourceGroupName, serviceName, filter, options) {
        const iter = this.listByUserPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByUserPagingPage(resourceGroupName, serviceName, filter, options);
            }
        };
    }
    listByUserPagingPage(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByUserPagingPage_1() {
            let result = yield tslib.__await(this._listByUser(resourceGroupName, serviceName, filter, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByUserNext(resourceGroupName, serviceName, filter, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByUserPagingAll(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByUserPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByUserPagingPage(resourceGroupName, serviceName, filter, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists report records by API Operations.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | filter | eq |     | </br>| subscriptionId |
     *               filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | select, filter | eq |
     *                | </br>| callCountSuccess | select, orderBy |     |     | </br>| callCountBlocked | select, orderBy
     *               |     |     | </br>| callCountFailed | select, orderBy |     |     | </br>| callCountOther | select,
     *               orderBy |     |     | </br>| callCountTotal | select, orderBy |     |     | </br>| bandwidth |
     *               select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>| cacheMissCount |
     *               select |     |     | </br>| apiTimeAvg | select, orderBy |     |     | </br>| apiTimeMin | select |
     *                  |     | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg | select |     |     |
     *               </br>| serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    listByOperation(resourceGroupName, serviceName, filter, options) {
        const iter = this.listByOperationPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByOperationPagingPage(resourceGroupName, serviceName, filter, options);
            }
        };
    }
    listByOperationPagingPage(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByOperationPagingPage_1() {
            let result = yield tslib.__await(this._listByOperation(resourceGroupName, serviceName, filter, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByOperationNext(resourceGroupName, serviceName, filter, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByOperationPagingAll(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByOperationPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByOperationPagingPage(resourceGroupName, serviceName, filter, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Lists report records by Product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | select, filter | eq |     | </br>|
     *               subscriptionId | filter | eq |     | </br>| callCountSuccess | select, orderBy |     |     | </br>|
     *               callCountBlocked | select, orderBy |     |     | </br>| callCountFailed | select, orderBy |     |
     *                | </br>| callCountOther | select, orderBy |     |     | </br>| callCountTotal | select, orderBy |
     *                 |     | </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount | select |     |
     *                | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg | select, orderBy |     |     |
     *               </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |     | </br>|
     *               serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    listByProduct(resourceGroupName, serviceName, filter, options) {
        const iter = this.listByProductPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByProductPagingPage(resourceGroupName, serviceName, filter, options);
            }
        };
    }
    listByProductPagingPage(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProductPagingPage_1() {
            let result = yield tslib.__await(this._listByProduct(resourceGroupName, serviceName, filter, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByProductNext(resourceGroupName, serviceName, filter, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByProductPagingAll(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProductPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByProductPagingPage(resourceGroupName, serviceName, filter, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Lists report records by geography.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| country | select |     |     | </br>| region | select |     |     | </br>| zip |
     *               select |     |     | </br>| apiRegion | filter | eq |     | </br>| userId | filter | eq |     |
     *               </br>| productId | filter | eq |     | </br>| subscriptionId | filter | eq |     | </br>| apiId |
     *               filter | eq |     | </br>| operationId | filter | eq |     | </br>| callCountSuccess | select |
     *               |     | </br>| callCountBlocked | select |     |     | </br>| callCountFailed | select |     |     |
     *               </br>| callCountOther | select |     |     | </br>| bandwidth | select, orderBy |     |     | </br>|
     *               cacheHitsCount | select |     |     | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg
     *               | select |     |     | </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |
     *                 | </br>| serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    listByGeo(resourceGroupName, serviceName, filter, options) {
        const iter = this.listByGeoPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByGeoPagingPage(resourceGroupName, serviceName, filter, options);
            }
        };
    }
    listByGeoPagingPage(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByGeoPagingPage_1() {
            let result = yield tslib.__await(this._listByGeo(resourceGroupName, serviceName, filter, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByGeoNext(resourceGroupName, serviceName, filter, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByGeoPagingAll(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByGeoPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByGeoPagingPage(resourceGroupName, serviceName, filter, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Lists report records by subscription.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | select, filter | eq |     | </br>| productId | select, filter | eq |     | </br>|
     *               subscriptionId | select, filter | eq |     | </br>| callCountSuccess | select, orderBy |     |     |
     *               </br>| callCountBlocked | select, orderBy |     |     | </br>| callCountFailed | select, orderBy |
     *                 |     | </br>| callCountOther | select, orderBy |     |     | </br>| callCountTotal | select,
     *               orderBy |     |     | </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount |
     *               select |     |     | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg | select,
     *               orderBy |     |     | </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |
     *                | </br>| serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    listBySubscription(resourceGroupName, serviceName, filter, options) {
        const iter = this.listBySubscriptionPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(resourceGroupName, serviceName, filter, options);
            }
        };
    }
    listBySubscriptionPagingPage(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(resourceGroupName, serviceName, filter, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(resourceGroupName, serviceName, filter, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(resourceGroupName, serviceName, filter, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Lists report records by Time.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter, select
     *               | ge, le |     | </br>| interval | select |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | filter | eq |     | </br>| subscriptionId |
     *               filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | filter | eq |     |
     *               </br>| callCountSuccess | select |     |     | </br>| callCountBlocked | select |     |     | </br>|
     *               callCountFailed | select |     |     | </br>| callCountOther | select |     |     | </br>| bandwidth
     *               | select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>| cacheMissCount |
     *               select |     |     | </br>| apiTimeAvg | select |     |     | </br>| apiTimeMin | select |     |
     *               | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg | select |     |     | </br>|
     *               serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |     |     | </br>
     * @param interval By time interval. Interval must be multiple of 15 minutes and may not be zero. The
     *                 value should be in ISO  8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).This code can
     *                 be used to convert TimeSpan to a valid interval string: XmlConvert.ToString(new TimeSpan(hours,
     *                 minutes, seconds)).
     * @param options The options parameters.
     */
    listByTime(resourceGroupName, serviceName, filter, interval, options) {
        const iter = this.listByTimePagingAll(resourceGroupName, serviceName, filter, interval, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByTimePagingPage(resourceGroupName, serviceName, filter, interval, options);
            }
        };
    }
    listByTimePagingPage(resourceGroupName, serviceName, filter, interval, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTimePagingPage_1() {
            let result = yield tslib.__await(this._listByTime(resourceGroupName, serviceName, filter, interval, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByTimeNext(resourceGroupName, serviceName, filter, interval, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByTimePagingAll(resourceGroupName, serviceName, filter, interval, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTimePagingAll_1() {
            var e_7, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByTimePagingPage(resourceGroupName, serviceName, filter, interval, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Lists report records by Request.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| apiId | filter | eq |     | </br>| operationId | filter | eq |     | </br>| productId
     *               | filter | eq |     | </br>| userId | filter | eq |     | </br>| apiRegion | filter | eq |     |
     *               </br>| subscriptionId | filter | eq |     | </br>
     * @param options The options parameters.
     */
    listByRequest(resourceGroupName, serviceName, filter, options) {
        const iter = this.listByRequestPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByRequestPagingPage(resourceGroupName, serviceName, filter, options);
            }
        };
    }
    listByRequestPagingPage(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByRequestPagingPage_1() {
            let result = yield tslib.__await(this._listByRequest(resourceGroupName, serviceName, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByRequestPagingAll(resourceGroupName, serviceName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByRequestPagingAll_1() {
            var e_8, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByRequestPagingPage(resourceGroupName, serviceName, filter, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * Lists report records by API.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter The filter to apply on the operation.
     * @param options The options parameters.
     */
    _listByApi(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listByApiOperationSpec);
    }
    /**
     * Lists report records by User.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| userId | select, filter | eq |
     *               | </br>| apiRegion | filter | eq |     | </br>| productId | filter | eq |     | </br>|
     *               subscriptionId | filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | filter
     *               | eq |     | </br>| callCountSuccess | select, orderBy |     |     | </br>| callCountBlocked |
     *               select, orderBy |     |     | </br>| callCountFailed | select, orderBy |     |     | </br>|
     *               callCountOther | select, orderBy |     |     | </br>| callCountTotal | select, orderBy |     |     |
     *               </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>|
     *               cacheMissCount | select |     |     | </br>| apiTimeAvg | select, orderBy |     |     | </br>|
     *               apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg |
     *               select |     |     | </br>| serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |
     *                 |     | </br>
     * @param options The options parameters.
     */
    _listByUser(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listByUserOperationSpec);
    }
    /**
     * Lists report records by API Operations.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | filter | eq |     | </br>| subscriptionId |
     *               filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | select, filter | eq |
     *                | </br>| callCountSuccess | select, orderBy |     |     | </br>| callCountBlocked | select, orderBy
     *               |     |     | </br>| callCountFailed | select, orderBy |     |     | </br>| callCountOther | select,
     *               orderBy |     |     | </br>| callCountTotal | select, orderBy |     |     | </br>| bandwidth |
     *               select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>| cacheMissCount |
     *               select |     |     | </br>| apiTimeAvg | select, orderBy |     |     | </br>| apiTimeMin | select |
     *                  |     | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg | select |     |     |
     *               </br>| serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    _listByOperation(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listByOperationOperationSpec);
    }
    /**
     * Lists report records by Product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | select, filter | eq |     | </br>|
     *               subscriptionId | filter | eq |     | </br>| callCountSuccess | select, orderBy |     |     | </br>|
     *               callCountBlocked | select, orderBy |     |     | </br>| callCountFailed | select, orderBy |     |
     *                | </br>| callCountOther | select, orderBy |     |     | </br>| callCountTotal | select, orderBy |
     *                 |     | </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount | select |     |
     *                | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg | select, orderBy |     |     |
     *               </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |     | </br>|
     *               serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    _listByProduct(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listByProductOperationSpec);
    }
    /**
     * Lists report records by geography.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| country | select |     |     | </br>| region | select |     |     | </br>| zip |
     *               select |     |     | </br>| apiRegion | filter | eq |     | </br>| userId | filter | eq |     |
     *               </br>| productId | filter | eq |     | </br>| subscriptionId | filter | eq |     | </br>| apiId |
     *               filter | eq |     | </br>| operationId | filter | eq |     | </br>| callCountSuccess | select |
     *               |     | </br>| callCountBlocked | select |     |     | </br>| callCountFailed | select |     |     |
     *               </br>| callCountOther | select |     |     | </br>| bandwidth | select, orderBy |     |     | </br>|
     *               cacheHitsCount | select |     |     | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg
     *               | select |     |     | </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |
     *                 | </br>| serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    _listByGeo(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listByGeoOperationSpec);
    }
    /**
     * Lists report records by subscription.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | select, filter | eq |     | </br>| productId | select, filter | eq |     | </br>|
     *               subscriptionId | select, filter | eq |     | </br>| callCountSuccess | select, orderBy |     |     |
     *               </br>| callCountBlocked | select, orderBy |     |     | </br>| callCountFailed | select, orderBy |
     *                 |     | </br>| callCountOther | select, orderBy |     |     | </br>| callCountTotal | select,
     *               orderBy |     |     | </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount |
     *               select |     |     | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg | select,
     *               orderBy |     |     | </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |
     *                | </br>| serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    _listBySubscription(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listBySubscriptionOperationSpec);
    }
    /**
     * Lists report records by Time.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter, select
     *               | ge, le |     | </br>| interval | select |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | filter | eq |     | </br>| subscriptionId |
     *               filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | filter | eq |     |
     *               </br>| callCountSuccess | select |     |     | </br>| callCountBlocked | select |     |     | </br>|
     *               callCountFailed | select |     |     | </br>| callCountOther | select |     |     | </br>| bandwidth
     *               | select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>| cacheMissCount |
     *               select |     |     | </br>| apiTimeAvg | select |     |     | </br>| apiTimeMin | select |     |
     *               | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg | select |     |     | </br>|
     *               serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |     |     | </br>
     * @param interval By time interval. Interval must be multiple of 15 minutes and may not be zero. The
     *                 value should be in ISO  8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).This code can
     *                 be used to convert TimeSpan to a valid interval string: XmlConvert.ToString(new TimeSpan(hours,
     *                 minutes, seconds)).
     * @param options The options parameters.
     */
    _listByTime(resourceGroupName, serviceName, filter, interval, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, interval, options }, listByTimeOperationSpec);
    }
    /**
     * Lists report records by Request.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| apiId | filter | eq |     | </br>| operationId | filter | eq |     | </br>| productId
     *               | filter | eq |     | </br>| userId | filter | eq |     | </br>| apiRegion | filter | eq |     |
     *               </br>| subscriptionId | filter | eq |     | </br>
     * @param options The options parameters.
     */
    _listByRequest(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listByRequestOperationSpec);
    }
    /**
     * ListByApiNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter The filter to apply on the operation.
     * @param nextLink The nextLink from the previous successful call to the ListByApi method.
     * @param options The options parameters.
     */
    _listByApiNext(resourceGroupName, serviceName, filter, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, nextLink, options }, listByApiNextOperationSpec);
    }
    /**
     * ListByUserNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| userId | select, filter | eq |
     *               | </br>| apiRegion | filter | eq |     | </br>| productId | filter | eq |     | </br>|
     *               subscriptionId | filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | filter
     *               | eq |     | </br>| callCountSuccess | select, orderBy |     |     | </br>| callCountBlocked |
     *               select, orderBy |     |     | </br>| callCountFailed | select, orderBy |     |     | </br>|
     *               callCountOther | select, orderBy |     |     | </br>| callCountTotal | select, orderBy |     |     |
     *               </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>|
     *               cacheMissCount | select |     |     | </br>| apiTimeAvg | select, orderBy |     |     | </br>|
     *               apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg |
     *               select |     |     | </br>| serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |
     *                 |     | </br>
     * @param nextLink The nextLink from the previous successful call to the ListByUser method.
     * @param options The options parameters.
     */
    _listByUserNext(resourceGroupName, serviceName, filter, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, nextLink, options }, listByUserNextOperationSpec);
    }
    /**
     * ListByOperationNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | filter | eq |     | </br>| subscriptionId |
     *               filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | select, filter | eq |
     *                | </br>| callCountSuccess | select, orderBy |     |     | </br>| callCountBlocked | select, orderBy
     *               |     |     | </br>| callCountFailed | select, orderBy |     |     | </br>| callCountOther | select,
     *               orderBy |     |     | </br>| callCountTotal | select, orderBy |     |     | </br>| bandwidth |
     *               select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>| cacheMissCount |
     *               select |     |     | </br>| apiTimeAvg | select, orderBy |     |     | </br>| apiTimeMin | select |
     *                  |     | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg | select |     |     |
     *               </br>| serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |     |     | </br>
     * @param nextLink The nextLink from the previous successful call to the ListByOperation method.
     * @param options The options parameters.
     */
    _listByOperationNext(resourceGroupName, serviceName, filter, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, nextLink, options }, listByOperationNextOperationSpec);
    }
    /**
     * ListByProductNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | select, filter | eq |     | </br>|
     *               subscriptionId | filter | eq |     | </br>| callCountSuccess | select, orderBy |     |     | </br>|
     *               callCountBlocked | select, orderBy |     |     | </br>| callCountFailed | select, orderBy |     |
     *                | </br>| callCountOther | select, orderBy |     |     | </br>| callCountTotal | select, orderBy |
     *                 |     | </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount | select |     |
     *                | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg | select, orderBy |     |     |
     *               </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |     | </br>|
     *               serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param nextLink The nextLink from the previous successful call to the ListByProduct method.
     * @param options The options parameters.
     */
    _listByProductNext(resourceGroupName, serviceName, filter, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, nextLink, options }, listByProductNextOperationSpec);
    }
    /**
     * ListByGeoNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| country | select |     |     | </br>| region | select |     |     | </br>| zip |
     *               select |     |     | </br>| apiRegion | filter | eq |     | </br>| userId | filter | eq |     |
     *               </br>| productId | filter | eq |     | </br>| subscriptionId | filter | eq |     | </br>| apiId |
     *               filter | eq |     | </br>| operationId | filter | eq |     | </br>| callCountSuccess | select |
     *               |     | </br>| callCountBlocked | select |     |     | </br>| callCountFailed | select |     |     |
     *               </br>| callCountOther | select |     |     | </br>| bandwidth | select, orderBy |     |     | </br>|
     *               cacheHitsCount | select |     |     | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg
     *               | select |     |     | </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |
     *                 | </br>| serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param nextLink The nextLink from the previous successful call to the ListByGeo method.
     * @param options The options parameters.
     */
    _listByGeoNext(resourceGroupName, serviceName, filter, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, nextLink, options }, listByGeoNextOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | select, filter | eq |     | </br>| productId | select, filter | eq |     | </br>|
     *               subscriptionId | select, filter | eq |     | </br>| callCountSuccess | select, orderBy |     |     |
     *               </br>| callCountBlocked | select, orderBy |     |     | </br>| callCountFailed | select, orderBy |
     *                 |     | </br>| callCountOther | select, orderBy |     |     | </br>| callCountTotal | select,
     *               orderBy |     |     | </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount |
     *               select |     |     | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg | select,
     *               orderBy |     |     | </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |
     *                | </br>| serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(resourceGroupName, serviceName, filter, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListByTimeNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter, select
     *               | ge, le |     | </br>| interval | select |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | filter | eq |     | </br>| subscriptionId |
     *               filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | filter | eq |     |
     *               </br>| callCountSuccess | select |     |     | </br>| callCountBlocked | select |     |     | </br>|
     *               callCountFailed | select |     |     | </br>| callCountOther | select |     |     | </br>| bandwidth
     *               | select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>| cacheMissCount |
     *               select |     |     | </br>| apiTimeAvg | select |     |     | </br>| apiTimeMin | select |     |
     *               | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg | select |     |     | </br>|
     *               serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |     |     | </br>
     * @param interval By time interval. Interval must be multiple of 15 minutes and may not be zero. The
     *                 value should be in ISO  8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).This code can
     *                 be used to convert TimeSpan to a valid interval string: XmlConvert.ToString(new TimeSpan(hours,
     *                 minutes, seconds)).
     * @param nextLink The nextLink from the previous successful call to the ListByTime method.
     * @param options The options parameters.
     */
    _listByTimeNext(resourceGroupName, serviceName, filter, interval, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, interval, nextLink, options }, listByTimeNextOperationSpec);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByApiOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byApi",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1,
        orderby
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByUserOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byUser",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1,
        orderby
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byOperation",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1,
        orderby
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByProductOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byProduct",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1,
        orderby
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByGeoOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byGeo",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/bySubscription",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1,
        orderby
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByTimeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byTime",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1,
        orderby,
        interval
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByRequestOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byRequest",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RequestReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByApiNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1,
        orderby
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByUserNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1,
        orderby
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByOperationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1,
        orderby
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByProductNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1,
        orderby
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByGeoNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1,
        orderby
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByTimeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReportCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        top,
        skip,
        apiVersion,
        filter1,
        orderby,
        interval
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TenantSettings operations. */
class TenantSettingsImpl {
    /**
     * Initialize a new instance of the class TenantSettings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Public settings.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Public settings.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$3);
    }
    /**
     * Get tenant settings.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param settingsType The identifier of the settings.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, settingsType, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, settingsType, options }, getOperationSpec$4);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/settings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TenantSettingsCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [filter, apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/settings/{settingsType}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TenantSettingsContract,
            headersMapper: TenantSettingsGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        settingsType
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByServiceNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TenantSettingsCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [filter, apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApiManagementSkus operations. */
class ApiManagementSkusImpl {
    /**
     * Initialize a new instance of the class ApiManagementSkus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the list of Microsoft.ApiManagement SKUs available for your Subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the list of Microsoft.ApiManagement SKUs available for your Subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$4);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ApiManagement/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiManagementSkusResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$b
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiManagementSkusResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Subscription operations. */
class SubscriptionImpl {
    /**
     * Initialize a new instance of the class Subscription class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all subscriptions of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    list(resourceGroupName, serviceName, options) {
        const iter = this.listPagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all subscriptions of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _list(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listOperationSpec$3);
    }
    /**
     * Gets the entity state (Etag) version of the apimanagement subscription specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param sid Subscription entity Identifier. The entity represents the association between a user and
     *            a product in API Management.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, sid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, sid, options }, getEntityTagOperationSpec$2);
    }
    /**
     * Gets the specified Subscription entity.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param sid Subscription entity Identifier. The entity represents the association between a user and
     *            a product in API Management.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, sid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, sid, options }, getOperationSpec$3);
    }
    /**
     * Creates or updates the subscription of specified user to the specified product.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param sid Subscription entity Identifier. The entity represents the association between a user and
     *            a product in API Management.
     * @param parameters Create parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, sid, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, sid, parameters, options }, createOrUpdateOperationSpec$1);
    }
    /**
     * Updates the details of a subscription specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param sid Subscription entity Identifier. The entity represents the association between a user and
     *            a product in API Management.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, sid, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, sid, ifMatch, parameters, options }, updateOperationSpec$2);
    }
    /**
     * Deletes the specified subscription.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param sid Subscription entity Identifier. The entity represents the association between a user and
     *            a product in API Management.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, sid, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, sid, ifMatch, options }, deleteOperationSpec$1);
    }
    /**
     * Regenerates primary key of existing subscription of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param sid Subscription entity Identifier. The entity represents the association between a user and
     *            a product in API Management.
     * @param options The options parameters.
     */
    regeneratePrimaryKey(resourceGroupName, serviceName, sid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, sid, options }, regeneratePrimaryKeyOperationSpec$2);
    }
    /**
     * Regenerates secondary key of existing subscription of the API Management service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param sid Subscription entity Identifier. The entity represents the association between a user and
     *            a product in API Management.
     * @param options The options parameters.
     */
    regenerateSecondaryKey(resourceGroupName, serviceName, sid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, sid, options }, regenerateSecondaryKeyOperationSpec$2);
    }
    /**
     * Gets the specified Subscription keys.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param sid Subscription entity Identifier. The entity represents the association between a user and
     *            a product in API Management.
     * @param options The options parameters.
     */
    listSecrets(resourceGroupName, serviceName, sid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, sid, options }, listSecretsOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/subscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getEntityTagOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/subscriptions/{sid}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: SubscriptionGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        sid
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/subscriptions/{sid}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionContract,
            headersMapper: SubscriptionGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        sid
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/subscriptions/{sid}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SubscriptionContract,
            headersMapper: SubscriptionCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: SubscriptionContract,
            headersMapper: SubscriptionCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters53,
    queryParameters: [
        apiVersion,
        notify,
        appType
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        sid
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$a
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/subscriptions/{sid}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SubscriptionContract,
            headersMapper: SubscriptionUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters54,
    queryParameters: [
        apiVersion,
        notify,
        appType
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        sid
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$a
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/subscriptions/{sid}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        sid
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$a
};
const regeneratePrimaryKeyOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/subscriptions/{sid}/regeneratePrimaryKey",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        sid
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const regenerateSecondaryKeyOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/subscriptions/{sid}/regenerateSecondaryKey",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        sid
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSecretsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/subscriptions/{sid}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SubscriptionKeysContract,
            headersMapper: SubscriptionListSecretsHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        sid
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TagResource operations. */
class TagResourceImpl {
    /**
     * Initialize a new instance of the class TagResource class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of resources associated with tags.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of resources associated with tags.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$2);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tagResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagResourceCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByServiceNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagResourceCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TenantAccess operations. */
class TenantAccessImpl {
    /**
     * Initialize a new instance of the class TenantAccess class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list of access infos - for Git and Management endpoints.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of access infos - for Git and Management endpoints.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec$1);
    }
    /**
     * Tenant access metadata
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param accessName The identifier of the Access configuration.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, accessName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, accessName, options }, getEntityTagOperationSpec$1);
    }
    /**
     * Get tenant access information details without secrets.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param accessName The identifier of the Access configuration.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, accessName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, accessName, options }, getOperationSpec$2);
    }
    /**
     * Update tenant access information details.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param accessName The identifier of the Access configuration.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Parameters supplied to retrieve the Tenant Access Information.
     * @param options The options parameters.
     */
    create(resourceGroupName, serviceName, accessName, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            accessName,
            ifMatch,
            parameters,
            options
        }, createOperationSpec);
    }
    /**
     * Update tenant access information details.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param accessName The identifier of the Access configuration.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Parameters supplied to retrieve the Tenant Access Information.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, accessName, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceName,
            accessName,
            ifMatch,
            parameters,
            options
        }, updateOperationSpec$1);
    }
    /**
     * Regenerate primary access key
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param accessName The identifier of the Access configuration.
     * @param options The options parameters.
     */
    regeneratePrimaryKey(resourceGroupName, serviceName, accessName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, accessName, options }, regeneratePrimaryKeyOperationSpec$1);
    }
    /**
     * Regenerate secondary access key
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param accessName The identifier of the Access configuration.
     * @param options The options parameters.
     */
    regenerateSecondaryKey(resourceGroupName, serviceName, accessName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, accessName, options }, regenerateSecondaryKeyOperationSpec$1);
    }
    /**
     * Get tenant access information details.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param accessName The identifier of the Access configuration.
     * @param options The options parameters.
     */
    listSecrets(resourceGroupName, serviceName, accessName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, accessName, options }, listSecretsOperationSpec);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AccessInformationCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [filter, apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getEntityTagOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant/{accessName}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: TenantAccessGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        accessName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant/{accessName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AccessInformationContract,
            headersMapper: TenantAccessGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        accessName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant/{accessName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AccessInformationContract,
            headersMapper: TenantAccessCreateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters55,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        accessName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$8
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant/{accessName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AccessInformationContract,
            headersMapper: TenantAccessUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters56,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        accessName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$8
};
const regeneratePrimaryKeyOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant/{accessName}/regeneratePrimaryKey",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        accessName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const regenerateSecondaryKeyOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant/{accessName}/regenerateSecondaryKey",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        accessName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant/{accessName}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AccessInformationSecretsContract,
            headersMapper: TenantAccessListSecretsHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        accessName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByServiceNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AccessInformationCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [filter, apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing TenantAccessGit operations. */
class TenantAccessGitImpl {
    /**
     * Initialize a new instance of the class TenantAccessGit class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Regenerate primary access key for GIT.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param accessName The identifier of the Access configuration.
     * @param options The options parameters.
     */
    regeneratePrimaryKey(resourceGroupName, serviceName, accessName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, accessName, options }, regeneratePrimaryKeyOperationSpec);
    }
    /**
     * Regenerate secondary access key for GIT.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param accessName The identifier of the Access configuration.
     * @param options The options parameters.
     */
    regenerateSecondaryKey(resourceGroupName, serviceName, accessName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, accessName, options }, regenerateSecondaryKeyOperationSpec);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const regeneratePrimaryKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant/{accessName}/git/regeneratePrimaryKey",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        accessName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const regenerateSecondaryKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant/{accessName}/git/regenerateSecondaryKey",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        accessName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing TenantConfiguration operations. */
class TenantConfigurationImpl {
    /**
     * Initialize a new instance of the class TenantConfiguration class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * This operation applies changes from the specified Git branch to the configuration database. This is
     * a long running operation and could take several minutes to complete.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param configurationName The identifier of the Git Configuration Operation.
     * @param parameters Deploy Configuration parameters.
     * @param options The options parameters.
     */
    beginDeploy(resourceGroupName, serviceName, configurationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serviceName,
                configurationName,
                parameters,
                options
            }, deployOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This operation applies changes from the specified Git branch to the configuration database. This is
     * a long running operation and could take several minutes to complete.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param configurationName The identifier of the Git Configuration Operation.
     * @param parameters Deploy Configuration parameters.
     * @param options The options parameters.
     */
    beginDeployAndWait(resourceGroupName, serviceName, configurationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeploy(resourceGroupName, serviceName, configurationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * This operation creates a commit with the current configuration snapshot to the specified branch in
     * the repository. This is a long running operation and could take several minutes to complete.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param configurationName The identifier of the Git Configuration Operation.
     * @param parameters Save Configuration parameters.
     * @param options The options parameters.
     */
    beginSave(resourceGroupName, serviceName, configurationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serviceName,
                configurationName,
                parameters,
                options
            }, saveOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This operation creates a commit with the current configuration snapshot to the specified branch in
     * the repository. This is a long running operation and could take several minutes to complete.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param configurationName The identifier of the Git Configuration Operation.
     * @param parameters Save Configuration parameters.
     * @param options The options parameters.
     */
    beginSaveAndWait(resourceGroupName, serviceName, configurationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSave(resourceGroupName, serviceName, configurationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * This operation validates the changes in the specified Git branch. This is a long running operation
     * and could take several minutes to complete.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param configurationName The identifier of the Git Configuration Operation.
     * @param parameters Validate Configuration parameters.
     * @param options The options parameters.
     */
    beginValidate(resourceGroupName, serviceName, configurationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serviceName,
                configurationName,
                parameters,
                options
            }, validateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This operation validates the changes in the specified Git branch. This is a long running operation
     * and could take several minutes to complete.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param configurationName The identifier of the Git Configuration Operation.
     * @param parameters Validate Configuration parameters.
     * @param options The options parameters.
     */
    beginValidateAndWait(resourceGroupName, serviceName, configurationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidate(resourceGroupName, serviceName, configurationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the status of the most recent synchronization between the configuration database and the Git
     * repository.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param configurationName The identifier of the Git Configuration Operation.
     * @param options The options parameters.
     */
    getSyncState(resourceGroupName, serviceName, configurationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, configurationName, options }, getSyncStateOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deployOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant/{configurationName}/deploy",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: OperationResultContract
        },
        201: {
            bodyMapper: OperationResultContract
        },
        202: {
            bodyMapper: OperationResultContract
        },
        204: {
            bodyMapper: OperationResultContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters57,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        configurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const saveOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant/{configurationName}/save",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: OperationResultContract
        },
        201: {
            bodyMapper: OperationResultContract
        },
        202: {
            bodyMapper: OperationResultContract
        },
        204: {
            bodyMapper: OperationResultContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters58,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        configurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const validateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant/{configurationName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: OperationResultContract
        },
        201: {
            bodyMapper: OperationResultContract
        },
        202: {
            bodyMapper: OperationResultContract
        },
        204: {
            bodyMapper: OperationResultContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters57,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        configurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const getSyncStateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/tenant/{configurationName}/syncState",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TenantConfigurationSyncStateContract
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        configurationName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing User operations. */
class UserImpl {
    /**
     * Initialize a new instance of the class User class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a collection of registered users in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, serviceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServicePagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result = yield tslib.__await(this._listByService(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a collection of registered users in the specified service instance.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listByServiceOperationSpec);
    }
    /**
     * Gets the entity state (Etag) version of the user specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    getEntityTag(resourceGroupName, serviceName, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, options }, getEntityTagOperationSpec);
    }
    /**
     * Gets the details of the user specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, options }, getOperationSpec$1);
    }
    /**
     * Creates or Updates a user.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param parameters Create or update parameters.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serviceName, userId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, parameters, options }, createOrUpdateOperationSpec);
    }
    /**
     * Updates the details of the user specified by its identifier.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param parameters Update parameters.
     * @param options The options parameters.
     */
    update(resourceGroupName, serviceName, userId, ifMatch, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, ifMatch, parameters, options }, updateOperationSpec);
    }
    /**
     * Deletes specific user.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param ifMatch ETag of the Entity. ETag should match the current entity state from the header
     *                response of the GET request or it should be * for unconditional update.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serviceName, userId, ifMatch, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, ifMatch, options }, deleteOperationSpec);
    }
    /**
     * Retrieves a redirection URL containing an authentication token for signing a given user into the
     * developer portal.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    generateSsoUrl(resourceGroupName, serviceName, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, options }, generateSsoUrlOperationSpec);
    }
    /**
     * Gets the Shared Access Authorization Token for the User.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param parameters Create Authorization Token parameters.
     * @param options The options parameters.
     */
    getSharedAccessToken(resourceGroupName, serviceName, userId, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, parameters, options }, getSharedAccessTokenOperationSpec);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByServiceNextOperationSpec);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByServiceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/users",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UserCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        expandGroups
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getEntityTagOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/users/{userId}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: UserGetEntityTagHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/users/{userId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UserContract,
            headersMapper: UserGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/users/{userId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: UserContract,
            headersMapper: UserCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: UserContract,
            headersMapper: UserCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters59,
    queryParameters: [apiVersion, notify],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$5
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/users/{userId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: UserContract,
            headersMapper: UserUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters60,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch1
    ],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/users/{userId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        deleteSubscriptions,
        notify,
        appType
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId
    ],
    headerParameters: [accept, ifMatch1],
    serializer: serializer$5
};
const generateSsoUrlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/users/{userId}/generateSsoUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GenerateSsoUrlResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getSharedAccessTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/users/{userId}/token",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: UserTokenResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters61,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const listByServiceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UserCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion,
        expandGroups
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing UserGroup operations. */
class UserGroupImpl {
    /**
     * Initialize a new instance of the class UserGroup class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all user groups.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    list(resourceGroupName, serviceName, userId, options) {
        const iter = this.listPagingAll(resourceGroupName, serviceName, userId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, serviceName, userId, options);
            }
        };
    }
    listPagingPage(resourceGroupName, serviceName, userId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, serviceName, userId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, serviceName, userId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, serviceName, userId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, serviceName, userId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all user groups.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _list(resourceGroupName, serviceName, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, serviceName, userId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/users/{userId}/groups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GroupCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GroupCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        userId
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing UserSubscription operations. */
class UserSubscriptionImpl {
    /**
     * Initialize a new instance of the class UserSubscription class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the collection of subscriptions of the specified user.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    list(resourceGroupName, serviceName, userId, options) {
        const iter = this.listPagingAll(resourceGroupName, serviceName, userId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, serviceName, userId, options);
            }
        };
    }
    listPagingPage(resourceGroupName, serviceName, userId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, serviceName, userId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, serviceName, userId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, serviceName, userId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, serviceName, userId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the collection of subscriptions of the specified user.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _list(resourceGroupName, serviceName, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, options }, listOperationSpec$1);
    }
    /**
     * Gets the specified Subscription entity associated with a particular user.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param sid Subscription entity Identifier. The entity represents the association between a user and
     *            a product in API Management.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, userId, sid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, sid, options }, getOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, serviceName, userId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/users/{userId}/subscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/users/{userId}/subscriptions/{sid}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionContract,
            headersMapper: UserSubscriptionGetHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId,
        sid
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        filter,
        top,
        skip,
        apiVersion
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        userId
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing UserIdentities operations. */
class UserIdentitiesImpl {
    /**
     * Initialize a new instance of the class UserIdentities class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List of all user identities.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    list(resourceGroupName, serviceName, userId, options) {
        const iter = this.listPagingAll(resourceGroupName, serviceName, userId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, serviceName, userId, options);
            }
        };
    }
    listPagingPage(resourceGroupName, serviceName, userId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, serviceName, userId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, serviceName, userId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, serviceName, userId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, serviceName, userId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List of all user identities.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    _list(resourceGroupName, serviceName, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, serviceName, userId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/users/{userId}/identities",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UserIdentityCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UserIdentityCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        nextLink,
        userId
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing UserConfirmationPassword operations. */
class UserConfirmationPasswordImpl {
    /**
     * Initialize a new instance of the class UserConfirmationPassword class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Sends confirmation
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param userId User identifier. Must be unique in the current API Management service instance.
     * @param options The options parameters.
     */
    send(resourceGroupName, serviceName, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, userId, options }, sendOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const sendOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/users/{userId}/confirmations/password/send",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, appType],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId,
        userId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ApiManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the ApiManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId Subscription credentials which uniquely identify Microsoft Azure subscription.
     *                       The subscription ID forms part of the URI for every service call.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-apimanagement/8.1.2`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: `${optionsWithDefaults.credentialScopes}`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2021-08-01";
        this.api = new ApiImpl(this);
        this.apiRevision = new ApiRevisionImpl(this);
        this.apiRelease = new ApiReleaseImpl(this);
        this.apiOperation = new ApiOperationImpl(this);
        this.apiOperationPolicy = new ApiOperationPolicyImpl(this);
        this.tag = new TagImpl(this);
        this.apiProduct = new ApiProductImpl(this);
        this.apiPolicy = new ApiPolicyImpl(this);
        this.apiSchema = new ApiSchemaImpl(this);
        this.apiDiagnostic = new ApiDiagnosticImpl(this);
        this.apiIssue = new ApiIssueImpl(this);
        this.apiIssueComment = new ApiIssueCommentImpl(this);
        this.apiIssueAttachment = new ApiIssueAttachmentImpl(this);
        this.apiTagDescription = new ApiTagDescriptionImpl(this);
        this.operationOperations = new OperationOperationsImpl(this);
        this.apiExport = new ApiExportImpl(this);
        this.apiVersionSet = new ApiVersionSetImpl(this);
        this.authorizationServer = new AuthorizationServerImpl(this);
        this.backend = new BackendImpl(this);
        this.cache = new CacheImpl(this);
        this.certificate = new CertificateImpl(this);
        this.contentType = new ContentTypeImpl(this);
        this.contentItem = new ContentItemImpl(this);
        this.deletedServices = new DeletedServicesImpl(this);
        this.apiManagementOperations = new ApiManagementOperationsImpl(this);
        this.apiManagementServiceSkus = new ApiManagementServiceSkusImpl(this);
        this.apiManagementService = new ApiManagementServiceImpl(this);
        this.diagnostic = new DiagnosticImpl(this);
        this.emailTemplate = new EmailTemplateImpl(this);
        this.gateway = new GatewayImpl(this);
        this.gatewayHostnameConfiguration = new GatewayHostnameConfigurationImpl(this);
        this.gatewayApi = new GatewayApiImpl(this);
        this.gatewayCertificateAuthority = new GatewayCertificateAuthorityImpl(this);
        this.group = new GroupImpl(this);
        this.groupUser = new GroupUserImpl(this);
        this.identityProvider = new IdentityProviderImpl(this);
        this.issue = new IssueImpl(this);
        this.logger = new LoggerImpl(this);
        this.namedValue = new NamedValueImpl(this);
        this.networkStatus = new NetworkStatusImpl(this);
        this.notification = new NotificationImpl(this);
        this.notificationRecipientUser = new NotificationRecipientUserImpl(this);
        this.notificationRecipientEmail = new NotificationRecipientEmailImpl(this);
        this.openIdConnectProvider = new OpenIdConnectProviderImpl(this);
        this.outboundNetworkDependenciesEndpoints = new OutboundNetworkDependenciesEndpointsImpl(this);
        this.policy = new PolicyImpl(this);
        this.policyDescription = new PolicyDescriptionImpl(this);
        this.portalRevision = new PortalRevisionImpl(this);
        this.portalSettings = new PortalSettingsImpl(this);
        this.signInSettings = new SignInSettingsImpl(this);
        this.signUpSettings = new SignUpSettingsImpl(this);
        this.delegationSettings = new DelegationSettingsImpl(this);
        this.privateEndpointConnectionOperations = new PrivateEndpointConnectionOperationsImpl(this);
        this.product = new ProductImpl(this);
        this.productApi = new ProductApiImpl(this);
        this.productGroup = new ProductGroupImpl(this);
        this.productSubscriptions = new ProductSubscriptionsImpl(this);
        this.productPolicy = new ProductPolicyImpl(this);
        this.quotaByCounterKeys = new QuotaByCounterKeysImpl(this);
        this.quotaByPeriodKeys = new QuotaByPeriodKeysImpl(this);
        this.region = new RegionImpl(this);
        this.reports = new ReportsImpl(this);
        this.tenantSettings = new TenantSettingsImpl(this);
        this.apiManagementSkus = new ApiManagementSkusImpl(this);
        this.subscription = new SubscriptionImpl(this);
        this.tagResource = new TagResourceImpl(this);
        this.tenantAccess = new TenantAccessImpl(this);
        this.tenantAccessGit = new TenantAccessGitImpl(this);
        this.tenantConfiguration = new TenantConfigurationImpl(this);
        this.user = new UserImpl(this);
        this.userGroup = new UserGroupImpl(this);
        this.userSubscription = new UserSubscriptionImpl(this);
        this.userIdentities = new UserIdentitiesImpl(this);
        this.userConfirmationPassword = new UserConfirmationPasswordImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Performs a connectivity check between the API Management service and a given destination, and
     * returns metrics for the connection, as well as errors encountered while trying to establish it.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param connectivityCheckRequestParams Connectivity Check request parameters.
     * @param options The options parameters.
     */
    beginPerformConnectivityCheckAsync(resourceGroupName, serviceName, connectivityCheckRequestParams, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serviceName,
                connectivityCheckRequestParams,
                options
            }, performConnectivityCheckAsyncOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Performs a connectivity check between the API Management service and a given destination, and
     * returns metrics for the connection, as well as errors encountered while trying to establish it.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the API Management service.
     * @param connectivityCheckRequestParams Connectivity Check request parameters.
     * @param options The options parameters.
     */
    beginPerformConnectivityCheckAsyncAndWait(resourceGroupName, serviceName, connectivityCheckRequestParams, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPerformConnectivityCheckAsync(resourceGroupName, serviceName, connectivityCheckRequestParams, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const performConnectivityCheckAsyncOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/connectivityCheck",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ConnectivityCheckResponse
        },
        201: {
            bodyMapper: ConnectivityCheckResponse
        },
        202: {
            bodyMapper: ConnectivityCheckResponse
        },
        204: {
            bodyMapper: ConnectivityCheckResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: connectivityCheckRequestParams,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        serviceName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};

exports.ApiManagementClient = ApiManagementClient;
//# sourceMappingURL=index.js.map
